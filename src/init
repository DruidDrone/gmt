begin.c:	GMT_Message (API, GMT_TIME_NONE, "\t<format(s)> sets the default plot format(s) [%s].\n", gmt_session_format[API->GMT->current.setting.graphics_format]);
begin.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Unrecognized graphics format %s\n", p);
blockmean.c:							GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Unrecognized field argument %s in -A.!\n", p);
blockmean.c:					GMT_Report (GMT->parent, GMT_MSG_DEBUG, "-A interpreted to mean -Az.\n");
blockmean.c:					GMT_Report (GMT->parent, GMT_MSG_COMPAT, "-Ep is deprecated; see -E+p|P instead.\n");
blockmean.c:				if (!GMT->parent->external && Ctrl->G.n) {	/* Command line interface */
blockmean.c:					GMT_Report (GMT->parent, GMT_MSG_NORMAL, "-G can only be set once!\n");
blockmean.c:							GMT_Report (GMT->parent, GMT_MSG_COMPAT, "-S and -Sz options are deprecated; use -Ss instead.\n");
blockmean.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "-E+p|P given without -W or -W+s sets -Wi+s.\n");
blockmean.c:		if (GMT->parent->external && !Ctrl->A.active) {		/* From externals let -G equals -Az */
blockmean.c:	n_errors += gmt_M_check_condition (GMT, !GMT->parent->external && Ctrl->A.active && !Ctrl->G.active, "Syntax error: -A requires -G\n");
blockmean.c:	n_errors += gmt_M_check_condition (GMT, GMT->parent->external && Ctrl->G.active && !Ctrl->A.active,
blockmean.c:		if (Ctrl->A.active && Ctrl->A.n_selected > 1 && !GMT->parent->external && !strstr (Ctrl->G.file[0], "%s")) {
blockmean.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "-G file format must contain a %%s for field type substitution.\n");
blockmean.c:				GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "-E is required if -A specifies s, l, or h.  -E was added.\n");
blockmean.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "-W or -Wo is required if -A specifies w.\n");
blockmean.c:	n_errors += gmt_M_check_condition (GMT, !GMT->common.R.active[RSET], "Syntax error: Must specify -R option\n");
blockmean.c:	n_errors += gmt_M_check_condition (GMT, GMT->common.R.inc[GMT_X] <= 0.0 || GMT->common.R.inc[GMT_Y] <= 0.0,
blockmean.c:		          GMT->current.setting.format_float_out, GMT->current.setting.format_float_out,
blockmean.c:				  GMT->current.setting.format_float_out, GMT->current.setting.format_float_out);
blockmean.c:	GMT->session.min_meminc = GMT_INITIAL_MEM_ROW_ALLOC;	/* Start by allocating a 32 Mb chunk */ 
blockmean.c:	GMT->session.min_meminc = GMT_MIN_MEMINC;		/* Reset to the default value */
blockmean.c:				GridOut[NF]->data[node] = GMT->session.f_NaN;
blockmean.c:		if (GMT->common.h.add_colnames) {	/* Create meaningful column header */
blockmean.c:					/ (zw[node].a[BLK_W] * zw[node].a[BLK_W] * ((np[node] - 1.0) / np[node]))) : GMT->session.d_NaN;
blockmean.c:															 1.0))) : GMT->session.d_NaN;
blockmedian.c:								GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Unrecognized field argument %s in -A!\n", p);
blockmedian.c:							GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Unrecognized field argument %s in -A!\n", p);
blockmedian.c:					GMT_Report (GMT->parent, GMT_MSG_DEBUG, "-A interpreted to mean -Az.\n");
blockmedian.c:								GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Unrecognized argument -E%s!\n", opt->arg);
blockmedian.c:				if (!GMT->parent->external && Ctrl->G.n) {	/* Command line interface */
blockmedian.c:					GMT_Report (GMT->parent, GMT_MSG_NORMAL, "-G can only be set once!\n");
blockmedian.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Cannot combine s with q25 or q75.\n");
blockmedian.c:				GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "-E is required if -A specifies s, l, or h.  -E was added.\n");
blockmedian.c:			GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "-Eb is required if -A specifies q25 or q75.  -Eb was added.\n");
blockmedian.c:			GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "-E is required if -A specifies s, l, or h.  -E was added.\n");
blockmedian.c:		if (GMT->parent->external && !Ctrl->A.active) {		/* From externals let -G equals -Az */
blockmedian.c:	n_errors += gmt_M_check_condition (GMT, !GMT->parent->external && Ctrl->A.active && !Ctrl->G.active, "Syntax error: -A requires -G\n");
blockmedian.c:	n_errors += gmt_M_check_condition (GMT, GMT->parent->external && Ctrl->G.active && !Ctrl->A.active,
blockmedian.c:		if (Ctrl->A.active && Ctrl->A.n_selected > 1 && !GMT->parent->external && !strstr (Ctrl->G.file[0], "%s")) {
blockmedian.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "-G file format must contain a %%s for field type substitution.\n");
blockmedian.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "-W or -Wo is required if -A specifies w.\n");
blockmedian.c:	n_errors += gmt_M_check_condition (GMT, !GMT->common.R.active[RSET], "Syntax error: Must specify -R option\n");
blockmedian.c:	n_errors += gmt_M_check_condition (GMT, GMT->common.R.inc[GMT_X] <= 0.0 || GMT->common.R.inc[GMT_Y] <= 0.0,
blockmedian.c:		snprintf (format, GMT_LEN512, "W: %s E: %s S: %s N: %s n_columns: %%d n_rows: %%d\n", GMT->current.setting.format_float_out, GMT->current.setting.format_float_out, GMT->current.setting.format_float_out, GMT->current.setting.format_float_out);
blockmedian.c:	GMT->session.min_meminc = GMT_INITIAL_MEM_ROW_ALLOC;	/* Start by allocating a 32 MB chunk */
blockmedian.c:	GMT->session.min_meminc = GMT_MIN_MEMINC;		/* Reset to the default value */
blockmedian.c:				GridOut[NF]->data[node] = GMT->session.f_NaN;
blockmedian.c:		old_format = GMT->current.io.o_format[i_col];		/* Need to restore this at end */
blockmedian.c:		GMT->current.io.o_format[i_col] = strdup ("%.0f");	/* Integer format for src_id */
blockmedian.c:				out[3] = GMT->session.d_NaN;
blockmedian.c:		gmt_M_str_free (GMT->current.io.o_format[i_col]);	/* Free the temporary integer format */
blockmedian.c:		GMT->current.io.o_format[i_col] = old_format;		/* Restore previous format */
blockmode.c:							GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Unrecognized field argument %s in -A!\n", p);
blockmode.c:					GMT_Report (GMT->parent, GMT_MSG_DEBUG, "-A interpreted to mean -Az.\n");
blockmode.c:								GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Unrecognized modifier +%c.\n", p[0]);
blockmode.c:								GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Unrecognized argument -E%s!\n", opt->arg);
blockmode.c:				if (!GMT->parent->external && Ctrl->G.n) {	/* Command line interface */
blockmode.c:					GMT_Report (GMT->parent, GMT_MSG_NORMAL, "-G can only be set once!\n");
blockmode.c:		if (GMT->parent->external && !Ctrl->A.active) {		/* From externals let -G equals -Az */
blockmode.c:	n_errors += gmt_M_check_condition (GMT, GMT->parent->external && Ctrl->G.active && !Ctrl->A.active,
blockmode.c:		if (Ctrl->A.active && Ctrl->A.n_selected > 1 && !GMT->parent->external && !strstr (Ctrl->G.file[0], "%s")) {
blockmode.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "-G file format must contain a %%s for field type substitution.\n");
blockmode.c:				GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "-E is required if -A specifies s, l, or h.  -E was added.\n");
blockmode.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "-W or -Wo is required if -A specifies w.\n");
blockmode.c:	n_errors += gmt_M_check_condition (GMT, !GMT->common.R.active[RSET], "Syntax error: Must specify -R option\n");
blockmode.c:	n_errors += gmt_M_check_condition (GMT, GMT->common.R.inc[GMT_X] <= 0.0 || GMT->common.R.inc[GMT_Y] <= 0.0,
blockmode.c:			GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "For integer data and no -D<width> specified we default to <width> = 1\n");
blockmode.c:			GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "For integer data and integer width we automatically select centered bins\n");
blockmode.c:				GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "For integer data and integer width we automatically select lowest mode\n");
blockmode.c:		GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Effective mode option is -D%g+c+%c\n", width, mode[mode_choice+1]);
blockmode.c:		snprintf (format, GMT_LEN512, "W: %s E: %s S: %s N: %s n_columns: %%d n_rows: %%d\n", GMT->current.setting.format_float_out, GMT->current.setting.format_float_out, GMT->current.setting.format_float_out, GMT->current.setting.format_float_out);
blockmode.c:	GMT->session.min_meminc = GMT_INITIAL_MEM_ROW_ALLOC;	/* Start by allocating a 32 Mb chunk */
blockmode.c:	GMT->session.min_meminc = GMT_MIN_MEMINC;		/* Reset to the default value */
blockmode.c:				GridOut[NF]->data[node] = GMT->session.f_NaN;
blockmode.c:		old_format = GMT->current.io.o_format[i_col];		/* Need to restore this at end */
blockmode.c:		GMT->current.io.o_format[i_col] = strdup ("%.0f");	/* Integer format for src_id */
blockmode.c:				out[3] = GMT->session.d_NaN;
blockmode.c:		gmt_M_str_free (GMT->current.io.o_format[i_col]);	/* Free the temporary integer format */
blockmode.c:		GMT->current.io.o_format[i_col] = old_format;		/* Restore previous format */
clear.c:	GMT_Message (API, GMT_TIME_NONE, "\t   cache     Deletes the user\'s cache directory [%s].\n", API->GMT->session.CACHEDIR);
clear.c:	GMT_Message (API, GMT_TIME_NONE, "\t   data      Deletes the user\'s data download directory [%s/server].\n", API->GMT->session.USERDIR);
clear.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "No target specified\n");
clear.c:	if (gmt_remove_dir (API, API->GMT->session.CACHEDIR, false))
clear.c:	sprintf (dir, "%s/server/srtm1", API->GMT->session.USERDIR);
clear.c:	sprintf (dir, "%s/server/srtm3", API->GMT->session.USERDIR);
clear.c:	sprintf (dir, "%s/server", API->GMT->session.USERDIR);
clear.c:			if (API->GMT->current.setting.run_mode == GMT_MODERN && clear_defaults (API))
clear.c:			if (API->GMT->current.setting.run_mode == GMT_CLASSIC) {
dimfilter.c:		n_errors += gmt_M_check_condition (GMT, GMT->common.R.active[ISET] && (GMT->common.R.inc[GMT_X] <= 0.0 || GMT->common.R.inc[GMT_Y] <= 0.0), "Syntax error -I option: Must specify positive increment(s)\n");
dimfilter.c:	F.deg2km = GMT->current.proj.DIST_KM_PR_DEG;
dimfilter.c:		gmt_M_memcpy (wesn, (GMT->common.R.active[RSET] ? GMT->common.R.wesn : Gin->header->wesn), 4, double);
dimfilter.c:		if (GMT->common.R.active[ISET])
dimfilter.c:			gmt_M_memcpy (inc, GMT->common.R.inc, 2, double);
dimfilter.c:					Gout->data[ij_out] = GMT->session.f_NaN;
dimfilter.c:					if (Ctrl->S.active) Sout->data[ij_out] = GMT->session.f_NaN;
docs.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Unknown option (-%c)\n", opt->option);
docs.c:			if (GMT->hidden.func_level == GMT_TOP_MODULE) {	/* Can only open figs if called indirectly via gmt end show */
docs.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Argument %s is not a known module or documentation short-hand\n",
docs.c:				GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Reporting local file %s to stdout\n", name);
docs.c:					GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Opening local file %s via %s\n", opt->arg, file_viewer);
docs.c:						GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Opening local file %s via %s failed with error %d\n",
docs.c:							GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Unable to determine current working directory - pass file name as is.\n");
docs.c:						GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Try URL path: %s\n", URL);
docs.c:					snprintf (URL, PATH_MAX, "file:///%s/doc/html/%s", API->GMT->session.SHAREDIR, module);
docs.c:					GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Try URL path: %s\n", URL);
docs.c:						GMT_Report (GMT->parent, GMT_MSG_DEBUG, "No access, Now try URL path: %s\n", URL);
docs.c:							GMT_Report (GMT->parent, GMT_MSG_DEBUG, "No access, Now try URL path: %s\n", URL);
docs.c:								GMT_Report (GMT->parent, GMT_MSG_DEBUG, "No local access,use server URL path: %s\n", URL);
docs.c:				GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Reporting URL %s to stdout\n", URL);
docs.c:				GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Opening %s via %s\n", URL, file_viewer);
docs.c:					GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Opening %s via %s failed with error %d\n",
docs.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Opening local file(s) via %s\n", view);
docs.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Opening local files via %s failed with error %d\n",
docs.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "No files or documents given\n");
end.c:					GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Unrecognized argument %s\n", opt->arg);
end.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Unrecognized option %s\n", opt->arg);
end.c:	if (API->GMT->current.setting.run_mode == GMT_CLASSIC) {
figure.c:	GMT_Message (API, GMT_TIME_NONE, "\t<formats> contains one or more comma-separated formats [%s].\n", gmt_session_format[API->GMT->current.setting.graphics_format]);
figure.c:		if (GMT->parent->external) return GMT_NOERROR;
figure.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Required figure name not specified!\n");
figure.c:					GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Unrecognized graphics format %s\n", p);
figure.c:					GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Unrecognized psconvert option  -%s\n", p);
figure.c:	if (API->GMT->current.setting.run_mode == GMT_CLASSIC) {
filter1d.c:	struct GMTAPI_CTRL *API = GMT->parent;
filter1d.c:			GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Must normalize custom filter since weight sum > 1 [%g]\n", w_sum);
filter1d.c:	GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "F width: %g Resolution: %g Start: %g Stop: %g\n", F->filter_width, F->dt, F->t_start, F->t_stop);
filter1d.c:					data_sum[i_col] = GMT->session.d_NaN;
filter1d.c:						outval[i_col] = GMT->session.d_NaN;
filter1d.c:	if (GMT->common.b.active[GMT_IN] && GMT->common.b.ncol[GMT_IN] < F.n_cols) Return (GMT_N_COLS_VARY,
filter1d.c:			save_col = GMT->current.io.col_type[GMT_IN][GMT_X];	/* Save col type in case it is a time column */
filter1d.c:	GMT->current.io.skip_if_NaN[GMT_X] = GMT->current.io.skip_if_NaN[GMT_Y] = false;	/* Turn off default GMT NaN-handling */
filter1d.c:	GMT->current.io.skip_if_NaN[F.t_col] = true;			/* ... But disallow NaN in "time" column */
filter1d.c:	GMT->common.b.ncol[GMT_OUT] = F.n_cols;
filter1d.c:			if (GMT->current.io.multi_segments[GMT_OUT]) GMT_Put_Record (API, GMT_WRITE_SEGMENT_HEADER, S->header);
fitcircle.c:							GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -F option: Bad arg %s. Select any combination from fmnsc\n", opt->arg);
fitcircle.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Cannot find small circle fitting better than great circle.\n");
fitcircle.c:		if ((error = GMT_Set_Columns (GMT->parent, GMT_OUT, n_cols, GMT_COL_FIX_NO_TEXT)) != GMT_NOERROR) {
fitcircle.c:	else if ((error = GMT_Set_Columns (GMT->parent, GMT_OUT, 2, GMT_COL_FIX)) != GMT_NOERROR) {
fitcircle.c:					sprintf (format, "L1 Small Circle Pole. Distance from Pole to L1 Small Circle (degrees): %s", GMT->current.setting.format_float_out);
fitcircle.c:				if (Ctrl->F.mode & 16) {out[col++] = GMT->session.d_NaN; out[col++] = GMT->session.d_NaN; out[col++] = GMT->session.d_NaN; }
fitcircle.c:					snprintf (format, GMT_LEN256, "L2 Small Circle Pole.  Distance from Pole to L2 Small Circle (degrees): %s", GMT->current.setting.format_float_out);
fitcircle.c:				if (Ctrl->F.mode & 16) {out[col++] = GMT->session.d_NaN; out[col++] = GMT->session.d_NaN; out[col++] = GMT->session.d_NaN; }
gmt.c:				if (api_ctrl->GMT->session.DATADIR == NULL)
gmt.c:					fprintf(stdout, "%s\n", api_ctrl->GMT->session.DATADIR);
gmt.c:				fprintf(stdout, "%s\n", api_ctrl->GMT->session.DATASERVER);
gmt.c:				fprintf (stdout, "%s\n", api_ctrl->GMT->init.runtime_bindir);
gmt.c:				fprintf (stdout, "%s\n", api_ctrl->GMT->init.runtime_plugindir);
gmt.c:				fprintf (stdout, "%s\n", api_ctrl->GMT->init.runtime_library);
gmt.c:				fprintf (stdout, "%s\n", api_ctrl->GMT->session.SHAREDIR);
gmt2kml.c:	C->W.pen = GMT->current.setting.map_default_pen; C->W.pen.width = 1.0;		/* Default pen width = 1p */
gmt2kml.c:	struct GMTAPI_CTRL *API = GMT->parent;
gmt2kml.c:				Ctrl->R2.active = GMT->common.R.active[RSET] = true;
gmt2kml.c:	if (GMT->common.b.active[GMT_IN] && GMT->common.b.ncol[GMT_IN] == 0) GMT->common.b.ncol[GMT_IN] = 2;
gmt2kml.c:	n_errors += gmt_M_check_condition (GMT, GMT->common.b.active[GMT_OUT], "Syntax error: Cannot produce binary KML output\n");
gmt2kml.c:	n_errors += gmt_M_check_condition (GMT, GMT->common.b.active[GMT_IN] && Ctrl->N.mode == GET_LABEL, "Syntax error: Cannot use -Nt when -b is used.\n");
gmt2kml.c:	if (*lat < GMT->common.R.wesn[YLO] || *lat > GMT->common.R.wesn[YHI]) return (true);
gmt2kml.c:	if (*lon < GMT->common.R.wesn[XLO]) *lon += 360.0;
gmt2kml.c:	if (*lon > GMT->common.R.wesn[XHI]) *lon -= 360.0;
gmt2kml.c:	if (*lon < GMT->common.R.wesn[XLO]) return (true);
gmt2kml.c:		gmt_M_rgb_copy (rgb, GMT->current.setting.ps_page_rgb);
gmt2kml.c:		KML_plot_object (GMT->parent, Out, kml->flon, kml->flat, kml->n_out, POLYGON, process_id, amode, N, altitude);
gmt2kml.c:		KML_plot_object (GMT->parent, Out, kml->flon, kml->flat, np, LINE, process_id, amode, N, altitude);
gmt2kml.c:	strcpy (GMT->current.setting.io_col_separator, ",");		/* Specify comma-separated output */
gmt2kml.c:	strcpy (GMT->current.setting.format_float_out, "%.12g");	/* Make sure we use enough decimals */
gmt2kml.c:		Ctrl->Q.scale = R2D * (Ctrl->Q.scale / GMT->current.map.dist[GMT_MAP_DIST].scale) / GMT->current.proj.mean_radius;
gmt2kml.c:	if (!GMT->common.O.active) {
gmt2kml.c:	if (GMT->common.O.active || GMT->common.K.active) use_folder = true;	/* When at least one or -O, -K is used */
gmt2kml.c:	if (GMT->common.O.active) N++;	/* Due to the extra folder tag */
gmt2kml.c:	if (GMT->common.R.active[RSET] && first)	/* Issue Region tag as given on command line */
gmt2kml.c:		place_region_tag (API, Out, GMT->common.R.wesn, Ctrl->Z.min, Ctrl->Z.max, N);
gmt2kml.c:					if (GMT->common.R.active[RSET] && check_lon_lat (GMT, &out[GMT_X], &out[GMT_Y])) continue;
gmt2kml.c:	if (!GMT->common.K.active) {
gmt_agc_io.c:		fp = GMT->session.std[GMT_IN];
gmt_agc_io.c:		fp = GMT->session.std[GMT_OUT];
gmt_agc_io.c:		fp = GMT->session.std[GMT_IN];
gmt_agc_io.c:				grid[ij] = (z[j][i] == 0.0) ? GMT->session.f_NaN : z[j][i];	/* AGC uses exact zero as NaN flag */
gmt_agc_io.c:		fp = GMT->session.std[GMT_OUT];
gmt_agc_io.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "AGC grids are always gridline-registered.  Your pixel-registered grid will be converted.\n");
gmt_agc_io.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "AGC grid region in file %s reset to %g/%g/%g/%g\n", HH->name, header->wesn[XLO], header->wesn[XHI], header->wesn[YLO], header->wesn[YHI]);
gmt_api.c:	if (GMT->common.g.active) return (MAX (n, GMT->common.g.n_col));	/* n or n_col (if larger) */
gmt_api.c:	if (GMT->current.io.need_previous) gmt_M_memcpy (GMT->current.io.prev_rec, GMT->current.io.curr_rec, n_use, double);
gmt_api.c:	if (API->GMT->current.setting.run_mode == GMT_MODERN) {	/* Just need to check if a classic name was given... */
gmt_api.c:	API->GMT->current.setting.use_modern_name = gmtlib_is_modern_name (API, module);
gmt_api.c:	if (API->GMT->current.setting.use_modern_name) {	/* Make some checks needed to handle synopsis and usage messages in classic vs modern mode */
gmt_api.c:			if (API->GMT->current.setting.run_mode == GMT_CLASSIC)
gmt_api.c:		API->GMT->current.setting.run_mode = GMT_MODERN;
gmt_api.c:	if (API->GMT->current.setting.run_mode == GMT_MODERN)	/* If running in modern mode we want to use modern names */
gmt_api.c:		API->GMT->current.setting.use_modern_name = true;
gmt_api.c:	bool running_in_bindir_src = !strncmp (GMT->init.runtime_bindir, GMT_BINARY_DIR_SRC_DEBUG, strlen(GMT_BINARY_DIR_SRC_DEBUG));
gmt_api.c:	if (GMT->init.runtime_libdir) {	/* Successfully determined runtime dir for shared libs */
gmt_api.c:		snprintf (plugindir, PATH_MAX, "%s/%s", GMT->init.runtime_libdir, GMT_CORE_LIB_NAME);
gmt_api.c:		if (!GMT->init.runtime_library) GMT->init.runtime_library = strdup (plugindir);
gmt_api.c:			snprintf (plugindir, PATH_MAX, "%s/gmt_plugins", GMT->init.runtime_libdir);	/* Generate the Win standard plugins path */
gmt_api.c:			snprintf (plugindir, PATH_MAX, "%s/gmt" GMT_INSTALL_NAME_SUFFIX "/plugins", GMT->init.runtime_libdir);	/* Generate the *nix standard plugins path */
gmt_api.c:		if (!GMT->init.runtime_plugindir) GMT->init.runtime_plugindir = strdup (plugindir);
gmt_api.c:	if (GMT->session.CUSTOM_LIBS) {	/* We specified custom shared libraries */
gmt_api.c:		k = (unsigned int)strlen (GMT->session.CUSTOM_LIBS) - 1;	/* Index of last char in CUSTOM_LIBS */
gmt_api.c:		if (GMT->session.CUSTOM_LIBS[k] == '/' || GMT->session.CUSTOM_LIBS[k] == '\\') {	/* We gave CUSTOM_LIBS as a subdirectory, add all files found inside it to shared libs list */
gmt_api.c:			strcpy (plugindir, GMT->session.CUSTOM_LIBS);
gmt_api.c:			while (gmt_strtok (GMT->session.CUSTOM_LIBS, ",", &pos, text)) {
gmt_api.c:			wesn = (direction == GMT_IN && GMT->common.R.active[RSET]) ? GMT->common.R.wesn : NULL;
gmt_api.c:			wesn = (direction == GMT_OUT && GMT->common.R.active[RSET]) ? GMT->common.R.wesn : NULL;
gmt_api.c:			wesn = (direction == GMT_IN && GMT->common.R.active[RSET]) ? GMT->common.R.wesn : NULL;
gmt_api.c:			wesn = (direction == GMT_OUT && GMT->common.R.active[RSET]) ? GMT->common.R.wesn : NULL;
gmt_api.c:	if (GMT->common.o.select)	/* -o has selected some columns */
gmt_api.c:		col_pos = GMT->current.io.col[GMT_OUT][col].col;	/* Which data column to pick */
gmt_api.c:	else if (GMT->current.setting.io_lonlat_toggle[GMT_OUT] && col < GMT_Z)	/* Worry about -: for lon,lat */
gmt_api.c:	val = (col_pos >= S->n_columns) ? GMT->session.d_NaN : S->data[col_pos][row];	/* If we request a column beyond length of array, return NaN */
gmt_api.c:	if (GMT->common.d.active[GMT_OUT] && gmt_M_is_dnan (val)) val = GMT->common.d.nan_proxy[GMT_OUT];	/* Write this value instead of NaNs */
gmt_api.c:	if (gmt_M_is_type (GMT, GMT_OUT, col_pos, GMT_IS_LON)) gmt_lon_range_adjust (GMT->current.io.geo.range, &val);	/* Set longitude range */
gmt_api.c:	val = (col_pos >= n_colums) ? GMT->session.d_NaN : record[col_pos];	/* If we request a column beyond length of array, return NaN */
gmt_api.c:	if (GMT->common.d.active[GMT_OUT] && gmt_M_is_dnan (val)) val = GMT->common.d.nan_proxy[GMT_OUT];	/* Write this value instead of NaNs */
gmt_api.c:	if (gmt_M_is_type (GMT, GMT_OUT, col_pos, GMT_IS_LON)) gmt_lon_range_adjust (GMT->current.io.geo.range, &val);	/* Set longitude range */
gmt_api.c:	if (GMT->common.i.select)	/* -i has selected some columns */
gmt_api.c:		col_pos = GMT->current.io.col[GMT_IN][col].col;	/* Which data column to pick */
gmt_api.c:	else if (GMT->current.setting.io_lonlat_toggle[GMT_IN] && col < GMT_Z)	/* Worry about -: for lon,lat */
gmt_api.c:	val = (col_pos >= n_colums) ? GMT->session.d_NaN : record[col_pos];	/* If we request a column beyond length of array, return NaN */
gmt_api.c:	if (GMT->common.d.active[GMT_IN] && gmt_M_is_dnan (val)) val = GMT->common.d.nan_proxy[GMT_IN];	/* Write this value instead of NaNs */
gmt_api.c:	if (gmt_M_is_type (GMT, GMT_IN, col_pos, GMT_IS_LON)) gmt_lon_range_adjust (GMT->current.io.geo.range, &val);	/* Set longitude range */
gmt_api.c: 	 * The current data record has already been read from wherever and is available in GMT->current.io.curr_rec */
gmt_api.c:	GMT->current.io.status = GMT_IO_DATA_RECORD;	/* Default status we expect, but this may change below */
gmt_api.c:	GMT->current.io.rec_no++;			/* One more input record read */
gmt_api.c:	GMT->current.io.pt_no++;	/* Actually got a valid data record */
gmt_api.c:	if (mode & 4) API->GMT->current.time.tic = toc;	/* Reset previous timestamp to now */
gmt_api.c:			strftime (stamp, sizeof(stamp), API->GMT->current.setting.format_time_stamp, localtime (&right_now));
gmt_api.c:			T = (double)(toc - (clock_t)API->GMT->current.time.tic);	/* Elapsed time in ticks */
gmt_api.c:		tmp = (API->GMT->current.setting.run_mode == GMT_MODERN) ? strdup (&c[1]) : strdup (string_);
gmt_api.c:		if (API->GMT->current.setting.run_mode == GMT_MODERN && !strncmp (next, ">X}", 3U)) {	/* Modern mode cannot have PS redirection */
gmt_api.c:	GMT->current.io.ogr = GMT_OGR_UNKNOWN;
gmt_api.c:	GMT->current.io.variable_in_columns = false;
gmt_api.c:	GMT->current.io.need_previous = (GMT->common.g.active || GMT->current.io.skip_duplicates);
gmt_api.c:	GMT->current.io.segment_header[0] = GMT->current.io.curr_text[0] = 0;
gmt_api.c:	gmt_M_grd_setpad (GMT, h_tmp, GMT->current.io.pad);	/* Use the system pad setting by default */
gmt_api.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Unable to read header-less grid file %s without a preset header structure\n", file);
gmt_api.c:	fmt = GMT->session.grdformat[G->header->type];
gmt_api.c:		strncat (buffer, API->GMT->init.module_name, lim);
gmt_api.c:	struct GMT_COMMON *C = &API->GMT->common;	/* Short-hand to the common arg structs */
gmt_api.c:	gmt_M_memset (GMT->current.io.curr_pos[direction], 4U, int64_t);	/* Reset file, seg, point, header counters */
gmt_api.c:		mode = GMT->current.io.r_mode;
gmt_api.c:		GMT->current.io.curr_pos[GMT_IN][GMT_SEG] = -1;	/* First segment of input is set to -1 until first segment header have been dealt with */
gmt_api.c:		mode = GMT->current.io.w_mode;
gmt_api.c:	S_obj->n_expected_fields = (GMT->common.b.ncol[direction]) ? GMT->common.b.ncol[direction] : GMT_MAX_COLUMNS;
gmt_api.c:				mode = GMT->current.io.a_mode;	/* Must append to an existing file (we have already checked the file exists) */
gmt_api.c:			strncpy (GMT->current.io.filename[direction], &(S_obj->filename[first]), PATH_MAX-1);
gmt_api.c:					operation[direction], GMT->current.setting.io_n_header_items, dir[direction], &(S_obj->filename[first]));
gmt_api.c:			if (S_obj->family == GMT_IS_DATASET && S_obj->fp == GMT->session.std[direction])
gmt_api.c:			kind = (S_obj->fp == GMT->session.std[direction]) ? 0 : 1;	/* For message only: 0 if stdin/out, 1 otherwise for user pointer */
gmt_api.c:			snprintf (GMT->current.io.filename[direction], PATH_MAX-1, "<%s %s>", GMT_stream[kind], GMT_direction[direction]);
gmt_api.c:					operation[direction], GMT->current.setting.io_n_header_items, dir[direction], GMT_stream[kind]);
gmt_api.c:			kind = (S_obj->fp == GMT->session.std[direction]) ? 0 : 1;	/* For message only: 0 if stdin/out, 1 otherwise for user pointer */
gmt_api.c:			snprintf (GMT->current.io.filename[direction], PATH_MAX-1, "<%s %s>", GMT_stream[kind], GMT_direction[direction]);
gmt_api.c:					operation[direction], GMT->current.setting.io_n_header_items, dir[direction], GMT_stream[kind]);
gmt_api.c:				GMT->common.b.ncol[direction] = M_obj->n_columns;	/* Basically doing binary i/o with specified number of columns */
gmt_api.c:			GMT->common.b.active[direction] = true;	/* Basically, we are doing what GMT calls binary i/o since it is all in memory */
gmt_api.c:			strcpy (GMT->current.io.filename[direction], "<matrix memory>");
gmt_api.c:				GMT->common.b.ncol[direction] = V_obj->n_columns;	/* Basically doing binary i/o with specified number of columns */
gmt_api.c:			GMT->common.b.active[direction] = true;	/* Basically, we are doing what GMT calls binary i/o */
gmt_api.c:			strcpy (GMT->current.io.filename[direction], "<vector memory>");
gmt_api.c:	GMT->current.io.rec_in_tbl_no = 0;	/* Start on new table */
gmt_api.c:		GMT->current.io.record.data = NULL;	/* Since there isn't any data */
gmt_api.c:		S_obj->import = GMT->current.io.input;	/* import may point to ASCII or binary (if -b) input functions */
gmt_api.c:	return (api_get_object_id_from_data_ptr (GMT->parent, ptr) == GMT_NOTSET) ? false : true;
gmt_api.c:			kind = (S_obj->fp == GMT->session.std[GMT_IN]) ? 0 : 1;	/* 0 if stdin, 1 otherwise for user pointer */
gmt_api.c:			kind = (S_obj->fp == GMT->session.std[GMT_OUT]) ? 0 : 1;	/* 0 if stdout, 1 otherwise for user pointer */
gmt_api.c:			kind = (S_obj->fp == GMT->session.std[GMT_IN]) ? 0 : 1;	/* 0 if stdin, 1 otherwise for user pointer */
gmt_api.c:			kind = (S_obj->fp == GMT->session.std[GMT_OUT]) ? 0 : 1;	/* 0 if stdout, 1 otherwise for user pointer */
gmt_api.c:	uint64_t row = 0, col, ij, dim[4] = {0, 0, 0, GMT->current.setting.export_type};
gmt_api.c:		if ((fp = gmt_fopen (GMT, M_file, GMT->current.io.r_mode)) == NULL) {
gmt_api.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Cannot open Matrix file %s\n", M_file);
gmt_api.c:			return_null (GMT->parent, GMT_ERROR_ON_FOPEN);
gmt_api.c:		if (fp == NULL) fp = GMT->session.std[GMT_IN];	/* Default destination */
gmt_api.c:		if (fp == GMT->session.std[GMT_IN])
gmt_api.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Cannot convert Matrix file descriptor %d to stream in api_read_matrix\n", *fd);
gmt_api.c:			return_null (GMT->parent, GMT_ERROR_ON_FDOPEN);
gmt_api.c:		if (fd == NULL) fp = GMT->session.std[GMT_IN];	/* Default destination */
gmt_api.c:		if (fp == GMT->session.std[GMT_IN])
gmt_api.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Unrecognized source type %d in api_read_matrix\n", src_type);
gmt_api.c:		return_null (GMT->parent, GMT_NOT_A_VALID_METHOD);
gmt_api.c:	GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Read Matrix from %s\n", M_file);
gmt_api.c:		if (line[0] == GMT->current.setting.io_head_marker[GMT_IN]) continue;	/* Just skip headers */
gmt_api.c:				for (col = 0; col < dim[0]; col++) GMT->hidden.mem_coord[col][row] = GMT->session.d_NaN;
gmt_api.c:			dim[0] = gmtlib_conv_text2datarec (GMT, line, GMT_BUFSIZ, GMT->current.io.curr_rec);
gmt_api.c:			for (col = 0; col < dim[0]; col++) GMT->hidden.mem_coord[col][row] = GMT->current.io.curr_rec[col];
gmt_api.c:	if (add_first_segheader) for (col = 0; col < dim[0]; col++) GMT->hidden.mem_coord[col][0] = GMT->session.d_NaN;
gmt_api.c:	if ((M = GMT_Create_Data (GMT->parent, GMT_IS_MATRIX, GMT_IS_POINT, 0, dim, NULL, NULL, 0, 0, NULL)) == NULL) {
gmt_api.c:		return_null (GMT->parent, GMT_MEMORY_ERROR);
gmt_api.c:	api_put_val = api_select_put_function (GMT->parent, M->type);	/* Get correct put function given data type */
gmt_api.c:	GMT_2D_to_index = api_get_2d_to_index (GMT->parent, M->shape, GMT_GRID_IS_REAL);	/* Get ij index function */
gmt_api.c:			api_put_val (&(M->data), ij, GMT->hidden.mem_coord[col][row]);
gmt_api.c:			kind = (S_obj->fp == GMT->session.std[GMT_IN]) ? 0 : 1;	/* Used for message: 0 if stdin, 1 otherwise for user pointer */
gmt_api.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Cannot %s Matrix file %s\n", msg2[append], &M_file[append]);
gmt_api.c:		if (fp == NULL) fp = GMT->session.std[GMT_OUT];	/* Default destination */
gmt_api.c:		if (fp == GMT->session.std[GMT_OUT])
gmt_api.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Cannot convert Matrix file descriptor %d to stream in api_write_matrix\n", *fd);
gmt_api.c:		if (fd == NULL) fp = GMT->session.std[GMT_OUT];	/* Default destination */
gmt_api.c:		if (fp == GMT->session.std[GMT_OUT])
gmt_api.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Unrecognized source type %d in api_write_matrix\n", dest_type);
gmt_api.c:	GMT_Report (GMT->parent, GMT_MSG_DEBUG, "%s Matrix to %s\n", msg1[append], &M_file[append]);
gmt_api.c:	GMT_2D_to_index = api_get_2d_to_index (GMT->parent, M->shape, GMT_GRID_IS_REAL);
gmt_api.c:	api_get_val = api_select_get_function (GMT->parent, M->type);
gmt_api.c:			api_get_val (&(M->data), ij, &(GMT->current.io.curr_rec[col]));
gmt_api.c:			fprintf (fp, GMT->current.setting.format_float_out, GMT->current.io.curr_rec[0]);
gmt_api.c:				fprintf (fp, "%s", GMT->current.setting.io_col_separator);
gmt_api.c:				fprintf (fp, GMT->current.setting.format_float_out, GMT->current.io.curr_rec[col]);
gmt_api.c:			kind = (S_obj->fp == GMT->session.std[GMT_OUT]) ? 0 : 1;	/* For message only: 0 if stdout, 1 otherwise for user pointer */
gmt_api.c:		GMT_Report(GMT->parent, GMT_MSG_NORMAL, "GMTAPI: api_write_vector passed a NULL pointer *V\n");
gmt_api.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Cannot %s Matrix file %s\n", msg2[append], &V_file[append]);
gmt_api.c:		if (fp == NULL) fp = GMT->session.std[GMT_OUT];	/* Default destination */
gmt_api.c:		if (fp == GMT->session.std[GMT_OUT])
gmt_api.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Cannot convert Matrix file descriptor %d to stream in api_write_matrix\n", *fd);
gmt_api.c:		if (fd == NULL) fp = GMT->session.std[GMT_OUT];	/* Default destination */
gmt_api.c:		if (fp == GMT->session.std[GMT_OUT])
gmt_api.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Unrecognized source type %d in api_write_matrix\n", dest_type);
gmt_api.c:	GMT_Report (GMT->parent, GMT_MSG_DEBUG, "%s Matrix to %s\n", msg1[append], &V_file[append]);
gmt_api.c:		api_get_val[col] = api_select_get_function (GMT->parent, V->type[col]);
gmt_api.c:			api_get_val[col] (&(V->data[col]), row, &(GMT->current.io.curr_rec[col]));
gmt_api.c:			fprintf (fp, GMT->current.setting.format_float_out, GMT->current.io.curr_rec[0]);
gmt_api.c:				fprintf (fp, "%s", GMT->current.setting.io_col_separator);
gmt_api.c:				fprintf (fp, GMT->current.setting.format_float_out, GMT->current.io.curr_rec[col]);
gmt_api.c:			kind = (S_obj->fp == GMT->session.std[GMT_OUT]) ? 0 : 1;	/* For message only: 0 if stdout, 1 otherwise for user pointer */
gmt_api.c:	uint64_t row = 0, col, dim[GMT_DIM_SIZE] = {0, 0, GMT->current.setting.export_type, 0};
gmt_api.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Cannot open Vector file %s\n", V_file);
gmt_api.c:			return_null (GMT->parent, GMT_ERROR_ON_FOPEN);
gmt_api.c:		if (fp == NULL) fp = GMT->session.std[GMT_IN];	/* Default destination */
gmt_api.c:		if (fp == GMT->session.std[GMT_IN])
gmt_api.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Cannot convert Vector file descriptor %d to stream in api_read_vector\n", *fd);
gmt_api.c:			return_null (GMT->parent, GMT_ERROR_ON_FDOPEN);
gmt_api.c:		if (fd == NULL) fp = GMT->session.std[GMT_IN];	/* Default destination */
gmt_api.c:		if (fp == GMT->session.std[GMT_IN])
gmt_api.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Unrecognized source type %d in api_read_vector\n", src_type);
gmt_api.c:		return_null (GMT->parent, GMT_NOT_A_VALID_METHOD);
gmt_api.c:	GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Read Vector from %s\n", V_file);
gmt_api.c:		if (line[0] == GMT->current.setting.io_head_marker[GMT_IN]) continue;	/* Just skip headers */
gmt_api.c:				for (col = 0; col < dim[0]; col++) GMT->hidden.mem_coord[col][row] = GMT->session.d_NaN;
gmt_api.c:			dim[0] = gmtlib_conv_text2datarec (GMT, line, GMT_BUFSIZ, GMT->current.io.curr_rec);
gmt_api.c:			for (col = 0; col < dim[0]; col++) GMT->hidden.mem_coord[col][row] = GMT->current.io.curr_rec[col];
gmt_api.c:	if (add_first_segheader) for (col = 0; col < dim[0]; col++) GMT->hidden.mem_coord[col][0] = GMT->session.d_NaN;
gmt_api.c:	if ((V = GMT_Create_Data (GMT->parent, GMT_IS_VECTOR, GMT_IS_POINT, 0, dim, NULL, NULL, 0, 0, NULL)) == NULL) {
gmt_api.c:		return_null (GMT->parent, GMT_MEMORY_ERROR);
gmt_api.c:		api_put_val = api_select_put_function (GMT->parent, V->type[col]);
gmt_api.c:			api_put_val (&(V->data[col]), row, GMT->hidden.mem_coord[col][row]);
gmt_api.c:			kind = (S_obj->fp == GMT->session.std[GMT_IN]) ? 0 : 1;	/* For message only: 0 if stdin, 1 otherwise for user pointer */
gmt_api.c:	DH->alloc_level = GMT->hidden.func_level;	/* So GMT_* modules can free this memory (may override below) */
gmt_api.c:	GMT->current.io.seg_no = GMT->current.io.rec_no = GMT->current.io.rec_in_tbl_no = 0;	/* Reset for each new dataset */
gmt_api.c:	if (GMT->common.R.active[RSET] && GMT->common.R.wesn[XLO] < -180.0 && GMT->common.R.wesn[XHI] > -180.0) greenwich = false;
gmt_api.c:		geometry = (GMT->common.a.output) ? GMT->common.a.geometry : S_obj->geometry;	/* When reading GMT and writing OGR/GMT we must make sure we set this first */
gmt_api.c:				GMT->current.io.first_rec = true;
gmt_api.c:				if (GMT->current.io.ogr == GMT_OGR_TRUE && D_obj->n_tables > 0) {	/* Only single tables if GMT/OGR */
gmt_api.c:				GMT->current.io.first_rec = true;
gmt_api.c:				if (GMT->current.io.ogr == GMT_OGR_TRUE && D_obj->n_tables > 0)	{	/* Only single tables if GMT/OGR */
gmt_api.c:				n_columns = (GMT->common.i.select) ? GMT->common.i.n_cols : M_obj->n_columns;
gmt_api.c:						api_get_val (&(M_obj->data), ij, &(GMT->current.io.curr_rec[col]));
gmt_api.c:							S->data[col][n_records] = api_get_record_value (GMT, GMT->current.io.curr_rec, col, M_obj->n_columns);
gmt_api.c:				n_columns = (GMT->common.i.select) ? GMT->common.i.n_cols : V_obj->n_columns;
gmt_api.c:						api_get_val (&(V_obj->data[col]), row, &(GMT->current.io.curr_rec[col]));
gmt_api.c:							S->data[col][n_records] = api_get_record_value (GMT, GMT->current.io.curr_rec, col, V_obj->n_columns);
gmt_api.c:				n_columns = (GMT->common.i.select) ? GMT->common.i.n_cols : V_obj->n_columns;
gmt_api.c:					if (GMT->common.i.select)	/* -i has selected some columns */
gmt_api.c:						col_pos = GMT->current.io.col[GMT_IN][col].col;	/* Which data column to pick */
gmt_api.c:					else if (GMT->current.setting.io_lonlat_toggle[GMT_IN] && col < GMT_Z)	/* Worry about -: for lon,lat */
gmt_api.c:	if (API->GMT->common.o.end || GMT->common.o.text)	/* Asked for unspecified last column on input (e.g., -i3,2,5:), supply the missing last column number */
gmt_api.c:		gmtlib_reparse_o_option (GMT, (GMT->common.o.text) ? 0 : D_obj->n_columns);
gmt_api.c:			save = GMT->current.io.multi_segments[GMT_OUT];
gmt_api.c:			if (GMT->current.io.skip_headers_on_outout) GMT->current.io.multi_segments[GMT_OUT] = false;
gmt_api.c:			n_rows = (GMT->current.io.multi_segments[GMT_OUT]) ? D_obj->n_records + D_obj->n_segments : D_obj->n_records;	/* Number of rows needed to hold the data [incl any segment headers] */
gmt_api.c:			n_columns = (GMT->common.o.select) ? GMT->common.o.n_cols : D_obj->n_columns;					/* Number of columns needed to hold the data records */
gmt_api.c:					if (GMT->current.io.multi_segments[GMT_OUT]) {	/* Must write a NaN-segment record to indicate segment break */
gmt_api.c:							api_put_val (&(M_obj->data), ij, GMT->session.d_NaN);
gmt_api.c:			GMT->current.io.multi_segments[GMT_OUT] = save;
gmt_api.c:			save = GMT->current.io.multi_segments[GMT_OUT];
gmt_api.c:			if (GMT->current.io.skip_headers_on_outout) GMT->current.io.multi_segments[GMT_OUT] = false;
gmt_api.c:			n_columns = (GMT->common.o.select) ? GMT->common.o.n_cols : D_obj->n_columns;	/* Number of columns needed to hold the data records */
gmt_api.c:			n_rows = (GMT->current.io.multi_segments[GMT_OUT]) ? D_obj->n_records + D_obj->n_segments : D_obj->n_records;	/* Number of data records [and any segment headers] */
gmt_api.c:					if (GMT->current.io.multi_segments[GMT_OUT]) {		/* Must write a NaN-segment record */
gmt_api.c:							api_put_val (&(V_obj->data[col]), row_out, GMT->session.d_NaN);
gmt_api.c:			GMT->current.io.multi_segments[GMT_OUT] = save;
gmt_api.c:			n_columns = (GMT->common.o.select) ? GMT->common.o.n_cols : D_obj->n_columns;	/* Number of columns needed to hold the data records */
gmt_api.c:			if (!S_obj->region && gmt_grd_pad_status (GMT, I_obj->header, GMT->current.io.pad)) {	/* Want an exact copy with no subset and same padding */
gmt_api.c:			gmt_M_memcpy (I_obj->header->pad, GMT->current.io.pad, 4, int);	/* Set desired padding */
gmt_api.c:			if (!api_adjust_grdpadding (I_obj->header, GMT->current.io.pad)) break;	/* Pad is correct so we are done */
gmt_api.c:			gmt_grd_pad_on (GMT, image, GMT->current.io.pad);
gmt_api.c:			if (!api_adjust_grdpadding (I_obj->header, GMT->current.io.pad)) break;	/* Pad is correct so we are done */
gmt_api.c:			/* gmt_grd_pad_on (GMT, I, GMT->current.io.pad);*/
gmt_api.c:	if ((fp = gmt_fopen (GMT, fname, GMT->current.io.w_mode)) == NULL) {	/* Return -1 to signify failure */
gmt_api.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Cannot create file %s\n", fname);
gmt_api.c:							GMT->current.io.pad, mode), S_obj->filename))
gmt_api.c:			if (!S_obj->region && gmt_grd_pad_status (GMT, G_obj->header, GMT->current.io.pad)) {	/* Want an exact copy with no subset and same padding */
gmt_api.c:			gmt_M_memcpy (G_obj->header->pad, GMT->current.io.pad, 4, int);	/* Set desired padding */
gmt_api.c:			if (!api_adjust_grdpadding (G_obj->header, GMT->current.io.pad)) break;	/* Pad is correct so we are done */
gmt_api.c:			gmt_grd_pad_on (GMT, G_obj, GMT->current.io.pad);
gmt_api.c:				if (api_adjust_grdpadding (G_copy->header, GMT->current.io.pad))
gmt_api.c:					gmt_grd_pad_on (GMT, G_copy, GMT->current.io.pad);
gmt_api.c:			gmt_M_memcpy (G_obj->header->pad, GMT->current.io.pad, 4, int);		/* Set desired padding */
gmt_api.c:					if (API->GMT->common.R.active[RSET]) {	/* Global subset may have been specified (it might also match the grid/image domain) */
gmt_api.c:						gmt_M_memcpy (wesn, API->GMT->common.R.wesn, 4U, double);
gmt_api.c:		if ((object_ID = GMT_Register_IO (API, family|GMT_VIA_MODULE_INPUT, GMT_IS_STREAM, geometry, GMT_IN, NULL, API->GMT->session.std[GMT_IN])) == GMT_NOTSET)
gmt_api.c:		API->GMT->current.io.trailing_text[GMT_IN] = true;
gmt_api.c:		if ((object_ID = GMT_Register_IO (API, family, GMT_IS_STREAM, geometry, GMT_OUT, NULL, API->GMT->session.std[GMT_OUT])) == GMT_NOTSET)
gmt_api.c:	if (IH->alloc_level != API->GMT->hidden.func_level) return (GMT_FREE_WRONG_LEVEL);	/* Not the right level */
gmt_api.c:	if (GH->alloc_level != API->GMT->hidden.func_level) return (GMT_FREE_WRONG_LEVEL);	/* Not the right level */
gmt_api.c:	if (DH->alloc_level != API->GMT->hidden.func_level) return (GMT_FREE_WRONG_LEVEL);	/* Not the right level */
gmt_api.c:	if (PH->alloc_level != API->GMT->hidden.func_level) return (GMT_FREE_WRONG_LEVEL);	/* Not the right level */
gmt_api.c:	if (PH->alloc_level != API->GMT->hidden.func_level) return (GMT_FREE_WRONG_LEVEL);	/* Not the right level */
gmt_api.c:	if (MH->alloc_level != API->GMT->hidden.func_level) return (GMT_FREE_WRONG_LEVEL);	/* Not the right level */
gmt_api.c:	if (VH->alloc_level != API->GMT->hidden.func_level) return (GMT_FREE_WRONG_LEVEL);	/* Not the right level */
gmt_api.c:		if (!API || !API->GMT || (fp = API->GMT->session.std[GMT_ERR]) == NULL) fp = stderr;
gmt_api.c:		if (strlen(API->GMT->init.module_name) < 500)		/* 500, just to shut up a Coverity issue */
gmt_api.c:			strcat (buffer, API->GMT->init.module_name);
gmt_api.c:	if (GMT->session.grdformat[G->header->type][0] == 'c' || GMT->session.grdformat[G->header->type][0] == 'n')
gmt_api.c:		API->GMT->session.std[GMT_ERR] = fp;	/* Set the error fp pointer */
gmt_api.c:		API->GMT->init.module_name = API->session_tag;	/* So non-modules can report name of program, */
gmt_api.c:		API->GMT->init.module_name = unknown; /* or unknown */
gmt_api.c:	module = strdup (API->GMT->init.module_name);	/* Need a copy as the pointer to static memory in library will close soon */
gmt_api.c:	API->GMT->init.module_name = module;		/* So GMT_Report will function after supplemental.so shut down */
gmt_api.c:	if (API->GMT->session.std[GMT_ERR] != stderr)	/* Close the error log fp pointer */
gmt_api.c:		fclose (API->GMT->session.std[GMT_ERR]);
gmt_api.c:	 *   GMT_IS_REFERENCE:	A pointer to a data set to be passed as is [we may reallocate sizes only if GMT-allocated]
gmt_api.c:	 *   GMT_IS_REFERENCE:	A pointer to a data set to be passed as is [we may reallocate sizes only if GMT-allocated]
gmt_api.c:	S_obj->alloc_level = GMT->hidden.func_level;	/* Object was allocated at this module nesting level */
gmt_api.c:	int64_t *count = API->GMT->current.io.curr_pos[GMT_OUT];		/* Short-hand for counts of tbl, seg, rows */
gmt_api.c:		unsigned int smode = (API->GMT->current.io.record_type[GMT_OUT] & GMT_WRITE_TEXT) ? GMT_WITH_STRINGS : GMT_NO_STRINGS;
gmt_api.c:				api_put_val (&(M->data), ij, API->GMT->session.d_NaN);
gmt_api.c:				API->current_put_V_val[col] (&(V->data[col]), S->delay, API->GMT->session.d_NaN);
gmt_api.c:	gmtlib_free_ogr (API->GMT, &(API->GMT->current.io.OGR), 0);	/* Free segment-related array */
gmt_api.c:	IO = &(API->GMT->current.io);	/* Pointer to the GMT IO structure */
gmt_api.c:			S_obj->type = (via_type) ? via_type - 1 : API->GMT->current.setting.export_type;	/* Remember what output type we want */
gmt_api.c:		if ((in_ID = GMT_Register_IO (API, family|module_input, GMT_IS_STREAM, geometry, GMT_IN, wesn, API->GMT->session.std[GMT_IN])) == GMT_NOTSET) {
gmt_api.c:		if ((out_ID = GMT_Register_IO (API, family, GMT_IS_STREAM, geometry, GMT_OUT, wesn, API->GMT->session.std[GMT_OUT])) == GMT_NOTSET) return_error (API, API->error);	/* Failure to register std??? */
gmt_api.c:	if (GMT->current.io.status & GMT_IO_EOF) {	/* Hit end-of-file in current file (but there may be many files in queue) */
gmt_api.c:			GMT->current.io.status = GMT_IO_NEXT_FILE;	/* And set the status accordingly */
gmt_api.c:		GMT->current.io.tbl_no++;				/* Update number of tables we have processed */
gmt_api.c:		GMT->common.b.ncol[GMT_IN] = S->n_expected_fields;
gmt_api.c:			GMT->current.io.status = GMT_IO_EOF;
gmt_api.c:			GMT->current.io.status = GMT_IO_NEXT_FILE;
gmt_api.c:		API->current_get_n_columns = (GMT->common.i.select) ? GMT->common.i.n_cols : S->n_columns;
gmt_api.c:			API->current_get_M_val (&(M->data), ij, &(GMT->current.io.curr_rec[col]));
gmt_api.c:				strncpy (GMT->current.io.curr_trailing_text, M->text[S->rec-1], GMT_BUFSIZ-1);
gmt_api.c:			record = &GMT->current.io.record;
gmt_api.c:			GMT->current.io.status = GMT_IO_EOF;
gmt_api.c:			GMT->current.io.status = GMT_IO_NEXT_FILE;
gmt_api.c:		API->current_get_n_columns = (GMT->common.i.select) ? GMT->common.i.n_cols : S->n_columns;
gmt_api.c:			API->current_get_V_val[col] (&(V->data[col_pos]), S->rec, &(GMT->current.io.curr_rec[col]));
gmt_api.c:				strncpy (GMT->current.io.curr_trailing_text, V->text[S->rec-1], GMT_BUFSIZ-1);
gmt_api.c:			record = &GMT->current.io.record;
gmt_api.c:	int64_t *count = GMT->current.io.curr_pos[GMT_IN];	/* Shorthand used below */
gmt_api.c:				GMT->current.io.curr_rec[col] = D->table[count[GMT_TBL]]->segment[count[GMT_SEG]]->data[col_pos][count[GMT_ROW]];
gmt_api.c:				strncpy (GMT->current.io.curr_trailing_text, D->table[count[GMT_TBL]]->segment[count[GMT_SEG]]->text[count[GMT_ROW]], GMT_BUFSIZ-1);
gmt_api.c:			record = &GMT->current.io.record;
gmt_api.c:			GMT->common.b.ncol[GMT_IN] = API->current_get_n_columns;
gmt_api.c:				strncpy (GMT->current.io.segment_header, D->table[count[GMT_TBL]]->segment[count[GMT_SEG]]->header, GMT_BUFSIZ-1);
gmt_api.c:				GMT->current.io.segment_header[0] = '\0';	/* No header for this segment */
gmt_api.c:			strncpy (GMT->current.io.curr_text, D->table[count[GMT_TBL]]->header[count[GMTAPI_HDR_POS]-1], GMT_BUFSIZ-1);
gmt_api.c:	GMT->current.io.status = status;
gmt_api.c:	GMT->current.io.record.text = GMT->current.io.curr_trailing_text;
gmt_api.c:	GMT->current.io.record.data = GMT->current.io.curr_rec;
gmt_api.c:	GMT->current.io.status = 0;	/* Initialize status to OK */
gmt_api.c:			GMT->current.io.first_rec = true;
gmt_api.c:			API->current_get_n_columns = (GMT->common.i.select) ? GMT->common.i.n_cols : S->n_columns;
gmt_api.c:			if (API->current_get_M->text == NULL) GMT->current.io.record.text = NULL;
gmt_api.c:			API->current_get_n_columns = (GMT->common.i.select) ? GMT->common.i.n_cols : S->n_columns;
gmt_api.c:			if (API->current_get_V->text == NULL) GMT->current.io.record.text = NULL;
gmt_api.c:			API->current_get_n_columns = (GMT->common.i.select) ? GMT->common.i.n_cols : API->current_get_D_set->n_columns;
gmt_api.c:			if (!(API->current_get_D_set->type & GMT_READ_TEXT)) GMT->current.io.record.text = NULL;
gmt_api.c:	 * If not a data record we return NULL, and pass status via API->GMT->current.io.status.
gmt_api.c:		GMT->current.io.status = 0;	/* Initialize status to OK */
gmt_api.c:			s = (record) ? (char*) (record) : GMT->current.io.curr_text;	/* Default to last input record if NULL */
gmt_api.c:			if (record) strncpy (GMT->current.io.segment_header, (char*) (record), GMT_BUFSIZ-1);	/* Default to last segment record if NULL */
gmt_api.c:			gmt_write_segmentheader (GMT, API->current_fp, GMT->common.b.ncol[GMT_OUT]);	error = 1;	/* Write one item */
gmt_api.c:			if (GMT->common.b.ncol[GMT_OUT] == UINT_MAX) GMT->common.b.ncol[GMT_OUT] = GMT->common.b.ncol[GMT_IN];
gmt_api.c:			error = GMT->current.io.output (GMT, API->current_fp, GMT->common.b.ncol[GMT_OUT], record->data, record->text);
gmt_api.c:	int64_t *count = GMT->current.io.curr_pos[GMT_OUT];	/* Short hand to counters for table (not used as == 0), segment, row */
gmt_api.c:			s = (record) ? (char *)record : GMT->current.io.curr_text;	/* Default to last input record if NULL */
gmt_api.c:			s = (record) ? (char *)record : GMT->current.io.segment_header;	/* Default to last segment header record if NULL */
gmt_api.c:				value = api_select_record_value (GMT, record->data, (unsigned int)col, (unsigned int)GMT->common.b.ncol[GMT_OUT]);
gmt_api.c:				if (GMT->current.io.col_type[GMT_OUT][col] & GMT_IS_LON) gmt_lon_range_adjust (GMT->current.io.geo.range, &value);
gmt_api.c:				GMT->hidden.mem_coord[col][count[GMT_ROW]] = value;
gmt_api.c:				GMT->hidden.mem_txt[count[GMT_ROW]] = strdup (record->text);
gmt_api.c:			s = (record) ? (char *)record : GMT->current.io.curr_text;	/* Default to last input record if NULL */
gmt_api.c:			if (GMT->current.io.multi_segments[GMT_OUT]) {	/* Flag in data as NaNs in current_record (d) */
gmt_api.c:					API->current_put_M_val (&(M->data), ij, GMT->session.d_NaN);
gmt_api.c:						value = api_select_record_value (GMT, record->data, (unsigned int)col, (unsigned int)GMT->common.b.ncol[GMT_OUT]);
gmt_api.c:			s = (record) ? (char *)record : GMT->current.io.curr_text;	/* Default to last input record if NULL */
gmt_api.c:			if (GMT->current.io.multi_segments[GMT_OUT]) {	/* Segment header - flag in data as NaNs */
gmt_api.c:					API->current_put_V_val[col] (&(V->data[col]), API->current_put_obj->rec, GMT->session.d_NaN);
gmt_api.c:						value = api_select_record_value (GMT, record->data, (unsigned int)col, (unsigned int)GMT->common.b.ncol[GMT_OUT]);
gmt_api.c:			if (API->GMT->common.o.end || API->GMT->common.o.text)	/* Asked for unspecified last column on input (e.g., -i3,2,5:), supply the missing last column number */
gmt_api.c:				gmtlib_reparse_o_option (API->GMT, (API->GMT->common.o.text) ? 0 : S_obj->n_columns);
gmt_api.c:					if (record) strncpy (GMT->current.io.curr_text, (char*) (record), GMT_BUFSIZ-1);	/* Default to last segment record if NULL */
gmt_api.c:					API->tmp_header[API->n_tmp_headers++] = strdup (GMT->current.io.curr_text);
gmt_api.c:					if (record) strncpy (GMT->current.io.segment_header, (char*) (record), GMT_BUFSIZ-1);	/* Default to last segment record if NULL */
gmt_api.c:					API->tmp_segmentheader = strdup (GMT->current.io.segment_header);
gmt_api.c:					GMT->current.io.record_type[GMT_OUT] = GMT_WRITE_DATA;
gmt_api.c:					GMT->current.io.record_type[GMT_OUT] = GMT_WRITE_TEXT;
gmt_api.c:					GMT->current.io.record_type[GMT_OUT] = GMT_WRITE_MIXED;
gmt_api.c:				smode = (GMT->current.io.record_type[GMT_OUT] & GMT_WRITE_TEXT) ? GMT_WITH_STRINGS : GMT_NO_STRINGS;
gmt_api.c:				GMT->current.io.curr_pos[GMT_OUT][GMT_SEG] = -1;	/* Start at seg = -1 and increment at first segment header */
gmt_api.c:				col = (GMT->common.o.select) ? GMT->common.o.n_cols : GMT->common.b.ncol[GMT_OUT];	/* Number of columns needed to hold the data records */
gmt_api.c:				if ((GMT->current.io.record_type[GMT_OUT] & GMT_WRITE_DATA) && col == 0) {	/* Still don't know # of columns */
gmt_api.c:					if (GMT->common.b.ncol[GMT_IN] < GMT_MAX_COLUMNS) {	/* Hail Mary pass to input columns */
gmt_api.c:						col = GMT->common.b.ncol[GMT_IN];	/* Set output cols to equal input cols since not set */
gmt_api.c:						GMT_Report (API, GMT_MSG_DEBUG, "GMTAPI: GMT_Put_Record does not know the number of output columns - set to equal input at %d\n", (int)GMT->common.b.ncol[GMT_IN]);
gmt_api.c:				if (GMT->current.io.record_type[GMT_OUT] == GMT_WRITE_TEXT) col = 0;	/* Just to be safe rather than fucked */
gmt_api.c:				if (GMT->common.b.ncol[GMT_OUT] == 0) GMT->common.b.ncol[GMT_OUT] = col;
gmt_api.c:				if (record) strncpy (GMT->current.io.curr_text, (char*) (record), GMT_BUFSIZ-1);	/* Default to last segment record if NULL */
gmt_api.c:				API->tmp_header[API->n_tmp_headers++] = strdup (GMT->current.io.curr_text);
gmt_api.c:				col = (GMT->common.o.select) ? GMT->common.o.n_cols : GMT->common.b.ncol[GMT_OUT];	/* Number of columns needed to hold the data records */
gmt_api.c:				if (col == 0 && mode == GMT_WRITE_SEGMENT_HEADER && GMT->current.io.multi_segments[GMT_OUT]) {
gmt_api.c:				if (record) strncpy (GMT->current.io.curr_text, (char*) (record), GMT_BUFSIZ-1);	/* Default to last segment record if NULL */
gmt_api.c:				API->tmp_header[API->n_tmp_headers++] = strdup (GMT->current.io.curr_text);
gmt_api.c:				col = (GMT->common.o.select) ? GMT->common.o.n_cols : GMT->common.b.ncol[GMT_OUT];	/* Number of columns needed to hold the data records */
gmt_api.c:				if (col == 0 && mode == GMT_WRITE_SEGMENT_HEADER && GMT->current.io.multi_segments[GMT_OUT]) {
gmt_api.c:					V_obj->type[col] = GMT->current.setting.export_type;
gmt_api.c:	GMT->current.io.need_previous = (GMT->common.g.active || GMT->current.io.skip_duplicates);
gmt_api.c:	GMT->current.io.ogr = GMT_OGR_UNKNOWN;
gmt_api.c:	GMT->current.io.segment_header[0] = GMT->current.io.curr_text[0] = 0;
gmt_api.c:	GMT->current.io.first_rec = true;
gmt_api.c:		API->GMT->current.io.record_type[GMT_OUT] = API->GMT->current.io.record_type[GMT_IN];	/* Can be overruled by GMT_Set_Columns */
gmt_api.c:		//if (header == GMT_HEADER_ON && !GMT->common.b.active[GMT_OUT]) GMT_Put_Record (API, GMT_WRITE_TABLE_START, NULL);	/* Write standard ASCII header block */
gmt_api.c:		if (!GMT->common.o.active) GMT->current.io.trailing_text[GMT_OUT] = true;	/* Default reads and writes any trailing text */
gmt_api.c:		if (!GMT->common.i.active) GMT->current.io.trailing_text[GMT_IN] = true;	/* Default reads and writes any trailing text */
gmt_api.c:	fmt = GMT->session.grdformat[G->header->type];
gmt_api.c:				row[col] = GMT->session.f_NaN;
gmt_api.c:	fmt = GMT->session.grdformat[G->header->type];
gmt_api.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Data and FFT dimensions are equal - no data extension will take place\n");
gmt_api.c:			GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Data and FFT dimensions are equal - no tapering will be performed\n");
gmt_api.c:			GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "No interior tapering will be performed\n");
gmt_api.c:		GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Demultiplexing complex grid before tapering can take place.\n");
gmt_api.c:	i_data_start = GMT->current.io.pad[XLO];	/* Some shorthands for readability */
gmt_api.c:	j_data_start = GMT->current.io.pad[YHI];
gmt_api.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Tapering has been disabled via +t0\n");
gmt_api.c:			GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Grid margin (%s component) tapered to zero over %d %% of data width and height\n", comp[component], width_percent);
gmt_api.c:			GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Grid (%s component) extended via %s symmetry at all edges, then tapered to zero over %d %% of extended area\n", comp[component], method[F->taper_mode], width_percent);
gmt_api.c:	GMT->current.io.pad[XLO] = (F->n_columns - G->header->n_columns) / 2;	/* zero if n_columns < G->header->n_columns+1  */
gmt_api.c:	GMT->current.io.pad[YHI] = (F->n_rows - G->header->n_rows) / 2;
gmt_api.c:	GMT->current.io.pad[XHI] = F->n_columns - G->header->n_columns - GMT->current.io.pad[XLO];
gmt_api.c:	GMT->current.io.pad[YLO] = F->n_rows - G->header->n_rows - GMT->current.io.pad[YHI];
gmt_api.c:		K->delta_kx /= (GMT->current.proj.DIST_M_PR_DEG * cosd (0.5 * (G->header->wesn[YLO] + G->header->wesn[YHI])));
gmt_api.c:		K->delta_ky /= GMT->current.proj.DIST_M_PR_DEG;
gmt_api.c:			GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Extend grid via copy onto larger memory-aligned grid\n");
gmt_api.c:			gmt_grd_pad_on (GMT, G, GMT->current.io.pad);
gmt_api.c:		if (GMT_Read_Data (GMT->parent, GMT_IS_GRID, GMT_IS_FILE, GMT_IS_SURFACE, GMT_DATA_ONLY | mode, NULL, HH->name, G) == NULL)	/* Get data only */
gmt_api.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Created grid has no name to derive new names from; choose %s\n", file);
gmt_api.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "File name [ %s] way too long - trouble in fft_file_name_with_suffix\n", file);
gmt_api.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Demultiplexing complex grid before saving can take place.\n");
gmt_api.c:	gmt_M_memset (GMT->current.io.pad, 4U, unsigned int);	/* set GMT default pad to {0,0,0,0} */
gmt_api.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Unable to get file name for file %s\n", HH->name);
gmt_api.c:	if (GMT_Write_Data (GMT->parent, GMT_IS_GRID, GMT_IS_FILE, GMT_IS_SURFACE, GMT_DATA_ONLY | GMT_GRID_IS_COMPLEX_REAL, NULL, file, Grid) != GMT_NOERROR)
gmt_api.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Intermediate detrended, extended, and tapered grid could not be written to %s\n", file);
gmt_api.c:		GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Intermediate detrended, extended, and tapered grid written to %s\n", file);
gmt_api.c:	gmt_M_memcpy (GMT->current.io.pad, pad, 4U, unsigned int);	/* Restore GMT default pad */
gmt_api.c:	GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Write components of complex raw spectrum with file suffix %s and %s\n", suffix[mode][0], suffix[mode][1]);
gmt_api.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Cannot save complex grid unless it is interleaved.\n");
gmt_api.c:	gmt_M_memcpy (pad, GMT->current.io.pad, 4U, unsigned int);	/* Save current GMT pad */
gmt_api.c:	for (k = 0; k < 4; k++) GMT->current.io.pad[k] = 0;		/* No pad is what we need for this application */
gmt_api.c:	if ((Out = GMT_Create_Data (GMT->parent, GMT_IS_GRID, GMT_IS_SURFACE, GMT_CONTAINER_AND_DATA | GMT_GRID_IS_COMPLEX_MASK,
gmt_api.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Unable to create complex output grid for %s\n", HH->name);
gmt_api.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Unable to get file name for file %s\n", HH->name);
gmt_api.c:		if (GMT_Write_Data (GMT->parent, GMT_IS_GRID, GMT_IS_FILE, GMT_IS_SURFACE, GMT_CONTAINER_AND_DATA | wmode[k], NULL, file, Out) != GMT_NOERROR) {
gmt_api.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "%s could not be written\n", file);
gmt_api.c:	if (GMT_Destroy_Data (GMT->parent, &Out) != GMT_NOERROR) {
gmt_api.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error freeing temporary grid\n");
gmt_api.c:	gmt_M_memcpy (GMT->current.io.pad, pad, 4U, unsigned int);	/* Restore GMT pad */
gmt_api.c:		else if (API->GMT->current.setting.run_mode == GMT_MODERN && (opt = GMT_Find_Option (API, 'H', *head)) == NULL) {	/* Modern mode, no -H */
gmt_api.c:		if (API->GMT->current.setting.run_mode == GMT_MODERN && (opt = GMT_Find_Option (API, 'H', *head)) == NULL) {	/* Modern mode, no -H */
gmt_api.c:		case 'B':	if (GMT->common.B.active[0] || GMT->common.B.active[1]) ret = 0; break;
gmt_api.c:			if (GMT->common.R.active[ISET]) {
gmt_api.c:				if (par) gmt_M_memcpy (par, GMT->common.R.inc, 2, double);
gmt_api.c:		case 'J':	if (GMT->common.J.active) ret = 0; break;
gmt_api.c:		case 'K':	if (GMT->common.K.active) ret = 0; break;
gmt_api.c:		case 'O':	if (GMT->common.O.active) ret = 0; break;
gmt_api.c:		case 'P':	if (GMT->common.P.active) ret = 0; break;
gmt_api.c:			if (GMT->common.R.active[RSET]) {
gmt_api.c:				if (par) gmt_M_memcpy (par, GMT->common.R.wesn, 4, double);
gmt_api.c:		case 'U':	if (GMT->common.U.active) ret = 0; break;
gmt_api.c:		case 'V':	if (GMT->common.V.active) ret = GMT->current.setting.verbose; break;
gmt_api.c:			if (GMT->common.X.active) {
gmt_api.c:				if (par) par[0] = GMT->common.X.off;
gmt_api.c:			if (GMT->common.Y.active) {
gmt_api.c:				if (par) par[0] = GMT->common.Y.off;
gmt_api.c:		case 'a':	if (GMT->common.a.active) ret = GMT->common.a.geometry; break;
gmt_api.c:		case 'b':	if (GMT->common.b.active[GMT_IN]) ret = GMT_IN; else if (GMT->common.b.active[GMT_OUT]) ret = GMT_OUT; break;
gmt_api.c:		case 'f':	if (GMT->common.f.active[GMT_IN]) ret = GMT_IN; else if (GMT->common.f.active[GMT_OUT]) ret = GMT_OUT; break;
gmt_api.c:		case 'g':	if (GMT->common.g.active) ret = 0; break;
gmt_api.c:		case 'h':	if (GMT->common.h.active) ret = GMT->common.h.mode; break;
gmt_api.c:		case 'i':	if (GMT->common.i.select) ret = (int)GMT->common.i.n_cols; break;
gmt_api.c:		case 'n':	if (GMT->common.n.active) ret = 0; break;
gmt_api.c:		case 'o':	if (GMT->common.o.select) ret = (int)GMT->common.o.n_cols; break;
gmt_api.c:		case 'p':	if (GMT->common.p.active) ret = 0; break;
gmt_api.c:		case 'r':	if (GMT->common.R.active[GSET]) ret = GMT->common.R.registration; break;
gmt_api.c:		case 's':	if (GMT->common.s.active) ret = 0; break;
gmt_api.c:			if (GMT->common.t.active) {
gmt_api.c:				if (par) par[0] = GMT->common.t.value;
gmt_api.c:		case ':':	if (GMT->common.colon.toggle[GMT_IN]) ret = GMT_IN; else if (GMT->common.colon.toggle[GMT_OUT]) ret = GMT_OUT; break;
gmt_api.c:		sprintf (value, "%s", API->GMT->init.runtime_bindir);
gmt_api.c:		sprintf (value, "%s", API->GMT->session.SHAREDIR);
gmt_api.c:		sprintf (value, "%s", API->GMT->session.DATADIR);
gmt_api.c:		sprintf (value, "%s", API->GMT->init.runtime_plugindir);
gmt_api.c:		sprintf (value, "%s", API->GMT->init.runtime_library);
gmt_api.c:		gmt_M_memcpy (value, API->GMT->current.gdal_read_in.O.mem_layout, 4, char);
gmt_api.c:			gmt_M_memcpy (API->GMT->current.gdal_read_in.O.mem_layout, value, 4, char);
gmt_api.c:	if (API->GMT) err = API->GMT->session.std[GMT_ERR];
gmt_api.c:	g_level = (GMT) ? GMT->current.setting.verbose : 0;
gmt_api.c:	if (GMT) err = GMT->session.std[GMT_ERR];
gmt_api.c:	if (GMT && GMT->current.setting.timer_mode > GMT_NO_TIMER) {
gmt_api.c:		char *stamp = api_tictoc_string (API, GMT->current.setting.timer_mode);	/* NULL or pointer to a timestamp string */
gmt_api.c:	if (GMT && GMT->init.module_name)
gmt_api.c:		module_name = ((GMT->current.setting.run_mode == GMT_MODERN)) ? gmt_current_name (GMT->init.module_name, not_used) : GMT->init.module_name;
gmt_api.c:				fclose (API->GMT->session.std[GMT_ERR]);
gmt_api.c:			API->GMT->session.std[GMT_ERR] = stderr;
gmt_api.c:			API->GMT->session.std[GMT_ERR] = fp;	/* Set the error fp pointer */
gmt_api.c:	gmt_M_memcpy (col_type_save[GMT_IN],  GMT->current.io.col_type[GMT_IN],   2, unsigned int);
gmt_api.c:	gmt_M_memcpy (col_type_save[GMT_OUT], GMT->current.io.col_type[GMT_OUT],  2, unsigned int);
gmt_api.c:	gmt_M_memcpy (col_set_save[GMT_IN],   GMT->current.io.col_set[GMT_IN],    2, char);
gmt_api.c:	gmt_M_memcpy (col_set_save[GMT_OUT],  GMT->current.io.col_set[GMT_OUT],   2, char);
gmt_api.c:			value = gmt_convert_units (GMT, p, GMT->current.setting.proj_length_unit, GMT->current.setting.proj_length_unit);
gmt_api.c:			value /= GMT->current.map.dist[GMT_MAP_DIST].scale;	/* Convert to default unit */
gmt_api.c:	gmt_M_memcpy (GMT->current.io.col_type[GMT_IN],  col_type_save[GMT_IN],  2, unsigned int);
gmt_api.c:	gmt_M_memcpy (GMT->current.io.col_type[GMT_OUT], col_type_save[GMT_OUT], 2, unsigned int);
gmt_api.c:	gmt_M_memcpy (GMT->current.io.col_set[GMT_IN],   col_set_save[GMT_IN],   2, char);
gmt_api.c:	gmt_M_memcpy (GMT->current.io.col_set[GMT_OUT],  col_set_save[GMT_OUT],  2, char);
gmt_api.c:	was = GMT->current.setting.io_header[GMT_OUT];
gmt_api.c:	GMT->current.setting.io_header[GMT_OUT] = do_tbl_header (header);
gmt_api.c:	GMT->current.setting.io_header[GMT_OUT] = was;
gmt_api.c:		Out->type = (mode) ? mode - 1 : API->GMT->current.setting.export_type;
gmt_api.c:					api_put_val (&(Out->data), ij, GMT->session.d_NaN);
gmt_api.c:			Out->type[col] = (mode) ? mode - 1 : API->GMT->current.setting.export_type;
gmt_api.c:					api_put_val (&(Out->data[col]), row_out, GMT->session.d_NaN);
gmt_api.c:			Out->type[col] = (mode) ? mode - 1 : API->GMT->current.setting.export_type;
gmt_api.c:	api_put_val_v = api_select_put_function (API, GMT->current.setting.export_type);	/* Since all columns are of same type we get the pointer here */
gmt_api.c:		Out->type = (mode) ? mode - 1 : API->GMT->current.setting.export_type;
gmt_api.c:	if (H && H[0] == API->GMT->current.setting.io_seg_marker[GMT_IN]) {	/* User gave a record with segment marker in it */
gmt_api.c:			API->GMT->current.io.record_type[GMT_OUT] = GMT_WRITE_TEXT;
gmt_api.c:			API->GMT->current.io.record_type[GMT_OUT] = GMT_WRITE_DATA;
gmt_api.c:			API->GMT->current.io.record_type[GMT_OUT] = GMT_WRITE_MIXED;
gmt_api.c:			API->GMT->current.io.trailing_text[direction] = false;
gmt_api.c:			API->GMT->current.io.variable_in_columns = true;
gmt_api.c:	if (API->GMT->current.setting.run_mode == GMT_MODERN) {	/* Modern mode, file must be NULL */
gmt_api.c:		GMT_Report (API, GMT_MSG_DEBUG, "Hidden PS file %s found\n", API->GMT->current.ps.filename);
gmt_api.c:		if ((fp = fopen (API->GMT->current.ps.filename, "r")) == NULL) {
gmt_api.c:			GMT_Report (API, GMT_MSG_NORMAL, "GMT_Extract_Region: Failed to find/open current PS file %s\n", API->GMT->current.ps.filename);
gmt_api.c:	/* We expect GMT_Extract_Region to be applied to GMT-produced PS files so we know they are clean records readable with fgets */
gmt_bcr.c:		if (GMT->common.n.truncate) {
gmt_bcr.c:	return (GMT->session.d_NaN);
gmt_bcr.c:	if (bcr_reject (G->header, &xx, &yy)) return (GMT->session.d_NaN);	/* NaNs or outside */
gmt_bcr.c:		if (GMT->common.n.truncate) {
gmt_bcr.c:	return (GMT->session.d_NaN);
gmt_bcr.c:		for (b = 0; b < nb; b++) z[b] = gmt_M_u255 (GMT->current.setting.color_patch[GMT_NAN][b]);
gmt_calclock.c:			p->dt[0] -= (p->sd[0] * GMT->current.setting.time_system.i_scale);
gmt_calclock.c:				p->dt[0] -= ((p->sd[0] - x) * GMT->current.setting.time_system.i_scale);
gmt_calclock.c:			p->dt[1] = p->dt[0] + step_secs * GMT->current.setting.time_system.i_scale;
gmt_calclock.c:	f_days = (rd - GMT->current.setting.time_system.rata_die - GMT->current.setting.time_system.epoch_t0);
gmt_calclock.c:	return ((f_days * GMT_DAY2SEC_F  + secs) * GMT->current.setting.time_system.i_scale);
gmt_calclock.c:	t_sec = (t * GMT->current.setting.time_system.scale + GMT->current.setting.time_system.epoch_t0 * GMT_DAY2SEC_F);
gmt_calclock.c:	*rd = gmtlib_splitinteger (t_sec, GMT_DAY2SEC_I, s) + GMT->current.setting.time_system.rata_die;
gmt_calclock.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error: gmt_rd_from_gymd given bad month (%d) or day (%d).\n", gm, gd);
gmt_calclock.c:	   GMT->current.setting.time_Y2K_offset_year.
gmt_calclock.c:	   from GMT->current.setting.time_Y2K_offset_year.  Because these
gmt_calclock.c:	/* The GMT->current.time.Y2K_fix structure is initialized in GMT->current.io.info_init once  */
gmt_calclock.c:	return (y2 + ((y2 >= GMT->current.time.Y2K_fix.y2_cutoff) ? GMT->current.time.Y2K_fix.y100 : GMT->current.time.Y2K_fix.y200));
gmt_calclock.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error: time steps must be positive.\n");
gmt_calclock.c:				GMT_Report (GMT->parent, GMT_MSG_COMPAT, "Unit c for seconds is deprecated; use s.\n");
gmt_calclock.c:					GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error: time steps in seconds must be <= 60\n");
gmt_calclock.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error: Unrecognized time axis unit.\n");
gmt_calclock.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error: time steps in seconds must be <= 60\n");
gmt_calclock.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error: time steps in minutes must be <= 60\n");
gmt_calclock.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error: time steps in hours must be <= 24\n");
gmt_calclock.c:			if (GMT->current.plot.calclock.date.day_of_year) {
gmt_calclock.c:					GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error: time steps in year days must be <= 365\n");
gmt_calclock.c:					GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error: time steps in days of the month must be <= 31\n");
gmt_calclock.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error: time steps in weekdays must be <= 7\n");
gmt_calclock.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error: time step must be 1 for Gregorian weeks\n");
gmt_calclock.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error: time steps in weeks must be <= 52\n");
gmt_calclock.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error: time steps in months must be <= 12\n");
gmt_calclock.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error: Unrecognized time axis unit.\n");
gmt_calclock.c:				GMT_Report (GMT->parent, GMT_MSG_COMPAT, "Unit c for seconds is deprecated; use s.\n");
gmt_calclock.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "GMT_LOGIC_BUG:  Bad unit in GMT_init_moment_interval()\n");
gmt_calclock.c:			else if (GMT->current.plot.calclock.date.day_of_year) {
gmt_calclock.c:			assuming this numbering applies to GMT->current.setting.time_week_start,
gmt_calclock.c:			kws = (GMT->current.plot.calclock.date.iso_calendar) ? 1 : GMT->current.setting.time_week_start;
gmt_calclock.c:				k = p->cc[0].day_w - GMT->current.setting.time_week_start;
gmt_calclock.c:					GMT_Report (GMT->parent, GMT_MSG_NORMAL, "GMT_LOGIC_BUG:  bad ywd on floor (month) in GMT_init_moment_interval()\n");
gmt_calclock.c:					GMT_Report (GMT->parent, GMT_MSG_NORMAL, "GMT_LOGIC_BUG:  bad ymd on floor (month) in GMT_init_moment_interval()\n");
gmt_calclock.c:				if (GMT->current.plot.calclock.date.iso_calendar) {
gmt_calclock.c:			if (GMT->current.plot.calclock.date.iso_calendar) {
gmt_calclock.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "GMT_LOGIC_BUG:  Bad unit in GMT_init_moment_interval()\n");
gmt_calclock.c:	step = 0.5 / W->f_sec_to_int / GMT->current.setting.time_system.scale;	/* Precision desired in time units */
gmt_calclock.c:				strncpy (text, GMT->current.language.week_name[kind], GMT_LEN16);
gmt_calclock.c:				strncpy (text, GMT->current.language.month_name[kind][ival[D->item_pos[1]]-1], GMT_LEN16);
gmt_calclock.c:			if (T->upper_case) gmt_str_toupper (GMT->current.language.day_name[T->flavor][calendar.iso_d%7]);
gmt_calclock.c:			sprintf (string, "%s", GMT->current.language.day_name[T->flavor][calendar.iso_d%7]);
gmt_calclock.c:			sprintf (string, "%d", (calendar.day_w - GMT->current.setting.time_week_start + 7) % 7 + 1);
gmt_calclock.c:				GMT_Report (GMT->parent, GMT_MSG_COMPAT, "Unit C for seconds is deprecated; use S.\n");
gmt_calclock.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Wrong unit passed to gmtlib_get_time_label\n");
gmt_calclock.c:				GMT_Report (GMT->parent, GMT_MSG_COMPAT, "Unit c for seconds is deprecated; use s.\n");
gmt_calclock.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Wrong unit passed to gmtlib_get_time_label\n");
gmt_calclock.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Wrong unit passed to gmtlib_get_time_label\n");
gmt_cdf.c:	GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Enter gmt_cdf_grd_info with argument %c\n", (int)job);
gmt_cdf.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Your grid contains more than 2^31 - 1 nodes (%" PRIu64 ") and cannot be stored with the deprecated GMT netCDF format.\n", header->nm);
gmt_cdf.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Please choose another grid format such as the default netCDF 4 COARDS-compliant grid format.\n");
gmt_cdf.c:				grid[kk] = GMT->session.f_NaN;
gmt_cdf.c:	if (nr_oor > 0) GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "%" PRIu64 " out-of-range grid values converted to _FillValue [%s]\n", nr_oor, HH->name);
gmt_cdf.c:		GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "No valid values in grid [%s]\n", HH->name);
gmt_customio.c:	if (header) GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Unknown grid format.\n");
gmt_customio.c:	if (header && grid && wesn && pad && complex_mode < 1024) GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Unknown grid format.\n");
gmt_customio.c:		fp = GMT->session.std[GMT_IN];
gmt_customio.c:		fp = GMT->session.std[GMT_OUT];
gmt_customio.c:		fp = GMT->session.std[GMT_IN];
gmt_customio.c:				grid[kk] = GMT->session.f_NaN;
gmt_customio.c:		fp = GMT->session.std[GMT_OUT];
gmt_customio.c:		fp = GMT->session.std[GMT_IN];
gmt_customio.c:				GMT_Report (GMT->parent, GMT_MSG_COMPAT, "Will try to determine if a native 4-byte grid is float or int but may be wrong.\n");
gmt_customio.c:				GMT_Report (GMT->parent, GMT_MSG_COMPAT, "Please append =bf (float) or =bi (integer) to avoid this situation.\n");
gmt_customio.c:					GMT_Report (GMT->parent, GMT_MSG_COMPAT, "Based on header values we guessed the grid is 4-byte float.  If wrong you must add =bi.\n");
gmt_customio.c:					GMT_Report (GMT->parent, GMT_MSG_COMPAT, "Based on header values we guessed the grid is 4-byte int.  If wrong you must add =bf.\n");
gmt_customio.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Cannot determine if a native 4-byte grid is float or int without more information.\n");
gmt_customio.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "You must append =bf (float) or =bi (integer) to avoid this situation.\n");
gmt_customio.c:		fp = GMT->session.std[GMT_IN];
gmt_customio.c:				grid[kk] = GMT->session.f_NaN;
gmt_customio.c:		fp = GMT->session.std[GMT_OUT];
gmt_customio.c:		fp = GMT->session.std[GMT_OUT];
gmt_customio.c:		fp = GMT->session.std[GMT_IN];
gmt_customio.c:	type = GMT->session.grdformat[header->type][1];
gmt_customio.c:				grid[kk] = GMT->session.f_NaN;
gmt_customio.c:		fp = GMT->session.std[GMT_OUT];
gmt_customio.c:	type = GMT->session.grdformat[header->type][1];
gmt_customio.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "GMT: Bad call to gmtlib_encode\n");
gmt_customio.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "GMT: Bad call to gmtlib_decode\n");
gmt_customio.c:			fval = GMT->session.f_NaN;
gmt_customio.c:		fp = GMT->session.std[GMT_IN];
gmt_customio.c:		fp = GMT->session.std[GMT_OUT];
gmt_customio.c:		fp = GMT->session.std[GMT_IN];
gmt_customio.c:	type = GMT->session.grdformat[header->type][1];
gmt_customio.c:				grid[kk] = GMT->session.f_NaN;
gmt_customio.c:	if (GMT->session.grdformat[header->type][1] == 'd') {
gmt_customio.c:		GMT_Message(GMT->parent, GMT_TIME_NONE,
gmt_customio.c:		GMT_Message(GMT->parent, GMT_TIME_NONE,
gmt_customio.c:		fp = GMT->session.std[GMT_OUT];
gmt_customio.c:	type = GMT->session.grdformat[header->type][1];
gmt_customio.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Pipes cannot be used within the GDAL interface.\n");
gmt_customio.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "ERROR reading file (metadata) with gdalread.\n");
gmt_customio.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "ERROR reading file with gdalread.\n");
gmt_customio.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "ERROR data type not supported with gdalread in gmt_customio.\n");
gmt_customio.c:						*grid = GMT->session.f_NaN;
gmt_customio.c:						*grid = GMT->session.f_NaN;
gmt_customio.c:	header->nan_value = GMT->session.f_NaN;
gmt_customio.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Cannot write with GDAL without knowing which driver to use.\n");
gmt_customio.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Unknown or unsupported data type code in gmt_customio for writing file with GDAL.\n");
gmt_customio.c:	GMT->session.grdformat[id]  = "Unknown grid format";
gmt_customio.c:	GMT->session.readinfo[id]   = &gmt_dummy_grd_info;
gmt_customio.c:	GMT->session.updateinfo[id] = &gmt_dummy_grd_info;
gmt_customio.c:	GMT->session.writeinfo[id]  = &gmt_dummy_grd_info;
gmt_customio.c:	GMT->session.readgrd[id]    = &gmt_dummy_grd_read;
gmt_customio.c:	GMT->session.writegrd[id]   = &gmt_dummy_grd_read;
gmt_customio.c:	GMT->session.grdformat[id]  = "nb = GMT netCDF format (8-bit integer), " GMT_NC_CONVENTION;
gmt_customio.c:	GMT->session.readinfo[id]   = &gmt_nc_read_grd_info;
gmt_customio.c:	GMT->session.updateinfo[id] = &gmt_nc_update_grd_info;
gmt_customio.c:	GMT->session.writeinfo[id]  = &gmt_nc_write_grd_info;
gmt_customio.c:	GMT->session.readgrd[id]    = &gmt_nc_read_grd;
gmt_customio.c:	GMT->session.writegrd[id]   = &gmt_nc_write_grd;
gmt_customio.c:	GMT->session.grdformat[id]  = "ns = GMT netCDF format (16-bit integer), " GMT_NC_CONVENTION;
gmt_customio.c:	GMT->session.readinfo[id]   = &gmt_nc_read_grd_info;
gmt_customio.c:	GMT->session.updateinfo[id] = &gmt_nc_update_grd_info;
gmt_customio.c:	GMT->session.writeinfo[id]  = &gmt_nc_write_grd_info;
gmt_customio.c:	GMT->session.readgrd[id]    = &gmt_nc_read_grd;
gmt_customio.c:	GMT->session.writegrd[id]   = &gmt_nc_write_grd;
gmt_customio.c:	GMT->session.grdformat[id]  = "ni = GMT netCDF format (32-bit integer), " GMT_NC_CONVENTION;
gmt_customio.c:	GMT->session.readinfo[id]   = &gmt_nc_read_grd_info;
gmt_customio.c:	GMT->session.updateinfo[id] = &gmt_nc_update_grd_info;
gmt_customio.c:	GMT->session.writeinfo[id]  = &gmt_nc_write_grd_info;
gmt_customio.c:	GMT->session.readgrd[id]    = &gmt_nc_read_grd;
gmt_customio.c:	GMT->session.writegrd[id]   = &gmt_nc_write_grd;
gmt_customio.c:	GMT->session.grdformat[id]  = "nf = GMT netCDF format (32-bit float), " GMT_NC_CONVENTION;
gmt_customio.c:	GMT->session.readinfo[id]   = &gmt_nc_read_grd_info;
gmt_customio.c:	GMT->session.updateinfo[id] = &gmt_nc_update_grd_info;
gmt_customio.c:	GMT->session.writeinfo[id]  = &gmt_nc_write_grd_info;
gmt_customio.c:	GMT->session.readgrd[id]    = &gmt_nc_read_grd;
gmt_customio.c:	GMT->session.writegrd[id]   = &gmt_nc_write_grd;
gmt_customio.c:	GMT->session.grdformat[id]  = "nd = GMT netCDF format (64-bit float), " GMT_NC_CONVENTION;
gmt_customio.c:	GMT->session.readinfo[id]   = &gmt_nc_read_grd_info;
gmt_customio.c:	GMT->session.updateinfo[id] = &gmt_nc_update_grd_info;
gmt_customio.c:	GMT->session.writeinfo[id]  = &gmt_nc_write_grd_info;
gmt_customio.c:	GMT->session.readgrd[id]    = &gmt_nc_read_grd;
gmt_customio.c:	GMT->session.writegrd[id]   = &gmt_nc_write_grd;
gmt_customio.c:	GMT->session.grdformat[id]  = "cb = GMT netCDF format (8-bit integer, deprecated)";
gmt_customio.c:	GMT->session.readinfo[id]   = &gmt_cdf_read_grd_info;
gmt_customio.c:	GMT->session.updateinfo[id] = &gmt_cdf_update_grd_info;
gmt_customio.c:	GMT->session.writeinfo[id]  = &gmt_cdf_write_grd_info;
gmt_customio.c:	GMT->session.readgrd[id]    = &gmt_cdf_read_grd;
gmt_customio.c:	GMT->session.writegrd[id]   = &gmt_cdf_write_grd;
gmt_customio.c:	GMT->session.grdformat[id]  = "cs = GMT netCDF format (16-bit integer, deprecated)";
gmt_customio.c:	GMT->session.readinfo[id]   = &gmt_cdf_read_grd_info;
gmt_customio.c:	GMT->session.updateinfo[id] = &gmt_cdf_update_grd_info;
gmt_customio.c:	GMT->session.writeinfo[id]  = &gmt_cdf_write_grd_info;
gmt_customio.c:	GMT->session.readgrd[id]    = &gmt_cdf_read_grd;
gmt_customio.c:	GMT->session.writegrd[id]   = &gmt_cdf_write_grd;
gmt_customio.c:	GMT->session.grdformat[id]  = "ci = GMT netCDF format (32-bit integer, deprecated)";
gmt_customio.c:	GMT->session.readinfo[id]   = &gmt_cdf_read_grd_info;
gmt_customio.c:	GMT->session.updateinfo[id] = &gmt_cdf_update_grd_info;
gmt_customio.c:	GMT->session.writeinfo[id]  = &gmt_cdf_write_grd_info;
gmt_customio.c:	GMT->session.readgrd[id]    = &gmt_cdf_read_grd;
gmt_customio.c:	GMT->session.writegrd[id]   = &gmt_cdf_write_grd;
gmt_customio.c:	GMT->session.grdformat[id]  = "cf = GMT netCDF format (32-bit float, deprecated)";
gmt_customio.c:	GMT->session.readinfo[id]   = &gmt_cdf_read_grd_info;
gmt_customio.c:	GMT->session.updateinfo[id] = &gmt_cdf_update_grd_info;
gmt_customio.c:	GMT->session.writeinfo[id]  = &gmt_cdf_write_grd_info;
gmt_customio.c:	GMT->session.readgrd[id]    = &gmt_cdf_read_grd;
gmt_customio.c:	GMT->session.writegrd[id]   = &gmt_cdf_write_grd;
gmt_customio.c:	GMT->session.grdformat[id]  = "cd = GMT netCDF format (64-bit float, deprecated)";
gmt_customio.c:	GMT->session.readinfo[id]   = &gmt_cdf_read_grd_info;
gmt_customio.c:	GMT->session.updateinfo[id] = &gmt_cdf_update_grd_info;
gmt_customio.c:	GMT->session.writeinfo[id]  = &gmt_cdf_write_grd_info;
gmt_customio.c:	GMT->session.readgrd[id]    = &gmt_cdf_read_grd;
gmt_customio.c:	GMT->session.writegrd[id]   = &gmt_cdf_write_grd;
gmt_customio.c:	GMT->session.grdformat[id]  = "bm = GMT native, C-binary format (bit-mask)";
gmt_customio.c:	GMT->session.readinfo[id]   = &gmt_native_read_grd_info;
gmt_customio.c:	GMT->session.updateinfo[id] = &gmt_native_write_grd_info;
gmt_customio.c:	GMT->session.writeinfo[id]  = &gmt_native_write_grd_info;
gmt_customio.c:	GMT->session.readgrd[id]    = &gmt_bit_read_grd;
gmt_customio.c:	GMT->session.writegrd[id]   = &gmt_bit_write_grd;
gmt_customio.c:	GMT->session.grdformat[id]  = "bb = GMT native, C-binary format (8-bit integer)";
gmt_customio.c:	GMT->session.readinfo[id]   = &gmt_native_read_grd_info;
gmt_customio.c:	GMT->session.updateinfo[id] = &gmt_native_write_grd_info;
gmt_customio.c:	GMT->session.writeinfo[id]  = &gmt_native_write_grd_info;
gmt_customio.c:	GMT->session.readgrd[id]    = &gmt_native_read_grd;
gmt_customio.c:	GMT->session.writegrd[id]   = &gmt_native_write_grd;
gmt_customio.c:	GMT->session.grdformat[id]  = "bs = GMT native, C-binary format (16-bit integer)";
gmt_customio.c:	GMT->session.readinfo[id]   = &gmt_native_read_grd_info;
gmt_customio.c:	GMT->session.updateinfo[id] = &gmt_native_write_grd_info;
gmt_customio.c:	GMT->session.writeinfo[id]  = &gmt_native_write_grd_info;
gmt_customio.c:	GMT->session.readgrd[id]    = &gmt_native_read_grd;
gmt_customio.c:	GMT->session.writegrd[id]   = &gmt_native_write_grd;
gmt_customio.c:	GMT->session.grdformat[id]  = "bi = GMT native, C-binary format (32-bit integer)";
gmt_customio.c:	GMT->session.readinfo[id]   = &gmt_native_read_grd_info;
gmt_customio.c:	GMT->session.updateinfo[id] = &gmt_native_write_grd_info;
gmt_customio.c:	GMT->session.writeinfo[id]  = &gmt_native_write_grd_info;
gmt_customio.c:	GMT->session.readgrd[id]    = &gmt_native_read_grd;
gmt_customio.c:	GMT->session.writegrd[id]   = &gmt_native_write_grd;
gmt_customio.c:	GMT->session.grdformat[id]  = "bf = GMT native, C-binary format (32-bit float)";
gmt_customio.c:	GMT->session.readinfo[id]   = &gmt_native_read_grd_info;
gmt_customio.c:	GMT->session.updateinfo[id] = &gmt_native_write_grd_info;
gmt_customio.c:	GMT->session.writeinfo[id]  = &gmt_native_write_grd_info;
gmt_customio.c:	GMT->session.readgrd[id]    = &gmt_native_read_grd;
gmt_customio.c:	GMT->session.writegrd[id]   = &gmt_native_write_grd;
gmt_customio.c:	GMT->session.grdformat[id]  = "bd = GMT native, C-binary format (64-bit float)";
gmt_customio.c:	GMT->session.readinfo[id]   = &gmt_native_read_grd_info;
gmt_customio.c:	GMT->session.updateinfo[id] = &gmt_native_write_grd_info;
gmt_customio.c:	GMT->session.writeinfo[id]  = &gmt_native_write_grd_info;
gmt_customio.c:	GMT->session.readgrd[id]    = &gmt_native_read_grd;
gmt_customio.c:	GMT->session.writegrd[id]   = &gmt_native_write_grd;
gmt_customio.c:	GMT->session.grdformat[id]  = "rb = SUN rasterfile format (8-bit standard)";
gmt_customio.c:	GMT->session.readinfo[id]   = &gmt_ras_read_grd_info;
gmt_customio.c:	GMT->session.updateinfo[id] = &gmt_ras_write_grd_info;
gmt_customio.c:	GMT->session.writeinfo[id]  = &gmt_ras_write_grd_info;
gmt_customio.c:	GMT->session.readgrd[id]    = &gmt_ras_read_grd;
gmt_customio.c:	GMT->session.writegrd[id]   = &gmt_ras_write_grd;
gmt_customio.c:	GMT->session.grdformat[id]  = "rf = GEODAS grid format GRD98 (NGDC)";
gmt_customio.c:	GMT->session.readinfo[id]   = &gmt_mgg2_read_grd_info;
gmt_customio.c:	GMT->session.updateinfo[id] = &gmt_mgg2_write_grd_info;
gmt_customio.c:	GMT->session.writeinfo[id]  = &gmt_mgg2_write_grd_info;
gmt_customio.c:	GMT->session.readgrd[id]    = &gmt_mgg2_read_grd;
gmt_customio.c:	GMT->session.writegrd[id]   = &gmt_mgg2_write_grd;
gmt_customio.c:	GMT->session.grdformat[id]  = "sf = Golden Software Surfer format 6 (32-bit float)";
gmt_customio.c:	GMT->session.readinfo[id]   = &gmt_srf_read_grd_info;
gmt_customio.c:	GMT->session.updateinfo[id] = &gmt_srf_write_grd_info;
gmt_customio.c:	GMT->session.writeinfo[id]  = &gmt_srf_write_grd_info;
gmt_customio.c:	GMT->session.readgrd[id]    = &gmt_srf_read_grd;
gmt_customio.c:	GMT->session.writegrd[id]   = &gmt_srf_write_grd;
gmt_customio.c:	GMT->session.grdformat[id]  = "sd = Golden Software Surfer format 7 (64-bit float, read-only)";
gmt_customio.c:	GMT->session.readinfo[id]   = &gmt_srf_read_grd_info;
gmt_customio.c:	GMT->session.updateinfo[id] = &gmt_srf_write_grd_info;
gmt_customio.c:	GMT->session.writeinfo[id]  = &gmt_srf_write_grd_info;
gmt_customio.c:	GMT->session.readgrd[id]    = &gmt_srf_read_grd;
gmt_customio.c:	GMT->session.writegrd[id]   = &gmt_srf_write_grd;
gmt_customio.c:	GMT->session.grdformat[id]  = "af = Atlantic Geoscience Center format AGC (32-bit float)";
gmt_customio.c:	GMT->session.readinfo[id]   = &gmt_agc_read_grd_info;
gmt_customio.c:	GMT->session.updateinfo[id] = &gmt_agc_write_grd_info;
gmt_customio.c:	GMT->session.writeinfo[id]  = &gmt_agc_write_grd_info;
gmt_customio.c:	GMT->session.readgrd[id]    = &gmt_agc_read_grd;
gmt_customio.c:	GMT->session.writegrd[id]   = &gmt_agc_write_grd;
gmt_customio.c:	GMT->session.grdformat[id]  = "ei = ESRI Arc/Info ASCII Grid Interchange format (ASCII integer)";
gmt_customio.c:	GMT->session.readinfo[id]   = &gmt_esri_read_grd_info;
gmt_customio.c:	GMT->session.updateinfo[id] = &gmt_esri_write_grd_info;
gmt_customio.c:	GMT->session.writeinfo[id]  = &gmt_esri_write_grd_info;
gmt_customio.c:	GMT->session.readgrd[id]    = &gmt_esri_read_grd;
gmt_customio.c:	GMT->session.writegrd[id]   = &gmt_esri_writei_grd;
gmt_customio.c:	GMT->session.grdformat[id]  = "ef = ESRI Arc/Info ASCII Grid Interchange format (ASCII float)";
gmt_customio.c:	GMT->session.readinfo[id]   = &gmt_esri_read_grd_info;
gmt_customio.c:	GMT->session.updateinfo[id] = &gmt_esri_write_grd_info;
gmt_customio.c:	GMT->session.writeinfo[id]  = &gmt_esri_write_grd_info;
gmt_customio.c:	GMT->session.readgrd[id]    = &gmt_esri_read_grd;
gmt_customio.c:	GMT->session.writegrd[id]   = &gmt_esri_writef_grd;
gmt_customio.c:	GMT->session.grdformat[id]  = "gd = Import/export through GDAL";
gmt_customio.c:	GMT->session.readinfo[id]   = &gmt_gdal_read_grd_info;
gmt_customio.c:	GMT->session.updateinfo[id] = &gmt_gdal_write_grd_info;
gmt_customio.c:	GMT->session.writeinfo[id]  = &gmt_gdal_write_grd_info;
gmt_customio.c:	GMT->session.readgrd[id]    = &gmt_gdal_read_grd;
gmt_customio.c:	GMT->session.writegrd[id]   = &gmt_gdal_write_grd;
gmt_customio.c:	GMT->session.grdformat[id]  = "gd = Import/export through GDAL (not supported)";
gmt_customio.c:	GMT->session.readinfo[id]   = &gmt_dummy_grd_info;
gmt_customio.c:	GMT->session.updateinfo[id] = &gmt_dummy_grd_info;
gmt_customio.c:	GMT->session.writeinfo[id]  = &gmt_dummy_grd_info;
gmt_customio.c:	GMT->session.readgrd[id]    = &gmt_dummy_grd_read;
gmt_customio.c:	GMT->session.writegrd[id]   = &gmt_dummy_grd_read;
gmt_dcw.c:	 * 1. Check in GMT->session.DCWDIR, if set
gmt_dcw.c:	if (GMT->session.DCWDIR) {	/* 1. Check in GMT->session.DCWDIR */
gmt_dcw.c:		sprintf (path, "%s/%s%s", GMT->session.DCWDIR, name, suffix);
gmt_dcw.c:			/* remove reference to invalid GMT->session.DCWDIR but don't free
gmt_dcw.c:			GMT->session.DCWDIR = NULL;
gmt_dcw.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Unable to find or open the Digital Chart of the World for GMT\n");
gmt_dcw.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Perhaps you did not install this file in DIR_DCW, the shared dir, or the user dir?\n");
gmt_dcw.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Use your package manager to install package dcw-gmt.\n");
gmt_dcw.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Alternatively, get the latest dcw-gmt-<version>.tar.gz or dcw-gmt-<version>.zip from the %s.\n", DCW_SITE);
gmt_dcw.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Unable to open file %s [permission trouble?]\n", path);
gmt_dcw.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Unable to open file %s [permission trouble?]\n", path);
gmt_dcw.c:	GMT_Report (GMT->parent, GMT_MSG_DEBUG, "DCW: Found %u countries, %u countries with states, and %u states\n", dim[0], dim[2], dim[1]);
gmt_dcw.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Implementation error: Must pass wesn array if mode == %d\n", GMT_DCW_REGION);
gmt_dcw.c:					GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Continent code expanded from %s to %s [%d countries]\n", F->item[j]->codes, list, n_items);
gmt_dcw.c:					GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Continent code %s unrecognized\n", code);
gmt_dcw.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Requested %d DCW items: %s\n", n_items, list);
gmt_dcw.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "No countries selected\n");
gmt_dcw.c:		P = GMT_Alloc_Segment (GMT->parent, GMT_NO_STRINGS, 0, 2, NULL, NULL);
gmt_dcw.c:		GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Extract polygons from DCW - The Digital Chart of the World\n");
gmt_dcw.c:		if ((D = GMT_Create_Data (GMT->parent, GMT_IS_DATASET, GMT_IS_POLY, 0, dim, NULL, NULL, 0, 0, NULL)) == NULL) {
gmt_dcw.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Unable to create empty dataset for DCW polygons\n");
gmt_dcw.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Cannot open file %s!\n", path);
gmt_dcw.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Cannot obtain attribute version\n");
gmt_dcw.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Cannot obtain attribute title\n");
gmt_dcw.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Cannot obtain attribute source\n");
gmt_dcw.c:		GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Using country and state data from gmt-dcw\n");
gmt_dcw.c:		GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Title  : %s\n", title);
gmt_dcw.c:		GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Source : %s\n", source);
gmt_dcw.c:		GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Version: %s\n", version);
gmt_dcw.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "No country code matching %s (skipped)\n", code);
gmt_dcw.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Country %s does not have states (skipped)\n", code);
gmt_dcw.c:		GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, msg);
gmt_dcw.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error getting ID for variable %s in %s!\n", dim, path);
gmt_dcw.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error getting dimension length for variable %s in %s!\n", dim, path);
gmt_dcw.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error allocation memory!\n");
gmt_dcw.c:				strcpy (GMT->current.io.segment_header, msg);
gmt_dcw.c:				strcat (GMT->current.io.segment_header, segment);
gmt_dcw.c:				GMT_Put_Record (GMT->parent, GMT_WRITE_SEGMENT_HEADER, NULL);
gmt_dcw.c:					GMT_Put_Record (GMT->parent, GMT_WRITE_DATA, Out);
gmt_dcw.c:					if ((GMT->current.plot.n = gmt_geo_to_xy_line (GMT, P->data[GMT_X], P->data[GMT_Y], P->n_rows)) == 0) continue;
gmt_dcw.c:					gmt_plot_line (GMT, GMT->current.plot.x, GMT->current.plot.y, GMT->current.plot.pen, GMT->current.plot.n, PSL_LINEAR);
gmt_dcw.c:		GMT->current.io.geo.range = GMT_IGNORE_RANGE;		/* Override this setting explicitly */
gmt_dcw.c:		GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Region implied by DCW polygons is %g/%g/%g/%g\n", wesn[XLO], wesn[XHI], wesn[YLO], wesn[YHI]);
gmt_dcw.c:	GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "List of ISO 3166-1 alpha-2 codes for DCW supported countries:\n\n");
gmt_dcw.c:					GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Error -%c: Ambiguous modifier +r<val>; could be dpi of the pattern or (a deprecated) region increment - choosing dpi.\n", option);
gmt_dcw.c:					GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "If you meant the region modifier then place it before the +g pattern specification.\n", option);
gmt_dcw.c:						n = GMT_Get_Values (GMT->parent, &p[1], F->inc, 4);
gmt_dcw.c:							GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error -%c: Bad number of increment to modifier +%c.\n", option, p[0]);
gmt_dcw.c:					GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error -%c: Unrecognized modifier +%s.\n", option, p);
gmt_dcw.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error -%c: No country codes given\n", option);
gmt_esri_io.c:		snprintf (item, GMT_LEN64, GMT->current.setting.format_float_out, header->wesn[XLO]);
gmt_esri_io.c:		snprintf (item, GMT_LEN64, GMT->current.setting.format_float_out, header->wesn[YLO]);
gmt_esri_io.c:		snprintf (item, GMT_LEN64, GMT->current.setting.format_float_out, header->wesn[XLO]);
gmt_esri_io.c:		snprintf (item, GMT_LEN64, GMT->current.setting.format_float_out, header->wesn[YLO]);
gmt_esri_io.c:	snprintf (item, GMT_LEN64, GMT->current.setting.format_float_out, header->inc[GMT_X]);
gmt_esri_io.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "ESRI Arc/Info ASCII Interchange file must use proxy for NaN; default to -9999\n");
gmt_esri_io.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Arc/Info ASCII Grid: Error decoding NROWS record\n");
gmt_esri_io.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Arc/Info ASCII Grid: Error decoding NCOLS record\n");
gmt_esri_io.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Arc/Info ASCII Grid: Error decoding NBANDS record\n");
gmt_esri_io.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Arc/Info ASCII Grid: Cannot read file with number of Bands != 1 \n");
gmt_esri_io.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Arc/Info ASCII Grid: Error decoding NBITS record\n");
gmt_esri_io.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Arc/Info ASCII Grid: This data type (%d bits) is not supported\n", header->bits);
gmt_esri_io.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Arc/Info ASCII Grid: Error decoding nan_value_value record\n");
gmt_esri_io.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Arc/Info ASCII Grid: Error decoding ULXMAP record\n");
gmt_esri_io.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Arc/Info ASCII Grid: Error decoding ULYMAP record\n");
gmt_esri_io.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Arc/Info ASCII Grid: Error decoding XDIM record\n");
gmt_esri_io.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Arc/Info ASCII Grid: Error decoding YDIM record\n");
gmt_esri_io.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Arc/Info ASCII Grid: Error decoding ncols record\n");
gmt_esri_io.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Arc/Info ASCII Grid: Error decoding nrows record\n");
gmt_esri_io.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Arc/Info ASCII Grid: Error decoding xll record\n");
gmt_esri_io.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Arc/Info ASCII Grid: Error decoding yll record\n");
gmt_esri_io.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Arc/Info ASCII Grid: Error decoding cellsize record\n");
gmt_esri_io.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Arc/Info ASCII Grid: Error decoding nan_value_value record\n");
gmt_esri_io.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Arc/Info BINARY Grid: Error decoding endianness record\n");
gmt_esri_io.c:		fp = GMT->session.std[GMT_IN];
gmt_esri_io.c:		fp = GMT->session.std[GMT_OUT];
gmt_esri_io.c:		r_mode = GMT->current.io.r_mode;
gmt_esri_io.c:		fp = GMT->session.std[GMT_IN];
gmt_esri_io.c:					grid[kk] = GMT->session.f_NaN;
gmt_esri_io.c:						grid[kk] = (check && tmp[actual_col[ii]] == header->nan_value) ? GMT->session.f_NaN : tmp[actual_col[ii]];
gmt_esri_io.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Expected % "PRIu64 " points, found only % "PRIu64 "\n", header->nm, header->nm - n_left);
gmt_esri_io.c:		fp = GMT->session.std[GMT_OUT];
gmt_esri_io.c:	else if ((fp = gmt_fopen (GMT, HH->name, GMT->current.io.w_mode)) == NULL)
gmt_esri_io.c:				snprintf (item, GMT_LEN64-1, GMT->current.setting.format_float_out, grid[kk]);
gmt_fft.c:		GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, " Data dimension\t%d %d\ttime factor %.8g\trms error %.8e\tbytes %" PRIuS "\n", n_columns, n_rows, given_time, given_err, given_space);
gmt_fft.c:		GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, " Highest speed\t%d %d\ttime factor %.8g\trms error %.8e\tbytes %" PRIuS "\n",
gmt_fft.c:		GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, " Most accurate\t%d %d\ttime factor %.8g\trms error %.8e\tbytes %" PRIuS "\n",
gmt_fft.c:		GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, " Least storage\t%d %d\ttime factor %.8g\trms error %.8e\tbytes %" PRIuS "\n",
gmt_fft.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Bad mode selected (%u) - exit\n", mode);
gmt_fft.c:		if (GMT->session.CACHEDIR == NULL || access (GMT->session.CACHEDIR, R_OK|W_OK|X_OK))
gmt_fft.c:			strncpy (wisdom_file, GMT->session.CACHEDIR, PATH_MAX);
gmt_fft.c:				GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Imported FFTW Wisdom from file: %s\n", *filename);
gmt_fft.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Importing FFTW Wisdom from file failed: %s\n", *filename);
gmt_fft.c:		GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Exported FFTW Wisdom to file: %s\n", filename);
gmt_fft.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Exporting FFTW Wisdom to file failed: %s\n", filename);
gmt_fft.c:	if (GMT->current.setting.fftw_plan != FFTW_ESTIMATE) {
gmt_fft.c:			plan = fftwf_plan_dft_1d(n_columns, cin, cout, sign, FFTW_WISDOM_ONLY | GMT->current.setting.fftw_plan);
gmt_fft.c:			plan = fftwf_plan_dft_2d(n_rows, n_columns, cin, cout, sign, FFTW_WISDOM_ONLY | GMT->current.setting.fftw_plan);
gmt_fft.c:			GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Generating new FFTW Wisdom, be patient...\n");
gmt_fft.c:				plan = fftwf_plan_dft_1d(n_columns, in_place_tmp, in_place_tmp, sign, GMT->current.setting.fftw_plan);
gmt_fft.c:				plan = fftwf_plan_dft_2d(n_rows, n_columns, in_place_tmp, in_place_tmp, sign, GMT->current.setting.fftw_plan);
gmt_fft.c:			GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Using preexisting FFTW Wisdom.\n");
gmt_fft.c:	} /* GMT->current.setting.fftw_plan != FFTW_ESTIMATE */
gmt_fft.c:		GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Picking a (probably sub-optimal) FFTW plan quickly.\n");
gmt_fft.c:			plan = fftwf_plan_dft_1d(n_columns, cin, cout, sign, GMT->current.setting.fftw_plan);
gmt_fft.c:			plan = fftwf_plan_dft_2d(n_rows, n_columns, cin, cout, sign, GMT->current.setting.fftw_plan);
gmt_fft.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Could not create FFTW plan.\n");
gmt_fft.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Need Radix-2 input try: %u [n]\n", 1U<<propose_radix2 (n));
gmt_fft.c:	if (GMT->current.fft.n_1d != n) {	/* Must update the FFT setup arrays */
gmt_fft.c:		fft_1d_vDSP_reset (&GMT->current.fft);
gmt_fft.c:		GMT->current.fft.setup_1d = vDSP_create_fftsetup (log2n, kFFTRadix2);
gmt_fft.c:		GMT->current.fft.dsp_split_complex_1d.realp = calloc (n, sizeof(gmt_grdfloat));
gmt_fft.c:		GMT->current.fft.dsp_split_complex_1d.imagp = calloc (n, sizeof(gmt_grdfloat));
gmt_fft.c:		if (GMT->current.fft.dsp_split_complex_1d.realp == NULL || GMT->current.fft.dsp_split_complex_1d.imagp == NULL) {
gmt_fft.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Unable to allocate dsp_split_complex array of length %u\n", n);
gmt_fft.c:		GMT->current.fft.n_1d = n;
gmt_fft.c:	vDSP_ctoz (dsp_complex, 2, &GMT->current.fft.dsp_split_complex_1d, 1, n);
gmt_fft.c:	vDSP_fft_zip (GMT->current.fft.setup_1d, &GMT->current.fft.dsp_split_complex_1d, 1, log2n, fft_direction);
gmt_fft.c:	vDSP_ztoc (&GMT->current.fft.dsp_split_complex_1d, 1, dsp_complex, 2, n);
gmt_fft.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Need Radix-2 input try: %u/%u [n_columns/n_rows]\n",
gmt_fft.c:	if (GMT->current.fft.n_2d != n_xy) {	/* Must update the 2-D FFT setup arrays */
gmt_fft.c:		fft_2d_vDSP_reset (&GMT->current.fft);
gmt_fft.c:		GMT->current.fft.setup_2d = vDSP_create_fftsetup (MAX (log2nx, log2ny), kFFTRadix2);
gmt_fft.c:		GMT->current.fft.dsp_split_complex_2d.realp = calloc (n_xy, sizeof(gmt_grdfloat));
gmt_fft.c:		GMT->current.fft.dsp_split_complex_2d.imagp = calloc (n_xy, sizeof(gmt_grdfloat));
gmt_fft.c:		if (GMT->current.fft.dsp_split_complex_2d.realp == NULL || GMT->current.fft.dsp_split_complex_2d.imagp == NULL) {
gmt_fft.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Unable to allocate dsp_split_complex array of length %u\n", n_xy);
gmt_fft.c:		GMT->current.fft.n_2d = n_xy;
gmt_fft.c:	vDSP_ctoz (dsp_complex, 2, &GMT->current.fft.dsp_split_complex_2d, 1, n_xy);
gmt_fft.c:	vDSP_fft2d_zip (GMT->current.fft.setup_2d, &GMT->current.fft.dsp_split_complex_2d, 1, 0, log2nx, log2ny, fft_direction);
gmt_fft.c:	vDSP_fft2d_zrip (setup, &GMT->current.fft.dsp_split_complex_2d, 1, 0, log2nx, log2ny, fft_direction); */
gmt_fft.c:	vDSP_ztoc (&GMT->current.fft.dsp_split_complex_2d, 1, dsp_complex, 2, n_xy);
gmt_fft.c:        GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Brenner_fourt_ work size = %" PRIuS "\n", work_size);
gmt_fft.c:	if (GMT->current.setting.fft != k_fft_auto) {
gmt_fft.c:		if (GMT->session.fft1d[GMT->current.setting.fft])
gmt_fft.c:			return GMT->current.setting.fft; /* User defined FFT */
gmt_fft.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Desired FFT Algorithm (%s) not configured - choosing suitable alternative.\n", GMT_fft_algo[GMT->current.setting.fft]);
gmt_fft.c:	if (GMT->session.fft1d[k_fft_accelerate] && radix2 (n))
gmt_fft.c:	if (GMT->session.fft1d[k_fft_fftw])
gmt_fft.c:	if (GMT->current.setting.fft != k_fft_auto) {
gmt_fft.c:		if (GMT->session.fft2d[GMT->current.setting.fft])
gmt_fft.c:			return GMT->current.setting.fft; /* User defined FFT */
gmt_fft.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Desired FFT Algorithm (%s) not configured - choosing suitable alternative.\n", GMT_fft_algo[GMT->current.setting.fft]);
gmt_fft.c:	if (GMT->session.fft2d[k_fft_accelerate] && radix2 (n_columns) && radix2 (n_rows))
gmt_fft.c:	if (GMT->session.fft2d[k_fft_fftw])
gmt_fft.c:	GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "1-D FFT using %s\n", GMT_fft_algo[use]);
gmt_fft.c:	status = GMT->session.fft1d[use] (GMT, data, (unsigned int)n, direction, mode);
gmt_fft.c:	GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "2-D FFT using %s\n", GMT_fft_algo[use]);
gmt_fft.c:	status = GMT->session.fft2d[use] (GMT, data, n_columns, n_rows, direction, mode);
gmt_fft.c:	GMT->current.setting.fftw_plan = FFTW_ESTIMATE; /* default planner flag [only accessed if FFTW is compiled in] */
gmt_fft.c:	if (n_cpu > 1 && !GMT->current.setting.fftwf_threads) {
gmt_fft.c:			GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Initialize FFTW with %d threads.\n", n_cpu);
gmt_fft.c:	memset (GMT->session.fft1d, k_n_fft_algorithms, sizeof(void*));
gmt_fft.c:	memset (GMT->session.fft2d, k_n_fft_algorithms, sizeof(void*));
gmt_fft.c:	GMT->session.fft1d[k_fft_accelerate] = &fft_1d_vDSP;
gmt_fft.c:	GMT->session.fft2d[k_fft_accelerate] = &fft_2d_vDSP;
gmt_fft.c:	GMT->session.fft1d[k_fft_fftw] = &fft_1d_fftwf;
gmt_fft.c:	GMT->session.fft2d[k_fft_fftw] = &fft_2d_fftwf;
gmt_fft.c:	GMT->session.fft1d[k_fft_kiss] = &fft_1d_kiss;
gmt_fft.c:	GMT->session.fft2d[k_fft_kiss] = &fft_2d_kiss;
gmt_fft.c:	GMT->session.fft1d[k_fft_brenner] = &fft_1d_brenner;
gmt_fft.c:	GMT->session.fft2d[k_fft_brenner] = &fft_2d_brenner;
gmt_fft.c:	fft_1d_vDSP_reset (&GMT->current.fft);
gmt_fft.c:	fft_2d_vDSP_reset (&GMT->current.fft);
gmt_gdal_librarified.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "GDALOpen failed %s\n", CPLGetLastErrorMsg());
gmt_gdal_librarified.c:	GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "GDAL Info\n\n%s\n", info);
gmt_gdalread.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Unable to find %s.\n", gdal_filename);
gmt_gdalread.c:	xy_geo[0] = xy_geo[1] = GMT->session.d_NaN;		/* Default return values */
gmt_gdalread.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "gdalread: Unsupported data type\n");
gmt_gdalread.c: *        GMT->session.d_NaN value is used. Besides this, the Ctrl->band_field_names[nBand].nodata
gmt_gdalread.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Unable to open %s.\n", gdal_filename);
gmt_gdalread.c:		GMT_Report(GMT->parent, GMT_MSG_VERBOSE, "GDAL seamed to have returned garbage in adfGeoTransform. Arbitrarily setting inc = 1.\n");
gmt_gdalread.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "The -projwin option was used, but the geotransform is rotated."
gmt_gdalread.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Quitting with error\n");
gmt_gdalread.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Computed -srcwin falls outside raster size of %dx%d.\n",
gmt_gdalread.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Quitting with error\n");
gmt_gdalread.c:			Ctrl->band_field_names[nBand].MinMax[0] = GMT->session.d_NaN;
gmt_gdalread.c:			Ctrl->band_field_names[nBand].MinMax[1] = GMT->session.d_NaN;
gmt_gdalread.c:			GMT_Report(GMT->parent, GMT_MSG_LONG_VERBOSE, "An HDF5 file. Trying to get scale_offset from string metadata.\n");
gmt_gdalread.c:			dfNoDataValue = GMT->session.d_NaN;
gmt_gdalread.c:			Ctrl->nodata = GMT->session.d_NaN;
gmt_gdalread.c:			Ctrl->GEOGCorners.LL[0] = Ctrl->GEOGCorners.LL[1] = GMT->session.d_NaN;
gmt_gdalread.c:		Ctrl->GEOGCorners.LL[0] = Ctrl->GEOGCorners.LL[1] = GMT->session.d_NaN;
gmt_gdalread.c:	GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "File %s reads with GDAL driver %s\n",
gmt_gdalread.c:	if (nReqBands && GMT->current.setting.verbose >= GMT_MSG_LONG_VERBOSE) {
gmt_gdalread.c:		GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Read band(s):");
gmt_gdalread.c:			GMT_Message (GMT->parent, GMT_TIME_NONE, "\t%d", whichBands[k]);
gmt_gdalread.c:		GMT_Message (GMT->parent, GMT_TIME_NONE, "\n");
gmt_gdalread.c:	if (!metadata_only && GMT->current.gdal_read_in.O.mem_layout[0]) {    /* first char T(op)|B(ot), second R(ow)|C(ol), third B(and)|P(ixel)|L(ine) */
gmt_gdalread.c:		if (GMT->current.gdal_read_in.O.mem_layout[0] == 'T')
gmt_gdalread.c:		if (GMT->current.gdal_read_in.O.mem_layout[1] == 'C')
gmt_gdalread.c:		if (GMT->current.gdal_read_in.O.mem_layout[2] == 'B' || GMT->current.gdal_read_in.O.mem_layout[2] == 'L')
gmt_gdalread.c:		strncpy(prhs->O.mem_layout, GMT->current.gdal_read_in.O.mem_layout, 4);
gmt_gdalread.c:		error += (GMT_Get_Values (GMT->parent, prhs->R.region, wesn, 4) < 4);
gmt_gdalread.c:				pad_w = (int)((GMT->common.R.wesn[XLO] - wesn[XLO]) / prhs->registration.x_inc + 0.5);
gmt_gdalread.c:				pad_e = (int)((wesn[XHI] - GMT->common.R.wesn[XHI]) / prhs->registration.x_inc + 0.5);
gmt_gdalread.c:				pad_s = (int)((GMT->common.R.wesn[YLO] - wesn[YLO]) / prhs->registration.y_inc + 0.5);
gmt_gdalread.c:				pad_n = (int)((wesn[YHI] - GMT->common.R.wesn[YHI]) / prhs->registration.y_inc + 0.5);
gmt_gdalread.c:		error += (GMT_Get_Values (GMT->parent, prhs->R.region, wesn, 4) < 4);
gmt_gdalread.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "gmt_gdalread failed to extract a Sub-region\n");
gmt_gdalread.c:			GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "gmt_gdalread failed to convert the proj4 string\n%s\n to WKT\n",
gmt_gdalread.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "GDALOpen failed %s\n", CPLGetLastErrorMsg());
gmt_gdalread.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL,
gmt_gdalread.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Computed -srcwin falls outside raster size of %dx%d.\n",
gmt_gdalread.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "gdalread: Unsupported data type\n");
gmt_gdalread.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "gdalread: failure to allocate enough memory\n");
gmt_gdalread.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "GDALRasterIO failed to open band %d [err = %d]\n", i, gdal_code);
gmt_gdalread.c:				if (do_BIP || !GMT->current.gdal_read_in.O.mem_layout[0]) {
gmt_gdalwrite.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Unupported image format. Supported formats are:\nBMP,GIF,JPG,PNG & TIF\n");
gmt_gdalwrite.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Alternatively, append :<driver> for a valid GDAL driver\n");
gmt_gdalwrite.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "%s memory layout is not supported, for now only: T(op)C(ol)B(and) or TRP\n",
gmt_gdalwrite.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "gmt_gdalwrite: Unsupported input data class!\n");
gmt_gdalwrite.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "gmt_gdalwrite: The Jpeg2000 driver does not support floats.\n");
gmt_gdalwrite.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "gmt_gdalwrite failed to convert the proj4 string\n%s\n to WKT\n",
gmt_gdalwrite.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "gmt_gdalwrite: Output driver %s not recognized\n", pszFormat);
gmt_gdalwrite.c:			GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "The following format drivers are configured and support output:\n");
gmt_gdalwrite.c:					GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "  %s: %s\n",
gmt_gdalwrite.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "GDALOpen failed - %d\n%s\n", CPLGetLastErrorNo(), CPLGetLastErrorMsg());
gmt_gdalwrite.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "\tERROR creating Color Table");
gmt_gdalwrite.c:						GMT_Report(GMT->parent, GMT_MSG_NORMAL, "GDALRasterIO failed to write band %d [err = %d]\n", i, gdal_err);
gmt_gdalwrite.c:						GMT_Report(GMT->parent, GMT_MSG_NORMAL, "GDALRasterIO failed to write band %d [err = %d]\n", i, gdal_err);
gmt_gdalwrite.c:						GMT_Report(GMT->parent, GMT_MSG_NORMAL, "GDALRasterIO failed to write alpha band [err = %d]\n", gdal_err);
gmt_gdalwrite.c:					GMT_Report (GMT->parent, GMT_MSG_NORMAL, "GDALRasterIO failed to write band %d [err = %d]\n", i, gdal_err);
gmt_gdalwrite.c:						GMT_Report (GMT->parent, GMT_MSG_NORMAL, "GDALRasterIO failed to write band %d [err = %d]\n", i, gdal_err);
gmt_gdalwrite.c:						GMT_Report (GMT->parent, GMT_MSG_NORMAL, "GDALRasterIO failed to write band %d [err = %d]\n", i, gdal_err);
gmt_grdio.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Complex grid not large enough to hold both components!.\n");
gmt_grdio.c:			GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Demultiplexing complex grid before reading can take place.\n");
gmt_grdio.c:			GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Overwriting previously stored %s component in complex grid.\n", kind[type]);
gmt_grdio.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Asking to write out complex components from a non-complex grid.\n");
gmt_grdio.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Complex grid has no real components that can be written to file.\n");
gmt_grdio.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Complex grid has no imaginary components that can be written to file.\n");
gmt_grdio.c:			GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Demultiplexing complex grid before writing can take place.\n");
gmt_grdio.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Grid file x/y unit specification %s was unrecognized (part of file name?) and is ignored.\n", c);
gmt_grdio.c:	HH->xy_unit_to_meter[direction] = GMT->current.proj.m_per_unit[u_number];	/* Converts unit to meters */
gmt_grdio.c:			GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Input grid file x/y unit was converted from meters to %s after reading.\n", GMT->current.proj.unit_name[HH->xy_unit[GMT_IN]]);
gmt_grdio.c:			GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Input grid file x/y unit was converted from %s to meters after reading.\n", GMT->current.proj.unit_name[HH->xy_unit[GMT_IN]]);
gmt_grdio.c:				GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Output grid file x/y unit was converted from %s to meters before writing.\n", GMT->current.proj.unit_name[HH->xy_unit[GMT_OUT]]);
gmt_grdio.c:				GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Output grid file x/y unit was converted from meters to %s before writing.\n", GMT->current.proj.unit_name[HH->xy_unit[GMT_OUT]]);
gmt_grdio.c:				GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Output grid file x/y unit was reverted back to %s from meters before writing.\n", GMT->current.proj.unit_name[HH->xy_unit[GMT_IN]]);
gmt_grdio.c:				GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Output grid file x/y unit was reverted back from meters to %s before writing.\n", GMT->current.proj.unit_name[HH->xy_unit[GMT_IN]]);
gmt_grdio.c:	if (GMT->current.setting.io_gridfile_shorthand) {	/* Look for matches */
gmt_grdio.c:		for (i = 0, found = false; !found && i < GMT->session.n_shorthands; ++i) {
gmt_grdio.c:			length = strlen (GMT->session.shorthand[i].suffix);
gmt_grdio.c:			found = (length > f_length) ? false : !strncmp (&file[f_length - length], GMT->session.shorthand[i].suffix, length);
gmt_grdio.c:			sprintf (fname, "%s=%s", file, GMT->session.shorthand[i].format);
gmt_grdio.c:				GMT_Report (GMT->parent, GMT_MSG_DEBUG, "grdio_parse_grd_format_scale_new: Using %s to represent missing value (NaN)\n", &p[1]);
gmt_grdio.c:				GMT_Report (GMT->parent, GMT_MSG_DEBUG, "grdio_parse_grd_format_scale_new: Setting offset as %s\n", &p[1]);
gmt_grdio.c:				GMT_Report (GMT->parent, GMT_MSG_DEBUG, "grdio_parse_grd_format_scale_new: Setting scale as %s\n", &p[1]);
gmt_grdio.c:		GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Average %d angles at the %s pole\n", header->n_columns, name[pole+1]);
gmt_grdio.c:			GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Detected %u inconsistent values at south pole. Values fixed by setting all to average row value.\n", p_conflicts);
gmt_grdio.c:			GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Detected %u inconsistent values at north pole. Values fixed by setting all to average row value.\n", p_conflicts);
gmt_grdio.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Detected %u inconsistent values along periodic east boundary of grid. Values fixed by duplicating west boundary.\n", we_conflicts);
gmt_grdio.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Calling grdio_grd_wipe_pad on interleaved complex grid! Programming error?\n");
gmt_grdio.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "grdio_pad_grd_on_sub can copy row-by-row\n");
gmt_grdio.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "grdio_pad_grd_on_sub must copy node-by-node\n");
gmt_grdio.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "grdio_pad_grd_on_sub: last ij_new = %d, last ij_old = %d\n", (int)ij_new, (int)ij_old);
gmt_grdio.c:			GMT_Report (GMT->parent, GMT_MSG_DEBUG, "grdio_pad_grd_on_sub: Must loop from end to front\n");
gmt_grdio.c:			GMT_Report (GMT->parent, GMT_MSG_DEBUG, "grdio_pad_grd_on_sub: Must loop from front to end\n");
gmt_grdio.c:	gmt_M_memcpy (GMT->common.R.wesn, header->wesn, 4, double);	/* Initially we set -R as is from grid header */
gmt_grdio.c:	if (!gmt_M_360_range (GMT->common.R.wesn[XLO], GMT->common.R.wesn[XHI]) && fabs (header->n_columns * header->inc[GMT_X] - 360.0) < GMT_CONV4_LIMIT) {
gmt_grdio.c:		GMT->common.R.wesn[XHI] = GMT->common.R.wesn[XLO] + 360.0;
gmt_grdio.c:	if (!gmt_M_180_range (GMT->common.R.wesn[YLO], GMT->common.R.wesn[YHI]) && fabs (header->n_rows * header->inc[GMT_Y] - 180.0) < GMT_CONV4_LIMIT) {
gmt_grdio.c:		GMT->common.R.wesn[YLO] = -90.0;
gmt_grdio.c:		GMT->common.R.wesn[YHI] = +90.0;
gmt_grdio.c:		if (GMT->current.io.col_type[GMT_IN][i] & GMT_IS_GEO) continue;
gmt_grdio.c:		if (GMT->current.io.col_type[GMT_IN][i] & GMT_IS_RATIME) {
gmt_grdio.c:			GMT->current.proj.xyz_projection[i] = GMT_TIME;
gmt_grdio.c:			GMT->current.proj.xyz_projection[i] = GMT_TIME;
gmt_grdio.c:			gmt_M_memcpy (&time_system, &GMT->current.setting.time_system, 1, struct GMT_TIME_SYSTEM);
gmt_grdio.c:				GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Time units [%s] in grid not recognised, defaulting to gmt.conf.\n", units);
gmt_grdio.c:			scale = time_system.scale * GMT->current.setting.time_system.i_scale;
gmt_grdio.c:			offset = (time_system.rata_die - GMT->current.setting.time_system.rata_die) + (time_system.epoch_t0 - GMT->current.setting.time_system.epoch_t0);
gmt_grdio.c:			offset *= GMT_DAY2SEC_F * GMT->current.setting.time_system.i_scale;
gmt_grdio.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "gmt_grd_mux_demux called with inappropriate mode - skipped.\n");
gmt_grdio.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Your grid contains more than 2^31 - 1 nodes (%" PRIu64 ") and cannot be stored with the deprecated GMT netCDF format via GDAL.\n", header->nm);
gmt_grdio.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Please choose another grid format such as the default netCDF 4 COARDS-compliant grid format.\n");
gmt_grdio.c:	else {			/* Writing: get format type, scale, offset and missing value from GMT->current.setting.io_gridfile_format */
gmt_grdio.c:		if ((val = grdio_parse_grd_format_scale (GMT, header, GMT->current.setting.io_gridfile_format)) != GMT_NOERROR)
gmt_grdio.c:		if (gmt_M_type (GMT, GMT_OUT, i) == GMT_IS_UNKNOWN) GMT->current.io.col_type[GMT_OUT][i] = GMT->current.io.col_type[GMT_IN][i];
gmt_grdio.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Output type for X-coordinate of grid %s is LAT. Replaced by LON.\n", HH->name);
gmt_grdio.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Output type for Y-coordinate of grid %s is LON. Replaced by LAT.\n", HH->name);
gmt_grdio.c:				switch (GMT->current.setting.time_system.unit) {
gmt_grdio.c:				gmt_format_calendar (GMT, date, clock, &GMT->current.io.date_output, &GMT->current.io.clock_output, false, 1, 0.0);
gmt_grdio.c:				if (i == 2 && GMT->session.grdformat[header->type][1] != 'd')
gmt_grdio.c:					GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Use double precision output grid to avoid loss of significance of time coordinate.\n");
gmt_grdio.c:			GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Geographic %s grid, longitudes span exactly 360\n", dir[direction]);
gmt_grdio.c:			GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Geographic %s grid, longitude cells span exactly 360\n", dir[direction]);
gmt_grdio.c:			GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Geographic %s grid, longitudes span more than 360\n", dir[direction]);
gmt_grdio.c:			GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Geographic %s grid, longitudes span less than 360\n", dir[direction]);
gmt_grdio.c:			GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Cartesian %s grid, yet x spans exactly 360 and -90 <= y <= 90.\n", dir[direction]);
gmt_grdio.c:			GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "     To make sure the grid is recognized as geographical and global, use the -fg option\n");
gmt_grdio.c:			GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Cartesian %s grid, yet x cells span exactly 360 and -90 <= y <= 90.\n", dir[direction]);
gmt_grdio.c:			GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "     To make sure the grid is recognized as geographical and global, use the -fg option\n");
gmt_grdio.c:	GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Cartesian %s grid\n", dir[direction]);
gmt_grdio.c:			GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Round-off patrol changed geographic grid increment for %s from %.18g to %.18g\n",
gmt_grdio.c:			GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Round-off patrol found south latitude outside valid range (%.16g)!\n", header->wesn[YLO]);
gmt_grdio.c:			GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Round-off patrol found north latitude outside valid range (%.16g)!\n", header->wesn[YHI]);
gmt_grdio.c:			GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Round-off patrol changed grid limit for %s from %.16g to %.16g\n",
gmt_grdio.c:	gmt_M_err_trap ((*GMT->session.readinfo[header->type]) (GMT, header));
gmt_grdio.c:	GMT_Set_Index (GMT->parent, header, GMT_GRID_LAYOUT);
gmt_grdio.c:			GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Grid has wrong registration type. Switching from pixel to gridline registration\n");
gmt_grdio.c:			GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Grid has wrong registration type. Switching from gridline to pixel registration\n");
gmt_grdio.c:	return ((*GMT->session.writeinfo[header->type]) (GMT, header));
gmt_grdio.c:	return ((*GMT->session.updateinfo[header->type]) (GMT, header));
gmt_grdio.c:	gmt_M_err_trap ((*GMT->session.readgrd[header->type]) (GMT, header, grid, P.wesn, P.pad, complex_mode));
gmt_grdio.c:	err = (*GMT->session.writegrd[header->type]) (GMT, header, grid, wesn, pad, complex_mode);
gmt_grdio.c:	if (GMT->parent->leave_grid_scaled == 0) grdio_pack_grid (GMT, header, grid, k_grd_unpack); /* revert scale and offset to leave grid as it was before writing unless session originated from gm*/
gmt_grdio.c:	switch (GMT->session.grdformat[format][1]) {
gmt_grdio.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Unknown grid data type: %c\n", GMT->session.grdformat[format][1]);
gmt_grdio.c:			if (strncmp (GMT->session.grdformat[i], code, 2) == 0) {
gmt_grdio.c:	if (!strcmp (GMT->init.module_name, "grdedit")) return (GMT_NOERROR);	/* Separate handling in grdedit to allow grdedit -A */
gmt_grdio.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Grid x increment <= 0.0\n");
gmt_grdio.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Grid x range <= 0.0\n");
gmt_grdio.c:			if (gmt_M_is_geographic (GMT, GMT_IN)) GMT_Report (GMT->parent, GMT_MSG_NORMAL,
gmt_grdio.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL,
gmt_grdio.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Grid y increment <= 0.0\n");
gmt_grdio.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Grid y range <= 0.0\n");
gmt_grdio.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL,
gmt_grdio.c:	GMT_Report (GMT->parent, GMT_MSG_DEBUG, "region: %g %g, grid: %g %g\n", wesn[XLO], wesn[XHI], header->wesn[XLO], header->wesn[XHI]);
gmt_grdio.c:	GMT_Report (GMT->parent, GMT_MSG_DEBUG, "-> region: %g %g, grid: %g %g\n", wesn[XLO], wesn[XHI], header->wesn[XLO], header->wesn[XHI]);
gmt_grdio.c:	GMT_Report (GMT->parent, GMT_MSG_DEBUG, "row: %d %d, col: %d %d\n", *first_row, *last_row, *first_col, *last_col);
gmt_grdio.c:						GMT_Report (GMT->parent, GMT_MSG_VERBOSE,
gmt_grdio.c:						GMT_Report (GMT->parent, GMT_MSG_VERBOSE,
gmt_grdio.c:						GMT_Report (GMT->parent, GMT_MSG_VERBOSE,
gmt_grdio.c:						GMT_Report (GMT->parent, GMT_MSG_VERBOSE,
gmt_grdio.c:						GMT_Report (GMT->parent, GMT_MSG_VERBOSE,
gmt_grdio.c:						GMT_Report (GMT->parent, GMT_MSG_VERBOSE,
gmt_grdio.c:						GMT_Report (GMT->parent, GMT_MSG_VERBOSE,
gmt_grdio.c:						GMT_Report (GMT->parent, GMT_MSG_VERBOSE,
gmt_grdio.c:						GMT_Report (GMT->parent, GMT_MSG_VERBOSE,
gmt_grdio.c:						GMT_Report (GMT->parent, GMT_MSG_VERBOSE,
gmt_grdio.c:	GMT_Message (GMT->parent, GMT_TIME_NONE, "\t-%c Append grid header information as one string composed of one or\n", option);
gmt_grdio.c:	GMT_Message (GMT->parent, GMT_TIME_NONE, "\t   more modifiers; items not listed will remain unchanged:\n");
gmt_grdio.c:	GMT_Message (GMT->parent, GMT_TIME_NONE, "\t     +x[<name>]   Sets the x-unit name; leave blank to reset\n");
gmt_grdio.c:	GMT_Message (GMT->parent, GMT_TIME_NONE, "\t     +y[<name>]   Sets the y-unit name; leave blank to reset\n");
gmt_grdio.c:	GMT_Message (GMT->parent, GMT_TIME_NONE, "\t     +z[<name>]   Sets the z-unit name; leave blank to reset\n");
gmt_grdio.c:	GMT_Message (GMT->parent, GMT_TIME_NONE, "\t     +t[<title>]  Sets the grid title;  leave blank to reset\n");
gmt_grdio.c:	GMT_Message (GMT->parent, GMT_TIME_NONE, "\t     +r[<remark>] Sets the grid remark; leave blank to reset\n");
gmt_grdio.c:	GMT_Message (GMT->parent, GMT_TIME_NONE, "\t     +s<scale>    Sets the z-scale\n");
gmt_grdio.c:	GMT_Message (GMT->parent, GMT_TIME_NONE, "\t     +o<offset>   Sets the z-offset\n");
gmt_grdio.c:		header->z_min          = GMT->session.d_NaN;
gmt_grdio.c:		header->z_max          = GMT->session.d_NaN;
gmt_grdio.c:		header->nan_value      = GMT->session.f_NaN;
gmt_grdio.c:		gmt_M_grd_setpad (GMT, header, GMT->current.io.pad); /* Assign default pad */
gmt_grdio.c:		struct GMTAPI_CTRL *API = GMT->parent;
gmt_grdio.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Could not create argc, argv from linked structure options!\n");
gmt_grdio.c:		strncpy (header->command, GMT->init.module_name, GMT_GRID_COMMAND_LEN320-1);
gmt_grdio.c:		snprintf (header->title, GMT_GRID_TITLE_LEN80, "Produced by %s", GMT->init.module_name);
gmt_grdio.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Cannot rotate grid, width is too small\n");
gmt_grdio.c:	if (gridline) GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Repeating column now at %g/%g\n", G->header->wesn[XLO], G->header->wesn[XHI]);
gmt_grdio.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Inconsistent values at repeated longitude nodes (%g and %g) for %d rows\n",
gmt_grdio.c:	 * It does so by using GMT->common.R.wesn which have been set correctly by map_setup.
gmt_grdio.c:	wesn[YLO] = GMT->common.R.wesn[YLO] - off * h->inc[GMT_Y], wesn[YHI] = GMT->common.R.wesn[YHI] + off * h->inc[GMT_Y];
gmt_grdio.c:	if (gmt_M_360_range (GMT->common.R.wesn[XLO], GMT->common.R.wesn[XHI]) && gmt_M_x_is_lon (GMT, GMT_IN)) off = 0.0;
gmt_grdio.c:	wesn[XLO] = GMT->common.R.wesn[XLO] - off * h->inc[GMT_X], wesn[XHI] = GMT->common.R.wesn[XHI] + off * h->inc[GMT_X];
gmt_grdio.c:	if (GMT->common.R.oblique && !gmt_M_is_rect_graticule (GMT)) {	/* Used -R... with oblique boundaries - return entire grid */
gmt_grdio.c:		if (wesn[XHI] < h->wesn[XLO])	/* Make adjustments so GMT->current.proj.[w,e] jives with h->wesn */
gmt_grdio.c:		/* Make sure we do not exceed grid domain (which can happen if GMT->common.R.wesn exceeds the grid limits) */
gmt_grdio.c:		if (!GMT->current.map.outside (GMT, 0.0, +90.0)) wesn[XLO] = h->wesn[XLO], wesn[XHI] = h->wesn[XHI], wesn[YHI] = h->wesn[YHI];
gmt_grdio.c:		if (!GMT->current.map.outside (GMT, 0.0, -90.0)) wesn[XLO] = h->wesn[XLO], wesn[XHI] = h->wesn[XHI], wesn[YLO] = h->wesn[YLO];
gmt_grdio.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Your grid y's or latitudes appear to be outside the map region and will be skipped.\n");
gmt_grdio.c:			while ((wesn[XLO]) < GMT->common.R.wesn[XLO]) wesn[XLO] += h->inc[GMT_X];
gmt_grdio.c:			while ((wesn[XHI]) > GMT->common.R.wesn[XHI]) wesn[XHI] -= h->inc[GMT_X];
gmt_grdio.c:	if (GMT->current.map.is_world) {
gmt_grdio.c:		if (gmt_M_360_range (GMT->common.R.wesn[XLO], GMT->common.R.wesn[XHI])) {
gmt_grdio.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Your grid x's or longitudes appear to be outside the map region and will be skipped.\n");
gmt_grdio.c:		GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Region exceeds grid domain. Region reduced to grid domain.\n");
gmt_grdio.c:			GMT_Report (GMT->parent, GMT_MSG_VERBOSE,
gmt_grdio.c:			          GMT->current.setting.format_float_out, GMT->current.setting.format_float_out);
gmt_grdio.c:			GMT_Report (GMT->parent, GMT_MSG_VERBOSE, format, wesn[XLO], val);
gmt_grdio.c:			GMT_Report (GMT->parent, GMT_MSG_VERBOSE,
gmt_grdio.c:			          GMT->current.setting.format_float_out, GMT->current.setting.format_float_out);
gmt_grdio.c:			GMT_Report (GMT->parent, GMT_MSG_VERBOSE, format, wesn[XHI], val);
gmt_grdio.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "(s - y_min) must equal (NY + eps) * y_inc), where NY is an integer and |eps| <= %g.\n",
gmt_grdio.c:		          GMT->current.setting.format_float_out, GMT->current.setting.format_float_out);
gmt_grdio.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, format, wesn[YLO], val);
gmt_grdio.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "(n - y_min) must equal (NY + eps) * y_inc), where NY is an integer and |eps| <= %g.\n",
gmt_grdio.c:		          GMT->current.setting.format_float_out, GMT->current.setting.format_float_out);
gmt_grdio.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, format, wesn[YHI], val);
gmt_grdio.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Scale must be a non-zero normalized number (%g).\n", scale);
gmt_grdio.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Offset must be a finite number (%g).\n", offset);
gmt_grdio.c:			GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "img file %s has unusual size - grid increment defaults to %d min\n", file, min);
gmt_grdio.c:	GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Reading img grid from file %s (scale = %g mode = %d lat = %g)\n",
gmt_grdio.c:		GMT->current.setting.proj_ellipsoid = gmt_get_ellipsoid (GMT, "Sphere");
gmt_grdio.c:		GMT->current.proj.units_pr_degree = true;
gmt_grdio.c:		GMT->current.proj.pars[0] = 180.0;
gmt_grdio.c:		GMT->current.proj.pars[1] = 0.0;
gmt_grdio.c:		GMT->current.proj.pars[2] = 1.0;
gmt_grdio.c:		GMT->current.proj.projection = GMT->current.proj.projection_GMT = GMT_MERCATOR;
gmt_grdio.c:		GMT->common.J.active = true;
gmt_grdio.c:	Grid->header->wesn[YHI] = MIN (GMT->current.proj.rect[YHI], ceil (Grid->header->wesn[YHI] / Grid->header->inc[GMT_Y]) * Grid->header->inc[GMT_Y]);
gmt_grdio.c:	gmt_M_grd_setpad (GMT, Grid->header, GMT->current.io.pad);			/* Assign default pad */
gmt_grdio.c:	n_skip = lrint (floor ((GMT->current.proj.rect[YHI] - Grid->header->wesn[YHI]) * HH->r_inc[GMT_Y]));	/* Number of rows clearly above y_max */
gmt_grdio.c:				GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "File %s probably needs to byteswapped (max change = %u)\n", file, max_step);
gmt_grdio.c:		gmt_M_memcpy (GMT->common.R.wesn, wesn, 4, double);
gmt_grdio.c:		GMT->common.J.active = false;
gmt_grdio.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Calling gmt_grd_pad_off on interleaved complex grid! Programming error?\n");
gmt_grdio.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Calling gmt_grd_pad_off on interleaved complex grid! Programming error?\n");
gmt_grdio.c:		GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Extend grid via copy onto larger memory-aligned grid\n");
gmt_grdio.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Calling gmt_grd_pad_off on interleaved complex grid! Programming error?\n");
gmt_grdio.c:	GMT_Set_Index (GMT->parent, G->header, GMT_GRID_LAYOUT);
gmt_grdio.c:	GH->alloc_level = GMT->hidden.func_level;	/* Must be freed at this level. */
gmt_grdio.c:	GH->id = GMT->parent->unique_var_ID++;		/* Give unique identifier */
gmt_grdio.c:		if ((mode & GMT_DUPLICATE_RESET) && !gmt_grd_pad_status (GMT, G->header, GMT->current.io.pad)) {
gmt_grdio.c:			gmt_M_grd_setpad (GMT, Gnew->header, GMT->current.io.pad);	/* Set default pad size */
gmt_grdio.c:		if ((*Out = GMT_Duplicate_Data (GMT->parent, GMT_IS_GRID, GMT_DUPLICATE_DATA, G)) == NULL) {
gmt_grdio.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Unable to duplicate grid! - this is not a good thing and may crash this module\n");
gmt_grdio.c:	if (registration & GMT_GRID_DEFAULT_REG) registration |= GMT->common.R.registration;	/* Set the default registration */
gmt_grdio.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Grid/Image dimensions imply w/e/s/n = 0/%g/0/%g, inc = 1/1, %s registration, n_layers = %u\n",
gmt_grdio.c:			if (!GMT->common.R.active[RSET]) {
gmt_grdio.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "No w/e/s/n given and no -R in effect.  Cannot initialize new grid\n");
gmt_grdio.c:			if (!GMT->common.R.active[ISET]) {
gmt_grdio.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "No increment given and no -I in effect.  Cannot initialize new grid\n");
gmt_grdio.c:			GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Grid/Image dimensions imply w/e/s/n = %g/%g/%g/%g, inc = %g/%g, %s registration, n_layers = %u\n",
gmt_grdio.c:		gmt_M_memcpy (header->wesn, GMT->common.R.wesn, 4, double);
gmt_grdio.c:		gmt_M_memcpy (header->inc, GMT->common.R.inc, 2, double);
gmt_grdio.c:	if (GMT->common.R.row_order) HH->row_order = GMT->common.R.row_order;
gmt_grdio.c:	gmt_M_grd_setpad (GMT, header, GMT->current.io.pad);	/* Assign default GMT pad */
gmt_grdio.c:	if (n == 0) h->z_min = h->z_max = GMT->session.d_NaN;	/* No non-NaNs in the entire grid */
gmt_grdio.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Grid has already been detrending - no action taken\n");
gmt_grdio.c:		GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "No detrending selected\n");
gmt_grdio.c:		GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Demultiplexing complex grid before detrending can take place.\n");
gmt_grdio.c:				GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Mean value removed from %s component: %.8g Variance reduction: %.2f\n",
gmt_grdio.c:				GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Mean value removed: %.8g Variance reduction: %.2f\n", a[0], var_redux);
gmt_grdio.c:				GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Mid value removed from %s component: %.8g Variance reduction: %.2f\n",
gmt_grdio.c:				GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Mid value removed: %.8g Variance reduction: %.2f\n", a[0], var_redux);
gmt_grdio.c:				GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Plane removed from %s component. Mean, S.D., Dx, Dy: %.8g\t%.8g\t%.8g\t%.8g Variance reduction: %.2f\n",
gmt_grdio.c:				GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Plane removed.  Mean, S.D., Dx, Dy: %.8g\t%.8g\t%.8g\t%.8g Variance reduction: %.2f\n",
gmt_grdio.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "gmtlib_expand_headerpad: %d pad sides changed. Now %u/%u/%u/%u\n",
gmt_grdio.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "gmtlib_expand_headerpad: No pad adjustment needed\n");
gmt_grdio.c:	GMT_Report (GMT->parent, GMT_MSG_DEBUG, "gmtlib_contract_headerpad: Pad and wesn reset to original values\n");
gmt_grdio.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "%s considered a valid image instead of grid. Open via GDAL\n", file);
gmt_grdio.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "%s may be image or grid.  Open via GDAL for checking\n", file);
gmt_grdio.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "%s is most likely a grid. Open in GMT as grid\n", file);
gmt_grdio.c:	if (GMT->current.proj.projection == GMT_LINEAR) return GMT_NOERROR;	/* Only linear projection is allowed with this projected grid */
gmt_grdio.c:	GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Cannot use a map projection with an already projected grid (spherical Mercator img grid).  Use -Jx or -JX.\n");
gmt_grdio.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "ERROR reading image with gdalread.\n");
gmt_grdio.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Using data type other than byte (unsigned char) is not implemented\n");
gmt_grdio.c:	GMT_Set_Index (GMT->parent, I->header, GMT_IMAGE_LAYOUT);
gmt_grdio.c:	/*gmt_M_err_trap ((*GMT->session.readgrd[header->type]) (GMT, header, image, P.wesn, P.pad, complex_mode));*/
gmt_grdio.c:	if (GMT->common.R.active[RSET]) {
gmt_grdio.c:		snprintf (strR, GMT_LEN128, "%.10f/%.10f/%.10f/%.10f", GMT->common.R.wesn[XLO], GMT->common.R.wesn[XHI],
gmt_grdio.c:		          GMT->common.R.wesn[YLO], GMT->common.R.wesn[YHI]);
gmt_grdio.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "ERROR reading image with gdalread.\n");
gmt_init.c:#define GMT_def(case_val) *GMT->session.u2u[GMT_INCH][gmtlib_unit_lookup(GMT, GMT->current.setting.given_unit[case_val], GMT->current.setting.proj_length_unit)], GMT->current.setting.given_unit[case_val]
gmt_init.c:#define GMT_COMPAT_WARN GMT_Report (GMT->parent, GMT_MSG_COMPAT, "Parameter %s is deprecated.\n" GMT_COMPAT_INFO, GMT_keywords[case_val])
gmt_init.c:#define GMT_COMPAT_CHANGE(new_P) GMT_Report (GMT->parent, GMT_MSG_COMPAT, "Parameter %s is deprecated. Use %s instead.\n" GMT_COMPAT_INFO, GMT_keywords[case_val], new_P)
gmt_init.c:#define GMT_COMPAT_OPT(new_P) if (strchr (list, option)) { GMT_Report (GMT->parent, GMT_MSG_COMPAT, "Option -%c is deprecated. Use -%c instead.\n" GMT_COMPAT_INFO, option, new_P); option = new_P; }
gmt_init.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Exclusive lock could not be acquired (%s)\n", dlerror());
gmt_init.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Failed to release lock (%s)\n", dlerror());
gmt_init.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Exclusive lock could not be acquired (%s)\n", strerror(errsv));
gmt_init.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Failed to release lock (%s)\n", strerror(errsv));
gmt_init.c:	GMT_Report (GMT->parent, GMT_MSG_DEBUG, "File locking not supported.\n");
gmt_init.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error %s: %s\n", err_msg, txt);
gmt_init.c:		GMT->current.setting.io_header[GMT_IN] = GMT->current.setting.io_header[GMT_OUT] = true;
gmt_init.c:		strncpy (GMT->common.g.string, item, GMT_LEN64-1);	/* Verbatim copy */
gmt_init.c:		strncpy (GMT->common.g.string, item, GMT_LEN64-1);	/* Verbatim copy */
gmt_init.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Can only set the number of input header records; %s ignored\n", &item[k]);
gmt_init.c:				GMT->current.setting.io_n_header_items = i;
gmt_init.c:		GMT->current.setting.io_header[GMT_IN] = true;
gmt_init.c:		GMT->current.setting.io_header[GMT_OUT] = false;
gmt_init.c:		GMT->current.setting.io_header[GMT_OUT] = true;
gmt_init.c:		GMT->current.setting.io_header[GMT_IN] = false;
gmt_init.c:		GMT->current.setting.io_header[GMT_IN] = true;
gmt_init.c:		GMT->current.setting.io_header[GMT_OUT] = true;
gmt_init.c:					GMT->common.h.mode = GMT_COMMENT_IS_RESET;
gmt_init.c:					GMT->common.h.add_colnames = true;
gmt_init.c:					gmt_M_str_free (GMT->common.h.multi_segment);
gmt_init.c:					GMT->common.h.multi_segment = strdup (&p[1]);
gmt_init.c:					gmt_M_str_free (GMT->common.h.remark);
gmt_init.c:					GMT->common.h.remark = strdup (&p[1]);
gmt_init.c:					gmt_M_str_free (GMT->common.h.title);
gmt_init.c:					GMT->common.h.title = strdup (&p[1]);
gmt_init.c:					GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Unrecognized modifier +%c.\n", p[0]);
gmt_init.c:	GMT->current.setting.ps_page_size[0] = GMT->current.setting.ps_page_size[1] = GMT_PAPER_DIM;	/* Max area in points */
gmt_init.c:	GMT->current.setting.ps_media = -USER_MEDIA_OFFSET;
gmt_init.c:	GMT->current.setting.ps_orientation = PSL_PORTRAIT;
gmt_init.c:	GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Call gmtinit_rectR_to_geoR to convert projected -R to geo -R\n");
gmt_init.c:	if (gmt_M_is_dnan (GMT->current.proj.lon0)) {
gmt_init.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Central meridian is not known; cannot convert -R<unit>... to geographic corners\n");
gmt_init.c:	if (gmt_M_is_dnan (GMT->current.proj.lat0)) {
gmt_init.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Projection standard latitude is not known; cannot convert -R<unit>... to geographic corners\n");
gmt_init.c:	if ((In = GMT_Create_Data (GMT->parent, GMT_IS_DATASET, GMT_IS_POINT, 0, dim, NULL, NULL, 0, 0, NULL)) == NULL) return (GMT_MEMORY_ERROR);
gmt_init.c:	if (GMT_Open_VirtualFile (GMT->parent, GMT_IS_DATASET, GMT_IS_POINT, GMT_IN, In, in_string) == GMT_NOTSET)
gmt_init.c:		return (GMT->parent->error);
gmt_init.c:	if (GMT_Open_VirtualFile (GMT->parent, GMT_IS_DATASET, GMT_IS_POINT, GMT_OUT, NULL, out_string) == GMT_NOTSET)
gmt_init.c:		return (GMT->parent->error);
gmt_init.c:	was_R = GMT->common.R.active[RSET];	was_J = GMT->common.J.active;
gmt_init.c:	GMT->common.R.active[RSET] = GMT->common.J.active = false;	/* To allow new entries */
gmt_init.c:	wesn[XLO] = GMT->current.proj.lon0 - 1.0;		wesn[XHI] = GMT->current.proj.lon0 + 1.0;
gmt_init.c:	wesn[YLO] = MAX (GMT->current.proj.lat0 -1.0, -90.0);	wesn[YHI] = MIN (GMT->current.proj.lat0 + 1.0, 90.0);
gmt_init.c:	proj_class = GMT->current.proj.projection_GMT / 100;	/* 1-4 for valid projections */
gmt_init.c:	if (GMT->current.proj.projection_GMT == GMT_AZ_EQDIST) proj_class = 4;	/* Make -JE use global region */
gmt_init.c:			if (GMT->current.proj.projection_GMT == GMT_UTM && gmt_UTMzone_to_wesn (GMT, GMT->current.proj.utm_zonex, GMT->current.proj.utm_zoney, GMT->current.proj.utm_hemisphere, wesn)) {
gmt_init.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "UTM projection insufficiently specified to auto-determine geographic region\n");
gmt_init.c:			if (doubleAlmostEqualZero (GMT->current.proj.lat0, 90.0)) {
gmt_init.c:				wesn[XLO] = GMT->current.proj.lon0 - 180.0;	wesn[XHI] = GMT->current.proj.lon0 + 180.0;
gmt_init.c:			else if (doubleAlmostEqualZero (GMT->current.proj.lat0, -90.0)) {
gmt_init.c:				wesn[XLO] = GMT->current.proj.lon0 - 180.0;	wesn[XHI] = GMT->current.proj.lon0 + 180.0;
gmt_init.c:			GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "No map projection specified to auto-determine geographic region\n");
gmt_init.c:		wesn[XLO], wesn[XHI], wesn[YLO], wesn[YHI], GMT->common.J.string, unit, in_string, out_string);
gmt_init.c:	if (get_R) GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Obtaining geographic corner coordinates via mapproject %s\n", buffer);
gmt_init.c:	if (GMT_Call_Module (GMT->parent, "mapproject", GMT_MODULE_CMD, buffer) != GMT_OK)	/* Get the corners in degrees via mapproject */
gmt_init.c:		return (GMT->parent->error);
gmt_init.c:	GMT->common.R.active[RSET] = was_R;	GMT->common.J.active = was_J;
gmt_init.c:	if ((Out = GMT_Read_VirtualFile (GMT->parent, out_string)) == NULL)
gmt_init.c:		return (GMT->parent->error);
gmt_init.c:	if (GMT_Close_VirtualFile (GMT->parent, in_string) != GMT_NOERROR)
gmt_init.c:		return (GMT->parent->error);
gmt_init.c:	if (GMT_Close_VirtualFile (GMT->parent, out_string) != GMT_NOERROR)
gmt_init.c:		return (GMT->parent->error);
gmt_init.c:	if (GMT_Destroy_Data (GMT->parent, &In) != GMT_OK)
gmt_init.c:		return (GMT->parent->error);
gmt_init.c:	if (GMT_Destroy_Data (GMT->parent, &Out) != GMT_OK)
gmt_init.c:		return (GMT->parent->error);
gmt_init.c:	if (get_R) GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE,
gmt_init.c:		GMT->common.R.string, out_wesn[XLO], out_wesn[YLO], out_wesn[XHI], out_wesn[YHI]);
gmt_init.c:		GMT->current.ps.origin[GMT_X] = GMT->common.X.mode = 'r';
gmt_init.c:		GMT->current.setting.map_origin[GMT_X] = 0.0;
gmt_init.c:			GMT->current.ps.origin[GMT_X] = GMT->common.X.mode = text[0]; i++; break;
gmt_init.c:			GMT->current.ps.origin[GMT_X] = GMT->common.X.mode = 'r'; break;
gmt_init.c:			GMT->current.setting.map_origin[GMT_X] = GMT->current.map.last_width;
gmt_init.c:				GMT->current.setting.map_origin[GMT_X] *= -1;
gmt_init.c:				GMT->current.setting.map_origin[GMT_X] /= atof (&text[i]);
gmt_init.c:			if (text[i]) GMT->current.setting.map_origin[GMT_X] += gmt_M_to_inch (GMT, &text[i]);
gmt_init.c:			GMT->current.setting.map_origin[GMT_X] = gmt_M_to_inch (GMT, &text[i]);
gmt_init.c:		GMT->current.setting.map_origin[GMT_X] = 0.0;
gmt_init.c:		GMT->current.ps.origin[GMT_Y] = GMT->common.Y.mode = 'r';
gmt_init.c:		GMT->current.setting.map_origin[GMT_Y] = 0.0;
gmt_init.c:			GMT->current.ps.origin[GMT_Y] = GMT->common.Y.mode = text[0]; i++; break;
gmt_init.c:			GMT->current.ps.origin[GMT_Y] = GMT->common.Y.mode = 'r'; break;
gmt_init.c:			GMT->current.setting.map_origin[GMT_Y] = GMT->current.map.last_height;
gmt_init.c:				GMT->current.setting.map_origin[GMT_Y] *= -1;
gmt_init.c:				GMT->current.setting.map_origin[GMT_Y] /= atof (&text[i]);
gmt_init.c:			if (text[i]) GMT->current.setting.map_origin[GMT_Y] += gmt_M_to_inch (GMT, &text[i]);
gmt_init.c:			GMT->current.setting.map_origin[GMT_Y] = gmt_M_to_inch (GMT, &text[i]);
gmt_init.c:		GMT->current.setting.map_origin[GMT_Y] = 0.0;
gmt_init.c:	strncpy (GMT->common.a.string, arg, GMT_LEN256-1);	/* Verbatim copy */
gmt_init.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error -a: No such geometry: %s.\n", s+2);
gmt_init.c:		GMT->common.a.geometry = t;
gmt_init.c:		if (s[1] == 'G') GMT->common.a.clip = true;	/* Clip features at Dateline */
gmt_init.c:		GMT->common.a.output = true;	/* We are producing, not reading an OGR/GMT file */
gmt_init.c:		if (GMT->current.setting.io_seg_marker[GMT_OUT] != '>') {
gmt_init.c:			GMT_Report (GMT->parent, GMT_MSG_VERBOSE,
gmt_init.c:				GMT->current.setting.io_seg_marker[GMT_OUT]);
gmt_init.c:			GMT->current.setting.io_seg_marker[GMT_OUT] = '>';
gmt_init.c:	else if (GMT->current.setting.io_seg_marker[GMT_IN] != '>') {
gmt_init.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE,
gmt_init.c:			GMT->current.setting.io_seg_marker[GMT_IN]);
gmt_init.c:		GMT->current.setting.io_seg_marker[GMT_IN] = '>';
gmt_init.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error -a: No such type: %s.\n", c+1);
gmt_init.c:			GMT->common.a.type[GMT->common.a.n_aspatial] = t;
gmt_init.c:			GMT->common.a.type[GMT->common.a.n_aspatial] = GMT_DOUBLE;
gmt_init.c:					GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error -a: Columns 0 and 1 are reserved for lon and lat.\n");
gmt_init.c:		GMT->common.a.col[GMT->common.a.n_aspatial] = col;
gmt_init.c:		if (col < 0 && col != GMT_IS_Z) GMT->common.a.type[GMT->common.a.n_aspatial] = GMT_TEXT;
gmt_init.c:		gmt_M_str_free (GMT->common.a.name[GMT->common.a.n_aspatial]);	/* Free any previous names */
gmt_init.c:		GMT->common.a.name[GMT->common.a.n_aspatial] = strdup (name);
gmt_init.c:		GMT->common.a.n_aspatial++;
gmt_init.c:		if (GMT->common.a.n_aspatial == MAX_ASPATIAL) return (GMT_PARSE_ERROR);	/* Too many items */
gmt_init.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -b: Bad endian modifier +%c\n", (int)p[1]);
gmt_init.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -b: Cannot use both w and endian modifiers\n");
gmt_init.c:	GMT->common.b.active[id] = true;
gmt_init.c:	GMT->common.b.type[id] = 'd';	/* Set default to double */
gmt_init.c:	GMT->common.b.swab[id] = k_swap_none;	/* No byte swapping */
gmt_init.c:			GMT_Report (GMT->parent, GMT_MSG_COMPAT, "Syntax warning: -b[i]c now applies to character tables, not to netCDF\n");
gmt_init.c:			GMT_Report (GMT->parent, GMT_MSG_COMPAT, "Syntax warning: If input file is netCDF, just leave out -b[i]c\n");
gmt_init.c:			GMT->common.b.type[id] = 'c';
gmt_init.c:			GMT_Report (GMT->parent, GMT_MSG_COMPAT, "Syntax warning: -b[i]c<varlist> is deprecated. Use <file>?<varlist> instead.\n");
gmt_init.c:			GMT->common.b.nc[id] = true;
gmt_init.c:			GMT->common.b.active[id] = false;	/* Binary is 'false' if netCDF is to be read */
gmt_init.c:			strncpy (GMT->common.b.varnames, &text[k+1], GMT_BUFSIZ-1);	/* Copy the list of netCDF variable names */
gmt_init.c:		GMT->common.b.type[id] = text[k];			/* Set the default column type to the first (and possibly only data type) listed */
gmt_init.c:			if (GMT->common.b.type[id] == 's') GMT->common.b.type[id] = 'f';
gmt_init.c:			if (GMT->common.b.type[id] == 'S') { GMT->common.b.type[id] = 'f'; GMT->common.b.swab[id] = (id == GMT_IN) ? k_swap_in : k_swap_out;	}
gmt_init.c:			if (GMT->common.b.type[id] == 'D') { GMT->common.b.type[id] = 'd'; GMT->common.b.swab[id] = (id == GMT_IN) ? k_swap_in : k_swap_out;	}
gmt_init.c:		if (text[k+1] == 'w') GMT->common.b.swab[id] = (id == GMT_IN) ? k_swap_in : k_swap_out;	/* Default swab */
gmt_init.c:						GMT_Report (GMT->parent, GMT_MSG_COMPAT,
gmt_init.c:						GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Malformed -b argument [%s]\n", text);
gmt_init.c:						GMT_Report (GMT->parent, GMT_MSG_COMPAT, "-b[o]d is deprecated; Use <n>d to indicate how many columns\n");
gmt_init.c:						GMT->common.b.type[id] = c;	/* Set default to double */
gmt_init.c:						GMT->current.io.fmt[id][col].io = gmtlib_get_io_ptr (GMT, id, swap_flag, c);
gmt_init.c:						GMT->current.io.fmt[id][col].type = gmt_get_io_type (GMT, c);
gmt_init.c:							GMT->current.io.fmt[GMT_OUT][col].io = gmtlib_get_io_ptr (GMT, GMT_OUT, swap_flag, c);
gmt_init.c:							GMT->current.io.fmt[GMT_OUT][col].type = gmt_get_io_type (GMT, c);
gmt_init.c:						GMT->current.io.fmt[id][col].skip = -ncol;	/* Number of bytes to skip */
gmt_init.c:						GMT->current.io.fmt[id][col-1].skip = ncol;	/* Number of bytes to skip */
gmt_init.c:					if (!i_or_o) GMT->current.io.fmt[GMT_OUT][col-1].skip = GMT->current.io.fmt[id][col-1].skip;
gmt_init.c:						GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -b: Column count must be > 0\n");
gmt_init.c:					GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Malformed -b argument [%s]\n", text);
gmt_init.c:	GMT->common.b.ncol[id] = col;
gmt_init.c:		for (col = 0; col < GMT->common.b.ncol[id]; col++) {
gmt_init.c:			GMT->current.io.fmt[id][col].io   = gmtlib_get_io_ptr (GMT, id, swab, 'd');
gmt_init.c:			GMT->current.io.fmt[id][col].type = gmt_get_io_type (GMT, 'd');
gmt_init.c:				GMT->current.io.fmt[GMT_OUT][col].io   = gmtlib_get_io_ptr (GMT, GMT_OUT, swab, 'd');
gmt_init.c:				GMT->current.io.fmt[GMT_OUT][col].type = gmt_get_io_type (GMT, 'd');
gmt_init.c:		GMT->common.b.nc[GMT_OUT] = GMT->common.b.nc[GMT_IN];
gmt_init.c:		GMT->common.b.active[GMT_OUT] = GMT->common.b.active[GMT_IN];
gmt_init.c:		GMT->common.b.ncol[GMT_OUT] = GMT->common.b.ncol[GMT_IN];
gmt_init.c:		GMT->common.b.type[GMT_OUT] = GMT->common.b.type[GMT_IN];
gmt_init.c:		if (GMT->common.b.swab[GMT_IN] == k_swap_in) GMT->common.b.swab[GMT_OUT] = k_swap_out;
gmt_init.c:		strncpy (GMT->common.b.string, text, GMT_LEN256-1);
gmt_init.c:		strncpy (GMT->common.b.string, text, GMT_LEN256-1);
gmt_init.c:		col = GMT->current.io.col_type[GMT_IN];
gmt_init.c:		strncpy (GMT->common.f.string, arg, GMT_LEN64-1);	/* Verbatim copy */
gmt_init.c:		col = GMT->current.io.col_type[GMT_OUT];
gmt_init.c:		strncpy (GMT->common.f.string, arg, GMT_LEN64-1);	/* Verbatim copy */
gmt_init.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Malformed -f argument [%s] - bad projected unit\n", arg);
gmt_init.c:		GMT->current.proj.inv_coordinates = true;
gmt_init.c:		GMT->current.proj.inv_coord_unit = unit;
gmt_init.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Malformed -f argument [%s]\n", arg);
gmt_init.c:		GMT->parent->print_func (stdout, message);
gmt_init.c:		 * struct GMTAPI_CTRL *G = GMT->parent;
gmt_init.c:		snprintf (message, GMT_LEN128, "%s\n", GMT->session.SHAREDIR);
gmt_init.c:		GMT->parent->print_func (stdout, message);
gmt_init.c:	if (!strncmp (text, "PS_CHAR_ENCODING", 16U)) GMT->current.ps.switch_set = true;
gmt_init.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "INTERNAL Error gmtinit_trend_modifiers: was passed dim >= 2 (%u)\n", dim);
gmt_init.c:				if ((k = GMT_Get_Values (GMT->parent, &p[1], M->origin, 2)) < 1) {
gmt_init.c:					GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error -%c: Unable to parse the +o arguments (%s)\n", option, &p[1]);
gmt_init.c:					GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error -%c: Did not provide %u arguments to +o\n", option, dim);
gmt_init.c:				if ((k = GMT_Get_Values (GMT->parent, &p[1], M->period, 2)) < 1) {
gmt_init.c:					GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error -%c: Unable to parse the +l argument (%s)\n", option, &p[1]);
gmt_init.c:					GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error -%c: Did not provide %u arguments to +l\n", option, dim);
gmt_init.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error -%c: Unrecognized modifier +%s\n", option, p);
gmt_init.c:			GMT_Report (GMT->parent, GMT_MSG_COMPAT, "-%c%s is deprecated; see usage for new syntax\n", option, arg);
gmt_init.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error -%c: Old-style arguments given and chosen compatibility mode does not allow it\n", option);
gmt_init.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error -%c: No arguments given!\n", option);
gmt_init.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error -%c: Bad basis function type (%c)\n", option, p[0]);
gmt_init.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error -%c: Bad basis function order (%s)\n", option, this_range);
gmt_init.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error -%c: Exceeding max basis functions (%d) \n", option, GMT_N_MAX_MODEL);
gmt_init.c:					GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error -%c: Basis %c%u occurs more than once!\n", option, name[M->term[k].kind], M->term[k].order[GMT_X]);
gmt_init.c:		if (!M->intercept) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning -%c: No intercept term (p0) given\n", option);
gmt_init.c:		GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Solving for %u terms using a %s norm.  The model:\n", n_model, way[M->robust]);
gmt_init.c:		GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, report);
gmt_init.c:		GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "In the above, x = 2*(x - x_mid)/(x_max - x_min) for polynomials and x = 2*pi*(x - origin)/length for Fourier components\n");
gmt_init.c:			if (M->type & 1) GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "The complete polynomial will be represented via Chebyshev polynomials\n");
gmt_init.c:			if (M->type & 1) GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "The partial polynomial will be represented via powers of x\n");
gmt_init.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error -%c: No arguments given!\n", option);
gmt_init.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error -%c: Bad basis function type (%c)\n", option, p[0]);
gmt_init.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error -%c: Bad basis function order (%s)\n", option, this_range);
gmt_init.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error -%c: Cosine|Sine cannot start with order 0.  Use p0 to add a constant\n", option);
gmt_init.c:							GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error -%c: Exceeding max basis functions (%d) \n", option, GMT_N_MAX_MODEL);
gmt_init.c:								GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error -%c: Exceeding max basis functions (%d) \n", option, GMT_N_MAX_MODEL);
gmt_init.c:						GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error -%c: Exceeding max basis functions (%d) \n", option, GMT_N_MAX_MODEL);
gmt_init.c:							GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error -%c: Exceeding max basis functions (%d) \n", option, GMT_N_MAX_MODEL);
gmt_init.c:							GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error -%c: Exceeding max basis functions (%d) \n", option, GMT_N_MAX_MODEL);
gmt_init.c:							GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error -%c: Exceeding max basis functions (%d) \n", option, GMT_N_MAX_MODEL);
gmt_init.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error -%c: Basis %cx%uy%u occurs more than once!\n", option, name[M->term[k].kind], M->term[k].order[GMT_X], M->term[k].order[GMT_Y]);
gmt_init.c:		if (!got_intercept) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning -%c: No intercept term (p0) given\n", option);
gmt_init.c:	GMT->current.setting.map_logo = true;
gmt_init.c:		if (item[0]) strncpy (GMT->current.ps.map_logo_label, item, GMT_LEN256-1);	/* Got a label */
gmt_init.c:						GMT->current.ps.logo_cmd = true;
gmt_init.c:						just = gmt_just_decode (GMT, &word[1], GMT->current.setting.map_logo_justify);
gmt_init.c:						if ((k = gmt_get_pair (GMT, &word[1], GMT_PAIR_DIM_DUP, GMT->current.setting.map_logo_pos)) < 2) error++;
gmt_init.c:		GMT->current.setting.map_logo_justify = just;
gmt_init.c:				n = sscanf (&item[1], "%[^/]/%[^/]/%[^\n]", txt_x, txt_y, GMT->current.ps.map_logo_label);
gmt_init.c:				n = sscanf (item, "%[^/]/%[^/]/%[^/]/%[^\n]", txt_j, txt_x, txt_y, GMT->current.ps.map_logo_label);
gmt_init.c:				just = gmt_just_decode (GMT, txt_j, GMT->current.setting.map_logo_justify);
gmt_init.c:				strncpy (GMT->current.ps.map_logo_label, item, GMT_LEN256-1);
gmt_init.c:				GMT->current.setting.map_logo_justify = just;
gmt_init.c:				GMT->current.setting.map_logo_pos[GMT_X] = gmt_M_to_inch (GMT, txt_x);
gmt_init.c:				GMT->current.setting.map_logo_pos[GMT_Y] = gmt_M_to_inch (GMT, txt_y);
gmt_init.c:			strncpy (GMT->current.ps.map_logo_label, item, GMT_LEN256-1);
gmt_init.c:		if (GMT->current.ps.map_logo_label[0] == 'c' && GMT->current.ps.map_logo_label[1] == 0) {	/* Old way of asking for +c */
gmt_init.c:			GMT->current.ps.logo_cmd = true;
gmt_init.c:			GMT->current.ps.map_logo_label[0] = '\0';
gmt_init.c:	GMT->common.x.active = true;
gmt_init.c:		GMT->common.x.n_threads = gmtlib_get_num_processors();
gmt_init.c:		GMT->common.x.n_threads = atoi (arg);
gmt_init.c:	if (GMT->common.x.n_threads == 0)
gmt_init.c:		GMT->common.x.n_threads = 1;
gmt_init.c:	else if (GMT->common.x.n_threads < 0)
gmt_init.c:		GMT->common.x.n_threads = MAX(gmtlib_get_num_processors() - GMT->common.x.n_threads, 1);		/* Max-n but at least one */
gmt_init.c:			GMT->current.setting.io_lonlat_toggle[way] = true;
gmt_init.c:			GMT->current.setting.io_lonlat_toggle[way] = true;
gmt_init.c:			GMT->current.setting.io_lonlat_toggle[way] = true;
gmt_init.c:			GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "-:%s given but %s order already set by -f; -:%s ignored.\n", mode[way+off], dir[way], mode[way+off]);
gmt_init.c:	if (error) GMT->current.setting.io_lonlat_toggle[GMT_IN] = GMT->current.setting.io_lonlat_toggle[GMT_OUT] = false;	/* Leave in case we had errors */
gmt_init.c:	return (GMT->current.io.prev_rec[col] - GMT->current.io.curr_rec[col]);
gmt_init.c:	return (GMT->current.io.curr_rec[col] - GMT->current.io.prev_rec[col]);
gmt_init.c:	return (fabs (GMT->current.io.curr_rec[col] - GMT->current.io.prev_rec[col]));
gmt_init.c:	gmt_geo_to_xy (GMT, GMT->current.io.prev_rec[GMT_X], GMT->current.io.prev_rec[GMT_Y], &X[GMT_X][0], &X[GMT_Y][0]);
gmt_init.c:	gmt_geo_to_xy (GMT, GMT->current.io.curr_rec[GMT_X], GMT->current.io.curr_rec[GMT_Y], &X[GMT_X][1], &X[GMT_Y][1]);
gmt_init.c:	gmt_geo_to_xy (GMT, GMT->current.io.prev_rec[GMT_X], GMT->current.io.prev_rec[GMT_Y], &X[GMT_X][0], &X[GMT_Y][0]);
gmt_init.c:	gmt_geo_to_xy (GMT, GMT->current.io.curr_rec[GMT_X], GMT->current.io.curr_rec[GMT_Y], &X[GMT_X][1], &X[GMT_Y][1]);
gmt_init.c:	gmt_geo_to_xy (GMT, GMT->current.io.prev_rec[GMT_X], GMT->current.io.prev_rec[GMT_Y], &X[GMT_X][0], &X[GMT_Y][0]);
gmt_init.c:	gmt_geo_to_xy (GMT, GMT->current.io.curr_rec[GMT_X], GMT->current.io.curr_rec[GMT_Y], &X[GMT_X][1], &X[GMT_Y][1]);
gmt_init.c:	return (gmtlib_cartesian_dist_proj (GMT, GMT->current.io.prev_rec[GMT_X], GMT->current.io.prev_rec[GMT_Y], GMT->current.io.curr_rec[GMT_X], GMT->current.io.curr_rec[GMT_Y]));
gmt_init.c:	return (gmtlib_great_circle_dist_degree (GMT, GMT->current.io.prev_rec[GMT_X], GMT->current.io.prev_rec[GMT_Y], GMT->current.io.curr_rec[GMT_X], GMT->current.io.curr_rec[GMT_Y]));
gmt_init.c:	return (gmt_great_circle_dist_meter (GMT, GMT->current.io.prev_rec[GMT_X], GMT->current.io.prev_rec[GMT_Y], GMT->current.io.curr_rec[GMT_X], GMT->current.io.curr_rec[GMT_Y]));
gmt_init.c:	return (gmtlib_cartesian_dist (GMT, GMT->current.io.prev_rec[GMT_X], GMT->current.io.prev_rec[GMT_Y], GMT->current.io.curr_rec[GMT_X], GMT->current.io.curr_rec[GMT_Y]));
gmt_init.c:	strncpy (GMT->common.n.string, item, GMT_LEN64-1);	/* Make copy of -n argument verbatim */
gmt_init.c:			GMT->common.n.interpolant = BCR_BICUBIC; k = 0; break;
gmt_init.c:			GMT->common.n.interpolant = BCR_NEARNEIGHBOR; break;
gmt_init.c:			GMT->common.n.interpolant = BCR_BILINEAR; break;
gmt_init.c:			GMT->common.n.interpolant = BCR_BSPLINE; break;
gmt_init.c:			GMT->common.n.interpolant = BCR_BICUBIC; break;
gmt_init.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Use %s to set 2-D grid interpolation mode.\n", GMT_n_OPT);
gmt_init.c:				GMT->common.n.antialias = false;
gmt_init.c:				GMT->common.n.bc_set = true;
gmt_init.c:				gmt_strncpy (GMT->common.n.BC, &p[1], 4U);
gmt_init.c:				for (j = 0; j < MIN (4,strlen (GMT->common.n.BC)); j++) {
gmt_init.c:					switch (GMT->common.n.BC[j]) {
gmt_init.c:							GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error -n: +b<BC> requires <BC> to be g or p[x|y], n[x|y]\n");
gmt_init.c:				GMT->common.n.truncate = true;
gmt_init.c:				GMT->common.n.threshold = atof (&p[1]);
gmt_init.c:				if (GMT->common.n.threshold < 0.0 || GMT->common.n.threshold > 1.0) {
gmt_init.c:					GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error -n: Interpolation threshold must be in [0,1] range\n");
gmt_init.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Use %s to set 2-D grid interpolation mode.\n", GMT_n_OPT);
gmt_init.c:	if (!GMT->common.J.active) {
gmt_init.c:		if (!GMT->common.J.active)
gmt_init.c:			GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning -p option works best in consort with -J (and -R or a grid)\n");
gmt_init.c:		case 'x': GMT->current.proj.z_project.view_plane = GMT_X + GMT_ZW; l++; break;
gmt_init.c:		case 'y': GMT->current.proj.z_project.view_plane = GMT_Y + GMT_ZW; l++;	break;
gmt_init.c:		case 'z': GMT->current.proj.z_project.view_plane = GMT_Z + GMT_ZW; l++; break;
gmt_init.c:		default: GMT->current.proj.z_project.view_plane  = GMT_Z + GMT_ZW; break;
gmt_init.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error in -p (%s): Syntax is %s\n", item, GMT_p_OPT);
gmt_init.c:	if (k == 1) { GMT->common.p.do_z_rotation = true; el = 90.0;}
gmt_init.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -p option: Elevation must be in 0-90 range\n");
gmt_init.c:						GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error in -p (%s): Syntax is %s\n", p, GMT_p_OPT);
gmt_init.c:					GMT->current.proj.z_project.view_x = gmt_M_to_inch (GMT, txt_a);
gmt_init.c:					GMT->current.proj.z_project.view_y = gmt_M_to_inch (GMT, txt_b);
gmt_init.c:					GMT->current.proj.z_project.view_given = true;
gmt_init.c:						GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error in -p (%s): Syntax is %s\n", p, GMT_p_OPT);
gmt_init.c:					error += gmt_verify_expectations (GMT, gmt_M_type (GMT, GMT_IN, GMT_X), gmt_scanf (GMT, txt_a, gmt_M_type (GMT, GMT_IN, GMT_X), &GMT->current.proj.z_project.world_x), txt_a);
gmt_init.c:					error += gmt_verify_expectations (GMT, gmt_M_type (GMT, GMT_IN, GMT_Y), gmt_scanf (GMT, txt_b, gmt_M_type (GMT, GMT_IN, GMT_Y), &GMT->current.proj.z_project.world_y), txt_b);
gmt_init.c:					if (k == 3) error += gmt_verify_expectations (GMT, gmt_M_type (GMT, GMT_IN, GMT_Z), gmt_scanf (GMT, txt_c, gmt_M_type (GMT, GMT_IN, GMT_Z), &GMT->current.proj.z_project.world_z), txt_c);
gmt_init.c:					GMT->current.proj.z_project.world_given = true;
gmt_init.c:		if (!GMT->common.p.do_z_rotation) GMT->current.proj.z_project.fixed = true;
gmt_init.c:		GMT->current.proj.z_project.view_azimuth   = az;
gmt_init.c:		GMT->current.proj.z_project.view_elevation = el;
gmt_init.c:		if (k == 3) GMT->current.proj.z_level      = z;
gmt_init.c:		GMT->common.p.z_rotation = az;
gmt_init.c:	gmt_M_memset (GMT->current.io.io_nan_col, GMT_MAX_COLUMNS, int);
gmt_init.c:	GMT->current.io.io_nan_col[0] = GMT_Z;	/* The default is to examine the z-column */
gmt_init.c:	GMT->current.io.io_nan_ncols = 1;		/* Default is that single z column */
gmt_init.c:	GMT->current.setting.io_nan_mode = GMT_IO_NAN_SKIP;	/* Plain -s */
gmt_init.c:	strncpy (GMT->common.s.string, item, GMT_LEN64-1);	/* Make copy of -n argument verbatim */
gmt_init.c:		GMT->current.setting.io_nan_mode = GMT_IO_NAN_ONE, c[0] = '\0';		/* Set -s+a */
gmt_init.c:		GMT->current.setting.io_nan_mode = GMT_IO_NAN_KEEP, c[0] = '\0';		/* Set -s+r */
gmt_init.c:	if (item[n-1] == 'a') GMT->current.setting.io_nan_mode = GMT_IO_NAN_ONE, n--;		/* Old syntax set -sa */
gmt_init.c:	else if (item[n-1] == 'r') GMT->current.setting.io_nan_mode = GMT_IO_NAN_KEEP, n--;	/* Old syntax set -sr */
gmt_init.c:	for (i = n = 0; i < GMT_MAX_COLUMNS; i++) if (tmp[i] != -1) GMT->current.io.io_nan_col[n++] = (unsigned int)i;
gmt_init.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -s option: Unable to decode columns from %s\n", item);
gmt_init.c:	GMT->current.io.io_nan_ncols = n;
gmt_init.c:	if (GMT->current.setting.ps_encoding.code[gmt_ring] == 32 && GMT->current.setting.ps_encoding.code[gmt_degree] == 32) {	/* Neither /ring or /degree encoded */
gmt_init.c:	else if (GMT->current.setting.map_degree_symbol == gmt_ring && GMT->current.setting.ps_encoding.code[gmt_ring] == 32) {		/* want /ring but only /degree is encoded */
gmt_init.c:		GMT->current.setting.map_degree_symbol = gmt_degree;
gmt_init.c:	else if (GMT->current.setting.map_degree_symbol == gmt_degree && GMT->current.setting.ps_encoding.code[gmt_degree] == 32) {	/* want /degree but only /ring is encoded */
gmt_init.c:		GMT->current.setting.map_degree_symbol = gmt_ring;
gmt_init.c:	if (GMT->current.setting.map_degree_symbol < 2 && GMT->current.setting.ps_encoding.code[gmt_squote] == 32) {
gmt_init.c:	if (GMT->current.setting.map_degree_symbol < 2 && GMT->current.setting.ps_encoding.code[gmt_dquote] == 32) {
gmt_init.c:	GMT->current.map.frame.set_frame[part]++;
gmt_init.c:	if (GMT->current.map.frame.set_frame[GMT_PRIMARY] > 1 || GMT->current.map.frame.set_frame[GMT_SECONDARY] > 1) {
gmt_init.c:		GMT_Report (GMT->parent, GMT_MSG_COMPAT, "Error -B: <WESNZ-framesettings> given more than once!\n");
gmt_init.c:	for (i = 0; i < GMT_MAX_COLUMNS; i++) if (GMT->current.io.o_format[i])
gmt_init.c:		gmt_M_str_free (GMT->current.io.o_format[i]);
gmt_init.c:	strncpy (GMT->current.setting.format_float_out_orig, value, GMT_LEN256-1);
gmt_init.c:					GMT->current.io.o_format[k] = strdup (p);
gmt_init.c:		strncpy (GMT->current.setting.format_float_out, GMT->current.io.o_format[col], GMT_LEN64-1);
gmt_init.c:			GMT->current.io.o_format[k++] = strdup (fmt);
gmt_init.c:		if (k) strncpy (GMT->current.setting.format_float_out, GMT->current.io.o_format[k-1], GMT_LEN64-1);
gmt_init.c:		strncpy (GMT->current.setting.format_float_out, value, GMT_LEN64-1);
gmt_init.c:	GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error: Unrecognized keyword %s. You may have been using a deprecated GMT3 or GMT4 keyword.\nChange keyword or use with GMT_COMPATIBILITY=4. " GMT_COMPAT_INFO, keyword);
gmt_init.c:		fpo = GMT->session.std[GMT_OUT];
gmt_init.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Could not create file %s\n", file);
gmt_init.c:	if (fpo != GMT->session.std[GMT_OUT]) fclose (fpo);
gmt_init.c:	GMT->session.n_shorthands = 0; /* By default there are no shorthands unless gmt.io is found */
gmt_init.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error decoding file %s.  Bad format? [%s]\n", file, line);
gmt_init.c:			GMT->session.shorthand = gmt_M_malloc (GMT, GMT->session.shorthand, n, &n_alloc, struct GMT_SHORTHAND);
gmt_init.c:		GMT->session.shorthand[n].suffix = strdup (a);
gmt_init.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Unknown shorthand format [%s]\n", file, b);
gmt_init.c:		GMT->session.shorthand[n].format = strdup (line);
gmt_init.c:	n_alloc = GMT->session.n_shorthands = n;
gmt_init.c:	GMT->session.shorthand = gmt_M_malloc (GMT, GMT->session.shorthand, 0, &n_alloc, struct GMT_SHORTHAND);
gmt_init.c:	if (GMT->session.n_shorthands == 0)
gmt_init.c:	for (i = 0; i < GMT->session.n_shorthands; ++i) {
gmt_init.c:		gmt_M_str_free (GMT->session.shorthand[i].suffix);
gmt_init.c:		gmt_M_str_free (GMT->session.shorthand[i].format);
gmt_init.c:	gmt_M_free (GMT, GMT->session.shorthand);
gmt_init.c:	if (!(GMT->current.setting.history & GMT_HISTORY_READ))
gmt_init.c:	GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Enter: gmt_get_history\n");
gmt_init.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Unable to determine current working directory.\n");
gmt_init.c:	if (GMT->current.setting.run_mode == GMT_MODERN) {	/* Modern mode: Use the workflow directory and one history per figure */
gmt_init.c:		gmt_history_tag (GMT->parent, tag);
gmt_init.c:		snprintf (hfile, PATH_MAX, "%s/%s.%s", GMT->parent->gwf_dir, GMT_HISTORY_FILE, tag);
gmt_init.c:	else if (GMT->session.TMPDIR)			/* Isolation mode: Use GMT->session.TMPDIR/gmt.history */
gmt_init.c:		snprintf (hfile, PATH_MAX, "%s/%s", GMT->session.TMPDIR, GMT_HISTORY_FILE);
gmt_init.c:	else if (GMT->session.HOMEDIR)	/* Try home directory instead */
gmt_init.c:		snprintf (hfile, PATH_MAX, "%s/%s", GMT->session.HOMEDIR, GMT_HISTORY_FILE);
gmt_init.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "No writable directory found for gmt history - skipping it.\n");
gmt_init.c:				GMT->current.ps.clip_level = atoi (value);
gmt_init.c:				GMT->current.ps.layer = atoi (value);
gmt_init.c:		if (GMT->init.history[id])
gmt_init.c:			gmt_M_str_free (GMT->init.history[id]);
gmt_init.c:		GMT->init.history[id] = strdup (value);
gmt_init.c:	GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Exit:  gmt_get_history\n");
gmt_init.c:	if (!(GMT->current.setting.history & GMT_HISTORY_WRITE)) {
gmt_init.c:		if (GMT->current.setting.run_mode == GMT_MODERN && GMT->current.setting.history == GMT_HISTORY_OFF)
gmt_init.c:			GMT->current.setting.history = GMT->current.setting.history_orig;
gmt_init.c:		if (GMT->init.history[id]) empty = false;	/* Have something to write */
gmt_init.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Unable to determine current working directory.\n");
gmt_init.c:	if (GMT->current.setting.run_mode == GMT_MODERN) {	/* Modern mode: Use the workflow directory */
gmt_init.c:		gmt_history_tag (GMT->parent, tag);
gmt_init.c:		snprintf (hfile, PATH_MAX, "%s/%s.%s", GMT->parent->gwf_dir, GMT_HISTORY_FILE, tag);
gmt_init.c:	else if (GMT->session.TMPDIR)			/* Classic isolation mode: Use GMT->session.TMPDIR/gmt.history */
gmt_init.c:		snprintf (hfile, PATH_MAX, "%s/%s", GMT->session.TMPDIR, GMT_HISTORY_FILE);
gmt_init.c:	else if (GMT->session.HOMEDIR)	/* Try home directory instead */
gmt_init.c:		snprintf (hfile, PATH_MAX, "%s/%s", GMT->session.HOMEDIR, GMT_HISTORY_FILE);
gmt_init.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Unable to determine a writeable directory - gmt history not updated.\n");
gmt_init.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Directory %s is not locked for exclusive access. Multiple gmt processes running at once could corrupt history file.\n", hfile);
gmt_init.c:		if (!GMT->init.history[id]) continue;	/* Not specified */
gmt_init.c:		fprintf (fp, "%s\t%s\n", GMT_unique_option[id], GMT->init.history[id]);
gmt_init.c:	if (GMT->current.ps.clip_level) fprintf (fp, "@C\t%d\n", GMT->current.ps.clip_level); /* Write clip level */
gmt_init.c:	if (GMT->current.ps.layer) fprintf (fp, "@L\t%d\n", GMT->current.ps.layer); /* Write PS layer, if non-zero */
gmt_init.c:		if (GMT->init.history[id]) gmt_M_str_free (GMT->init.history[id]);
gmt_init.c:	if (GMT->current.plot.n_alloc) {
gmt_init.c:		gmt_M_free (GMT, GMT->current.plot.x);
gmt_init.c:		gmt_M_free (GMT, GMT->current.plot.y);
gmt_init.c:		gmt_M_free (GMT, GMT->current.plot.pen);
gmt_init.c:	GMT->current.plot.n = GMT->current.plot.n_alloc = 0;
gmt_init.c:	struct GMTAPI_CTRL *API = GMT->parent;
gmt_init.c:	bool running_in_bindir_src = !strncmp (GMT->init.runtime_bindir, GMT_BINARY_DIR_SRC_DEBUG, strlen(GMT_BINARY_DIR_SRC_DEBUG));
gmt_init.c:	/* Determine GMT->session.SHAREDIR (directory containing coast, cpt, etc. subdirectories) */
gmt_init.c:		GMT->session.SHAREDIR = strdup (this_c);
gmt_init.c:		GMT->session.SHAREDIR = strdup (this_c);
gmt_init.c:		GMT->session.SHAREDIR = strdup (this_c);
gmt_init.c:		GMT->session.SHAREDIR = strdup (GMT_SHARE_DIR_DEBUG);
gmt_init.c:		GMT->session.SHAREDIR = strdup (GMT_SHARE_DIR);
gmt_init.c:		if (gmt_guess_sharedir (path, GMT->init.runtime_bindir))
gmt_init.c:			GMT->session.SHAREDIR = strdup (path);
gmt_init.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error: Could not locate share directory for GMT.\n");
gmt_init.c:	gmt_dos_path_fix (GMT->session.SHAREDIR);
gmt_init.c:	trim_off_any_slash_at_end (GMT->session.SHAREDIR);
gmt_init.c:	GMT_Report (API, GMT_MSG_DEBUG, "GMT->session.SHAREDIR = %s\n", GMT->session.SHAREDIR);
gmt_init.c:		GMT->session.HOMEDIR = strdup (this_c);
gmt_init.c:		GMT->session.HOMEDIR = strdup (this_c);
gmt_init.c:		GMT->session.HOMEDIR = strdup (this_c);
gmt_init.c:		GMT->session.HOMEDIR = strdup ("/"); /* Note: Windows will use the current drive if drive letter unspecified. */
gmt_init.c:	if (GMT->session.HOMEDIR) {	/* Mostly to keep Coverity happy */
gmt_init.c:		gmt_dos_path_fix (GMT->session.HOMEDIR);
gmt_init.c:		trim_off_any_slash_at_end (GMT->session.HOMEDIR);
gmt_init.c:		GMT_Report (API, GMT_MSG_DEBUG, "GMT->session.HOMEDIR = %s\n", GMT->session.HOMEDIR);
gmt_init.c:		GMT->session.USERDIR = strdup (this_c);
gmt_init.c:	else if (GMT->session.HOMEDIR) {	/* Use default path for GMT_USERDIR (~/.gmt) */
gmt_init.c:		snprintf (path, PATH_MAX, "%s/%s", GMT->session.HOMEDIR, ".gmt");
gmt_init.c:		GMT->session.USERDIR = strdup (path);
gmt_init.c:	if (GMT->session.USERDIR) {
gmt_init.c:		gmt_dos_path_fix (GMT->session.USERDIR);
gmt_init.c:		trim_off_any_slash_at_end (GMT->session.USERDIR);
gmt_init.c:	if (GMT->session.USERDIR != NULL) {
gmt_init.c:		err = stat (GMT->session.USERDIR, &S);	/* Stat the userdir path (which may not exist) */
gmt_init.c:		if (err == ENOENT && gmt_mkdir (GMT->session.USERDIR)) { /* Path does not exist so we create that dir */
gmt_init.c:			GMT_Report (API, GMT_MSG_NORMAL, "Unable to create GMT User directory : %s\n", GMT->session.USERDIR);
gmt_init.c:			GMT->current.setting.auto_download = GMT_NO_DOWNLOAD;
gmt_init.c:			gmt_M_str_free (GMT->session.USERDIR);
gmt_init.c:		GMT->session.CACHEDIR = strdup (this_c);
gmt_init.c:	else if (GMT->session.USERDIR != NULL) {	/* Use default path for GMT_CACHEDIR as GMT_USERDIR/cache */
gmt_init.c:		snprintf (path, PATH_MAX, "%s/%s", GMT->session.USERDIR, "cache");
gmt_init.c:		GMT->session.CACHEDIR = strdup (path);
gmt_init.c:	if (GMT->session.CACHEDIR) {
gmt_init.c:		gmt_dos_path_fix (GMT->session.CACHEDIR);
gmt_init.c:		trim_off_any_slash_at_end (GMT->session.CACHEDIR);
gmt_init.c:	if (GMT->session.CACHEDIR != NULL) {
gmt_init.c:		err = stat (GMT->session.CACHEDIR, &S);	/* Stat the cachedir path (which may not exist) */
gmt_init.c:		if (err == ENOENT && gmt_mkdir (GMT->session.CACHEDIR)) {	/* Path does not exist so we create that dir */
gmt_init.c:			GMT_Report (API, GMT_MSG_NORMAL, "Unable to create GMT User cache directory : %s\n", GMT->session.CACHEDIR);
gmt_init.c:			GMT->current.setting.auto_download = GMT_NO_DOWNLOAD;
gmt_init.c:			gmt_M_str_free (GMT->session.CACHEDIR);
gmt_init.c:	else if (GMT->session.USERDIR != NULL) {	/* Use GMT_USERDIR/sessions as default path for GMT_SESSIONDIR */
gmt_init.c:		snprintf (path, PATH_MAX, "%s/%s", GMT->session.USERDIR, "sessions");
gmt_init.c:	if (GMT->session.USERDIR)  GMT_Report (API, GMT_MSG_DEBUG, "GMT->session.USERDIR = %s [%s]\n",  GMT->session.USERDIR,  how[u]);
gmt_init.c:	if (GMT->session.CACHEDIR) GMT_Report (API, GMT_MSG_DEBUG, "GMT->session.CACHEDIR = %s [%s]\n", GMT->session.CACHEDIR, how[c]);
gmt_init.c:			GMT_Report (API, GMT_MSG_VERBOSE, "System-wide color tables are in %s/cpt.\n", GMT->session.SHAREDIR);
gmt_init.c:			GMT_Report (API, GMT_MSG_VERBOSE, "Use GMT_USERDIR (%s) instead and place user-defined color tables there.\n", GMT->session.USERDIR);
gmt_init.c:		GMT->session.DATASERVER = strdup (this_c);
gmt_init.c:		GMT->session.DATASERVER = strdup (this_c);
gmt_init.c:		GMT->session.DATASERVER = strdup (GMT_DATA_SERVER);	/* SOEST default */
gmt_init.c:	if (GMT->session.DATASERVER)
gmt_init.c:		trim_off_any_slash_at_end (GMT->session.DATASERVER);
gmt_init.c:			GMT->session.DATADIR = strdup (this_c);
gmt_init.c:			gmt_dos_path_fix (GMT->session.DATADIR);
gmt_init.c:			GMT->session.DATADIR = strdup(this_c);
gmt_init.c:			gmt_dos_path_fix (GMT->session.DATADIR);
gmt_init.c:		gmt_replace_backslash_in_path (GMT->session.DATADIR);
gmt_init.c:		gmt_strrepc (GMT->session.DATADIR, PATH_SEPARATOR, ',');	/* Use comma for OS-independent separator */
gmt_init.c:			GMT->session.TMPDIR = NULL;
gmt_init.c:			GMT->session.TMPDIR = strdup (this_c);
gmt_init.c:			gmt_dos_path_fix (GMT->session.TMPDIR);
gmt_init.c:			trim_off_any_slash_at_end (GMT->session.TMPDIR);
gmt_init.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Missing terminating colon in -B string %c-component %s\n", str[axis], in);
gmt_init.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "More than one title in -B string %c-component %s\n", str[axis], in);
gmt_init.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "More than one unit string in -B %c-component %s\n", str[axis], in);
gmt_init.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "More than one prefix string in  -B component %s\n", in);
gmt_init.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "More than one label string in  -B component %s\n", in);
gmt_init.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error splitting -B string %s\n", in);
gmt_init.c:		GMT->current.map.frame.set_both = true;
gmt_init.c:	save_coltype = GMT->current.io.col_type[GMT_IN][GMT_X];
gmt_init.c:	save_trailing = GMT->current.io.trailing_text[GMT_IN];
gmt_init.c:	save_max_cols_to_read = GMT->current.io.max_cols_to_read;
gmt_init.c:	GMT->current.io.col_type[GMT_IN][GMT_X] = gmt_M_type (GMT, GMT_IN, A->id);
gmt_init.c:	GMT->current.io.record_type[GMT_IN] = GMT_READ_MIXED;
gmt_init.c:	GMT->current.io.trailing_text[GMT_IN] = true;
gmt_init.c:	if ((error = GMT_Set_Columns (GMT->parent, GMT_IN, 1, GMT_COL_FIX)) != GMT_NOERROR) return (1);
gmt_init.c:	if ((D = GMT_Read_Data (GMT->parent, GMT_IS_DATASET, GMT_IS_FILE, GMT_IS_NONE, GMT_READ_NORMAL, NULL, A->file_custom, NULL)) == NULL) {
gmt_init.c:		GMT->current.io.col_type[GMT_IN][GMT_X] = save_coltype;
gmt_init.c:	GMT->current.io.col_type[GMT_IN][GMT_X] = save_coltype;
gmt_init.c:	GMT->current.io.trailing_text[GMT_IN] = save_trailing;
gmt_init.c:	GMT->current.io.max_cols_to_read = save_max_cols_to_read;
gmt_init.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Bad format record [%s] at row %d in custom file %s.\n", S->text[row], (int)row, A->file_custom);
gmt_init.c:					GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Unrecognized type (%c) at row %d in custom file %s.\n", type[k], (int)row, A->file_custom);
gmt_init.c:	GMT_Destroy_Data (GMT->parent, &D);
gmt_init.c:	GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Processed custom annotations via %s for axis %d.\n", A->file_custom, A->id);
gmt_init.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Cannot mix interval and regular annotations in custom file %s.\n", A->file_custom);
gmt_init.c:		if ((val = strtod (t, &s)) < 0.0 && GMT->current.proj.xyz_projection[A->id] != GMT_LOG10) {	/* Interval must be >= 0 */
gmt_init.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Negative interval in -B option (%c-component, %c-info): %s\n", axis, flag, in);
gmt_init.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Bad interval in -B option (%c-component, %c-info): %s gave interval = 0\n", axis, flag, in);
gmt_init.c:		unit = (A->special == GMT_CUSTOM) ? 's' : GMT->current.setting.time_system.unit;
gmt_init.c:	if (!GMT->current.map.frame.primary) flag = (char) toupper ((int)flag);
gmt_init.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Time step interval (%g) must be an integer\n", val);
gmt_init.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Bad flag (%c) passed to gmtinit_set_titem\n", flag);
gmt_init.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Axis sub-item %c set more than once (typo?)\n", flag);
gmt_init.c:			GMT_Report (GMT->parent, GMT_MSG_COMPAT, "Unit c (arcseconds) is deprecated; use s instead.\n");
gmt_init.c:			GMT_Report (GMT->parent, GMT_MSG_COMPAT, "Unit %c not recognized.\n", unit);
gmt_init.c:	format = (GMT->current.map.frame.primary) ? GMT->current.setting.format_time[GMT_PRIMARY] : GMT->current.setting.format_time[GMT_SECONDARY];
gmt_init.c:	GMT->current.map.frame.draw = true;
gmt_init.c:	if (axis == 'z') GMT->current.map.frame.drawz = true;
gmt_init.c:				if (!GMT->current.map.frame.primary) flag = (char)toupper ((int)flag);
gmt_init.c:			if (n_int[1]) A->item[GMT_ANNOT_UPPER+!GMT->current.map.frame.primary].special = true;
gmt_init.c:			GMT->current.map.frame.draw = true;
gmt_init.c:			if (axis == GMT_Z) GMT->current.map.frame.drawz = true;
gmt_init.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Cannot access custom file in -B string %c-component %s\n", str[axis], &in[1]);
gmt_init.c:			GMT->current.map.frame.primary = false; k = part = 1; break;
gmt_init.c:			GMT->current.map.frame.primary = true; k = 1; break;
gmt_init.c:			GMT->current.map.frame.primary = true; k = 0; break;
gmt_init.c:	i = (GMT->current.map.frame.primary) ? 0 : 1;
gmt_init.c:	strncpy (GMT->common.B.string[i], in, GMT_LEN256-1);	/* Keep a copy of the actual option(s) */
gmt_init.c:	/* GMT->current.map.frame.side[] may be set already when parsing gmt.conf flags */
gmt_init.c:	if (!GMT->current.map.frame.init) {	/* First time we initialize stuff */
gmt_init.c:			gmt_M_memset (&GMT->current.map.frame.axis[i], 1, struct GMT_PLOT_AXIS);
gmt_init.c:			GMT->current.map.frame.axis[i].id = i;
gmt_init.c:			for (j = 0; j < 6; j++) GMT->current.map.frame.axis[i].item[j].parent = i;
gmt_init.c:			if (GMT->current.proj.xyz_projection[i] == GMT_TIME) GMT->current.map.frame.axis[i].type = GMT_TIME;
gmt_init.c:		GMT->current.map.frame.header[0] = '\0';
gmt_init.c:		GMT->current.map.frame.init = true;
gmt_init.c:		GMT->current.map.frame.draw = false;
gmt_init.c:		GMT->current.map.frame.set_frame[GMT_PRIMARY] = GMT->current.map.frame.set_frame[GMT_SECONDARY] = 0;
gmt_init.c:	for (i = (int)strlen(in) - 1, ignore = false; !GMT->current.map.frame.paint && !error && i >= 0; i--) {	/** Look for +g<fill */
gmt_init.c:			if (GMT->current.proj.projection_GMT == GMT_OBLIQUE_MERC) {
gmt_init.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -B option: Cannot specify oblique gridlines for the oblique Mercator projection\n");
gmt_init.c:			GMT->current.map.frame.obl_grid = true;
gmt_init.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -B option: Did not find the expected format +o<plon>/<plat>\n");
gmt_init.c:			if (GMT->current.proj.projection_GMT != GMT_OBLIQUE_MERC) gmtlib_set_oblique_pole_and_origin (GMT, lon, lat, 0.0, 0.0);
gmt_init.c:			if (gmt_getfill (GMT, out1, &GMT->current.map.frame.fill)) error++;
gmt_init.c:				GMT->current.map.frame.paint = true;
gmt_init.c:	error += gmtinit_strip_colonitem (GMT, 0, &in[k], ":.", GMT->current.map.frame.header, out1);	/* Extract header string, if any */
gmt_init.c:	gmtlib_enforce_rgb_triplets (GMT, GMT->current.map.frame.header, GMT_LEN256);	/* If @; is used, make sure the color information passed on to ps_text is in r/b/g format */
gmt_init.c:	i = gmtinit_decode4_wesnz (GMT, out1, GMT->current.map.frame.side, &GMT->current.map.frame.draw_box, part);		/* Decode WESNZwesnz+ flags, if any */
gmt_init.c:			GMT->current.map.frame.draw = true;
gmt_init.c:			if (i == GMT_Z) GMT->current.map.frame.drawz = true;
gmt_init.c:		error += gmtinit_strip_colonitem (GMT, i, info[i], ":,", GMT->current.map.frame.axis[i].unit, out1);	/* Pull out annotation unit, if any */
gmt_init.c:		error += gmtinit_strip_colonitem (GMT, i, out1, ":=", GMT->current.map.frame.axis[i].prefix, out2);	/* Pull out annotation prefix, if any */
gmt_init.c:		error += gmtinit_strip_colonitem (GMT, i, out2, ":", GMT->current.map.frame.axis[i].label, out3);	/* Pull out axis label, if any */
gmt_init.c:		gmtinit_handle_atcolon (GMT, GMT->current.map.frame.axis[i].label, 1);	/* Restore any @^ to @: */
gmt_init.c:		gmtinit_handle_atcolon (GMT, GMT->current.map.frame.axis[i].prefix, 1);	/* Restore any @^ to @: */
gmt_init.c:		gmtinit_handle_atcolon (GMT, GMT->current.map.frame.axis[i].unit, 1);	/* Restore any @^ to @: */
gmt_init.c:		if (GMT->current.map.frame.axis[i].prefix[0]) {	/* Deal with space/no space before prefix */
gmt_init.c:			if (GMT->current.map.frame.axis[i].prefix[0] == '-') /* Don't want a space */
gmt_init.c:				strncpy (workspace, &GMT->current.map.frame.axis[i].prefix[1], GMT_LEN64-1);
gmt_init.c:				strncpy (&workspace[1], GMT->current.map.frame.axis[i].prefix, GMT_LEN64-1);
gmt_init.c:			gmt_M_memcpy (GMT->current.map.frame.axis[i].prefix, workspace, GMT_LEN64, char);
gmt_init.c:		if (GMT->current.map.frame.axis[i].unit[0]) {	/* Deal with space/no space before unit */
gmt_init.c:			if (GMT->current.map.frame.axis[i].unit[0] == '-') /* Don't want a space */
gmt_init.c:				strncpy (workspace, &GMT->current.map.frame.axis[i].unit[1], GMT_LEN64-1);
gmt_init.c:				strncpy (&workspace[1], GMT->current.map.frame.axis[i].unit, GMT_LEN64-1);
gmt_init.c:			gmt_M_memcpy (GMT->current.map.frame.axis[i].unit, workspace, GMT_LEN64, char);
gmt_init.c:		GMT->current.map.frame.set = true;	/* Got here so we are setting intervals */
gmt_init.c:			error += gmtinit_decode_tinfo (GMT, i, 'c', out3, &GMT->current.map.frame.axis[i]);
gmt_init.c:					error += gmtinit_decode_tinfo (GMT, i, out3[k], &out3[k+1], &GMT->current.map.frame.axis[i]);
gmt_init.c:					error += gmtinit_decode_tinfo (GMT, i, 'a', out3, &GMT->current.map.frame.axis[i]);
gmt_init.c:		A = &GMT->current.map.frame.axis[i];
gmt_init.c:	if (GMT->current.proj.projection_GMT == GMT_LINEAR && GMT->current.setting.map_degree_symbol != gmt_none) {
gmt_init.c:			if (gmt_M_type (GMT, GMT_IN, i) & GMT_IS_GEO && GMT->current.map.frame.axis[i].unit[0] == 0) {
gmt_init.c:				GMT->current.map.frame.axis[i].unit[0] = '-';
gmt_init.c:				GMT->current.map.frame.axis[i].unit[1] = (char)GMT->current.setting.ps_encoding.code[GMT->current.setting.map_degree_symbol];
gmt_init.c:				GMT->current.map.frame.axis[i].unit[2] = '\0';
gmt_init.c:		GMT->current.map.frame.set_frame[GMT_PRIMARY]++, GMT->current.map.frame.set_frame[GMT_SECONDARY]++;
gmt_init.c:		if (GMT->current.map.frame.set_frame[GMT_PRIMARY] > 1 || GMT->current.map.frame.set_frame[GMT_SECONDARY] > 1) {
gmt_init.c:			GMT_Report (GMT->parent, GMT_MSG_COMPAT, "Error -B: <WESNZ-framesettings> given more than once!\n");
gmt_init.c:					GMT->current.map.frame.draw_box = true;
gmt_init.c:					GMT->current.map.frame.no_frame = true;
gmt_init.c:					GMT_Report (GMT->parent, GMT_MSG_COMPAT, "Modifier + in MAP_FRAME_AXES is deprecated; use +b instead.\n");
gmt_init.c:					GMT->current.map.frame.draw_box = true;
gmt_init.c:					GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Modifier + in MAP_FRAME_AXES not recognized.\n");
gmt_init.c:		gmt_M_memcpy (GMT->current.map.frame.side, f_side, 5, unsigned int);	/* Overwrite the GMT defaults */
gmt_init.c:		GMT->current.map.frame.no_frame = false;
gmt_init.c:		GMT->current.map.frame.draw = true;
gmt_init.c:		if (check && f_side[Z_SIDE]) GMT->current.map.frame.drawz = true;
gmt_init.c:	if (GMT->current.map.frame.no_frame) gmt_M_memset (GMT->current.map.frame.side, 5, unsigned int);	/* Set all to nothing */
gmt_init.c:	if (z_axis[0] || z_axis[1] || z_axis[2] || z_axis[3]) gmt_M_memcpy (GMT->current.map.frame.z_axis, z_axis, 4, unsigned int);	/* Overwrite the GMT defaults */
gmt_init.c:	GMT->current.map.frame.header[0] = '\0';
gmt_init.c:					GMT->current.map.frame.draw_box = true;
gmt_init.c:					if (p[1] == 0 || gmt_getfill (GMT, &p[1], &GMT->current.map.frame.fill)) {
gmt_init.c:						GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Bad +g<fill> argument %s\n", &p[1]);
gmt_init.c:					GMT->current.map.frame.paint = true;
gmt_init.c:					GMT->current.map.frame.no_frame = true;
gmt_init.c:					if (GMT->current.proj.projection_GMT == GMT_OBLIQUE_MERC) {
gmt_init.c:						GMT_Report (GMT->parent, GMT_MSG_NORMAL,
gmt_init.c:					else if (!p[1] || (k = GMT_Get_Values (GMT->parent, &p[1], pole, 2)) != 2) {
gmt_init.c:						GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Bad +o[<plon>/<plat>] argument %s\n", &p[1]);
gmt_init.c:						GMT->current.map.frame.obl_grid = true;
gmt_init.c:						strncpy (GMT->current.map.frame.header, &p[1], GMT_LEN256-1);
gmt_init.c:						gmt_handle5_plussign (GMT, GMT->current.map.frame.header, NULL, 1);	/* Recover any non-modifier plus signs */
gmt_init.c:						gmtlib_enforce_rgb_triplets (GMT, GMT->current.map.frame.header, GMT_LEN256);	/* If @; is used, make sure the color information passed on to ps_text is in r/b/g format */
gmt_init.c:					GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -B option: Unrecognized frame modifier %s\n", p);
gmt_init.c:		gmt_M_memset (&GMT->current.map.frame.axis[no], 1, struct GMT_PLOT_AXIS);
gmt_init.c:		GMT->current.map.frame.axis[no].id = no;
gmt_init.c:		for (k = 0; k < 6; k++) GMT->current.map.frame.axis[no].item[k].parent = no;
gmt_init.c:		if (GMT->current.proj.xyz_projection[no] == GMT_TIME) GMT->current.map.frame.axis[no].type = GMT_TIME;
gmt_init.c:	GMT->common.B.string[0][0] = GMT->common.B.string[1][0] = '\0';
gmt_init.c:	GMT->current.map.frame.init = true;
gmt_init.c:	GMT->current.map.frame.draw = false;
gmt_init.c:	GMT->current.map.frame.set_frame[GMT_PRIMARY] = GMT->current.map.frame.set_frame[GMT_SECONDARY] = 0;
gmt_init.c:	if (!GMT->current.map.frame.init)	/* First time we initialize stuff */
gmt_init.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -B option: Found frame setting modifiers (+b|g|n|o|p) mixed with axes settings!\n");
gmt_init.c:		case 's': GMT->current.map.frame.primary = false; k = 1; break;
gmt_init.c:		case 'p': GMT->current.map.frame.primary = true;  k = 1; break;
gmt_init.c:		default:  GMT->current.map.frame.primary = true;  k = 0; break;
gmt_init.c:	no = (GMT->current.map.frame.primary) ? 0 : 1;
gmt_init.c:	if (GMT->common.B.string[no][0]) {	/* Append this option */
gmt_init.c:		strcat (GMT->common.B.string[no], group_sep);
gmt_init.c:		strncat (GMT->common.B.string[no], in, GMT_LEN256-1);
gmt_init.c:		strncpy (GMT->common.B.string[no], in, GMT_LEN256-1);	/* Keep a copy of the actual option(s) */
gmt_init.c:	if (!(side[GMT_X] || side[GMT_Y] || side[GMT_Z])) GMT->current.map.frame.set_both = side[GMT_X] = side[GMT_Y] = implicit = true;	/* If no axis were named we default to both x and y */
gmt_init.c:		if (no == GMT_Z) GMT->current.map.frame.drawz = true;
gmt_init.c:			GMT->current.map.frame.draw = GMT->current.map.frame.drawz = true;	/* But we do wish to draw the frame */
gmt_init.c:							GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -B option: Cannot use +a for geographic basemaps\n");
gmt_init.c:								GMT->current.map.frame.axis[no].angle = 90.0;
gmt_init.c:								GMT->current.map.frame.axis[no].angle = 0.0;
gmt_init.c:								GMT->current.map.frame.axis[no].angle = atof (&p[1]);
gmt_init.c:							if (GMT->current.map.frame.axis[no].angle < -90.0 || GMT->current.map.frame.axis[no].angle > 90.0) {
gmt_init.c:								GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -B option: +a<angle> must be in the -90 to +90 range\n");
gmt_init.c:								GMT->current.map.frame.axis[no].use_angle = true;
gmt_init.c:							GMT->current.map.frame.axis[no].use_angle = true;
gmt_init.c:								GMT->current.map.frame.axis[no].angle = 0.0;
gmt_init.c:								GMT->current.map.frame.axis[no].angle = 90.0;
gmt_init.c:								GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -B option: Only modifiers +an|p is allowed for the y-axis\n");
gmt_init.c:								GMT->current.map.frame.axis[no].use_angle = false;
gmt_init.c:							GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "-B option: The +a modifier only applies to the x and y axes; selection for %c-axis ignored\n", the_axes[no]);
gmt_init.c:						GMT->current.map.frame.axis[no].label_mode = 1;
gmt_init.c:							GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -B option: No axis label given after +l|L\n");
gmt_init.c:							strncpy (GMT->current.map.frame.axis[no].label, &p[1], GMT_LEN256-1);
gmt_init.c:							gmt_handle5_plussign (GMT, GMT->current.map.frame.axis[no].label, NULL, 1);	/* Recover any non-modifier plus signs */
gmt_init.c:							gmtlib_enforce_rgb_triplets (GMT, GMT->current.map.frame.axis[no].label, GMT_LEN256);	/* If @; is used, make sure the color information passed on to ps_text is in r/b/g format */
gmt_init.c:							GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -B option: No annotation prefix given after +p\n");
gmt_init.c:							strncpy (GMT->current.map.frame.axis[no].prefix, &p[1], GMT_LEN64-1);
gmt_init.c:							gmt_handle5_plussign (GMT, GMT->current.map.frame.axis[no].prefix, NULL, 1);	/* Recover any non-modifier plus signs */
gmt_init.c:							gmtlib_enforce_rgb_triplets (GMT, GMT->current.map.frame.axis[no].prefix, GMT_LEN256);	/* If @; is used, make sure the color information passed on to ps_text is in r/b/g format */
gmt_init.c:						GMT->current.map.frame.axis[no].label_mode = 1;
gmt_init.c:							GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -B option: No secondary axis label given after +s|S\n");
gmt_init.c:							strncpy (GMT->current.map.frame.axis[no].secondary_label, &p[1], GMT_LEN256-1);
gmt_init.c:							gmt_handle5_plussign (GMT, GMT->current.map.frame.axis[no].secondary_label, NULL, 1);	/* Recover any non-modifier plus signs */
gmt_init.c:							gmtlib_enforce_rgb_triplets (GMT, GMT->current.map.frame.axis[no].secondary_label, GMT_LEN256);	/* If @; is used, make sure the color information passed on to ps_text is in r/b/g format */
gmt_init.c:							GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -B option: No annotation suffix given after +u\n");
gmt_init.c:							strncpy (GMT->current.map.frame.axis[no].unit, &p[1], GMT_LEN64-1);
gmt_init.c:							gmt_handle5_plussign (GMT, GMT->current.map.frame.axis[no].unit, NULL, 1);	/* Recover any non-modifier plus signs */
gmt_init.c:							gmtlib_enforce_rgb_triplets (GMT, GMT->current.map.frame.axis[no].unit, GMT_LEN256);	/* If @; is used, make sure the color information passed on to ps_text is in r/b/g format */
gmt_init.c:						GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -B option: Unrecognized axis modifier %s\n", p);
gmt_init.c:		GMT->current.map.frame.set = true;	/* Got here so we are setting intervals */
gmt_init.c:		if (strstr (orig_string, "pi")) GMT->current.map.frame.axis[no].substitute_pi = true;	/* Use pi in formatting labels */
gmt_init.c:			error += gmtinit_decode_tinfo (GMT, no, 'c', string, &GMT->current.map.frame.axis[no]);
gmt_init.c:					error += gmtinit_decode_tinfo (GMT, no, string[k], &string[k+1], &GMT->current.map.frame.axis[no]);
gmt_init.c:					error += gmtinit_decode_tinfo (GMT, no, 'a', string, &GMT->current.map.frame.axis[no]);
gmt_init.c:		A = &GMT->current.map.frame.axis[no];
gmt_init.c:	if (GMT->current.proj.projection_GMT == GMT_LINEAR && GMT->current.setting.map_degree_symbol != gmt_none) {
gmt_init.c:			if (gmt_M_type (GMT, GMT_IN, no) & GMT_IS_GEO && GMT->current.map.frame.axis[no].unit[0] == 0) {
gmt_init.c:				GMT->current.map.frame.axis[no].unit[0] = (char)GMT->current.setting.ps_encoding.code[GMT->current.setting.map_degree_symbol];
gmt_init.c:				GMT->current.map.frame.axis[no].unit[1] = '\0';
gmt_init.c:	if (GMT->common.B.mode == 0) {
gmt_init.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Internal error: Calling gmtlib_parse_B_option before gmt_check_b_options somehow\n");
gmt_init.c:	else if (GMT->common.B.mode == -1) {
gmt_init.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -B option: Mixing of GMT 4 and 5 level syntax is not possible\n");
gmt_init.c:	else if (GMT->common.B.mode == 4) {	/* Got GMT 4 syntax */
gmt_init.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -B option: Cannot use GMT 4 syntax except in GMT classic with compatibility mode\n");
gmt_init.c:	GMT->current.proj.units_pr_degree = (answer != 0);
gmt_init.c:	if (GMT->current.proj.units_pr_degree) {	/* Check if we got "1" and this is grd|map-project */
gmt_init.c:			GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning -J option: Your scale of 1 was interpreted to mean 1:1 since no plotting is involved.\n");
gmt_init.c:			GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "If a scale of 1 was intended, please append a unit from %s.\n", GMT_DIM_UNITS_DISPLAY);
gmt_init.c:		*value = 1.0 / (*value * GMT->current.proj.unit);
gmt_init.c:		if (GMT->current.proj.gave_map_width) {
gmt_init.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -J option: Cannot specify map width with 1:xxxx format\n");
gmt_init.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Your scale or width (%s) resulted in a zero value.\n", scale_or_width);
gmt_init.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Geographic scale (%s) cannot be negative.\n", scale_or_width);
gmt_init.c:	GMT->current.proj.pars[15] = *value;	/* Store the scale here so we always know where to find it */
gmt_init.c:	 * GMT->current.proj structure.  The function returns true if an error is encountered.
gmt_init.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -J option: No argument for parsing\n");
gmt_init.c:	if (!GMT->common.J.active)	/* Down want to clobber this during -Jz/Z after the horizontal part has been set */
gmt_init.c:		GMT->current.proj.lon0 = GMT->current.proj.lat0 = GMT->session.d_NaN;	/* Projection center, to be set via -J */
gmt_init.c:		strncpy (GMT->common.J.zstring, args, GMT_LEN128-1);	/* Verbatim copy of -Jz|Z */
gmt_init.c:		strncpy (GMT->common.J.string, args, GMT_LEN128-1);	/* Verbatim copy or map -J */
gmt_init.c:					GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -J option: Invalid modifier %s\n", d);
gmt_init.c:		GMT->current.proj.units_pr_degree = (k == -1) ? true : false;
gmt_init.c:		GMT->current.proj.gave_map_width = mod_flag;
gmt_init.c:	GMT->current.proj.unit = GMT_units[GMT_INCH];	/* No of meters in an inch */
gmt_init.c:			GMT->current.proj.compute_scale[GMT_X] = GMT->current.proj.compute_scale[GMT_Y] = width_given;
gmt_init.c:				GMT->current.proj.autoscl[GMT_X] = 1;	/* Want same scale as for y; compute width from x-range */
gmt_init.c:				GMT->current.proj.autoscl[GMT_X] = -1;	/* Want same scale as for y but reverse direction; compute width from x-range */
gmt_init.c:				GMT->current.proj.pars[0] = GMT->session.u2u[GMT_M][GMT_INCH] / atof (&args_cp[2]);
gmt_init.c:				GMT->current.proj.pars[0] = gmt_M_to_inch (GMT, args_cp);	/* x-scale */
gmt_init.c:			GMT->current.proj.xyz_projection[GMT_X] = GMT_LINEAR;
gmt_init.c:				GMT->current.proj.xyz_projection[GMT_X] = GMT_LOG10;
gmt_init.c:				GMT->current.proj.xyz_projection[GMT_X] = GMT_POW;
gmt_init.c:				GMT->current.proj.pars[2] = atof (&args[p_pos[GMT_X]+1]);	/* pow to raise x */
gmt_init.c:				GMT->current.proj.xyz_projection[GMT_X] = GMT_TIME;
gmt_init.c:					GMT->current.proj.autoscl[GMT_Y] = 1;	/* Want same scale as for x; compute height from y-range */
gmt_init.c:					GMT->current.proj.autoscl[GMT_Y] = -1;	/* Want same scale as for x but reverse direction; compute height from y-range */
gmt_init.c:					GMT->current.proj.pars[1] = GMT->session.u2u[GMT_M][GMT_INCH] / atof (&args_cp[2]);
gmt_init.c:					GMT->current.proj.pars[1] = gmt_M_to_inch (GMT, args_cp);	/* y-scale */
gmt_init.c:				GMT->current.proj.xyz_projection[GMT_Y] = GMT_LINEAR;
gmt_init.c:					GMT->current.proj.xyz_projection[GMT_Y] = GMT_LOG10;
gmt_init.c:					GMT->current.proj.xyz_projection[GMT_Y] = GMT_POW;
gmt_init.c:					GMT->current.proj.pars[3] = atof (&args[p_pos[GMT_Y]+1]);	/* pow to raise y */
gmt_init.c:					GMT->current.proj.xyz_projection[GMT_Y] = GMT_TIME;
gmt_init.c:				GMT->current.proj.xyz_projection[GMT_Y] = GMT->current.proj.xyz_projection[GMT_X];
gmt_init.c:				GMT->current.proj.pars[1] = GMT->current.proj.pars[0];
gmt_init.c:				GMT->current.proj.pars[3] = GMT->current.proj.pars[2];
gmt_init.c:			if (GMT->current.proj.pars[GMT_X] == 0.0 && GMT->current.proj.pars[GMT_Y] == 0.0) error++;
gmt_init.c:			GMT->current.proj.compute_scale[GMT_Z] = width_given;
gmt_init.c:			GMT->current.proj.z_pars[0] = gmt_M_to_inch (GMT, args_cp);	/* z-scale */
gmt_init.c:			GMT->current.proj.xyz_projection[GMT_Z] = GMT_LINEAR;
gmt_init.c:				GMT->current.proj.xyz_projection[GMT_Z] = GMT_LOG10;
gmt_init.c:				GMT->current.proj.xyz_projection[GMT_Z] = GMT_POW;
gmt_init.c:				GMT->current.proj.z_pars[1] = atof (&args[p_pos[GMT_Z]+1]);	/* pow to raise z */
gmt_init.c:				GMT->current.proj.xyz_projection[GMT_Z] = GMT_TIME;
gmt_init.c:			if (GMT->current.proj.z_pars[0] == 0.0) error++;
gmt_init.c:			GMT->current.proj.JZ_set = true;
gmt_init.c:				GMT->current.proj.got_azimuths = true;	/* using azimuths instead of directions */
gmt_init.c:				GMT->current.proj.got_azimuths = false;
gmt_init.c:				GMT->current.proj.got_elevations = true;
gmt_init.c:				GMT->current.proj.z_down = true;
gmt_init.c:				GMT->current.proj.got_elevations = GMT->current.proj.z_down = false;
gmt_init.c:				n = sscanf (args, "%[^/]/%lf", txt_a, &GMT->current.proj.pars[1]);
gmt_init.c:				if (n == 2) GMT->current.proj.pars[0] = gmt_M_to_inch (GMT, &txt_a[i]);
gmt_init.c:				error += (GMT->current.proj.pars[0] <= 0.0 || n != 2) ? 1 : 0;
gmt_init.c:				GMT->current.proj.pars[0] = gmt_M_to_inch (GMT, &args[i]);
gmt_init.c:				error += (GMT->current.proj.pars[0] <= 0.0 || n != 1) ? 1 : 0;
gmt_init.c:			if (GMT->current.proj.got_elevations) args[j] = 'r';	/* Put the r back in the argument */
gmt_init.c:			if (GMT->current.proj.z_down) args[j] = 'z';	/* Put the z back in the argument */
gmt_init.c:			if (GMT->current.proj.got_azimuths) GMT->current.proj.pars[1] = -GMT->current.proj.pars[1];	/* Because azimuths go clockwise */
gmt_init.c:			GMT->current.proj.pars[0] = GMT->session.d_NaN;	/* Will be replaced by central meridian either below or in GMT_map_init_... */
gmt_init.c:				error += gmt_verify_expectations (GMT, GMT_IS_LON, gmt_scanf (GMT, txt_a, GMT_IS_LON, &GMT->current.proj.pars[0]), txt_a);
gmt_init.c:				GMT->current.proj.lon0 = GMT->current.proj.pars[0];	GMT->current.proj.lat0 = 0.0;
gmt_init.c:			error += gmtinit_scale_or_width (GMT, txt_b, &GMT->current.proj.pars[1]);
gmt_init.c:			GMT->current.proj.pars[0] = GMT->session.d_NaN;
gmt_init.c:			GMT->current.proj.pars[1] = 0.0;
gmt_init.c:				error += gmt_verify_expectations (GMT, GMT_IS_LON, gmt_scanf (GMT, txt_a, GMT_IS_LON, &GMT->current.proj.pars[0]), txt_a);
gmt_init.c:				GMT->current.proj.lon0 = GMT->current.proj.pars[0];
gmt_init.c:				error += gmt_verify_expectations (GMT, GMT_IS_LAT, gmt_scanf (GMT, txt_b, GMT_IS_LAT, &GMT->current.proj.pars[1]), txt_b);
gmt_init.c:				GMT->current.proj.lat0 = GMT->current.proj.pars[1];
gmt_init.c:			error += gmtinit_scale_or_width (GMT, txt_c, &GMT->current.proj.pars[2]);
gmt_init.c:				&& fabs (GMT->current.proj.pars[1]) >= 90.0);
gmt_init.c:			error += gmt_verify_expectations (GMT, GMT_IS_LON, gmt_scanf (GMT, txt_a, GMT_IS_LON, &GMT->current.proj.pars[0]), txt_a);
gmt_init.c:			error += gmt_verify_expectations (GMT, GMT_IS_LAT, gmt_scanf (GMT, txt_b, GMT_IS_LAT, &GMT->current.proj.pars[1]), txt_b);
gmt_init.c:			error += gmt_verify_expectations (GMT, GMT_IS_LAT, gmt_scanf (GMT, txt_c, GMT_IS_LAT, &GMT->current.proj.pars[2]), txt_c);
gmt_init.c:			error += gmt_verify_expectations (GMT, GMT_IS_LAT, gmt_scanf (GMT, txt_d, GMT_IS_LAT, &GMT->current.proj.pars[3]), txt_d);
gmt_init.c:			error += gmtinit_scale_or_width (GMT, txt_e, &GMT->current.proj.pars[4]);
gmt_init.c:			GMT->current.proj.lon0 = GMT->current.proj.pars[0];	GMT->current.proj.lat0 = GMT->current.proj.pars[1];
gmt_init.c:			GMT->current.proj.g_debug = 0;
gmt_init.c:			GMT->current.proj.g_box = GMT->current.proj.g_outside = GMT->current.proj.g_longlat_set =
gmt_init.c:				GMT->current.proj.g_radius = GMT->current.proj.g_auto_twist = false;
gmt_init.c:			GMT->current.proj.g_sphere = true; /* force spherical as default */
gmt_init.c:			GMT->current.proj.pars[5] = GMT->current.proj.pars[6] = GMT->current.proj.pars[7] = 0.0;
gmt_init.c:					n = sscanf (args, "%[^/]/%[^/]/1:%lf", txt_a, txt_b, &GMT->current.proj.pars[3]);
gmt_init.c:					n = sscanf (args, "%[^/]/%[^/]/%[^/]/1:%lf", txt_a, txt_b, txt_c, &GMT->current.proj.pars[3]);
gmt_init.c:				if (GMT->current.proj.pars[3] != 0.0) GMT->current.proj.pars[3] = 1.0 / (GMT->current.proj.pars[3] * GMT->current.proj.unit);
gmt_init.c:				GMT->current.proj.pars[3] = gmt_M_to_inch (GMT, txt_d);
gmt_init.c:					GMT->current.proj.pars[3] = gmt_M_to_inch (GMT, txt_d);
gmt_init.c:						GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Oblique latitude must be in -90 to +90 range\n");
gmt_init.c:						error += gmt_verify_expectations (GMT, GMT_IS_LAT, gmt_scanf (GMT, txt_e, GMT_IS_LAT, &GMT->current.proj.pars[4]), txt_e);
gmt_init.c:			error += gmt_verify_expectations (GMT, GMT_IS_LON, gmt_scanf (GMT, txt_a, GMT_IS_LON, &GMT->current.proj.pars[0]), txt_a);
gmt_init.c:			error += gmt_verify_expectations (GMT, GMT_IS_LAT, gmt_scanf (GMT, txt_b, GMT_IS_LAT, &GMT->current.proj.pars[1]), txt_b);
gmt_init.c:			error += gmt_verify_expectations (GMT, GMT_IS_LON, gmt_scanf (GMT, txt_c, GMT_IS_LON, &GMT->current.proj.pars[2]), txt_c);  /* As co-latitude it may be 180 so cannot parse as latitude */
gmt_init.c:			error += (GMT->current.proj.pars[2] <= 0.0 || GMT->current.proj.pars[2] > 180.0 || GMT->current.proj.pars[3] <= 0.0 || (k >= 0 && width_given));
gmt_init.c:			error += (project == GMT_GNOMONIC && GMT->current.proj.pars[2] >= 90.0);
gmt_init.c:			error += (project == GMT_ORTHO && GMT->current.proj.pars[2] >= 180.0);
gmt_init.c:			GMT->current.proj.lon0 = GMT->current.proj.pars[0];	GMT->current.proj.lat0 = GMT->current.proj.pars[1];
gmt_init.c:					n = sscanf (args, "%[^/]/%[^/]/1:%lf", txt_a, txt_b, &GMT->current.proj.pars[3]);
gmt_init.c:					n = sscanf (args, "%[^/]/%[^/]/%[^/]/1:%lf", txt_a, txt_b, txt_e, &GMT->current.proj.pars[3]);
gmt_init.c:						GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Oblique latitude must be in -90 to +90 range\n");
gmt_init.c:						error += gmt_verify_expectations (GMT, GMT_IS_LAT, gmt_scanf (GMT, txt_e, GMT_IS_LAT, &GMT->current.proj.pars[4]), txt_e);
gmt_init.c:					GMT->current.proj.pars[5] = 1.0;	/* flag for true scale case */
gmt_init.c:					n = sscanf (args, "%[^/]/%[^/]/%[^/]/%[^/]/1:%lf", txt_a, txt_b, txt_c, txt_e, &GMT->current.proj.pars[3]);
gmt_init.c:						GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Oblique latitude must be in -90 to +90 range\n");
gmt_init.c:						error += gmt_verify_expectations (GMT, GMT_IS_LAT, gmt_scanf (GMT, txt_e, GMT_IS_LAT, &GMT->current.proj.pars[4]), txt_e);
gmt_init.c:					GMT->current.proj.pars[5] = 1.0;	/* flag for true scale case */
gmt_init.c:				if (GMT->current.proj.pars[3] != 0.0) GMT->current.proj.pars[3] = 1.0 / (GMT->current.proj.pars[3] * GMT->current.proj.unit);
gmt_init.c:				GMT->current.proj.pars[3] = gmt_M_to_inch (GMT, txt_d);
gmt_init.c:					GMT->current.proj.pars[3] = gmt_M_to_inch (GMT, txt_d);
gmt_init.c:						GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Oblique latitude must be in -90 to +90 range\n");
gmt_init.c:						error += gmt_verify_expectations (GMT, GMT_IS_LAT, gmt_scanf (GMT, txt_e, GMT_IS_LAT, &GMT->current.proj.pars[4]), txt_e);
gmt_init.c:			error += gmt_verify_expectations (GMT, GMT_IS_LON, gmt_scanf (GMT, txt_a, GMT_IS_LON, &GMT->current.proj.pars[0]), txt_a);
gmt_init.c:			error += gmt_verify_expectations (GMT, GMT_IS_LAT, gmt_scanf (GMT, txt_b, GMT_IS_LAT, &GMT->current.proj.pars[1]), txt_b);
gmt_init.c:			error += gmt_verify_expectations (GMT, GMT_IS_LON, gmt_scanf (GMT, txt_c, GMT_IS_LON, &GMT->current.proj.pars[2]), txt_c);
gmt_init.c:			error += (GMT->current.proj.pars[2] <= 0.0 || GMT->current.proj.pars[2] >= 180.0 || GMT->current.proj.pars[3] <= 0.0 || (k >= 0 && width_given));
gmt_init.c:			GMT->current.proj.lon0 = GMT->current.proj.pars[0];	GMT->current.proj.lat0 = GMT->current.proj.pars[1];
gmt_init.c:			GMT->current.proj.g_debug = 0;
gmt_init.c:			GMT->current.proj.g_box = GMT->current.proj.g_outside = GMT->current.proj.g_longlat_set = GMT->current.proj.g_radius = GMT->current.proj.g_auto_twist = false;
gmt_init.c:			GMT->current.proj.g_sphere = true; /* force spherical as default */
gmt_init.c:					GMT->current.proj.g_debug = 1;
gmt_init.c:					GMT->current.proj.g_debug = 2;
gmt_init.c:					GMT->current.proj.g_debug = 3;
gmt_init.c:					GMT->current.proj.g_sphere = true;
gmt_init.c:					GMT->current.proj.g_sphere = false;
gmt_init.c:			GMT->current.proj.pars[4] = GMT->current.proj.pars[5] = GMT->current.proj.pars[6] = GMT->current.proj.pars[7] = GMT->current.proj.pars[8] = GMT->current.proj.pars[9] = 0.0;
gmt_init.c:			if (GMT->current.proj.g_debug > 1) {
gmt_init.c:			if (GMT->current.proj.g_debug > 1) {
gmt_init.c:				m = sscanf(&(txt_arr[n-1][0]),"1:%lf", &GMT->current.proj.pars[2]);
gmt_init.c:				if (GMT->current.proj.pars[2] != 0.0) {
gmt_init.c:					GMT->current.proj.pars[2] = 1.0 / (GMT->current.proj.pars[2] * GMT->current.proj.unit);
gmt_init.c:				GMT->current.proj.pars[2] = gmt_M_to_inch (GMT, &(txt_arr[n-1][0]));
gmt_init.c:				GMT->current.proj.pars[2] = gmt_M_to_inch (GMT, &(txt_arr[n-2][0]));
gmt_init.c:				/*            GMT->current.proj.pars[3] = GMT_ddmmss_to_degree(txt_i); */
gmt_init.c:					GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Oblique latitude must be in -90 to +90 range\n");
gmt_init.c:					error += gmt_verify_expectations (GMT, GMT_IS_LAT, gmt_scanf (GMT, &(txt_arr[n-1][0]), GMT_IS_LAT, &GMT->current.proj.pars[3]), &(txt_arr[n-1][0]));
gmt_init.c:			error += gmt_verify_expectations (GMT, GMT_IS_LON, gmt_scanf (GMT, &(txt_arr[0][0]), GMT_IS_LON, &GMT->current.proj.pars[0]), &(txt_arr[0][0]));
gmt_init.c:			error += gmt_verify_expectations (GMT, GMT_IS_LAT, gmt_scanf (GMT, &(txt_arr[1][0]), GMT_IS_LAT, &GMT->current.proj.pars[1]), &(txt_arr[1][0]));
gmt_init.c:			/* g_alt    GMT->current.proj.pars[4] = atof(txt_c); */
gmt_init.c:				GMT->current.proj.g_radius = true;
gmt_init.c:			error += gmt_verify_expectations (GMT, GMT_IS_FLOAT, gmt_scanf (GMT, &(txt_arr[2][0]), GMT_IS_FLOAT, &GMT->current.proj.pars[4]), &(txt_arr[2][0]));
gmt_init.c:			/* g_az    GMT->current.proj.pars[5] = atof(txt_d); */
gmt_init.c:				GMT->current.proj.g_longlat_set = true;
gmt_init.c:			error += gmt_verify_expectations (GMT, GMT_IS_GEO, gmt_scanf (GMT, &(txt_arr[3][0]), GMT_IS_GEO, &GMT->current.proj.pars[5]), &(txt_arr[3][0]));
gmt_init.c:			/* g_tilt    GMT->current.proj.pars[6] = atof(txt_e); */
gmt_init.c:				GMT->current.proj.g_longlat_set = true;
gmt_init.c:			error += gmt_verify_expectations (GMT, GMT_IS_GEO, gmt_scanf (GMT, &(txt_arr[4][0]), GMT_IS_GEO, &GMT->current.proj.pars[6]), &(txt_arr[4][0]));
gmt_init.c:				/*g_twist   GMT->current.proj.pars[7] = atof(txt_f); */
gmt_init.c:					GMT->current.proj.g_auto_twist = true;
gmt_init.c:				error += gmt_verify_expectations (GMT, GMT_IS_GEO, gmt_scanf (GMT, &(txt_arr[5][0]), GMT_IS_GEO, &GMT->current.proj.pars[7]), &(txt_arr[5][0]));
gmt_init.c:				/*g_width   GMT->current.proj.pars[8] = atof(txt_f); */
gmt_init.c:					error += gmt_verify_expectations (GMT, GMT_IS_GEO, gmt_scanf (GMT, &(txt_arr[6][0]), GMT_IS_GEO, &GMT->current.proj.pars[8]), &(txt_arr[6][0]));
gmt_init.c:						/* g_height  GMT->current.proj.pars[9] = atof(txt_g); */
gmt_init.c:						error += gmt_verify_expectations (GMT, GMT_IS_GEO, gmt_scanf (GMT, &(txt_arr[7][0]), GMT_IS_GEO, &GMT->current.proj.pars[9]), &(txt_arr[7][0]));
gmt_init.c:			error += (GMT->current.proj.pars[2] <= 0.0 || (k >= 0 && width_given));
gmt_init.c:			GMT->current.proj.lon0 = GMT->current.proj.pars[0];	GMT->current.proj.lat0 = GMT->current.proj.pars[1];
gmt_init.c:			GMT->current.proj.N_hemi = (strchr ("AB", GMT->common.J.string[1]) == NULL) ? true : false;	/* Upper case -JoA, -JoB allows S pole views */
gmt_init.c:				error += gmt_verify_expectations (GMT, GMT_IS_LON, gmt_scanf (GMT, txt_a, GMT_IS_LON, &GMT->current.proj.pars[0]), txt_a);
gmt_init.c:				error += gmt_verify_expectations (GMT, GMT_IS_LAT, gmt_scanf (GMT, txt_b, GMT_IS_LAT, &GMT->current.proj.pars[1]), txt_b);
gmt_init.c:				GMT->current.proj.pars[2] = GMT->current.proj.pars[0] + atand (sind (c) * sind (az) / (cosd (GMT->current.proj.pars[1]) * cosd (c) - sind (GMT->current.proj.pars[1]) * sind (c) * cosd (az)));
gmt_init.c:				GMT->current.proj.pars[3] = d_asind (sind (GMT->current.proj.pars[1]) * cosd (c) + cosd (GMT->current.proj.pars[1]) * sind (c) * cosd (az));
gmt_init.c:				error += gmt_verify_expectations (GMT, GMT_IS_LON, gmt_scanf (GMT, txt_a, GMT_IS_LON, &GMT->current.proj.pars[0]), txt_a);
gmt_init.c:				error += gmt_verify_expectations (GMT, GMT_IS_LAT, gmt_scanf (GMT, txt_b, GMT_IS_LAT, &GMT->current.proj.pars[1]), txt_b);
gmt_init.c:				error += gmt_verify_expectations (GMT, GMT_IS_LON, gmt_scanf (GMT, txt_c, GMT_IS_LON, &GMT->current.proj.pars[2]), txt_c);
gmt_init.c:				error += gmt_verify_expectations (GMT, GMT_IS_LAT, gmt_scanf (GMT, txt_d, GMT_IS_LAT, &GMT->current.proj.pars[3]), txt_d);
gmt_init.c:			error += gmtinit_scale_or_width (GMT, txt_e, &GMT->current.proj.pars[4]);
gmt_init.c:			GMT->current.proj.pars[6] = 0.0;
gmt_init.c:			GMT->current.proj.lon0 = GMT->current.proj.pars[0];	GMT->current.proj.lat0 = GMT->current.proj.pars[1];
gmt_init.c:			GMT->current.proj.N_hemi = (GMT->common.J.string[1] != 'C') ? true : false;	/* Upper case -JoC allows S pole views */
gmt_init.c:			error += gmt_verify_expectations (GMT, GMT_IS_LON, gmt_scanf (GMT, txt_a, GMT_IS_LON, &GMT->current.proj.pars[0]), txt_a);
gmt_init.c:			error += gmt_verify_expectations (GMT, GMT_IS_LAT, gmt_scanf (GMT, txt_b, GMT_IS_LAT, &GMT->current.proj.pars[1]), txt_b);
gmt_init.c:			error += gmt_verify_expectations (GMT, GMT_IS_LON, gmt_scanf (GMT, txt_c, GMT_IS_LON, &GMT->current.proj.pars[2]), txt_c);
gmt_init.c:			error += gmt_verify_expectations (GMT, GMT_IS_LAT, gmt_scanf (GMT, txt_d, GMT_IS_LAT, &GMT->current.proj.pars[3]), txt_d);
gmt_init.c:			if (GMT->current.proj.pars[3] < 0.0) {	/* Flip from S hemisphere to N */
gmt_init.c:				GMT->current.proj.o_spole = true;
gmt_init.c:				GMT->current.proj.pars[3] = -GMT->current.proj.pars[3];
gmt_init.c:				GMT->current.proj.pars[2] += 180.0;
gmt_init.c:				if (GMT->current.proj.pars[2] >= 360.0) GMT->current.proj.pars[2] -= 360.0;
gmt_init.c:			error += gmtinit_scale_or_width (GMT, txt_e, &GMT->current.proj.pars[4]);
gmt_init.c:			GMT->current.proj.pars[6] = 1.0;
gmt_init.c:			GMT->current.proj.lon0 = GMT->current.proj.pars[0];	GMT->current.proj.lat0 = GMT->current.proj.pars[1];
gmt_init.c:				GMT->current.proj.pars[0] = -1.0;	/* Flag we need zone to be set later */
gmt_init.c:				error += gmtinit_scale_or_width (GMT, args, &GMT->current.proj.pars[1]);
gmt_init.c:				GMT->current.proj.pars[0] = atof (txt_a);
gmt_init.c:						GMT->current.proj.utm_hemisphere = -1;
gmt_init.c:						GMT->current.proj.utm_hemisphere = +1;
gmt_init.c:						GMT->current.proj.utm_hemisphere = 0;
gmt_init.c:					GMT->current.proj.utm_zoney = mod;
gmt_init.c:					GMT->current.proj.utm_hemisphere = -1;
gmt_init.c:					if (mod >= 'N') GMT->current.proj.utm_hemisphere = +1;
gmt_init.c:				GMT->current.proj.pars[0] = fabs (GMT->current.proj.pars[0]);
gmt_init.c:				GMT->current.proj.lat0 = 0.0;
gmt_init.c:				k = irint (GMT->current.proj.pars[0]);
gmt_init.c:				GMT->current.proj.lon0 = -180.0 + k * 6.0 - 3.0;
gmt_init.c:				GMT->current.proj.utm_zonex = k;
gmt_init.c:				error += gmtinit_scale_or_width (GMT, txt_b, &GMT->current.proj.pars[1]);
gmt_init.c:		GMT->current.proj.projection = project;
gmt_init.c:		GMT->current.proj.projection_GMT = project;		/* Make a copy to use when using the Proj4 lib */
gmt_init.c:				GMT_Report (GMT->parent, GMT_MSG_COMPAT, "Specifying a plot distance unit in meters is deprecated; use c, i, or p.\n");
gmt_init.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error option -Sf: Must specify <ticklen> when specifying the number of ticks\n");
gmt_init.c:							GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Bad +p<pen> argument %s\n", &p[1]);
gmt_init.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error option -Sf: Bad modifier +%c\n", p[0]);
gmt_init.c:			GMT_Report (GMT->parent, GMT_MSG_COMPAT, "Warning in Option -Sl: Sl<size>/<string>[%<font>] is deprecated syntax\n");
gmt_init.c:				if (gmt_getfont (GMT, c, &S->font)) GMT_Report (GMT->parent, GMT_MSG_NORMAL, "-Sl contains bad font (set to %s)\n", gmt_putfont (GMT, &S->font));
gmt_init.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -Sl option: No string given\n");
gmt_init.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -Sl option: Usage is -Sl[<size>]+t<string>[+f<font>][+j<justify]\n");
gmt_init.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -Sl option: No string information given\n");
gmt_init.c:						GMT_Report (GMT->parent, GMT_MSG_NORMAL, "-Sl contains bad +<font> modifier (set to %s)\n", gmt_putfont (GMT, &S->font));
gmt_init.c:					GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error option -Sl: Bad modifier +%c\n", p[0]);
gmt_init.c:	GMT->current.proj.m_per_unit[GMT_IS_METER]		= 1.0;				/* m in m */
gmt_init.c:	GMT->current.proj.m_per_unit[GMT_IS_KM]			= METERS_IN_A_KM;		/* m in km */
gmt_init.c:	GMT->current.proj.m_per_unit[GMT_IS_MILE]		= METERS_IN_A_MILE;		/* m in miles */
gmt_init.c:	GMT->current.proj.m_per_unit[GMT_IS_NAUTICAL_MILE]	= METERS_IN_A_NAUTICAL_MILE;	/* m in nautical mile */
gmt_init.c:	GMT->current.proj.m_per_unit[GMT_IS_INCH]		= 0.0254;			/* m in inch */
gmt_init.c:	GMT->current.proj.m_per_unit[GMT_IS_CM]			= 0.01;				/* m in cm */
gmt_init.c:	GMT->current.proj.m_per_unit[GMT_IS_PT]			= 0.0254 / 72.0;		/* m in point */
gmt_init.c:	GMT->current.proj.m_per_unit[GMT_IS_FOOT]		= METERS_IN_A_FOOT;		/* m in foot */
gmt_init.c:	GMT->current.proj.m_per_unit[GMT_IS_SURVEY_FOOT]	= METERS_IN_A_SURVEY_FOOT;	/* m in US Survey foot */
gmt_init.c:	strcpy (GMT->current.proj.unit_name[GMT_IS_METER],		"m");
gmt_init.c:	strcpy (GMT->current.proj.unit_name[GMT_IS_KM],		 	"km");
gmt_init.c:	strcpy (GMT->current.proj.unit_name[GMT_IS_MILE],		"mile");
gmt_init.c:	strcpy (GMT->current.proj.unit_name[GMT_IS_NAUTICAL_MILE], 	"nautical mile");
gmt_init.c:	strcpy (GMT->current.proj.unit_name[GMT_IS_INCH],		"inch");
gmt_init.c:	strcpy (GMT->current.proj.unit_name[GMT_IS_CM],		 	"cm");
gmt_init.c:	strcpy (GMT->current.proj.unit_name[GMT_IS_PT],		 	"point");
gmt_init.c:	strcpy (GMT->current.proj.unit_name[GMT_IS_FOOT],		"foot");
gmt_init.c:	strcpy (GMT->current.proj.unit_name[GMT_IS_SURVEY_FOOT],	"survey foot");
gmt_init.c:	struct GMT_ENCODING *enc = &GMT->current.setting.ps_encoding;
gmt_init.c:	strcpy (GMT->current.language.month_name[0][0], "January"); strcpy (GMT->current.language.month_name[1][0], "Jan");
gmt_init.c:	strcpy (GMT->current.language.month_name[2][0], "J");       strcpy (GMT->current.language.month_name[3][0], "JAN");
gmt_init.c:	strcpy (GMT->current.language.month_name[0][1], "February");strcpy (GMT->current.language.month_name[1][1], "Feb");
gmt_init.c:	strcpy (GMT->current.language.month_name[2][1], "F");       strcpy (GMT->current.language.month_name[3][1], "FEB");
gmt_init.c:	strcpy (GMT->current.language.month_name[0][2], "March");   strcpy (GMT->current.language.month_name[1][2], "Mar");
gmt_init.c:	strcpy (GMT->current.language.month_name[2][2], "M");       strcpy (GMT->current.language.month_name[3][2], "MAR");
gmt_init.c:	strcpy (GMT->current.language.month_name[0][3], "April");   strcpy (GMT->current.language.month_name[1][3], "Apr");
gmt_init.c:	strcpy (GMT->current.language.month_name[2][3], "A");       strcpy (GMT->current.language.month_name[3][3], "APR");
gmt_init.c:	strcpy (GMT->current.language.month_name[0][4], "May");     strcpy (GMT->current.language.month_name[1][4], "May");
gmt_init.c:	strcpy (GMT->current.language.month_name[2][4], "M");       strcpy (GMT->current.language.month_name[3][4], "MAY");
gmt_init.c:	strcpy (GMT->current.language.month_name[0][5], "June");    strcpy (GMT->current.language.month_name[1][5], "Jun");
gmt_init.c:	strcpy (GMT->current.language.month_name[2][5], "J");       strcpy (GMT->current.language.month_name[3][5], "JUN");
gmt_init.c:	strcpy (GMT->current.language.month_name[0][6], "July");    strcpy (GMT->current.language.month_name[1][6], "Jul");
gmt_init.c:	strcpy (GMT->current.language.month_name[2][6], "J");       strcpy (GMT->current.language.month_name[3][6], "JUL");
gmt_init.c:	strcpy (GMT->current.language.month_name[0][7], "August");  strcpy (GMT->current.language.month_name[1][7], "Aug");
gmt_init.c:	strcpy (GMT->current.language.month_name[2][7], "A");       strcpy (GMT->current.language.month_name[3][7], "AUG");
gmt_init.c:	strcpy (GMT->current.language.month_name[0][8], "September");strcpy(GMT->current.language.month_name[1][8], "Sep");
gmt_init.c:	strcpy (GMT->current.language.month_name[2][8], "S");       strcpy (GMT->current.language.month_name[3][8], "SEP");
gmt_init.c:	strcpy (GMT->current.language.month_name[0][9], "October"); strcpy (GMT->current.language.month_name[1][9], "Oct");
gmt_init.c:	strcpy (GMT->current.language.month_name[2][9], "O");       strcpy (GMT->current.language.month_name[3][9], "OCT");
gmt_init.c:	strcpy (GMT->current.language.month_name[0][10],"November");strcpy (GMT->current.language.month_name[1][10],"Nov");
gmt_init.c:	strcpy (GMT->current.language.month_name[2][10],"N");       strcpy (GMT->current.language.month_name[3][10],"NOV");
gmt_init.c:	strcpy (GMT->current.language.month_name[0][11],"December");strcpy (GMT->current.language.month_name[1][11],"Dec");
gmt_init.c:	strcpy (GMT->current.language.month_name[2][11],"D");       strcpy (GMT->current.language.month_name[3][11],"DEC");
gmt_init.c:	strcpy (GMT->current.language.week_name[0], "Week");        strcpy (GMT->current.language.week_name[1], "Wk");
gmt_init.c:	strcpy (GMT->current.language.week_name[2], "W");
gmt_init.c:	strcpy (GMT->current.language.day_name[0][0], "Sunday");   strcpy (GMT->current.language.day_name[1][0], "Sun");
gmt_init.c:	strcpy (GMT->current.language.day_name[2][0], "S");
gmt_init.c:	strcpy (GMT->current.language.day_name[0][1], "Monday");   strcpy (GMT->current.language.day_name[1][1], "Mon");
gmt_init.c:	strcpy (GMT->current.language.day_name[2][1], "M");
gmt_init.c:	strcpy (GMT->current.language.day_name[0][2], "Tuesday");  strcpy (GMT->current.language.day_name[1][2], "Tue");
gmt_init.c:	strcpy (GMT->current.language.day_name[2][2], "T");
gmt_init.c:	strcpy (GMT->current.language.day_name[0][3], "Wednesday");strcpy (GMT->current.language.day_name[1][3], "Wed");
gmt_init.c:	strcpy (GMT->current.language.day_name[2][3], "W");
gmt_init.c:	strcpy (GMT->current.language.day_name[0][4], "Thursday"); strcpy (GMT->current.language.day_name[1][4], "Thu");
gmt_init.c:	strcpy (GMT->current.language.day_name[2][4], "T");
gmt_init.c:	strcpy (GMT->current.language.day_name[0][5], "Friday");   strcpy (GMT->current.language.day_name[1][5], "Fri");
gmt_init.c:	strcpy (GMT->current.language.day_name[2][5], "F");
gmt_init.c:	strcpy (GMT->current.language.day_name[0][6], "Saturday"); strcpy (GMT->current.language.day_name[1][6], "Sat");
gmt_init.c:	strcpy (GMT->current.language.day_name[2][6], "S");
gmt_init.c:	strcpy (GMT->current.language.cardinal_name[0][0], "West"); strcpy (GMT->current.language.cardinal_name[1][0], "W");
gmt_init.c:	strcpy (GMT->current.language.cardinal_name[2][0], "W");
gmt_init.c:	strcpy (GMT->current.language.cardinal_name[0][1], "East"); strcpy (GMT->current.language.cardinal_name[1][1], "E");
gmt_init.c:	strcpy (GMT->current.language.cardinal_name[2][1], "E");
gmt_init.c:	strcpy (GMT->current.language.cardinal_name[0][2], "South"); strcpy (GMT->current.language.cardinal_name[1][2], "S");
gmt_init.c:	strcpy (GMT->current.language.cardinal_name[2][2], "S");
gmt_init.c:	strcpy (GMT->current.language.cardinal_name[0][3], "North"); strcpy (GMT->current.language.cardinal_name[1][3], "N");
gmt_init.c:	strcpy (GMT->current.language.cardinal_name[2][3], "N");
gmt_init.c:	GMT->current.setting.verbose = (unsigned int)mode;
gmt_init.c:	if (!strcmp(GMT->current.setting.language, "us")) {
gmt_init.c:	snprintf (line, GMT_BUFSIZ, "gmt_%s", GMT->current.setting.language);
gmt_init.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Could not load language %s - revert to us (English)!\n",
gmt_init.c:			GMT->current.setting.language);
gmt_init.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Could not find %s!\n", file);
gmt_init.c:		strcpy (GMT->current.setting.language, "us");
gmt_init.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Index in %s is zero or negative!\n", line);
gmt_init.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Month index in %s exceeds 12!\n", line);
gmt_init.c:			strncpy (GMT->current.language.month_name[0][i-1], full, GMT_LEN16-1);
gmt_init.c:			strncpy (GMT->current.language.month_name[1][i-1], abbrev, GMT_LEN16-1);
gmt_init.c:			strncpy (GMT->current.language.month_name[2][i-1], c, GMT_LEN16-1);
gmt_init.c:			strncpy (GMT->current.language.month_name[3][i-1], abbrev, GMT_LEN16-1);
gmt_init.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Weekday index in %s exceeds 7!\n", line);
gmt_init.c:			strncpy (GMT->current.language.day_name[0][i-1], full, GMT_LEN16-1);
gmt_init.c:			strncpy (GMT->current.language.day_name[1][i-1], abbrev, GMT_LEN16-1);
gmt_init.c:			strncpy (GMT->current.language.day_name[2][i-1], c, GMT_LEN16-1);
gmt_init.c:			strncpy (GMT->current.language.week_name[0], full, GMT_LEN16-1);
gmt_init.c:			strncpy (GMT->current.language.week_name[1], abbrev, GMT_LEN16-1);
gmt_init.c:			strncpy (GMT->current.language.week_name[2], c, GMT_LEN16-1);
gmt_init.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Cardinal name index in %s exceeds 4!\n", line);
gmt_init.c:			strncpy (GMT->current.language.cardinal_name[0][i-1], full, GMT_LEN16-1);
gmt_init.c:			strncpy (GMT->current.language.cardinal_name[1][i-1], abbrev, GMT_LEN16-1);
gmt_init.c:			strncpy (GMT->current.language.cardinal_name[2][i-1], c, GMT_LEN16-1);
gmt_init.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Mismatch between expected and actual contents in %s!\n", file);
gmt_init.c:	strcpy(GMT->current.setting.format_clock_in, "hh:mm:ss");
gmt_init.c:	gmtlib_clock_C_format (GMT, GMT->current.setting.format_clock_in, &GMT->current.io.clock_input, 0);
gmt_init.c:	strcpy (GMT->current.setting.format_date_in, "yyyy-mm-dd");
gmt_init.c:	gmtlib_date_C_format (GMT, GMT->current.setting.format_date_in, &GMT->current.io.date_input, 0);
gmt_init.c:	strcpy (GMT->current.setting.format_clock_out, "hh:mm:ss");
gmt_init.c:	gmtlib_clock_C_format (GMT, GMT->current.setting.format_clock_out, &GMT->current.io.clock_output, 1);
gmt_init.c:	strcpy (GMT->current.setting.format_date_out, "yyyy-mm-dd");
gmt_init.c:	gmtlib_date_C_format (GMT, GMT->current.setting.format_date_out, &GMT->current.io.date_output, 1);
gmt_init.c:	strcpy (GMT->current.setting.format_geo_out, "D");
gmt_init.c:	strcpy (GMT->current.setting.format_clock_map, "hh:mm:ss");
gmt_init.c:	gmtlib_clock_C_format (GMT, GMT->current.setting.format_clock_map, &GMT->current.plot.calclock.clock, 2);
gmt_init.c:	strcpy (GMT->current.setting.format_date_map, "yyyy-mm-dd");
gmt_init.c:	gmtlib_date_C_format (GMT, GMT->current.setting.format_date_map, &GMT->current.plot.calclock.date, 2);
gmt_init.c:	strcpy (GMT->current.setting.format_geo_map, "ddd:mm:ss");
gmt_init.c:	strcpy (GMT->current.setting.format_time[GMT_PRIMARY], "full");
gmt_init.c:	strcpy (GMT->current.setting.format_time[GMT_SECONDARY], "full");
gmt_init.c:	strcpy (GMT->current.setting.format_float_out, "%.12g");
gmt_init.c:	strcpy (GMT->current.setting.format_float_out_orig, "%.12g");
gmt_init.c:	strcpy (GMT->current.setting.format_float_map, "%.12g");
gmt_init.c:	strcpy (GMT->current.setting.format_time_stamp, "%Y %b %d %H:%M:%S");
gmt_init.c:	error += gmt_getfont (GMT, "12p,Helvetica,black", &GMT->current.setting.font_annot[GMT_PRIMARY]);
gmt_init.c:	GMT->current.setting.given_unit[GMTCASE_FONT_ANNOT_PRIMARY] = 'p';
gmt_init.c:	error += gmt_getfont (GMT, "14p,Helvetica,black", &GMT->current.setting.font_annot[GMT_SECONDARY]);
gmt_init.c:	GMT->current.setting.given_unit[GMTCASE_FONT_ANNOT_SECONDARY] = 'p';
gmt_init.c:	error += gmt_getfont (GMT, "32p,Helvetica,black", &GMT->current.setting.font_heading);
gmt_init.c:	GMT->current.setting.given_unit[GMTCASE_FONT_HEADING] = 'p';
gmt_init.c:	error += gmt_getfont (GMT, "24p,Helvetica,black", &GMT->current.setting.font_title);
gmt_init.c:	GMT->current.setting.given_unit[GMTCASE_FONT_TITLE] = 'p';
gmt_init.c:	error += gmt_getfont (GMT, "16p,Helvetica,black", &GMT->current.setting.font_label);
gmt_init.c:	GMT->current.setting.given_unit[GMTCASE_FONT_LABEL] = 'p';
gmt_init.c:	error += gmt_getfont (GMT, "20p,Helvetica,black", &GMT->current.setting.font_tag);
gmt_init.c:	GMT->current.setting.given_unit[GMTCASE_FONT_TAG] = 'p';
gmt_init.c:	error += gmt_getfont (GMT, "8p,Helvetica,black", &GMT->current.setting.font_logo);
gmt_init.c:	GMT->current.setting.given_unit[GMTCASE_FONT_LOGO] = 'p';
gmt_init.c:	GMT->current.setting.map_annot_offset[GMT_PRIMARY] = GMT->current.setting.map_annot_offset[GMT_SECONDARY] = 5 * pt; /* 5p */
gmt_init.c:	GMT->current.setting.given_unit[GMTCASE_MAP_ANNOT_OFFSET_PRIMARY] = 'p';
gmt_init.c:	GMT->current.setting.given_unit[GMTCASE_MAP_ANNOT_OFFSET_SECONDARY] = 'p';
gmt_init.c:	GMT->current.setting.map_annot_oblique = GMT_OBL_ANNOT_ANYWHERE;
gmt_init.c:	GMT->current.setting.map_annot_min_angle = 20;
gmt_init.c:	GMT->current.setting.map_annot_min_spacing = 0; /* 0p */
gmt_init.c:	GMT->current.setting.given_unit[GMTCASE_MAP_ANNOT_MIN_SPACING] = 'p';
gmt_init.c:	strcpy (GMT->current.setting.map_annot_ortho, "we");
gmt_init.c:	GMT->current.setting.map_degree_symbol = gmt_degree;
gmt_init.c:	strcpy (GMT->current.setting.map_frame_axes, "WESNZ");
gmt_init.c:	for (i = 0; i < 5; i++) GMT->current.map.frame.side[i] = 0;	/* Unset default settings */
gmt_init.c:	GMT->current.map.frame.draw_box = false;
gmt_init.c:	error += gmt_getpen (GMT, "default,black", &GMT->current.setting.map_default_pen);
gmt_init.c:	error += gmt_getpen (GMT, "thicker,black", &GMT->current.setting.map_frame_pen);
gmt_init.c:	GMT->current.setting.map_frame_type = GMT_IS_FANCY;
gmt_init.c:	GMT->current.setting.map_graph_extension_unit = GMT_GRAPH_EXTENSION_UNIT;	/* Defaults for graph */
gmt_init.c:	GMT->current.setting.map_graph_extension = GMT_GRAPH_EXTENSION;
gmt_init.c:	GMT->current.setting.map_frame_width = 5 * pt; /* 5p */
gmt_init.c:	GMT->current.setting.given_unit[GMTCASE_MAP_FRAME_WIDTH] = 'p';
gmt_init.c:	GMT->current.setting.map_grid_cross_size[GMT_PRIMARY] = GMT->current.setting.map_grid_cross_size[GMT_SECONDARY] = 0; /* 0p */
gmt_init.c:	GMT->current.setting.given_unit[GMTCASE_MAP_GRID_CROSS_SIZE_PRIMARY] = 'p';
gmt_init.c:	GMT->current.setting.given_unit[GMTCASE_MAP_GRID_CROSS_SIZE_SECONDARY] = 'p';
gmt_init.c:	error += gmt_getpen (GMT, "default,black", &GMT->current.setting.map_grid_pen[GMT_PRIMARY]);
gmt_init.c:	error += gmt_getpen (GMT, "thinner,black", &GMT->current.setting.map_grid_pen[GMT_SECONDARY]);
gmt_init.c:	GMT->current.setting.map_heading_offset = 18 * pt;	/* 18p */
gmt_init.c:	GMT->current.setting.given_unit[GMTCASE_MAP_HEADING_OFFSET] = 'p';
gmt_init.c:	GMT->current.setting.map_label_offset = 8 * pt;	/* 8p */
gmt_init.c:	GMT->current.setting.given_unit[GMTCASE_MAP_LABEL_OFFSET] = 'p';
gmt_init.c:	GMT->current.setting.map_line_step = 0.75 * pt;	/* 0.75p */
gmt_init.c:	GMT->current.setting.given_unit[GMTCASE_MAP_LINE_STEP] = 'p';
gmt_init.c:	GMT->current.setting.map_logo = false;
gmt_init.c:	GMT->current.setting.map_logo_justify = PSL_BL;	/* BL */
gmt_init.c:	GMT->current.setting.map_logo_pos[GMT_X] = GMT->current.setting.map_logo_pos[GMT_Y] = -54 * pt;	/* -54p */
gmt_init.c:	GMT->current.setting.given_unit[GMTCASE_MAP_LOGO_POS] = 'p';
gmt_init.c:	GMT->current.setting.map_origin[GMT_X] = GMT->current.setting.map_origin[GMT_Y] = 72 * pt;	/* 72p = 1i */
gmt_init.c:	GMT->current.setting.given_unit[GMTCASE_MAP_ORIGIN_X] = 'p';
gmt_init.c:	GMT->current.setting.given_unit[GMTCASE_MAP_ORIGIN_Y] = 'p';
gmt_init.c:	GMT->current.setting.map_polar_cap[0] = 85;
gmt_init.c:	GMT->current.setting.map_polar_cap[1] = 90;
gmt_init.c:	GMT->current.setting.map_scale_height = 5 * pt;	/* 5p */
gmt_init.c:	GMT->current.setting.given_unit[GMTCASE_MAP_SCALE_HEIGHT] = 'p';
gmt_init.c:	GMT->current.setting.map_tick_length[GMT_ANNOT_UPPER] = 5 * pt;	/* 5p */
gmt_init.c:	GMT->current.setting.map_tick_length[GMT_TICK_UPPER] = 2.5 * pt;	/* 2.5p */
gmt_init.c:	GMT->current.setting.given_unit[GMTCASE_MAP_TICK_LENGTH_PRIMARY] = 'p';
gmt_init.c:	GMT->current.setting.map_tick_length[GMT_ANNOT_LOWER] = 15 * pt;	/* 15p */
gmt_init.c:	GMT->current.setting.map_tick_length[GMT_TICK_LOWER] = 3.75 * pt;	/* 3.75p */
gmt_init.c:	GMT->current.setting.given_unit[GMTCASE_MAP_TICK_LENGTH_SECONDARY] = 'p';
gmt_init.c:	error += gmt_getpen (GMT, "thinner,black", &GMT->current.setting.map_tick_pen[GMT_PRIMARY]);
gmt_init.c:	error += gmt_getpen (GMT, "thinner,black", &GMT->current.setting.map_tick_pen[GMT_SECONDARY]);
gmt_init.c:	GMT->current.setting.map_title_offset = 14 * pt;	/* 14p */
gmt_init.c:	GMT->current.setting.given_unit[GMTCASE_MAP_TITLE_OFFSET] = 'p';
gmt_init.c:	GMT->current.setting.map_vector_shape = 0;
gmt_init.c:	error += gmt_getrgb (GMT, "black", GMT->current.setting.color_patch[GMT_BGD]);
gmt_init.c:	error += gmt_getrgb (GMT, "white", GMT->current.setting.color_patch[GMT_FGD]);
gmt_init.c:	GMT->current.setting.color_model = GMT_RGB;
gmt_init.c:	error += gmt_getrgb (GMT, "127.5", GMT->current.setting.color_patch[GMT_NAN]);
gmt_init.c:	GMT->current.setting.color_hsv_min_s = 1;
gmt_init.c:	GMT->current.setting.color_hsv_max_s = 0.1;
gmt_init.c:	GMT->current.setting.color_hsv_min_v = 0.3;
gmt_init.c:	GMT->current.setting.color_hsv_max_v = 1;
gmt_init.c:	strcpy (GMT->current.setting.ps_encoding.name, "ISOLatin1+");
gmt_init.c:	GMT->current.setting.ps_color_mode = PSL_RGB;
gmt_init.c:	if (GMT->PSL) {	/* Only when using PSL in this session */
gmt_init.c:		GMT->PSL->internal.compress = PSL_DEFLATE;
gmt_init.c:		GMT->PSL->internal.deflate_level = 5;
gmt_init.c:		GMT->PSL->internal.compress = PSL_LZW;
gmt_init.c:		GMT->PSL->internal.line_cap = PSL_BUTT_CAP;
gmt_init.c:		GMT->PSL->internal.line_join = PSL_MITER_JOIN;
gmt_init.c:		GMT->PSL->internal.miter_limit = 35;
gmt_init.c:	error += gmt_getrgb (GMT, "white", GMT->current.setting.ps_page_rgb);
gmt_init.c:	if (GMT->current.setting.run_mode == GMT_MODERN) {
gmt_init.c:		GMT->current.setting.ps_orientation = PSL_LANDSCAPE;
gmt_init.c:		GMT->current.setting.ps_media = i;
gmt_init.c:		GMT->current.setting.ps_page_size[0] = GMT_media[i].width;
gmt_init.c:		GMT->current.setting.ps_page_size[1] = GMT_media[i].height;
gmt_init.c:	GMT->current.setting.ps_magnify[GMT_X] = 1;
gmt_init.c:	GMT->current.setting.ps_magnify[GMT_Y] = 1;
gmt_init.c:	strcpy (GMT->current.setting.ps_transpmode, "Normal");
gmt_init.c:	strcpy (GMT->current.setting.ps_convert, GMT_SESSION_CONVERT);
gmt_init.c:	if (GMT->PSL) GMT->PSL->internal.comments = 0;	/* Only when using PSL in this session */
gmt_init.c:	strcpy (GMT->current.setting.io_col_separator, "\t");
gmt_init.c:	GMT->current.setting.io_first_header = 0;
gmt_init.c:	strcpy (GMT->current.setting.io_gridfile_format, "nf");
gmt_init.c:	GMT->current.setting.io_gridfile_shorthand = false;
gmt_init.c:	GMT->current.setting.io_header[GMT_IN] = GMT->current.setting.io_header[GMT_OUT] = false;
gmt_init.c:	GMT->current.setting.io_head_marker[GMT_OUT] = GMT->current.setting.io_head_marker[GMT_IN] = '#';
gmt_init.c:	GMT->current.setting.io_n_header_items = 0;
gmt_init.c:	GMT->current.setting.io_nan_records = true;
gmt_init.c:	GMT->current.setting.io_nc4_chunksize[0] = k_netcdf_io_chunked_auto;
gmt_init.c:	GMT->current.setting.io_nc4_deflation_level = 3;
gmt_init.c:	GMT->current.setting.io_lonlat_toggle[GMT_IN] = false;
gmt_init.c:	GMT->current.setting.io_lonlat_toggle[GMT_OUT] = GMT->current.setting.io_lonlat_toggle[GMT_IN];
gmt_init.c:	GMT->current.setting.n_bin_header_cols = 2;
gmt_init.c:	GMT->current.setting.io_seg_marker[GMT_OUT] = GMT->current.setting.io_seg_marker[GMT_IN] = '>';
gmt_init.c:	GMT->current.setting.proj_aux_latitude = GMT_LATSWAP_G2A;
gmt_init.c:	GMT->current.setting.proj_ellipsoid = gmt_get_ellipsoid (GMT, "WGS-84");
gmt_init.c:	GMT->current.setting.proj_geodesic = GMT_GEODESIC_VINCENTY;
gmt_init.c:	GMT->current.setting.proj_length_unit = GMT_CM;
gmt_init.c:	GMT->current.setting.proj_mean_radius = GMT_RADIUS_AUTHALIC;
gmt_init.c:	GMT->current.setting.proj_scale_factor = -1.0;
gmt_init.c:	GMT->current.setting.compatibility = (GMT->current.setting.run_mode == GMT_CLASSIC) ? 4 : 6;
gmt_init.c:	GMT->current.setting.auto_download = GMT_YES_DOWNLOAD;
gmt_init.c:	GMT->current.setting.url_size_limit = 0;
gmt_init.c:	GMT->current.setting.export_type = GMT_DOUBLE;
gmt_init.c:	GMT->current.setting.extrapolate_val[0] = GMT_EXTRAPOLATE_NONE;
gmt_init.c:	GMT->current.setting.fft = k_fft_auto;
gmt_init.c:	GMT->current.setting.graphics_format = GMT_SESSION_FORMAT;
gmt_init.c:	GMT->current.setting.history = (GMT_HISTORY_READ | GMT_HISTORY_WRITE);
gmt_init.c:	GMT->current.setting.interpolant = GMT_SPLINE_AKIMA;
gmt_init.c:	strcpy (GMT->current.setting.language, "us");
gmt_init.c:	GMT->current.setting.triangulate = GMT_TRIANGLE_SHEWCHUK;
gmt_init.c:	GMT->current.setting.triangulate = GMT_TRIANGLE_WATSON;
gmt_init.c:	if (GMT->session.DCWDIR)
gmt_init.c:		gmt_M_str_free (GMT->session.DCWDIR);
gmt_init.c:	GMT->session.DCWDIR = strdup (DCW_INSTALL_PATH);
gmt_init.c:	if (GMT->session.GSHHGDIR)
gmt_init.c:		gmt_M_str_free (GMT->session.GSHHGDIR);
gmt_init.c:	GMT->session.GSHHGDIR = strdup (GSHHG_INSTALL_PATH);
gmt_init.c:	strcpy (GMT->current.setting.time_system.epoch, "1970-01-01T00:00:00");
gmt_init.c:	(void) gmt_init_time_system_structure (GMT, &GMT->current.setting.time_system);
gmt_init.c:	GMT->current.setting.time_is_interval = false;
gmt_init.c:	GMT->current.setting.time_interval_fraction = 0.5;
gmt_init.c:	GMT->current.setting.timer_mode = GMT_NO_TIMER;
gmt_init.c:	GMT->current.setting.time_system.unit = 's';
gmt_init.c:	(void) gmt_init_time_system_structure (GMT, &GMT->current.setting.time_system);
gmt_init.c:	GMT->current.setting.time_week_start = gmtinit_key_lookup ("Monday", GMT_weekdays, 7);
gmt_init.c:	GMT->current.setting.time_Y2K_offset_year = 1950;
gmt_init.c:	GMT->current.time.Y2K_fix.y2_cutoff = GMT->current.setting.time_Y2K_offset_year % 100;
gmt_init.c:	GMT->current.time.Y2K_fix.y100 = GMT->current.setting.time_Y2K_offset_year - GMT->current.time.Y2K_fix.y2_cutoff;
gmt_init.c:	GMT->current.time.Y2K_fix.y200 = GMT->current.time.Y2K_fix.y100 + 100;
gmt_init.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error: Unrecognized value during gmtdefaults initialization.\n");
gmt_init.c:	GMT->current.setting.proj_length_unit = GMT_INCH;
gmt_init.c:	strcpy (GMT->current.setting.ps_encoding.name, "Standard+");
gmt_init.c:	if (GMT->current.setting.run_mode == GMT_MODERN)
gmt_init.c:		GMT->current.setting.ps_media = i;
gmt_init.c:		GMT->current.setting.ps_page_size[0] = GMT_media[i].width;
gmt_init.c:		GMT->current.setting.ps_page_size[1] = GMT_media[i].height;
gmt_init.c:	GMT->current.setting.time_week_start = gmtinit_key_lookup ("Sunday", GMT_weekdays, 7);
gmt_init.c:	GMT->session.font = gmt_M_malloc (GMT, GMT->session.font, 0, &n_alloc, struct GMT_FONTSPEC);
gmt_init.c:	gmt_M_memcpy (GMT->session.font, GMT_standard_fonts, GMT_N_STANDARD_FONTS, struct GMT_FONTSPEC);
gmt_init.c:	GMT->session.n_fonts = n_GMT_fonts = i = GMT_N_STANDARD_FONTS;
gmt_init.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Cannot open %s\n", fullname);
gmt_init.c:			if (i == n_alloc) GMT->session.font = gmt_M_malloc (GMT, GMT->session.font, i, &n_alloc, struct GMT_FONTSPEC);
gmt_init.c:			if (sscanf (buf, "%s %lf %*d", fullname, &GMT->session.font[i].height) != 2) {
gmt_init.c:				GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Trouble decoding custom font info [%s].  Skipping this font.\n", buf);
gmt_init.c:				GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Font %s exceeds %d characters and will be truncated\n", fullname, GMT_LEN32);
gmt_init.c:			strncpy (GMT->session.font[i].name, fullname, GMT_LEN32-1);
gmt_init.c:		GMT->session.n_fonts = i;
gmt_init.c:	GMT->session.font = gmt_M_malloc (GMT, GMT->session.font, 0, &n_alloc, struct GMT_FONTSPEC);
gmt_init.c:	GMT->current.time.today_rata_die = gmt_rd_from_gymd (GMT, 1900 + moment->tm_year, moment->tm_mon + 1, moment->tm_mday);
gmt_init.c:	if (GMT->session.n_user_media == 0) return;	/* Nothing to free */
gmt_init.c:	for (i = 0; i < GMT->session.n_user_media; i++)
gmt_init.c:		gmt_M_str_free (GMT->session.user_media_name[i]);
gmt_init.c:	gmt_M_free (GMT, GMT->session.user_media_name);
gmt_init.c:	gmt_M_free (GMT, GMT->session.user_media);
gmt_init.c:	GMT->session.n_user_media = 0;
gmt_init.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error decoding file %s.  Bad format? [%s]\n", file, line);
gmt_init.c:			GMT->session.user_media = gmt_M_malloc (GMT, GMT->session.user_media, n, &k, struct GMT_MEDIA);
gmt_init.c:			GMT->session.user_media_name = gmt_M_malloc (GMT, GMT->session.user_media_name, n, &n_alloc, char *);
gmt_init.c:		GMT->session.user_media_name[n] = strdup (media);
gmt_init.c:		GMT->session.user_media[n].width  = w;
gmt_init.c:		GMT->session.user_media[n].height = h;
gmt_init.c:	GMT->session.user_media = gmt_M_malloc (GMT, GMT->session.user_media, 0, &n_alloc, struct GMT_MEDIA);
gmt_init.c:	GMT->session.user_media_name = gmt_M_malloc (GMT, GMT->session.user_media_name, 0, &n_alloc, char *);
gmt_init.c:	GMT->session.n_user_media = n;
gmt_init.c:	gmt_M_str_free (GMT->session.SHAREDIR);
gmt_init.c:	gmt_M_str_free (GMT->session.HOMEDIR);
gmt_init.c:	gmt_M_str_free (GMT->session.DATADIR);
gmt_init.c:	gmt_M_str_free (GMT->session.DCWDIR);
gmt_init.c:	gmt_M_str_free (GMT->session.GSHHGDIR);
gmt_init.c:	gmt_M_str_free (GMT->session.USERDIR);
gmt_init.c:	gmt_M_str_free (GMT->session.CACHEDIR);
gmt_init.c:	gmt_M_str_free (GMT->session.TMPDIR);
gmt_init.c:	gmt_M_str_free (GMT->session.CUSTOM_LIBS);
gmt_init.c:	gmt_M_str_free (GMT->session.DATASERVER);
gmt_init.c:	gmt_M_memcpy (GMT->current.setting.ref_ellipsoid, ref_ellipsoid, 1, ref_ellipsoid);
gmt_init.c:	gmt_M_memcpy (GMT->current.setting.proj_datum, datum, 1, datum);
gmt_init.c:	GMT->parent = API;
gmt_init.c:	GMT->session.std[GMT_IN]  = stdin;
gmt_init.c:	GMT->session.std[GMT_OUT] = stdout;
gmt_init.c:	GMT->session.std[GMT_ERR] = stderr;
gmt_init.c:	GMT->current.setting.verbose = GMT_MSG_COMPAT;
gmt_init.c:	GMT->session.min_meminc = GMT_MIN_MEMINC;
gmt_init.c:	GMT->session.max_meminc = GMT_MAX_MEMINC;
gmt_init.c:	GMT->init.module_name = GMT->init.module_lib = NULL;
gmt_init.c:	GMT->init.runtime_bindir = strdup (path);
gmt_init.c:	GMT->init.runtime_libdir = strdup (path);
gmt_init.c:	GMT->current.map.n_lon_nodes = 360;
gmt_init.c:	GMT->current.map.n_lat_nodes = 180;
gmt_init.c:	GMT->current.map.frame.check_side = false;
gmt_init.c:	GMT->current.map.frame.horizontal = 0;
gmt_init.c:	GMT->current.map.dlon = (GMT->common.R.wesn[XHI] - GMT->common.R.wesn[XLO]) / GMT->current.map.n_lon_nodes;
gmt_init.c:	GMT->current.map.dlat = (GMT->common.R.wesn[YHI] - GMT->common.R.wesn[YLO]) / GMT->current.map.n_lat_nodes;
gmt_init.c:	GMT->current.plot.mode_3D = 3;	/* Draw both fore and/or back 3-D box lines [1 + 2] */
gmt_init.c:	GMT->current.proj.projection = GMT_NO_PROJ;
gmt_init.c:	GMT->current.proj.fwd_x = GMT->current.proj.fwd_y = GMT->current.proj.fwd_z = &gmt_translin;
gmt_init.c:	GMT->current.proj.inv_x = GMT->current.proj.inv_y = GMT->current.proj.inv_z = &gmt_itranslin;
gmt_init.c:	GMT->current.proj.z_level = DBL_MAX;
gmt_init.c:	GMT->current.proj.xyz_pos[GMT_X] = GMT->current.proj.xyz_pos[GMT_Y] = GMT->current.proj.xyz_pos[GMT_Z] = true;
gmt_init.c:	GMT->current.proj.z_project.view_azimuth = 180.0;
gmt_init.c:	GMT->current.proj.z_project.view_elevation = 90.0;
gmt_init.c:	GMT->current.proj.z_project.plane = -1;	/* Initialize no perspective projection */
gmt_init.c:	GMT->current.proj.z_project.level = 0.0;
gmt_init.c:	for (i = 0; i < 4; i++) GMT->current.proj.edge[i] = true;
gmt_init.c:	GMT->current.proj.f_horizon = 90.0;
gmt_init.c:	GMT->current.proj.proj4 = gmt_M_memory (GMT, NULL, GMT_N_PROJ4, struct GMT_PROJ4);
gmt_init.c:		GMT->current.proj.proj4[i].name = strdup (GMT_proj4[i].name);
gmt_init.c:		GMT->current.proj.proj4[i].id = GMT_proj4[i].id;
gmt_init.c:	strcpy (GMT->current.setting.time_system.epoch, "2000-01-01T12:00:00");
gmt_init.c:	GMT->current.setting.time_system.unit = 'd';
gmt_init.c:	gmt_M_memcpy (GMT->session.u2u, u2u, 1, u2u);
gmt_init.c:	for (i = 0; i < 4; i++) strncpy (GMT->session.unit_name[i], unit_name[i], 7U);
gmt_init.c:	gmt_M_make_fnan (GMT->session.f_NaN);
gmt_init.c:	gmt_M_make_dnan (GMT->session.d_NaN);
gmt_init.c:	for (i = 0; i < 3; i++) GMT->session.no_rgb[i] = -1.0;
gmt_init.c:	GMT->common.x.n_threads = gmtlib_get_num_processors();
gmt_init.c:	strcpy (GMT->init.cpt[0], GMT_DEFAULT_CPT_NAME);	/* GMT default CPT unless overridden by data type specific CPT */
gmt_init.c:	strcpy (GMT->init.cpt[1], GMT_DEM_CPT_NAME);		/* GMT default CPT for earth_relief grids */
gmt_init.c:	strcpy (GMT->init.cpt[2], GMT_SRTM_CPT_NAME);		/* GMT default CPT for srtm_relief grids */
gmt_init.c:	if (GMT->current.setting.run_mode == GMT_MODERN)
gmt_init.c:	if (GMT->common.synopsis.extended) return;	/* Only want to list module-specific options, i.e gave + instead of - */
gmt_init.c:	u = GMT->session.unit_name[GMT->current.setting.proj_length_unit][0];
gmt_init.c:	s = GMT->session.u2u[GMT_INCH][GMT->current.setting.proj_length_unit];	/* Convert from internal inch to users unit */
gmt_init.c:			             GMT_weekdays[GMT->current.setting.time_week_start]);
gmt_init.c:			gmt_message (GMT, "\t       K: ISO weekday - plot name of weekdays in selected language [%s].\n", GMT->current.setting.language);
gmt_init.c:			             GMT->session.unit_name[GMT->current.setting.proj_length_unit]);
gmt_init.c:			             GMT->session.unit_name[GMT->current.setting.proj_length_unit]);
gmt_init.c:			gmt_message (GMT, "\t     in %s to the oblique parallel <lat>.\n", GMT->session.unit_name[GMT->current.setting.proj_length_unit]);
gmt_init.c:			gmt_message (GMT, "\t     in %s to the oblique parallel <lat>. \n", GMT->session.unit_name[GMT->current.setting.proj_length_unit]);
gmt_init.c:			gmt_message (GMT, "\t     in %s to the oblique parallel <lat>. \n", GMT->session.unit_name[GMT->current.setting.proj_length_unit]);
gmt_init.c:			gmt_message (GMT, "\t     in %s to the oblique parallel <lat>. \n", GMT->session.unit_name[GMT->current.setting.proj_length_unit]);
gmt_init.c:			gmt_message (GMT, "\t     in %s to the oblique parallel <lat>. \n", GMT->session.unit_name[GMT->current.setting.proj_length_unit]);
gmt_init.c:			             GMT->session.unit_name[GMT->current.setting.proj_length_unit]);
gmt_init.c:			             GMT->session.unit_name[GMT->current.setting.proj_length_unit]);
gmt_init.c:			gmt_message (GMT, "\t     Give zone (A,B,Y,Z, or 1-60 (negative for S hemisphere) or append GMT-X) and scale\n");
gmt_init.c:			             GMT->session.unit_name[GMT->current.setting.proj_length_unit]);
gmt_init.c:			             GMT->session.unit_name[GMT->current.setting.proj_length_unit],
gmt_init.c:			             GMT->session.unit_name[GMT->current.setting.proj_length_unit]);
gmt_init.c:			if (GMT->current.setting.run_mode == GMT_CLASSIC && !GMT->current.setting.use_modern_name)	/* -K don't exist in modern mode */
gmt_init.c:			if (GMT->current.setting.run_mode == GMT_CLASSIC && !GMT->current.setting.use_modern_name)	/* -O don't exist in modern mode */
gmt_init.c:			if (GMT->current.setting.run_mode == GMT_CLASSIC && !GMT->current.setting.use_modern_name)	/* -P don't exist in modern mode */
gmt_init.c:				gmt_message (GMT, "\t-P Set Portrait page orientation [%s].\n", GMT_choice[GMT->current.setting.ps_orientation]);
gmt_init.c:			gmt_message (GMT, "\t   [+jBL+o-54p/-54p].  Add +c to have the command line plotted [%s].\n", GMT_choice[GMT->current.setting.map_logo]);
gmt_init.c:			gmt_message (GMT, "\t-V Change the verbosity level (currently %c).\n", V_code[GMT->current.setting.verbose]);
gmt_init.c:			             GMT->current.setting.map_origin[GMT_Y] * s, u);
gmt_init.c:			             GMT->session.unit_name[GMT->current.setting.proj_length_unit],
gmt_init.c:			             GMT->session.unit_name[GMT->current.setting.proj_length_unit]);
gmt_init.c:			             GMT->session.unit_name[GMT->current.setting.proj_length_unit]);
gmt_init.c:			if (GMT->current.setting.run_mode == GMT_MODERN || GMT->current.setting.use_modern_name)	/* -c has no use in classic */
gmt_init.c:			             GMT_DIM_UNITS_DISPLAY, GMT->session.unit_name[GMT->current.setting.proj_length_unit]);
gmt_init.c:			             GMT->current.setting.io_n_header_items, GMT_choice[GMT->current.setting.io_header[GMT_IN]]);
gmt_init.c:			             GMT_choice[GMT->current.setting.io_lonlat_toggle[GMT_IN]], GMT_choice[GMT->current.setting.io_lonlat_toggle[GMT_OUT]]);
gmt_init.c:	if (kind < 2) gmt_message (GMT, "%s +f sets specified label font [Default is %s].\n", pad, gmt_putfont (GMT, &GMT->current.setting.font_annot[GMT_PRIMARY]));
gmt_init.c:	gap = 4.0 * GMT->session.u2u[GMT_INCH][GMT->current.setting.proj_length_unit];
gmt_init.c:		pad, GMT_DIM_UNITS_DISPLAY, GMT_LEN_UNITS_DISPLAY, gap, GMT->session.unit_name[GMT->current.setting.proj_length_unit][0]);
gmt_init.c:	if (error) GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -%c option.  Correct syntax:\n", option);
gmt_init.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -%s option.  Correct syntax:\n", longoption);
gmt_init.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -%c option.  Correct syntax:\n", option);
gmt_init.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -%s option.  Correct syntax:\n", longoption);
gmt_init.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -%c option.  Correct syntax:\n", option);
gmt_init.c:		gmt_message (GMT, string, gmt_putpen (GMT, &GMT->current.setting.map_default_pen));
gmt_init.c:	if (string[0] == ' ') GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -%c option.  Correct syntax:\n", option);
gmt_init.c:	if (string[0] == ' ') GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -%c option.  Correct syntax:\n", option);
gmt_init.c:	if (GMT->current.setting.run_mode == GMT_CLASSIC) {
gmt_init.c:	if (string[0] == ' ') GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -%c option.  Correct syntax:\n", option);
gmt_init.c:	if (string[0] == ' ') GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -%c option.  Correct syntax:\n", option);
gmt_init.c:	if (string[0] == ' ') GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -%c option.  Correct syntax:\n", option);
gmt_init.c:		gmt_putpen (GMT, &GMT->current.setting.map_frame_pen));
gmt_init.c:	if (string[0] == ' ') GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -%c option.  Correct syntax:\n", option);
gmt_init.c:	gmt_message (GMT, "\t     +h sets the vector head shape in -2/2 range [%g].\n", GMT->current.setting.map_vector_shape);
gmt_init.c:	char *u = GMT->session.unit_name[GMT->current.setting.proj_length_unit];
gmt_init.c:	GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -%c option. Correct syntax:\n", option);
gmt_init.c:			switch (GMT->current.proj.projection_GMT) {
gmt_init.c:		case 'B': error += (GMT->common.B.active[GMT_PRIMARY] == false && GMT->common.B.active[GMT_SECONDARY] == false); break;
gmt_init.c:		case 'J': error += GMT->common.J.active == false; break;
gmt_init.c:		case 'K': error += GMT->common.K.active == false; break;
gmt_init.c:		case 'O': error += GMT->common.O.active == false; break;
gmt_init.c:		case 'P': error += GMT->common.P.active == false; break;
gmt_init.c:		case 'R': error += GMT->common.R.active[RSET] == false; break;
gmt_init.c:		case 'U': error += GMT->common.U.active == false; break;
gmt_init.c:		case 'V': error += GMT->common.V.active == false; break;
gmt_init.c:		case 'X': error += GMT->common.X.active == false; break;
gmt_init.c:		case 'Y': error += GMT->common.Y.active == false; break;
gmt_init.c:		case 'a': error += GMT->common.a.active == false; break;
gmt_init.c:		case 'b': error += ((GMT->common.b.active[GMT_IN] == false && GMT->common.b.nc[GMT_IN] == false) \
gmt_init.c:			&& (GMT->common.b.active[GMT_OUT] == false && GMT->common.b.nc[GMT_OUT] == false)); break;
gmt_init.c:		case 'd': error += (GMT->common.d.active[GMT_IN] == false && GMT->common.d.active[GMT_OUT] == false); break;
gmt_init.c:		case 'e': error += GMT->common.e.active == false; break;
gmt_init.c:		case 'f': error += (GMT->common.f.active[GMT_IN] == false &&  GMT->common.f.active[GMT_OUT] == false); break;
gmt_init.c:		case 'g': error += GMT->common.g.active == false; break;
gmt_init.c:				error += GMT->common.h.active == false;
gmt_init.c:		case 'h': error += GMT->common.h.active == false; break;
gmt_init.c:		case 'i': error += GMT->common.i.active == false; break;
gmt_init.c:		case 'j': error += GMT->common.j.active == false; break;
gmt_init.c:		case 'l': error += GMT->common.l.active == false; break;
gmt_init.c:		case 'n': error += GMT->common.n.active == false; break;
gmt_init.c:		case 'o': error += GMT->common.o.active == false; break;
gmt_init.c:				error += GMT->common.p.active == false;
gmt_init.c:		case 'p': error += GMT->common.p.active == false; break;
gmt_init.c:		case 'r': error += GMT->common.R.active[GSET] == false; break;
gmt_init.c:		case 's': error += GMT->common.s.active == false; break;
gmt_init.c:		case 't': error += GMT->common.t.active == false; break;
gmt_init.c:		case 'x': error += GMT->common.x.active == false; break;
gmt_init.c:		case ':': error += GMT->common.colon.active == false; break;
gmt_init.c:	if (error) GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Unrecognized option -%c\n", option);
gmt_init.c:	if (GMT->current.setting.run_mode == GMT_MODERN) {	/* Must handle any internal history regarding increments and registration */
gmt_init.c:			GMT->common.R.active[GSET] = true;
gmt_init.c:			GMT->common.R.registration = strchr(&c[2], 'P') != NULL || strchr(&c[2], 'p') != NULL ? GMT_GRID_PIXEL_REG : GMT_GRID_NODE_REG;
gmt_init.c:			GMT->common.R.row_order = strchr(&c[2], 'T') != NULL || strchr(&c[2], 't') != NULL ? k_nc_start_north : k_nc_start_south;
gmt_init.c:			GMT_Report (GMT->parent, GMT_MSG_DEBUG, "GMT modern: Obtained grid registration and/or row order from -R%s\n", item);
gmt_init.c:			if (gmt_getinc (GMT, &d[2], GMT->common.R.inc)) {
gmt_init.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error in GMT modern: Error parsing the grid spacing.\n");
gmt_init.c:			GMT->common.R.active[ISET] = true;
gmt_init.c:			GMT_Report (GMT->parent, GMT_MSG_DEBUG, "GMT modern: Obtained grid spacing from -R%s\n", item);
gmt_init.c:	strncpy (GMT->common.R.string, item, GMT_LEN256-1);	/* Verbatim copy */
gmt_init.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error -R: Unrecognized justification code %s\n", code);
gmt_init.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error -R%s<lon0>/<lat0>/<n_columns>/<n_rows>: Did not get 4 items\n", code);
gmt_init.c:					GMT->current.proj.xyz_projection[icol] = GMT_TIME;
gmt_init.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error in -R%s<lon0>/<lat0>/<n_columns>/<n_rows>: Could not parse coordinate pair\n", code);
gmt_init.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error in -R%s<lon0>/<lat0>/<n_columns>/<n_rows>: Must have positive dimensions\n", code);
gmt_init.c:		if (!GMT->common.R.active[GSET]) n_columns--, n_rows--;	/* Needed to get correct dimensions */
gmt_init.c:		xdim = n_columns * GMT->common.R.inc[GMT_X];
gmt_init.c:		ydim = n_rows * GMT->common.R.inc[GMT_Y];
gmt_init.c:		GMT->common.R.wesn[XLO] = orig[GMT_X] - 0.5 * ((just%4)-1) * xdim;
gmt_init.c:		GMT->common.R.wesn[YLO] = orig[GMT_Y] - 0.5 * part * ydim;
gmt_init.c:		GMT->common.R.wesn[XHI] = GMT->common.R.wesn[XLO] + xdim;
gmt_init.c:		GMT->common.R.wesn[YHI] = GMT->common.R.wesn[YLO] + ydim;
gmt_init.c:			GMT->common.R.wesn[XLO] = 0.0, GMT->common.R.wesn[XHI] = 360.0;
gmt_init.c:			GMT->current.io.geo.range = GMT_IS_0_TO_P360_RANGE;
gmt_init.c:			GMT->common.R.wesn[XLO] = -180.0, GMT->common.R.wesn[XHI] = 180.0;
gmt_init.c:			GMT->current.io.geo.range = GMT_IS_M180_TO_P180_RANGE;
gmt_init.c:		GMT->common.R.wesn[YLO] = -90.0;	GMT->common.R.wesn[YHI] = +90.0;
gmt_init.c:		if ((G = GMT_Read_Data (GMT->parent, GMT_IS_GRID, GMT_IS_FILE, GMT_IS_SURFACE, GMT_CONTAINER_ONLY, NULL, &item[first], NULL)) == NULL) {	/* Read header */
gmt_init.c:			return (GMT->parent->error);
gmt_init.c:		if ((GMT->current.proj.projection_GMT == GMT_UTM || GMT->current.proj.projection_GMT == GMT_TM || GMT->current.proj.projection_GMT == GMT_STEREO)) {	/* Perhaps we got an [U]TM or stereographic grid? */
gmt_init.c:			gmt_M_memcpy (GMT->common.R.wesn, G->header->wesn, 4, double);
gmt_init.c:			if (GMT->common.R.active[ISET] == false) gmt_M_memcpy (GMT->common.R.inc, G->header->inc, 2, double);	/* Do not override settings given via -I */
gmt_init.c:			GMT->common.R.registration = (GMT->common.R.active[GSET]) ? !G->header->registration : G->header->registration;	/* Set, or toggle registration if -r was set */
gmt_init.c:			GMT->common.R.row_order = HH->row_order;	/* Copy the row order */
gmt_init.c:			GMT_Report (GMT->parent, GMT_MSG_DEBUG,
gmt_init.c:				"-R<grdfile> converted to -R%.16g/%.16g/%.16g/%.16g\n", GMT->common.R.wesn[XLO], GMT->common.R.wesn[XHI], GMT->common.R.wesn[YLO], GMT->common.R.wesn[YHI]);
gmt_init.c:			if (GMT->common.R.registration == GMT_GRID_NODE_REG && doubleAlmostEqualZero (GMT->common.R.wesn[XHI] - GMT->common.R.wesn[XLO] + GMT->common.R.inc[GMT_X], 360.0)) {
gmt_init.c:				GMT_Report (GMT->parent, GMT_MSG_DEBUG,
gmt_init.c:				if (gmt_M_is_zero (GMT->common.R.wesn[XLO]) || doubleAlmostEqualZero (GMT->common.R.wesn[XLO], -180.0))
gmt_init.c:					GMT->common.R.wesn[XHI] = GMT->common.R.wesn[XLO] + 360.0;
gmt_init.c:					GMT->common.R.wesn[XLO] = GMT->common.R.wesn[XHI] - 360.0;
gmt_init.c:			GMT->common.R.wesn[ZLO] = G->header->z_min;	GMT->common.R.wesn[ZHI] = G->header->z_max;
gmt_init.c:			GMT->common.R.active[ISET] = GMT->common.R.active[GSET] = GMT->common.R.active[FSET] = true;
gmt_init.c:			if (GMT_Destroy_Data (GMT->parent, &G) != GMT_OK)
gmt_init.c:				return (GMT->parent->error);
gmt_init.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Got global region (%s)\n", item);
gmt_init.c:		GMT->current.io.geo.range = (item[0] == 'g') ? GMT_IS_0_TO_P360_RANGE : GMT_IS_M180_TO_P180_RANGE;
gmt_init.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Got country code for region (%s)\n", item);
gmt_init.c:		(void) gmt_DCW_operation (GMT, &info, GMT->common.R.wesn, GMT_DCW_REGION);	/* Get region */
gmt_init.c:		if (fabs (GMT->common.R.wesn[XLO]) > 1000.0) return (GMT_MAP_NO_REGION);
gmt_init.c:			GMT->common.R.wesn[XLO] = -180.0;
gmt_init.c:			GMT->common.R.wesn[XHI] = +180.0;
gmt_init.c:			GMT->common.R.wesn[YLO] = -90.0;
gmt_init.c:		if (GMT->common.R.wesn[XLO] < 0.0 && GMT->common.R.wesn[XHI] > 0.0)
gmt_init.c:			GMT->current.io.geo.range = GMT_IS_M180_TO_P180_RANGE;
gmt_init.c:			GMT->current.io.geo.range = GMT_IS_0_TO_P360_RANGE;
gmt_init.c:	else if (item[length] != 'r' && !strstr (item, "+r") && (GMT->current.proj.projection_GMT == GMT_UTM || GMT->current.proj.projection_GMT == GMT_TM || GMT->current.proj.projection_GMT == GMT_STEREO)) {
gmt_init.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "For a UTM or TM projection, your region %s is too large to be in degrees and thus assumed to be in meters\n", string);
gmt_init.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Got regular w/e/s/n for region (%s)\n", item);
gmt_init.c:		GMT->common.R.oblique = true;
gmt_init.c:		GMT->common.R.oblique = true;
gmt_init.c:		GMT->common.R.oblique = false;
gmt_init.c:		else if (GMT->common.R.oblique)
gmt_init.c:		if (icol < 2 && GMT->current.setting.io_lonlat_toggle[GMT_IN]) icol = 1 - icol;	/* col_types were swapped */
gmt_init.c:					GMT->current.proj.xyz_projection[icol] = GMT_TIME;
gmt_init.c:					GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Could not parse %s into Geographical, Cartesian, or Temporal coordinates!", text);
gmt_init.c:	if (GMT->common.R.oblique) {
gmt_init.c:		gmt_M_memcpy (GMT->common.R.wesn_orig, p, 4, double);	/* Save these in case they get enlarged by oblique projections */
gmt_init.c:		GMT->common.R.oblique = false;
gmt_init.c:		GMT->common.R.oblique = true;
gmt_init.c:			GMT_Report (GMT->parent, GMT_MSG_VERBOSE,
gmt_init.c:		else if (p[0] > p[1] && GMT->common.R.oblique && !GMT->common.J.active) {	/* Used -Rw/s/e/nr for non mapping */
gmt_init.c:			if (GMT->current.io.geo.range == GMT_IS_M180_TO_P180_RANGE) p[0] -= 360.0; else p[1] += 360.0;
gmt_init.c:			GMT_Report (GMT->parent, GMT_MSG_VERBOSE,
gmt_init.c:			if (GMT->current.io.geo.range == GMT_IS_M180_TO_P180_RANGE) p[0] -= 360.0; else p[1] += 360.0;
gmt_init.c:			GMT_Report (GMT->parent, GMT_MSG_VERBOSE,
gmt_init.c:	if (i < 4 || i > 6 || ((!GMT->common.R.oblique && gmt_check_region (GMT, p)) || (i == 6 && p[4] >= p[5]))) error++;
gmt_init.c:	gmt_M_memcpy (GMT->common.R.wesn, p, 6, double);	/* This will probably be reset by gmt_map_setup */
gmt_init.c:	if (i == 6 && !GMT->current.proj.JZ_set && GMT->current.setting.run_mode == GMT_CLASSIC) {
gmt_init.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "-R with six parameters but no -Jz|Z given - ignore zmin/zmax\n");
gmt_init.c:		GMT->common.R.wesn[ZLO] = GMT->common.R.wesn[ZHI] = 0.0;
gmt_init.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "For -i: Sequence %s does not end at given stop value, reduced to %" PRIu64 "\n", p, *stop);
gmt_init.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Bad range [%s]: col, start-stop, start:stop, or start:step:stop must yield monotonically increasing positive selections\n", p);
gmt_init.c:		GMT->common.d.active[dir] = true;
gmt_init.c:		GMT->common.d.nan_proxy[dir] = atof (c);
gmt_init.c:		GMT->common.d.is_zero[dir] = doubleAlmostEqualZero (0.0, GMT->common.d.nan_proxy[dir]);
gmt_init.c:	if (first == GMT_IN) strncpy (GMT->common.d.string, arg, GMT_LEN64-1);	/* Verbatim copy */
gmt_init.c:	strncpy (GMT->common.e.string, arg, GMT_LEN64-1);	/* Make copy of -e argument verbatim */
gmt_init.c:	GMT->common.e.select = gmt_set_text_selection (GMT, arg);
gmt_init.c:	GMT->current.io.trailing_text[GMT_IN] = GMT->current.io.trailing_text[GMT_OUT] = false;	/* When using -i you have to specifically add column t to parse trailing text */
gmt_init.c:	GMT->common.i.end = false;
gmt_init.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Selection -i%s (just trailing text, no numerical input) is not allowed.  Consider using -ot instead, if available.\n", arg);
gmt_init.c:		GMT->current.io.trailing_text[GMT_IN] = true;
gmt_init.c:	strncpy (GMT->common.i.string, arg, GMT_LEN64-1);	/* Verbatim copy */
gmt_init.c:	for (i = 0; i < GMT_MAX_COLUMNS; i++) GMT->current.io.col_skip[i] = true;	/* Initially, no input column is requested */
gmt_init.c:						GMT_Report (GMT->parent, GMT_MSG_NORMAL, "-i...s contains bad scale info\n");
gmt_init.c:			GMT->current.io.trailing_text[GMT_IN] = GMT->current.io.trailing_text[GMT_OUT] = true;
gmt_init.c:					GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Cannot give negative word position\n");
gmt_init.c:					GMT->common.i.word = true;
gmt_init.c:					GMT->common.i.w_col = k + 1;	/* Store as 1-nwords */
gmt_init.c:			if (stop == (GMT_MAX_COLUMNS-1)) GMT->common.i.end = true;	/* Gave an open interval, e.g., 3: or 4- to mean "until last column" */
gmt_init.c:				GMT->current.io.col_skip[i] = false;	/* Do not skip these */
gmt_init.c:				GMT->current.io.col[GMT_IN][k].col = (unsigned int)i;	/* Requested physical column */
gmt_init.c:				GMT->current.io.col[GMT_IN][k].order = k;		/* Requested logical order of columns */
gmt_init.c:				GMT->current.io.col[GMT_IN][k].convert = convert;
gmt_init.c:				GMT->current.io.col[GMT_IN][k].scale = scale;
gmt_init.c:				GMT->current.io.col[GMT_IN][k].offset = offset;
gmt_init.c:	qsort (GMT->current.io.col[GMT_IN], k, sizeof (struct GMT_COL_INFO), gmtinit_compare_cols);
gmt_init.c:	GMT->common.i.n_cols = k;
gmt_init.c:		GMT->common.i.n_actual_cols = 1;
gmt_init.c:		for (i = 1; i < k; i++) if (GMT->current.io.col[GMT_IN][i].col != GMT->current.io.col[GMT_IN][i-1].col)
gmt_init.c:			GMT->common.i.n_actual_cols++;
gmt_init.c:	GMT->common.i.orig = GMT->common.i.select = true;
gmt_init.c:	if (GMT->common.i.n_cols == 0 && GMT->current.io.trailing_text[GMT_IN]) {
gmt_init.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "-it is not allowed, need at least 1-2 leading numerical columns\n");
gmt_init.c:		case 'c': GMT->common.j.mode = GMT_NO_MODE; break;
gmt_init.c:		case 'e': GMT->common.j.mode = GMT_GEODESIC; break;
gmt_init.c:		case 'f': GMT->common.j.mode = GMT_FLATEARTH; break;
gmt_init.c:		case 'g': case '\0': GMT->common.j.mode = GMT_GREATCIRCLE; break;
gmt_init.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "-j argument %s is not one of the valid modes e|f|g\n", arg);
gmt_init.c:	strncpy (GMT->common.j.string, arg, GMT_LEN8-1);
gmt_init.c:	if (GMT->current.setting.run_mode == GMT_CLASSIC) {     /* Not in modern mode */
gmt_init.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "-l is only recognized in modern mode\n");
gmt_init.c:	gmt_M_memset (&(GMT->common.l.item), 1, struct GMT_LEGEND_ITEM);	/* Initialize */
gmt_init.c:					GMT->common.l.item.draw |= GMT_LEGEND_DRAW_D;
gmt_init.c:					if (&txt[1]) strncpy (GMT->common.l.item.pen[GMT_LEGEND_PEN_D], &txt[1], GMT_LEN32-1);
gmt_init.c:				case 'f': strncpy (GMT->common.l.item.font, &txt[1], GMT_LEN32-1);		break;	/* Font to use for this -l entry */
gmt_init.c:				case 'g': strncpy (GMT->common.l.item.gap, &txt[1], GMT_LEN32-1);		break;	/* Gap before next item */
gmt_init.c:				case 'h': strncpy (GMT->common.l.item.header, &txt[1], GMT_LEN128-1); 		break;	/* Legend header */
gmt_init.c:				case 'j': GMT->common.l.item.just = gmt_just_decode (GMT, &txt[1], PSL_TR);	break;	/* legend placement */
gmt_init.c:							GMT_Report (GMT->parent, GMT_MSG_NORMAL, "-l +l<just>/<label> has bad justification %c\n", txt[1]);
gmt_init.c:						strncpy (GMT->common.l.item.subheader, &txt[3], GMT_LEN128-1);	/* Legend label */
gmt_init.c:						GMT->common.l.item.code = txt[1];	/* Justification code */
gmt_init.c:						strncpy (GMT->common.l.item.subheader, &txt[1], GMT_LEN128-1);	/* Legend label default left justified */
gmt_init.c:						GMT->common.l.item.code = 'L';
gmt_init.c:				case 'n': GMT->common.l.item.ncols = atoi (&txt[1]);				break;	/* Number of columns */
gmt_init.c:				case 's': GMT->common.l.item.size = gmt_M_to_inch (GMT, &txt[1]);		break;	/* Fixed size for a symbol */
gmt_init.c:					GMT->common.l.item.draw |= GMT_LEGEND_DRAW_V;
gmt_init.c:					if (&txt[1]) strncpy (GMT->common.l.item.pen[GMT_LEGEND_PEN_V], &txt[1], GMT_LEN32-1);
gmt_init.c:				case 'w': GMT->common.l.item.width = gmt_M_to_inch (GMT, &txt[1]);		break;	/* Legend width */
gmt_init.c:				case 'x': GMT->common.l.item.scale = atof (&txt[1]);				break;	/* Scale all symbols by this factor */
gmt_init.c:	if (arg[0]) strncpy (GMT->common.l.item.label, arg, GMT_LEN128-1);
gmt_init.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "The -o option does not take +l|o|s modifiers; consider -i instead.\n");
gmt_init.c:	strncpy (GMT->common.o.string, arg, GMT_LEN64-1);	/* Verbatim copy */
gmt_init.c:	GMT->current.io.trailing_text[GMT_OUT] = false;	/* When using -o you have to specifically add column t to parse trailing text */
gmt_init.c:		GMT->current.io.trailing_text[GMT_OUT] = true;
gmt_init.c:		GMT->common.o.text = true;	/* Special flag to switch to gmtlib_ascii_output_trailing_text output function later */
gmt_init.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Cannot give negative word position\n");
gmt_init.c:				GMT->common.o.word = true;
gmt_init.c:				GMT->common.o.w_col = kk + 1;	/* Store as 1-nwords */
gmt_init.c:		GMT->current.io.trailing_text[GMT_OUT] = true;
gmt_init.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Cannot give negative word position\n");
gmt_init.c:				GMT->common.o.word = true;
gmt_init.c:				GMT->common.o.w_col = kk + 1;	/* Store as 1-nwords */
gmt_init.c:			GMT->current.io.trailing_text[GMT_OUT] = true;	/* Include trailing text */
gmt_init.c:					GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Cannot give negative word position\n");
gmt_init.c:					GMT->common.o.word = true;
gmt_init.c:					GMT->common.o.w_col = kk + 1;	/* Store as 1-nwords */
gmt_init.c:			if (stop == (GMT_MAX_COLUMNS-1)) GMT->common.o.end = true;	/* Gave an open-ended interval, e.g., 3: or 3- to mean "from 3 until last column" */
gmt_init.c:				GMT->current.io.col[GMT_OUT][k].col = (unsigned int)i;	/* Requested order of columns */
gmt_init.c:				GMT->current.io.col[GMT_OUT][k].order = (unsigned int)k;		/* Requested order of columns */
gmt_init.c:	GMT->common.o.n_cols = k;
gmt_init.c:	if (GMT->common.b.active[GMT_OUT] && GMT->common.b.ncol[GMT_OUT] == 0) GMT->common.b.ncol[GMT_OUT] = GMT->common.b.ncol[GMT_IN];	/* Since -o machinery will march through */
gmt_init.c:	GMT->common.o.select = true;
gmt_init.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error -%c: Expected reference point coordinates but got this: %s\n", option, &in_arg[k]);
gmt_init.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error -%c: Selecting -Fc, -Fs, or -Fcs yields no change\n", option);
gmt_init.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error -%c: Only -Fr may accept refpoint = r\n", option);
gmt_init.c:	 *    GMT->common.b.ncol[GMT_IN] to be non-zero.
gmt_init.c:	if (!GMT->common.b.active[GMT_IN]) return (GMT_NOERROR);	/* Let machinery figure out input cols for ASCII */
gmt_init.c:	if (GMT->common.b.ncol[GMT_IN] == 0) GMT->common.b.ncol[GMT_IN] = n_req;
gmt_init.c:	if (GMT->common.b.ncol[GMT_IN] == 0) {
gmt_init.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error: Must specify number of columns in binary input data (-bi)\n");
gmt_init.c:	else if (n_req > GMT->common.b.ncol[GMT_IN]) {
gmt_init.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL,
gmt_init.c:			GMT->common.b.ncol[GMT_IN], n_req);
gmt_init.c:	if (GMT->common.b.ncol[GMT_IN] < GMT->common.i.n_actual_cols) {
gmt_init.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL,
gmt_init.c:			GMT->common.b.ncol[GMT_IN], GMT->common.i.n_actual_cols);
gmt_init.c:	if (GMT->common.b.active[GMT_OUT] && GMT->common.b.ncol[GMT_OUT] && (GMT->common.b.ncol[GMT_OUT] < GMT->common.o.n_cols)) {
gmt_init.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL,
gmt_init.c:			GMT->common.b.ncol[GMT_OUT], GMT->common.o.n_cols);
gmt_init.c:	GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Provides %d, expects %d-column binary data\n", GMT->common.b.ncol[GMT_IN], n_req);
gmt_init.c:	if ((i = GMT->common.g.n_methods) == GMT_N_GAP_METHODS) {
gmt_init.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Cannot specify more than %d gap criteria\n", GMT_N_GAP_METHODS);
gmt_init.c:	strncpy (GMT->common.g.string, txt, GMT_LEN64-1);	/* Verbatim copy */
gmt_init.c:		GMT->common.g.match_all = true;
gmt_init.c:			GMT_Report (GMT->parent, GMT_MSG_COMPAT, "Leading sign for gaps in -g is deprecated; use modifiers +n or +p instead\n");
gmt_init.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "gap value is negative; see -g syntax\n");
gmt_init.c:			GMT->common.g.method[i] = (gap == -1) ? GMT_NEGGAP_IN_COL : ((gap == +1) ? GMT_POSGAP_IN_COL : GMT_ABSGAP_IN_COL);
gmt_init.c:			GMT->common.g.col[i] = GMT_X;
gmt_init.c:			GMT->common.g.method[i] = (gap == -1) ? GMT_NEGGAP_IN_MAP_COL : ((gap == +1) ? GMT_POSGAP_IN_MAP_COL : GMT_ABSGAP_IN_MAP_COL);
gmt_init.c:			GMT->common.g.col[i] = GMT_X;
gmt_init.c:			GMT->common.g.method[i] = (gap == -1) ? GMT_NEGGAP_IN_COL : ((gap == +1) ? GMT_POSGAP_IN_COL : GMT_ABSGAP_IN_COL);
gmt_init.c:			GMT->common.g.col[i] = GMT_Y;
gmt_init.c:			GMT->common.g.method[i] = (gap == -1) ? GMT_NEGGAP_IN_MAP_COL : ((gap == +1) ? GMT_POSGAP_IN_MAP_COL : GMT_ABSGAP_IN_MAP_COL);
gmt_init.c:			GMT->common.g.col[i] = GMT_Y;
gmt_init.c:			GMT->common.g.method[i] = (gmt_M_is_geographic (GMT, GMT_IN)) ? GMT_GAP_IN_GDIST : GMT_GAP_IN_CDIST;
gmt_init.c:			GMT->common.g.col[i] = -1;
gmt_init.c:			GMT->common.g.method[i] = GMT_GAP_IN_PDIST;
gmt_init.c:			GMT->common.g.col[i] = -1;
gmt_init.c:			GMT->common.g.method[i] = (gap == -1) ? GMT_NEGGAP_IN_COL : ((gap == +1) ? GMT_POSGAP_IN_COL : GMT_ABSGAP_IN_COL);
gmt_init.c:			GMT->common.g.col[i] = 2;
gmt_init.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Bad gap selector (%c).  Choose from x|y|d|X|Y|D|[<col>]z\n", txt[k]);
gmt_init.c:			GMT->common.g.method[i] = (gap == -1) ? GMT_NEGGAP_IN_COL : ((gap == +1) ? GMT_POSGAP_IN_COL : GMT_ABSGAP_IN_COL);
gmt_init.c:			GMT->common.g.col[i] = atoi (&txt[c]);
gmt_init.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Bad gap selector (%c).  Choose from x|y|d|X|Y|D|[<col>]z\n", txt[0]);
gmt_init.c:	switch (GMT->common.g.method[i]) {
gmt_init.c:			GMT->common.g.get_dist[i] = &gmtinit_neg_col_dist;
gmt_init.c:			GMT->common.g.get_dist[i] = &gmtinit_pos_col_dist;
gmt_init.c:			GMT->common.g.get_dist[i] = &gmtinit_abs_col_dist;
gmt_init.c:			GMT->common.g.get_dist[i] = &gmtinit_neg_col_map_dist;
gmt_init.c:			GMT->common.g.get_dist[i] = &gmtinit_pos_col_map_dist;
gmt_init.c:			GMT->common.g.get_dist[i] = &gmtinit_abs_col_map_dist;
gmt_init.c:			GMT->common.g.get_dist[i] = &gmtinit_xy_true_dist;
gmt_init.c:			GMT->common.g.get_dist[i] = &gmtinit_xy_cart_dist;
gmt_init.c:			GMT->common.g.get_dist[i] = &gmtinit_xy_map_dist;
gmt_init.c:	if ((GMT->common.g.gap[i] = atof (&txt[k])) == 0.0) {
gmt_init.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Gap value must be non-zero\n");
gmt_init.c:	if (GMT->common.g.method[i] == GMT_GAP_IN_GDIST) {	/* Convert any gap given to meters */
gmt_init.c:				GMT->common.g.get_dist[i] = &gmtinit_xy_deg_dist;
gmt_init.c:				GMT->common.g.method[i] = GMT_GAP_IN_DDIST;
gmt_init.c:				GMT->common.g.get_dist[i] = &gmtinit_xy_deg_dist;
gmt_init.c:				GMT->common.g.method[i] = GMT_GAP_IN_DDIST;
gmt_init.c:				GMT->common.g.gap[i] *= GMT_MIN2DEG;
gmt_init.c:				GMT->common.g.get_dist[i] = &gmtinit_xy_deg_dist;
gmt_init.c:				GMT->common.g.method[i] = GMT_GAP_IN_DDIST;
gmt_init.c:				GMT->common.g.gap[i] *= GMT_SEC2DEG;
gmt_init.c:				GMT->common.g.gap[i] *= METERS_IN_A_FOOT;
gmt_init.c:				GMT->common.g.gap[i] *= 1000.0;
gmt_init.c:				GMT->common.g.gap[i] *= METERS_IN_A_MILE;
gmt_init.c:				GMT->common.g.gap[i] *= METERS_IN_A_NAUTICAL_MILE;
gmt_init.c:				GMT->common.g.gap[i] *= METERS_IN_A_SURVEY_FOOT;
gmt_init.c:	else if (GMT->common.g.method[i] == GMT_GAP_IN_PDIST){	/* Cartesian plot distance stuff */
gmt_init.c:				GMT->common.g.gap[i] /= 2.54;
gmt_init.c:				GMT->common.g.gap[i] /= 72.0;
gmt_init.c:	if ((uint64_t)(GMT->common.g.col[i] + 1) > GMT->common.g.n_col) GMT->common.g.n_col = (uint64_t)(GMT->common.g.col[i] + 1);	/* Needed when checking since it may otherwise not be read */
gmt_init.c:	GMT->common.g.n_methods++;
gmt_init.c:	GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Reading GMT Default parameters from file: %s\n", file);
gmt_init.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Last GMT Defaults parameter from command options had no value\n");
gmt_init.c:	if (n_errors) GMT_Report (GMT->parent, GMT_MSG_NORMAL, " %d GMT Defaults conversion errors from command options\n", n_errors);
gmt_init.c:			strncpy (GMT->current.setting.format_clock_in, value, GMT_LEN64-1);
gmt_init.c:			gmtlib_clock_C_format (GMT, GMT->current.setting.format_clock_in, &GMT->current.io.clock_input, 0);
gmt_init.c:			strncpy (GMT->current.setting.format_date_in, value, GMT_LEN64-1);
gmt_init.c:			gmtlib_date_C_format (GMT, GMT->current.setting.format_date_in, &GMT->current.io.date_input, 0);
gmt_init.c:			strncpy (GMT->current.setting.format_clock_out, value, GMT_LEN64-1);
gmt_init.c:			gmtlib_clock_C_format (GMT, GMT->current.setting.format_clock_out, &GMT->current.io.clock_output, 1);
gmt_init.c:			strncpy (GMT->current.setting.format_date_out, value, GMT_LEN64-1);
gmt_init.c:			gmtlib_date_C_format (GMT, GMT->current.setting.format_date_out, &GMT->current.io.date_output, 1);
gmt_init.c:			strncpy (GMT->current.setting.format_geo_out, value, GMT_LEN64-1);
gmt_init.c:			strncpy (GMT->current.setting.format_clock_map, value, GMT_LEN64-1);
gmt_init.c:			gmtlib_clock_C_format (GMT, GMT->current.setting.format_clock_map, &GMT->current.plot.calclock.clock, 2);
gmt_init.c:			strncpy (GMT->current.setting.format_date_map, value, GMT_LEN64-1);
gmt_init.c:			gmtlib_date_C_format (GMT, GMT->current.setting.format_date_map, &GMT->current.plot.calclock.date, 2);
gmt_init.c:			strncpy (GMT->current.setting.format_geo_map, value, GMT_LEN64-1);
gmt_init.c:			strncpy (GMT->current.setting.format_time[GMT_PRIMARY], value, GMT_LEN64-1);
gmt_init.c:			strncpy (GMT->current.setting.format_time[GMT_SECONDARY], value, GMT_LEN64-1);
gmt_init.c:			strncpy (GMT->current.setting.format_float_map, value, GMT_LEN64-1);
gmt_init.c:			strncpy (GMT->current.setting.format_time_stamp, value, GMT_LEN256-1);
gmt_init.c:				double scale = GMT->current.setting.font_annot[GMT_PRIMARY].size;
gmt_init.c:				if (gmt_getfont (GMT, &value[1], &GMT->current.setting.font_annot[GMT_PRIMARY])) error = true;
gmt_init.c:				scale = GMT->current.setting.font_annot[GMT_PRIMARY].size / scale;
gmt_init.c:				GMT->current.setting.font_annot[GMT_SECONDARY].size *= scale;
gmt_init.c:				GMT->current.setting.font_label.size *= scale;
gmt_init.c:				GMT->current.setting.font_heading.size *= scale;
gmt_init.c:				GMT->current.setting.font_tag.size *= scale;
gmt_init.c:				GMT->current.setting.font_title.size *= scale;
gmt_init.c:				GMT->current.setting.map_annot_offset[GMT_PRIMARY] *= scale;
gmt_init.c:				GMT->current.setting.map_annot_offset[GMT_SECONDARY] *= scale;
gmt_init.c:				GMT->current.setting.map_heading_offset *= scale;
gmt_init.c:				GMT->current.setting.map_label_offset *= scale;
gmt_init.c:				GMT->current.setting.map_title_offset *= scale;
gmt_init.c:				GMT->current.setting.map_frame_width *= scale;
gmt_init.c:				GMT->current.setting.map_tick_length[GMT_PRIMARY] *= scale;
gmt_init.c:				GMT->current.setting.map_tick_length[GMT_SECONDARY] *= scale;
gmt_init.c:				GMT->current.setting.map_tick_length[2] *= scale;
gmt_init.c:				GMT->current.setting.map_tick_length[3] *= scale;
gmt_init.c:				if (gmt_getfont (GMT, value, &GMT->current.setting.font_annot[GMT_PRIMARY])) error = true;
gmt_init.c:			if (gmt_getfont (GMT, value, &GMT->current.setting.font_annot[GMT_SECONDARY])) error = true;
gmt_init.c:			if (gmt_getfont (GMT, value, &GMT->current.setting.font_heading)) error = true;
gmt_init.c:			if (gmt_getfont (GMT, value, &GMT->current.setting.font_title)) error = true;
gmt_init.c:			if (gmt_getfont (GMT, value, &GMT->current.setting.font_tag)) error = true;
gmt_init.c:			if (gmt_getfont (GMT, value, &GMT->current.setting.font_label)) error = true;
gmt_init.c:			if (gmt_getfont (GMT, value, &GMT->current.setting.font_logo)) error = true;
gmt_init.c:					GMT->current.setting.font_annot[GMT_PRIMARY].size = dval;
gmt_init.c:					GMT->current.setting.font_annot[GMT_SECONDARY].size = dval;
gmt_init.c:					GMT->current.setting.font_title.size = dval;
gmt_init.c:					GMT->current.setting.font_label.size = dval;
gmt_init.c:			GMT->current.setting.map_annot_offset[GMT_PRIMARY] = gmt_M_to_inch (GMT, value);
gmt_init.c:			GMT->current.setting.map_annot_offset[GMT_SECONDARY] = gmt_M_to_inch (GMT, value);
gmt_init.c:				GMT->current.setting.map_annot_oblique = ival;
gmt_init.c:				GMT->current.setting.map_annot_min_angle = dval;
gmt_init.c:				GMT->current.setting.map_annot_min_spacing = gmt_M_to_inch (GMT, value);
gmt_init.c:					strncpy (GMT->current.setting.map_annot_ortho, "", 5U);
gmt_init.c:					strncpy (GMT->current.setting.map_annot_ortho, "we", 5U);
gmt_init.c:			strncpy (GMT->current.setting.map_annot_ortho, lower_value, 5U);
gmt_init.c:				GMT->current.setting.map_degree_symbol = gmt_degree;
gmt_init.c:				GMT->current.setting.map_degree_symbol = gmt_ring;
gmt_init.c:				GMT->current.setting.map_degree_symbol = gmt_colon;
gmt_init.c:				GMT->current.setting.map_degree_symbol = gmt_none;
gmt_init.c:			strncpy (GMT->current.setting.map_frame_axes, value, 5U);
gmt_init.c:			for (i = 0; i < 5; i++) GMT->current.map.frame.side[i] = 0;	/* Unset default settings */
gmt_init.c:			GMT->current.map.frame.draw_box = false;
gmt_init.c:			error = gmt_getpen (GMT, &value[i], &GMT->current.setting.map_default_pen);
gmt_init.c:				gmt_M_rgb_copy (&GMT->current.setting.map_grid_pen[GMT_PRIMARY].rgb, &GMT->current.setting.map_default_pen.rgb);
gmt_init.c:				gmt_M_rgb_copy (&GMT->current.setting.map_grid_pen[GMT_SECONDARY].rgb, &GMT->current.setting.map_default_pen.rgb);
gmt_init.c:				gmt_M_rgb_copy (&GMT->current.setting.map_frame_pen.rgb  , &GMT->current.setting.map_default_pen.rgb);
gmt_init.c:				gmt_M_rgb_copy (&GMT->current.setting.map_tick_pen[GMT_PRIMARY].rgb, &GMT->current.setting.map_default_pen.rgb);
gmt_init.c:				gmt_M_rgb_copy (&GMT->current.setting.map_tick_pen[GMT_SECONDARY].rgb, &GMT->current.setting.map_default_pen.rgb);
gmt_init.c:			error = gmt_getpen (GMT, value, &GMT->current.setting.map_frame_pen);
gmt_init.c:				GMT->current.setting.map_frame_type = GMT_IS_PLAIN;
gmt_init.c:				GMT->current.setting.map_frame_type = GMT_IS_GRAPH;
gmt_init.c:						GMT->current.setting.map_graph_extension_unit = unit;
gmt_init.c:						GMT->current.setting.map_graph_extension = atof (&c[1]);
gmt_init.c:						GMT->current.setting.map_graph_extension_unit = gmtlib_unit_lookup (GMT, unit, GMT->current.setting.proj_length_unit);	/* Will warn if c is not 0, 'c', 'i', 'p' */
gmt_init.c:						GMT->current.setting.map_graph_extension = gmt_M_to_inch (GMT, &c[1]);
gmt_init.c:					GMT->current.setting.map_graph_extension_unit = GMT_GRAPH_EXTENSION_UNIT;
gmt_init.c:					GMT->current.setting.map_graph_extension = GMT_GRAPH_EXTENSION;
gmt_init.c:				GMT->current.setting.map_frame_type = GMT_IS_FANCY;
gmt_init.c:				GMT->current.setting.map_frame_type = GMT_IS_ROUNDED;
gmt_init.c:				GMT->current.setting.map_frame_type = GMT_IS_INSIDE;
gmt_init.c:				GMT->current.setting.map_frame_width = dval;
gmt_init.c:				GMT->current.setting.map_grid_cross_size[GMT_PRIMARY] = GMT->current.setting.map_grid_cross_size[GMT_SECONDARY] = dval;
gmt_init.c:				GMT->current.setting.map_grid_cross_size[GMT_PRIMARY] = dval;
gmt_init.c:				GMT->current.setting.map_grid_cross_size[GMT_SECONDARY] = dval;
gmt_init.c:			error = gmt_getpen (GMT, value, &GMT->current.setting.map_grid_pen[GMT_PRIMARY]);
gmt_init.c:			error = gmt_getpen (GMT, value, &GMT->current.setting.map_grid_pen[GMT_SECONDARY]);
gmt_init.c:			GMT->current.setting.map_heading_offset = gmt_M_to_inch (GMT, value);
gmt_init.c:			GMT->current.setting.map_label_offset = gmt_M_to_inch (GMT, value);
gmt_init.c:			if ((GMT->current.setting.map_line_step = gmt_M_to_inch (GMT, value)) <= 0.0) {
gmt_init.c:				GMT->current.setting.map_line_step = 0.01;
gmt_init.c:				GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "%s <= 0, reset to %g %s\n", keyword, GMT->current.setting.map_line_step, GMT->session.unit_name[GMT_INCH]);
gmt_init.c:			error = gmtinit_true_false_or_error (lower_value, &GMT->current.setting.map_logo);
gmt_init.c:				GMT->current.setting.map_logo_pos[GMT_X] = gmt_M_to_inch (GMT, txt_a);
gmt_init.c:				GMT->current.setting.map_logo_pos[GMT_Y] = gmt_M_to_inch (GMT, txt_b);
gmt_init.c:				GMT->current.setting.map_logo_justify = gmt_just_decode (GMT, txt_a, PSL_NO_DEF);
gmt_init.c:				GMT->current.setting.map_logo_pos[GMT_X] = gmt_M_to_inch (GMT, txt_b);
gmt_init.c:				GMT->current.setting.map_logo_pos[GMT_Y] = gmt_M_to_inch (GMT, txt_c);
gmt_init.c:			GMT->current.setting.map_origin[GMT_X] = gmt_M_to_inch (GMT, value);
gmt_init.c:			GMT->current.setting.map_origin[GMT_Y] = gmt_M_to_inch (GMT, value);
gmt_init.c:				GMT->current.setting.map_polar_cap[0] = 90.0;
gmt_init.c:				GMT->current.setting.map_polar_cap[1] = 0.0;
gmt_init.c:					error = gmt_verify_expectations (GMT, GMT_IS_LAT, gmt_scanf (GMT, txt_a, GMT_IS_LAT, &GMT->current.setting.map_polar_cap[0]), txt_a);
gmt_init.c:				GMT->current.setting.map_polar_cap[1] = inc[GMT_X];
gmt_init.c:				GMT->current.setting.map_scale_height = dval;
gmt_init.c:				GMT->current.setting.map_tick_length[GMT_ANNOT_UPPER] = gmt_M_to_inch (GMT, value);
gmt_init.c:				GMT->current.setting.map_tick_length[GMT_TICK_UPPER]  = 0.50 * GMT->current.setting.map_tick_length[GMT_ANNOT_UPPER];
gmt_init.c:				GMT->current.setting.map_tick_length[GMT_ANNOT_LOWER] = 3.00 * GMT->current.setting.map_tick_length[GMT_ANNOT_UPPER];
gmt_init.c:				GMT->current.setting.map_tick_length[GMT_TICK_LOWER]  = 0.75 * GMT->current.setting.map_tick_length[GMT_ANNOT_UPPER];
gmt_init.c:			GMT->current.setting.map_tick_length[GMT_ANNOT_UPPER] = gmt_M_to_inch (GMT, txt_a);
gmt_init.c:			GMT->current.setting.map_tick_length[GMT_TICK_UPPER]  = (i > 1) ? gmt_M_to_inch (GMT, txt_b) : 0.50 * GMT->current.setting.map_tick_length[GMT_ANNOT_UPPER];
gmt_init.c:			GMT->current.setting.map_tick_length[GMT_ANNOT_LOWER] = gmt_M_to_inch (GMT, txt_a);
gmt_init.c:			GMT->current.setting.map_tick_length[GMT_TICK_LOWER]  = (i > 1) ? gmt_M_to_inch (GMT, txt_b) : 0.25 * GMT->current.setting.map_tick_length[GMT_ANNOT_LOWER];
gmt_init.c:			error = gmt_getpen (GMT, value, &GMT->current.setting.map_tick_pen[GMT_PRIMARY]);
gmt_init.c:			error = gmt_getpen (GMT, value, &GMT->current.setting.map_tick_pen[GMT_SECONDARY]);
gmt_init.c:			GMT->current.setting.map_title_offset = gmt_M_to_inch (GMT, value);
gmt_init.c:				GMT->current.setting.map_vector_shape = dval;
gmt_init.c:			error = gmt_getrgb (GMT, value, GMT->current.setting.color_patch[GMT_BGD]);
gmt_init.c:			error = gmt_getrgb (GMT, value, GMT->current.setting.color_patch[GMT_FGD]);
gmt_init.c:				GMT->current.setting.color_model = GMT_RGB;
gmt_init.c:				GMT->current.setting.color_model = GMT_RGB + GMT_COLORINT;
gmt_init.c:				GMT->current.setting.color_model = GMT_CMYK + GMT_COLORINT;
gmt_init.c:				GMT->current.setting.color_model = GMT_HSV + GMT_COLORINT;
gmt_init.c:					GMT_Report (GMT->parent, GMT_MSG_COMPAT, "warning: COLOR_MODEL = %s is deprecated, use COLOR_MODEL = %s instead\n" GMT_COMPAT_INFO, value, &lower_value[1]);
gmt_init.c:					GMT->current.setting.color_model = GMT_RGB + GMT_COLORINT;
gmt_init.c:					GMT_Report (GMT->parent, GMT_MSG_COMPAT, "warning: COLOR_MODEL = %s is deprecated, use COLOR_MODEL = %s instead\n" GMT_COMPAT_INFO, value, &lower_value[1]);
gmt_init.c:					GMT->current.setting.color_model = GMT_CMYK + GMT_COLORINT;
gmt_init.c:					GMT_Report (GMT->parent, GMT_MSG_COMPAT, "warning: COLOR_MODEL = %s is deprecated, use COLOR_MODEL = %s instead\n" GMT_COMPAT_INFO, value, &lower_value[1]);
gmt_init.c:					GMT->current.setting.color_model = GMT_HSV + GMT_COLORINT;
gmt_init.c:			error = gmt_getrgb (GMT, value, GMT->current.setting.color_patch[GMT_NAN]);
gmt_init.c:				GMT->current.setting.color_hsv_min_s = dval;
gmt_init.c:				GMT->current.setting.color_hsv_max_s = dval;
gmt_init.c:				GMT->current.setting.color_hsv_min_v = dval;
gmt_init.c:				GMT->current.setting.color_hsv_max_v = dval;
gmt_init.c:			strncpy (GMT->current.setting.ps_encoding.name, value, GMT_LEN64-1);
gmt_init.c:				GMT->current.setting.ps_color_mode = PSL_RGB;
gmt_init.c:				GMT->current.setting.ps_color_mode = PSL_CMYK;
gmt_init.c:				GMT->current.setting.ps_color_mode = PSL_HSV;
gmt_init.c:				GMT->current.setting.ps_color_mode = PSL_GRAY;
gmt_init.c:					GMT->current.setting.ps_copies = ival;
gmt_init.c:			if (!GMT->PSL) return (0);	/* Not using PSL in this session */
gmt_init.c:				GMT->PSL->internal.compress = PSL_NONE;
gmt_init.c:				GMT->PSL->internal.compress = PSL_RLE;
gmt_init.c:				GMT->PSL->internal.compress = PSL_LZW;
gmt_init.c:				GMT->PSL->internal.compress = PSL_DEFLATE;
gmt_init.c:				if ((sscanf (value + 7, " , %u", &GMT->PSL->internal.deflate_level) != 1)
gmt_init.c:						|| GMT->PSL->internal.deflate_level > 9)
gmt_init.c:					GMT->PSL->internal.deflate_level = 0;
gmt_init.c:				GMT->PSL->internal.compress = PSL_LZW;
gmt_init.c:				GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "PS_IMAGE_COMPRESS = DEFLATE not available, falling back to LZW.\n");
gmt_init.c:			if (!GMT->PSL) return (0);	/* Not using PSL in this session */
gmt_init.c:				GMT->PSL->internal.line_cap = PSL_BUTT_CAP;
gmt_init.c:				GMT->PSL->internal.line_cap = PSL_ROUND_CAP;
gmt_init.c:				GMT->PSL->internal.line_cap = PSL_SQUARE_CAP;
gmt_init.c:			if (!GMT->PSL) return (0);	/* Not using PSL in this session */
gmt_init.c:				GMT->PSL->internal.line_join = PSL_MITER_JOIN;
gmt_init.c:				GMT->PSL->internal.line_join = PSL_ROUND_JOIN;
gmt_init.c:				GMT->PSL->internal.line_join = PSL_BEVEL_JOIN;
gmt_init.c:			if (!GMT->PSL) return (0);	/* Not using PSL in this session */
gmt_init.c:				GMT->PSL->internal.miter_limit = ival;
gmt_init.c:			error = gmt_getrgb (GMT, value, GMT->current.setting.ps_page_rgb);
gmt_init.c:				GMT->current.setting.ps_orientation = PSL_LANDSCAPE;
gmt_init.c:				GMT->current.setting.ps_orientation = PSL_PORTRAIT;
gmt_init.c:			if (GMT->current.setting.run_mode == GMT_MODERN && !strcmp (lower_value, "auto")) {
gmt_init.c:					GMT_Report (GMT->parent, GMT_MSG_COMPAT, "Production of EPS format is no longer supported, remove + after paper size\n");
gmt_init.c:				GMT->current.setting.ps_media = i;
gmt_init.c:				GMT->current.setting.ps_page_size[0] = GMT_media[i].width;
gmt_init.c:				GMT->current.setting.ps_page_size[1] = GMT_media[i].height;
gmt_init.c:				(pos = gmtinit_key_lookup (lower_value, GMT->session.user_media_name, GMT->session.n_user_media)) < GMT->session.n_user_media) {
gmt_init.c:					GMT->current.setting.ps_media = pos + USER_MEDIA_OFFSET;
gmt_init.c:					GMT->current.setting.ps_page_size[0] = GMT->session.user_media[pos].width;
gmt_init.c:					GMT->current.setting.ps_page_size[1] = GMT->session.user_media[pos].height;
gmt_init.c:					GMT->current.setting.ps_page_size[0] = gmt_convert_units (GMT, txt_a, GMT_PT, GMT_PT);
gmt_init.c:					GMT->current.setting.ps_page_size[1] = gmt_convert_units (GMT, txt_b, GMT_PT, GMT_PT);
gmt_init.c:				if (GMT->current.setting.ps_page_size[0] <= 0.0) error = true;
gmt_init.c:				if (GMT->current.setting.ps_page_size[1] <= 0.0) error = true;
gmt_init.c:				GMT->current.setting.ps_media = -USER_MEDIA_OFFSET;
gmt_init.c:			if (!error && manual) GMT->current.setting.ps_page_size[0] = -GMT->current.setting.ps_page_size[0];
gmt_init.c:				GMT->current.setting.ps_magnify[GMT_X] = dval;
gmt_init.c:				GMT->current.setting.ps_magnify[GMT_Y] = dval;
gmt_init.c:				GMT_Report (GMT->parent, GMT_MSG_COMPAT, "Transparency is now part of pen and fill specifications.  TRANSPARENCY is ignored\n");
gmt_init.c:			strncpy (GMT->current.setting.ps_transpmode, value, GMT_LEN16-1);
gmt_init.c:			strncpy (GMT->current.setting.ps_convert, value, GMT_LEN256-1);
gmt_init.c:			if (!GMT->PSL) return (0);	/* Not using PSL in this session */
gmt_init.c:			GMT->PSL->internal.comments = (tf_answer) ? 1 : 0;
gmt_init.c:				strncpy (GMT->current.setting.io_col_separator, "\t", 8U);
gmt_init.c:				strncpy (GMT->current.setting.io_col_separator, " ", 8U);
gmt_init.c:				strncpy (GMT->current.setting.io_col_separator, ",", 8U);
gmt_init.c:				GMT->current.setting.io_col_separator[0] = 0;
gmt_init.c:				strncpy (GMT->current.setting.io_col_separator, "/", 8U);
gmt_init.c:				strncpy (GMT->current.setting.io_col_separator, value, 8U);
gmt_init.c:			GMT->current.setting.io_col_separator[7] = 0;	/* Just a precaution */
gmt_init.c:				GMT->current.setting.io_first_header = GMT_FIRST_SEGHEADER_MAYBE;
gmt_init.c:				GMT->current.setting.io_first_header = GMT_FIRST_SEGHEADER_ALWAYS;
gmt_init.c:				GMT->current.setting.io_first_header = GMT_FIRST_SEGHEADER_NEVER;
gmt_init.c:			strncpy (GMT->current.setting.io_gridfile_format, value, GMT_LEN64-1);
gmt_init.c:			error = gmtinit_true_false_or_error (lower_value, &GMT->current.setting.io_gridfile_shorthand);
gmt_init.c:			error = gmtinit_true_false_or_error (lower_value, &GMT->current.setting.io_header[GMT_IN]);
gmt_init.c:			GMT->current.setting.io_header[GMT_OUT] = GMT->current.setting.io_header[GMT_IN];
gmt_init.c:				GMT->current.setting.io_head_marker[GMT_OUT] = GMT->current.setting.io_head_marker[GMT_IN] = '#';
gmt_init.c:					GMT->current.setting.io_head_marker[dir] = txt[dir][0];
gmt_init.c:				GMT->current.setting.io_n_header_items = ival;
gmt_init.c:				GMT->current.setting.io_nan_records = true;
gmt_init.c:				GMT->current.setting.io_nan_records = false;
gmt_init.c:				GMT->current.setting.io_nc4_chunksize[0] = k_netcdf_io_chunked_auto;
gmt_init.c:				GMT->current.setting.io_nc4_chunksize[0] = k_netcdf_io_classic;
gmt_init.c:			         &GMT->current.setting.io_nc4_chunksize[0], &GMT->current.setting.io_nc4_chunksize[1])) > 0) {
gmt_init.c:					GMT->current.setting.io_nc4_chunksize[1] = GMT->current.setting.io_nc4_chunksize[0];
gmt_init.c:				if (GMT->current.setting.io_nc4_chunksize[0] <= k_netcdf_io_chunked_auto ||
gmt_init.c:				    GMT->current.setting.io_nc4_chunksize[1] <= k_netcdf_io_chunked_auto)
gmt_init.c:				GMT->current.setting.io_nc4_deflation_level = ival;
gmt_init.c:			if (!gmtinit_true_false_or_error (lower_value, &GMT->current.setting.io_lonlat_toggle[GMT_IN]))
gmt_init.c:				GMT->current.setting.io_lonlat_toggle[GMT_OUT] = GMT->current.setting.io_lonlat_toggle[GMT_IN];
gmt_init.c:				GMT->current.setting.io_lonlat_toggle[GMT_IN] = true;
gmt_init.c:				GMT->current.setting.io_lonlat_toggle[GMT_OUT] = false;
gmt_init.c:				GMT->current.setting.io_lonlat_toggle[GMT_IN] = false;
gmt_init.c:				GMT->current.setting.io_lonlat_toggle[GMT_OUT] = true;
gmt_init.c:				GMT->current.setting.n_bin_header_cols = 0;	/* 0 means do not consider nans to mean segment header */
gmt_init.c:					GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error decoding IO_SEGMENT_BINARY: Cannot be negative.\n");
gmt_init.c:					GMT->current.setting.n_bin_header_cols = (uint64_t)ival;	/* Only do it for files with at least this many cols */
gmt_init.c:				GMT->current.setting.io_seg_marker[GMT_OUT] = GMT->current.setting.io_seg_marker[GMT_IN] = '>';
gmt_init.c:							GMT->current.setting.io_blankline[dir] = true;
gmt_init.c:							GMT->current.setting.io_seg_marker[dir] = 'B';
gmt_init.c:							GMT->current.setting.io_nanline[dir] = true;
gmt_init.c:							GMT->current.setting.io_seg_marker[dir] = 'N';
gmt_init.c:							GMT->current.setting.io_seg_marker[dir] = txt[dir][k];
gmt_init.c:				GMT->current.setting.proj_aux_latitude = GMT_LATSWAP_NONE;
gmt_init.c:				GMT->current.setting.proj_aux_latitude = GMT_LATSWAP_NONE;
gmt_init.c:				GMT->current.setting.proj_aux_latitude = GMT_LATSWAP_G2A;
gmt_init.c:				GMT->current.setting.proj_aux_latitude = GMT_LATSWAP_G2C;
gmt_init.c:				GMT->current.setting.proj_aux_latitude = GMT_LATSWAP_G2O;
gmt_init.c:				GMT->current.setting.proj_aux_latitude = GMT_LATSWAP_G2M;
gmt_init.c:				GMT->current.setting.proj_aux_latitude = GMT_LATSWAP_G2P;
gmt_init.c:				GMT->current.setting.proj_ellipsoid = ival;
gmt_init.c:				GMT->current.setting.proj_geodesic = GMT_GEODESIC_VINCENTY;
gmt_init.c:				GMT->current.setting.proj_geodesic = GMT_GEODESIC_ANDOYER;
gmt_init.c:				GMT->current.setting.proj_geodesic = GMT_GEODESIC_RUDOE;
gmt_init.c:				case 'c': GMT->current.setting.proj_length_unit = GMT_CM; break;
gmt_init.c:				case 'i': GMT->current.setting.proj_length_unit = GMT_INCH; break;
gmt_init.c:				case 'p': GMT->current.setting.proj_length_unit = GMT_PT; break;
gmt_init.c:				GMT->current.setting.proj_mean_radius = GMT_RADIUS_MEAN;
gmt_init.c:				GMT->current.setting.proj_mean_radius = GMT_RADIUS_AUTHALIC;
gmt_init.c:				GMT->current.setting.proj_mean_radius = GMT_RADIUS_VOLUMETRIC;
gmt_init.c:				GMT->current.setting.proj_mean_radius = GMT_RADIUS_MERIDIONAL;
gmt_init.c:				GMT->current.setting.proj_mean_radius = GMT_RADIUS_QUADRATIC;
gmt_init.c:				GMT->current.setting.proj_scale_factor = -1.0;
gmt_init.c:					GMT->current.setting.proj_scale_factor = dval;
gmt_init.c:			limit = (GMT->current.setting.run_mode == GMT_CLASSIC) ? 4 : 6;
gmt_init.c:				GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "GMT_COMPATIBILITY: Expects values from %d to %d; reset to %d.\n", limit, GMT_MAJOR_VERSION, limit);
gmt_init.c:				GMT->current.setting.compatibility = 4;
gmt_init.c:				GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "GMT_COMPATIBILITY: Expects values from %d to %d; reset to %d.\n", limit, GMT_MAJOR_VERSION, GMT_MAJOR_VERSION);
gmt_init.c:				GMT->current.setting.compatibility = GMT_MAJOR_VERSION;
gmt_init.c:				GMT->current.setting.compatibility = ival;
gmt_init.c:				GMT->current.setting.auto_download = GMT_YES_DOWNLOAD;
gmt_init.c:				GMT->current.setting.auto_download = GMT_NO_DOWNLOAD;
gmt_init.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "GMT_AUTO_DOWNLOAD: Expects either on or off - set to off\n");
gmt_init.c:				GMT->current.setting.auto_download = GMT_NO_DOWNLOAD;
gmt_init.c:				if (GMT->session.DATASERVER) {
gmt_init.c:					if ((strcmp (GMT->session.DATASERVER, value) == 0))
gmt_init.c:					gmt_M_str_free (GMT->session.DATASERVER);
gmt_init.c:				GMT->session.DATASERVER = strdup (value);
gmt_init.c:				GMT->current.setting.url_size_limit = 0;
gmt_init.c:				GMT->current.setting.url_size_limit = atoi (lower_value) * f;
gmt_init.c:				if (GMT->session.CUSTOM_LIBS) {
gmt_init.c:					if ((strcmp (GMT->session.CUSTOM_LIBS, value) == 0))
gmt_init.c:					gmt_M_str_free (GMT->session.CUSTOM_LIBS);
gmt_init.c:				GMT->session.CUSTOM_LIBS = strdup (value);
gmt_init.c:				GMT->current.setting.export_type = GMT_DOUBLE;
gmt_init.c:				GMT->current.setting.export_type = GMT_FLOAT;
gmt_init.c:				GMT->current.setting.export_type = GMT_FLOAT;
gmt_init.c:				GMT->current.setting.export_type = GMT_LONG;
gmt_init.c:				GMT->current.setting.export_type = GMT_ULONG;
gmt_init.c:				GMT->current.setting.export_type = GMT_INT;
gmt_init.c:				GMT->current.setting.export_type = GMT_UINT;
gmt_init.c:				GMT->current.setting.export_type = GMT_SHORT;
gmt_init.c:				GMT->current.setting.export_type = GMT_USHORT;
gmt_init.c:				GMT->current.setting.export_type = GMT_CHAR;
gmt_init.c:				GMT->current.setting.export_type = GMT_UCHAR;
gmt_init.c:				GMT->current.setting.export_type = GMT_UCHAR;
gmt_init.c:				GMT->current.setting.extrapolate_val[0] = GMT_EXTRAPOLATE_NONE;
gmt_init.c:				GMT->current.setting.extrapolate_val[0] = GMT_EXTRAPOLATE_SPLINE;
gmt_init.c:				GMT->current.setting.extrapolate_val[0] = GMT_EXTRAPOLATE_CONSTANT;
gmt_init.c:				GMT->current.setting.extrapolate_val[1] = atof (&lower_value[10]);
gmt_init.c:					GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error decoding GMT_EXTRAPOLATE_VAL for 'val' value. Comma out of place.\n");
gmt_init.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "GMT_EXTRAPOLATE_VAL: resetting to 'extrapolated is NaN' to avoid later crash.\n");
gmt_init.c:				GMT->current.setting.extrapolate_val[0] = GMT_EXTRAPOLATE_NONE;
gmt_init.c:				GMT->current.setting.fft = k_fft_auto;
gmt_init.c:				GMT->current.setting.fft = k_fft_fftw;
gmt_init.c:				GMT->current.setting.fftw_plan = FFTW_ESTIMATE; /* default planner flag */
gmt_init.c:							GMT->current.setting.fftw_plan = FFTW_MEASURE;
gmt_init.c:							GMT->current.setting.fftw_plan = FFTW_PATIENT;
gmt_init.c:							GMT->current.setting.fftw_plan = FFTW_EXHAUSTIVE;
gmt_init.c:				GMT->current.setting.fft = k_fft_accelerate;
gmt_init.c:				GMT->current.setting.fft = k_fft_kiss;
gmt_init.c:				GMT->current.setting.fft = k_fft_brenner;
gmt_init.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Unrecognized graphics format %s\n", value);
gmt_init.c:				GMT->current.setting.graphics_format = ival;
gmt_init.c:				GMT->current.setting.history = (GMT_HISTORY_READ | GMT_HISTORY_WRITE);
gmt_init.c:				GMT->current.setting.history = GMT_HISTORY_READ;
gmt_init.c:				GMT->current.setting.history = GMT_HISTORY_OFF;
gmt_init.c:				GMT->current.setting.interpolant = GMT_SPLINE_LINEAR;
gmt_init.c:				GMT->current.setting.interpolant = GMT_SPLINE_AKIMA;
gmt_init.c:				GMT->current.setting.interpolant = GMT_SPLINE_CUBIC;
gmt_init.c:				GMT->current.setting.interpolant = GMT_SPLINE_NONE;
gmt_init.c:			strncpy (GMT->current.setting.language, lower_value, GMT_LEN64-1);
gmt_init.c:				GMT->current.setting.triangulate = GMT_TRIANGLE_WATSON;
gmt_init.c:				GMT->current.setting.triangulate = GMT_TRIANGLE_SHEWCHUK;
gmt_init.c:					GMT->current.setting.verbose = ival;
gmt_init.c:				if (GMT->session.CACHEDIR) {
gmt_init.c:					if ((strcmp (GMT->session.CACHEDIR, value) == 0))
gmt_init.c:					gmt_M_str_free (GMT->session.CACHEDIR);
gmt_init.c:				GMT->session.CACHEDIR = strdup (value);
gmt_init.c:				if (GMT->session.DATADIR) {
gmt_init.c:					if ((strcmp (GMT->session.DATADIR, value) == 0))
gmt_init.c:					gmt_M_str_free (GMT->session.DATADIR);
gmt_init.c:				GMT->session.DATADIR = strdup (value);
gmt_init.c:				if (GMT->session.DCWDIR) {
gmt_init.c:					if ((strcmp (GMT->session.DCWDIR, value) == 0))
gmt_init.c:					gmt_M_str_free (GMT->session.DCWDIR);
gmt_init.c:				GMT->session.DCWDIR = strdup (value);
gmt_init.c:				if (GMT->session.GSHHGDIR) {
gmt_init.c:					if ((strcmp (GMT->session.GSHHGDIR, value) == 0))
gmt_init.c:					gmt_M_str_free (GMT->session.GSHHGDIR);
gmt_init.c:				GMT->session.GSHHGDIR = strdup (value);
gmt_init.c:			strncpy (GMT->current.setting.time_system.epoch, value, GMT_LEN64-1);
gmt_init.c:			(void) gmt_init_time_system_structure (GMT, &GMT->current.setting.time_system);
gmt_init.c:				sscanf (&lower_value[1], "%d%c", &GMT->current.time.truncate.T.step, &GMT->current.time.truncate.T.unit);
gmt_init.c:				switch (GMT->current.time.truncate.T.unit) {
gmt_init.c:						GMT->current.time.truncate.direction = (lower_value[0] == '+') ? 0 : 1;
gmt_init.c:				if (GMT->current.time.truncate.T.step == 0) error = true;
gmt_init.c:				GMT->current.setting.time_is_interval = true;
gmt_init.c:				GMT->current.setting.time_is_interval = false;
gmt_init.c:			GMT->current.setting.time_interval_fraction = atof (value);
gmt_init.c:			error = gmtinit_true_false_or_error (lower_value, &GMT->current.setting.time_leap_seconds);
gmt_init.c:				GMT->current.setting.timer_mode = GMT_NO_TIMER;
gmt_init.c:				GMT->current.setting.timer_mode = GMT_ABS_TIMER;
gmt_init.c:				GMT->current.setting.timer_mode = GMT_ELAPSED_TIMER;
gmt_init.c:			GMT->current.setting.time_system.unit = lower_value[0];
gmt_init.c:			(void) gmt_init_time_system_structure (GMT, &GMT->current.setting.time_system);
gmt_init.c:			error = gmt_get_time_system (GMT, lower_value, &GMT->current.setting.time_system);
gmt_init.c:			(void) gmt_init_time_system_structure (GMT, &GMT->current.setting.time_system);
gmt_init.c:				GMT->current.setting.time_week_start = 0;
gmt_init.c:				GMT->current.setting.time_week_start = ival;
gmt_init.c:			else GMT->current.setting.time_Y2K_offset_year = ival;
gmt_init.c:			GMT->current.time.Y2K_fix.y2_cutoff = GMT->current.setting.time_Y2K_offset_year % 100;
gmt_init.c:			GMT->current.time.Y2K_fix.y100 = GMT->current.setting.time_Y2K_offset_year - GMT->current.time.Y2K_fix.y2_cutoff;
gmt_init.c:			GMT->current.time.Y2K_fix.y200 = GMT->current.time.Y2K_fix.y100 + 100;
gmt_init.c:			GMT_Report (GMT->parent, GMT_MSG_COMPAT, "Parameter %s (previously introduced in GMT5) is deprecated.\n" GMT_COMPAT_INFO, GMT_keywords[case_val]);
gmt_init.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error: Unrecognized keyword %s.\n", keyword);
gmt_init.c:		if (len && strchr (GMT_DIM_UNITS, value[len-1])) GMT->current.setting.given_unit[case_val] = value[len-1];
gmt_init.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error: %s given illegal value (%s)!\n", keyword, value);
gmt_init.c:			strncpy (value, GMT->current.setting.format_clock_in,  GMT_BUFSIZ-1);
gmt_init.c:			strncpy (value, GMT->current.setting.format_date_in, GMT_BUFSIZ-1);
gmt_init.c:			strncpy (value, GMT->current.setting.format_clock_out, GMT_BUFSIZ-1);
gmt_init.c:			strncpy (value, GMT->current.setting.format_date_out, GMT_BUFSIZ-1);
gmt_init.c:			strncpy (value, GMT->current.setting.format_geo_out, GMT_BUFSIZ-1);
gmt_init.c:			strncpy (value, GMT->current.setting.format_clock_map, GMT_BUFSIZ-1);
gmt_init.c:			strncpy (value, GMT->current.setting.format_date_map, GMT_BUFSIZ-1);
gmt_init.c:			strncpy (value, GMT->current.setting.format_geo_map, GMT_BUFSIZ-1);
gmt_init.c:			strncpy (value, GMT->current.setting.format_time[GMT_PRIMARY], GMT_BUFSIZ-1);
gmt_init.c:			strncpy (value, GMT->current.setting.format_time[GMT_SECONDARY], GMT_BUFSIZ-1);
gmt_init.c:			strncpy (value, GMT->current.setting.format_float_out_orig, GMT_BUFSIZ-1);
gmt_init.c:			strncpy (value, GMT->current.setting.format_float_map, GMT_BUFSIZ-1);
gmt_init.c:			strncpy (value, GMT->current.setting.format_time_stamp, GMT_BUFSIZ-1);
gmt_init.c:			strncpy (value, gmt_putfont (GMT, &GMT->current.setting.font_annot[GMT_PRIMARY]), GMT_BUFSIZ-1);
gmt_init.c:			strncpy (value, gmt_putfont (GMT, &GMT->current.setting.font_annot[GMT_SECONDARY]), GMT_BUFSIZ-1);
gmt_init.c:			strncpy (value, gmt_putfont (GMT, &GMT->current.setting.font_heading), GMT_BUFSIZ-1);
gmt_init.c:			strncpy (value, gmt_putfont (GMT, &GMT->current.setting.font_title), GMT_BUFSIZ-1);
gmt_init.c:			strncpy (value, gmt_putfont (GMT, &GMT->current.setting.font_tag), GMT_BUFSIZ-1);
gmt_init.c:			strncpy (value, gmt_putfont (GMT, &GMT->current.setting.font_label), GMT_BUFSIZ-1);
gmt_init.c:			strncpy (value, gmt_putfont (GMT, &GMT->current.setting.font_logo), GMT_BUFSIZ-1);
gmt_init.c:				snprintf (value, GMT_LEN256, "%g", GMT->current.setting.font_annot[GMT_PRIMARY].size);
gmt_init.c:				snprintf (value, GMT_LEN256, "%g", GMT->current.setting.font_annot[GMT_SECONDARY].size);
gmt_init.c:				snprintf (value, GMT_LEN256, "%g", GMT->current.setting.font_title.size);
gmt_init.c:				snprintf (value, GMT_LEN256, "%g", GMT->current.setting.font_label.size);
gmt_init.c:			snprintf (value, GMT_LEN256, "%g%c", GMT->current.setting.map_annot_offset[GMT_PRIMARY] GMT_def(GMTCASE_MAP_ANNOT_OFFSET_PRIMARY));
gmt_init.c:			snprintf (value, GMT_LEN256, "%g%c", GMT->current.setting.map_annot_offset[GMT_SECONDARY] GMT_def(GMTCASE_MAP_ANNOT_OFFSET_SECONDARY));
gmt_init.c:			snprintf (value, GMT_LEN256, "%d", GMT->current.setting.map_annot_oblique);
gmt_init.c:			snprintf (value, GMT_LEN256, "%g", GMT->current.setting.map_annot_min_angle);
gmt_init.c:			snprintf (value, GMT_LEN256, "%g%c", GMT->current.setting.map_annot_min_spacing GMT_def(GMTCASE_MAP_ANNOT_MIN_SPACING));
gmt_init.c:			strncpy (value, GMT->current.setting.map_annot_ortho, GMT_BUFSIZ-1);
gmt_init.c:			switch (GMT->current.setting.map_degree_symbol) {
gmt_init.c:			strncpy (value, GMT->current.setting.map_frame_axes, GMT_BUFSIZ-1);
gmt_init.c:			snprintf (value, GMT_LEN256, "%s", gmt_putpen (GMT, &GMT->current.setting.map_default_pen));
gmt_init.c:			snprintf (value, GMT_LEN256, "%s", gmt_putpen (GMT, &GMT->current.setting.map_frame_pen));
gmt_init.c:			if (GMT->current.setting.map_frame_type == GMT_IS_PLAIN)
gmt_init.c:			else if (GMT->current.setting.map_frame_type == GMT_IS_GRAPH) {
gmt_init.c:				if (GMT->current.setting.map_graph_extension_unit != GMT_GRAPH_EXTENSION_UNIT || !doubleAlmostEqual (GMT->current.setting.map_graph_extension, GMT_GRAPH_EXTENSION)) {
gmt_init.c:					if (GMT->current.setting.map_graph_extension_unit == GMT_GRAPH_EXTENSION_UNIT)	/* Extension in percent */
gmt_init.c:						snprintf (tmp, GMT_LEN32, ",%g%%", GMT->current.setting.map_graph_extension);
gmt_init.c:						double s = GMT->session.u2u[GMT_INCH][GMT->current.setting.map_graph_extension_unit];
gmt_init.c:						snprintf (tmp, GMT_LEN32, ",%g%c", s*GMT->current.setting.map_graph_extension, GMT->session.unit_name[GMT->current.setting.map_graph_extension_unit][0]);
gmt_init.c:			else if (GMT->current.setting.map_frame_type == GMT_IS_FANCY)
gmt_init.c:			else if (GMT->current.setting.map_frame_type == GMT_IS_ROUNDED)
gmt_init.c:			else if (GMT->current.setting.map_frame_type == GMT_IS_INSIDE)
gmt_init.c:			snprintf (value, GMT_LEN256, "%g%c", GMT->current.setting.map_frame_width GMT_def(GMTCASE_MAP_FRAME_WIDTH));
gmt_init.c:			snprintf (value, GMT_LEN256, "%g%c", GMT->current.setting.map_grid_cross_size[GMT_PRIMARY] GMT_def(GMTCASE_MAP_GRID_CROSS_SIZE_PRIMARY));
gmt_init.c:			snprintf (value, GMT_LEN256, "%g%c", GMT->current.setting.map_grid_cross_size[GMT_SECONDARY] GMT_def(GMTCASE_MAP_GRID_CROSS_SIZE_SECONDARY));
gmt_init.c:			snprintf (value, GMT_LEN256, "%s", gmt_putpen (GMT, &GMT->current.setting.map_grid_pen[GMT_PRIMARY]));
gmt_init.c:			snprintf (value, GMT_LEN256, "%s", gmt_putpen (GMT, &GMT->current.setting.map_grid_pen[GMT_SECONDARY]));
gmt_init.c:			snprintf (value, GMT_LEN256, "%g%c", GMT->current.setting.map_heading_offset GMT_def(GMTCASE_MAP_HEADING_OFFSET));
gmt_init.c:			snprintf (value, GMT_LEN256, "%g%c", GMT->current.setting.map_label_offset GMT_def(GMTCASE_MAP_LABEL_OFFSET));
gmt_init.c:			snprintf (value, GMT_LEN256, "%g%c", GMT->current.setting.map_line_step GMT_def(GMTCASE_MAP_LINE_STEP));
gmt_init.c:			snprintf (value, GMT_LEN256, "%s", ft[GMT->current.setting.map_logo]);
gmt_init.c:			snprintf (value, GMT_LEN256, "%s/%g%c/%g%c", GMT_just_string[GMT->current.setting.map_logo_justify],
gmt_init.c:			GMT->current.setting.map_logo_pos[GMT_X] GMT_def(GMTCASE_MAP_LOGO_POS),
gmt_init.c:			GMT->current.setting.map_logo_pos[GMT_Y] GMT_def(GMTCASE_MAP_LOGO_POS));
gmt_init.c:			snprintf (value, GMT_LEN256, "%g%c", GMT->current.setting.map_origin[GMT_X] GMT_def(GMTCASE_MAP_ORIGIN_X));
gmt_init.c:			snprintf (value, GMT_LEN256, "%g%c", GMT->current.setting.map_origin[GMT_Y] GMT_def(GMTCASE_MAP_ORIGIN_Y));
gmt_init.c:			if (doubleAlmostEqual (GMT->current.setting.map_polar_cap[0], 90.0))
gmt_init.c:				snprintf (value, GMT_LEN256, "%g/%g", GMT->current.setting.map_polar_cap[0], GMT->current.setting.map_polar_cap[1]);
gmt_init.c:			snprintf (value, GMT_LEN256, "%g%c", GMT->current.setting.map_scale_height GMT_def(GMTCASE_MAP_SCALE_HEIGHT));
gmt_init.c:			GMT->current.setting.map_tick_length[GMT_ANNOT_UPPER] GMT_def(GMTCASE_MAP_TICK_LENGTH_PRIMARY),
gmt_init.c:			GMT->current.setting.map_tick_length[GMT_TICK_UPPER] GMT_def(GMTCASE_MAP_TICK_LENGTH_PRIMARY));
gmt_init.c:			GMT->current.setting.map_tick_length[GMT_ANNOT_LOWER] GMT_def(GMTCASE_MAP_TICK_LENGTH_SECONDARY),
gmt_init.c:			GMT->current.setting.map_tick_length[GMT_TICK_LOWER] GMT_def(GMTCASE_MAP_TICK_LENGTH_SECONDARY));
gmt_init.c:			snprintf (value, GMT_LEN256, "%s", gmt_putpen (GMT, &GMT->current.setting.map_tick_pen[GMT_PRIMARY]));
gmt_init.c:			snprintf (value, GMT_LEN256, "%s", gmt_putpen (GMT, &GMT->current.setting.map_tick_pen[GMT_SECONDARY]));
gmt_init.c:			snprintf (value, GMT_LEN256, "%g%c", GMT->current.setting.map_title_offset GMT_def(GMTCASE_MAP_TITLE_OFFSET));
gmt_init.c:			snprintf (value, GMT_LEN256, "%g", GMT->current.setting.map_vector_shape);
gmt_init.c:			snprintf (value, GMT_LEN256, "%s", gmt_putcolor (GMT, GMT->current.setting.color_patch[GMT_BGD]));
gmt_init.c:			snprintf (value, GMT_LEN256, "%s", gmt_putcolor (GMT, GMT->current.setting.color_patch[GMT_FGD]));
gmt_init.c:			if (GMT->current.setting.color_model == GMT_RGB)
gmt_init.c:			else if (GMT->current.setting.color_model == (GMT_RGB + GMT_COLORINT))
gmt_init.c:			else if (GMT->current.setting.color_model == (GMT_CMYK + GMT_COLORINT))
gmt_init.c:			else if (GMT->current.setting.color_model == (GMT_HSV + GMT_COLORINT))
gmt_init.c:			snprintf (value, GMT_LEN256, "%s", gmt_putcolor (GMT, GMT->current.setting.color_patch[GMT_NAN]));
gmt_init.c:			snprintf (value, GMT_LEN256, "%g", GMT->current.setting.color_hsv_min_s);
gmt_init.c:			snprintf (value, GMT_LEN256, "%g", GMT->current.setting.color_hsv_max_s);
gmt_init.c:			snprintf (value, GMT_LEN256, "%g", GMT->current.setting.color_hsv_min_v);
gmt_init.c:			snprintf (value, GMT_LEN256, "%g", GMT->current.setting.color_hsv_max_v);
gmt_init.c:			strncpy (value, GMT->current.setting.ps_encoding.name, GMT_BUFSIZ-1);
gmt_init.c:			if (GMT->current.setting.ps_color_mode == PSL_RGB)
gmt_init.c:			else if (GMT->current.setting.ps_color_mode == PSL_CMYK)
gmt_init.c:			else if (GMT->current.setting.ps_color_mode == PSL_HSV)
gmt_init.c:			else if (GMT->current.setting.ps_color_mode == PSL_GRAY)
gmt_init.c:				snprintf (value, GMT_LEN256, "%d", GMT->current.setting.ps_copies);
gmt_init.c:			if (!GMT->PSL) return (NULL);	/* Not using PSL in this session */
gmt_init.c:			if (GMT->PSL->internal.compress == PSL_NONE)
gmt_init.c:			else if (GMT->PSL->internal.compress == PSL_RLE)
gmt_init.c:			else if (GMT->PSL->internal.compress == PSL_LZW)
gmt_init.c:			else if (GMT->PSL->internal.compress == PSL_DEFLATE) {
gmt_init.c:				if (GMT->PSL->internal.deflate_level != 0)
gmt_init.c:					snprintf (value, GMT_LEN256, "deflate,%u", GMT->PSL->internal.deflate_level);
gmt_init.c:			if (!GMT->PSL) return (NULL);	/* Not using PSL in this session */
gmt_init.c:			if (GMT->PSL->internal.line_cap == PSL_BUTT_CAP)
gmt_init.c:			else if (GMT->PSL->internal.line_cap == PSL_ROUND_CAP)
gmt_init.c:			else if (GMT->PSL->internal.line_cap == PSL_SQUARE_CAP)
gmt_init.c:			if (!GMT->PSL) return (NULL);	/* Not using PSL in this session */
gmt_init.c:			if (GMT->PSL->internal.line_join == PSL_MITER_JOIN)
gmt_init.c:			else if (GMT->PSL->internal.line_join == PSL_ROUND_JOIN)
gmt_init.c:			else if (GMT->PSL->internal.line_join == PSL_BEVEL_JOIN)
gmt_init.c:			if (!GMT->PSL) return (NULL);	/* Not using PSL in this session */
gmt_init.c:			snprintf (value, GMT_LEN256, "%d", GMT->PSL->internal.miter_limit);
gmt_init.c:			snprintf (value, GMT_LEN256, "%s", gmt_putcolor (GMT, GMT->current.setting.ps_page_rgb));
gmt_init.c:			if (GMT->current.setting.ps_orientation == PSL_LANDSCAPE)
gmt_init.c:			else if (GMT->current.setting.ps_orientation == PSL_PORTRAIT)
gmt_init.c:			if (GMT->current.setting.ps_media == -USER_MEDIA_OFFSET)
gmt_init.c:				snprintf (value, GMT_LEN256, "%gx%g", fabs (GMT->current.setting.ps_page_size[0]), fabs (GMT->current.setting.ps_page_size[1]));
gmt_init.c:			else if (GMT->current.setting.ps_media >= USER_MEDIA_OFFSET)
gmt_init.c:				snprintf (value, GMT_LEN256, "%s", GMT->session.user_media_name[GMT->current.setting.ps_media-USER_MEDIA_OFFSET]);
gmt_init.c:			else if (GMT->current.setting.ps_media < GMT_N_MEDIA)
gmt_init.c:				snprintf (value, GMT_LEN256, "%s", GMT_media_name[GMT->current.setting.ps_media]);
gmt_init.c:			if (GMT->current.setting.ps_page_size[0] < 0.0)
gmt_init.c:			else if (GMT->current.setting.ps_page_size[1] < 0.0)
gmt_init.c:			snprintf (value, GMT_LEN256, "%g", GMT->current.setting.ps_magnify[GMT_X]);
gmt_init.c:			snprintf (value, GMT_LEN256, "%g", GMT->current.setting.ps_magnify[GMT_Y]);
gmt_init.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Transparency is now part of pen and fill specifications.  TRANSPARENCY is ignored\n");
gmt_init.c:			strncpy (value, GMT->current.setting.ps_transpmode, GMT_LEN16-1);
gmt_init.c:			strncpy (value, GMT->current.setting.ps_convert, GMT_BUFSIZ-1);
gmt_init.c:			if (!GMT->PSL) return (NULL);	/* Not using PSL in this session */
gmt_init.c:			snprintf (value, GMT_LEN256, "%s", ft[GMT->PSL->internal.comments]);
gmt_init.c:			if (GMT->current.setting.io_col_separator[0] == '\t')	/* DEFAULT */
gmt_init.c:			else if (GMT->current.setting.io_col_separator[0] == ' ')
gmt_init.c:			else if (GMT->current.setting.io_col_separator[0] == ',')
gmt_init.c:			else if (!GMT->current.setting.io_col_separator[0])
gmt_init.c:				strncpy (value, GMT->current.setting.io_col_separator, GMT_BUFSIZ-1);
gmt_init.c:			if (GMT->current.setting.io_first_header == GMT_FIRST_SEGHEADER_MAYBE)
gmt_init.c:			else if (GMT->current.setting.io_first_header == GMT_FIRST_SEGHEADER_ALWAYS)
gmt_init.c:			strncpy (value, GMT->current.setting.io_gridfile_format, GMT_BUFSIZ-1);
gmt_init.c:			snprintf (value, GMT_LEN256, "%s", ft[GMT->current.setting.io_gridfile_shorthand]);
gmt_init.c:			snprintf (value, GMT_LEN256, "%s", ft[GMT->current.setting.io_header[GMT_IN]]);
gmt_init.c:			if (GMT->current.setting.io_head_marker[GMT_OUT] != GMT->current.setting.io_head_marker[GMT_IN]) {
gmt_init.c:				snprintf (txt, 8U, "%c,", GMT->current.setting.io_head_marker[GMT_IN]);	strcat (value, txt);
gmt_init.c:				snprintf (txt, 8U, "%c", GMT->current.setting.io_head_marker[GMT_OUT]);	strcat (value, txt);
gmt_init.c:				snprintf (txt, 8U, "%c", GMT->current.setting.io_head_marker[GMT_IN]);	strcat (value, txt);
gmt_init.c:			snprintf (value, GMT_LEN256, "%d", GMT->current.setting.io_n_header_items);
gmt_init.c:			if (GMT->current.setting.io_nan_records)
gmt_init.c:			if (GMT->current.setting.io_nc4_chunksize[0] == k_netcdf_io_chunked_auto)
gmt_init.c:			else if (GMT->current.setting.io_nc4_chunksize[0] == k_netcdf_io_classic)
gmt_init.c:						 GMT->current.setting.io_nc4_chunksize[0],
gmt_init.c:						 GMT->current.setting.io_nc4_chunksize[1]);
gmt_init.c:			snprintf (value, GMT_LEN256, "%u", GMT->current.setting.io_nc4_deflation_level);
gmt_init.c:			if (GMT->current.setting.io_lonlat_toggle[GMT_IN] && GMT->current.setting.io_lonlat_toggle[GMT_OUT])
gmt_init.c:			else if (!GMT->current.setting.io_lonlat_toggle[GMT_IN] && !GMT->current.setting.io_lonlat_toggle[GMT_OUT])
gmt_init.c:			else if (GMT->current.setting.io_lonlat_toggle[GMT_IN] && !GMT->current.setting.io_lonlat_toggle[GMT_OUT])
gmt_init.c:			if (GMT->current.setting.n_bin_header_cols == 0)
gmt_init.c:				snprintf (value, GMT_LEN256, "%" PRIu64, GMT->current.setting.n_bin_header_cols);
gmt_init.c:			if (GMT->current.setting.io_seg_marker[GMT_OUT] != GMT->current.setting.io_seg_marker[GMT_IN]) {
gmt_init.c:				if ((GMT->current.setting.io_seg_marker[GMT_IN] == 'N' && !GMT->current.setting.io_nanline[GMT_IN]) || (GMT->current.setting.io_seg_marker[GMT_IN] == 'B' && !GMT->current.setting.io_blankline[GMT_IN])) value[0] = '\\';
gmt_init.c:				snprintf (txt, 8U, "%c,", GMT->current.setting.io_seg_marker[GMT_IN]);	strcat (value, txt);
gmt_init.c:				if ((GMT->current.setting.io_seg_marker[GMT_IN] == 'N' && !GMT->current.setting.io_nanline[GMT_IN]) || (GMT->current.setting.io_seg_marker[GMT_IN] == 'B' && !GMT->current.setting.io_blankline[GMT_IN])) strcat (value, "\\");
gmt_init.c:				snprintf (txt, 8U, "%c", GMT->current.setting.io_seg_marker[GMT_OUT]);	strcat (value, txt);
gmt_init.c:				if ((GMT->current.setting.io_seg_marker[GMT_IN] == 'N' && !GMT->current.setting.io_nanline[GMT_IN]) || (GMT->current.setting.io_seg_marker[GMT_IN] == 'B' && !GMT->current.setting.io_blankline[GMT_IN])) value[0] = '\\';
gmt_init.c:				snprintf (txt, 8U, "%c", GMT->current.setting.io_seg_marker[GMT_IN]);	strcat (value, txt);
gmt_init.c:			switch (GMT->current.setting.proj_aux_latitude) {
gmt_init.c:			if (GMT->current.setting.proj_ellipsoid < GMT_N_ELLIPSOIDS - 1)	/* Custom ellipse */
gmt_init.c:				snprintf (value, GMT_LEN256, "%s", GMT->current.setting.ref_ellipsoid[GMT->current.setting.proj_ellipsoid].name);
gmt_init.c:				snprintf (value, GMT_LEN256, "%f", GMT->current.setting.ref_ellipsoid[GMT->current.setting.proj_ellipsoid].eq_radius);
gmt_init.c:				snprintf (value, GMT_LEN256, "%f,%f", GMT->current.setting.ref_ellipsoid[GMT->current.setting.proj_ellipsoid].eq_radius,
gmt_init.c:					1.0/GMT->current.setting.ref_ellipsoid[GMT->current.setting.proj_ellipsoid].flattening);
gmt_init.c:			switch (GMT->current.setting.proj_geodesic) {
gmt_init.c:			snprintf (value, GMT_LEN256, "%s", GMT->session.unit_name[GMT->current.setting.proj_length_unit]);
gmt_init.c:			switch (GMT->current.setting.proj_mean_radius) {
gmt_init.c:			if (doubleAlmostEqual (GMT->current.setting.proj_scale_factor, -1.0)) /* Default scale for chosen projection */
gmt_init.c:				snprintf (value, GMT_LEN256, "%g", GMT->current.setting.proj_scale_factor);
gmt_init.c:			snprintf (value, GMT_LEN256, "%u", GMT->current.setting.compatibility);
gmt_init.c:			strncpy (value, (GMT->current.setting.auto_download == GMT_NO_DOWNLOAD) ? "off" : "on", GMT_BUFSIZ-1);
gmt_init.c:			strncpy (value, (GMT->session.DATASERVER) ? GMT->session.DATASERVER : "", GMT_BUFSIZ-1);
gmt_init.c:			if (GMT->current.setting.url_size_limit == 0)
gmt_init.c:			else if (GMT->current.setting.url_size_limit < 1024)
gmt_init.c:				snprintf (value, GMT_BUFSIZ, "%" PRIu64, (uint64_t)GMT->current.setting.url_size_limit);
gmt_init.c:			else if (GMT->current.setting.url_size_limit < 1024*1024)
gmt_init.c:				snprintf (value, GMT_BUFSIZ, "%" PRIu64 "Kb", (uint64_t)GMT->current.setting.url_size_limit/1024);
gmt_init.c:			else if (GMT->current.setting.url_size_limit < 1024*1024*1024)
gmt_init.c:				snprintf (value, GMT_BUFSIZ, "%" PRIu64 "Mb", (uint64_t)GMT->current.setting.url_size_limit/(1024*1024));
gmt_init.c:				snprintf (value, GMT_BUFSIZ, "%" PRIu64 "Gb", (uint64_t)GMT->current.setting.url_size_limit/(1024*1024*1024));
gmt_init.c:			strncpy (value, (GMT->session.CUSTOM_LIBS) ? GMT->session.CUSTOM_LIBS : "", GMT_BUFSIZ-1);
gmt_init.c:			if (GMT->current.setting.export_type == GMT_DOUBLE)
gmt_init.c:			else if (GMT->current.setting.export_type == GMT_FLOAT)
gmt_init.c:			else if (GMT->current.setting.export_type == GMT_LONG)
gmt_init.c:			else if (GMT->current.setting.export_type == GMT_ULONG)
gmt_init.c:			else if (GMT->current.setting.export_type == GMT_INT)
gmt_init.c:			else if (GMT->current.setting.export_type == GMT_UINT)
gmt_init.c:			else if (GMT->current.setting.export_type == GMT_SHORT)
gmt_init.c:			else if (GMT->current.setting.export_type == GMT_USHORT)
gmt_init.c:			else if (GMT->current.setting.export_type == GMT_CHAR)
gmt_init.c:			else if (GMT->current.setting.export_type == GMT_UCHAR)
gmt_init.c:			if (GMT->current.setting.extrapolate_val[0] == GMT_EXTRAPOLATE_NONE)
gmt_init.c:			else if (GMT->current.setting.extrapolate_val[0] == GMT_EXTRAPOLATE_SPLINE)
gmt_init.c:			else if (GMT->current.setting.extrapolate_val[0] == GMT_EXTRAPOLATE_CONSTANT)
gmt_init.c:				snprintf (value, GMT_LEN256, "extrapval,%g", GMT->current.setting.extrapolate_val[1]);
gmt_init.c:			switch (GMT->current.setting.fft) {
gmt_init.c:					switch (GMT->current.setting.fftw_plan) {
gmt_init.c:			strncpy (value, gmt_session_format[GMT->current.setting.graphics_format], GMT_LEN256-1);
gmt_init.c:			if (GMT->current.setting.history & GMT_HISTORY_WRITE)
gmt_init.c:			else if (GMT->current.setting.history & GMT_HISTORY_READ)
gmt_init.c:			if (GMT->current.setting.interpolant == GMT_SPLINE_LINEAR)
gmt_init.c:			else if (GMT->current.setting.interpolant == GMT_SPLINE_AKIMA)
gmt_init.c:			else if (GMT->current.setting.interpolant == GMT_SPLINE_CUBIC)
gmt_init.c:			else if (GMT->current.setting.interpolant == GMT_SPLINE_NONE)
gmt_init.c:			strncpy (value, GMT->current.setting.language, GMT_LEN64-1);
gmt_init.c:			if (GMT->current.setting.triangulate == GMT_TRIANGLE_WATSON)
gmt_init.c:			else if (GMT->current.setting.triangulate == GMT_TRIANGLE_SHEWCHUK)
gmt_init.c:			switch (GMT->current.setting.verbose) {
gmt_init.c:			strncpy (value, (GMT->session.CACHEDIR) ? GMT->session.CACHEDIR : "", GMT_BUFSIZ-1);
gmt_init.c:			strncpy (value, (GMT->session.DATADIR) ? GMT->session.DATADIR : "", GMT_BUFSIZ-1);
gmt_init.c:			strncpy (value, (GMT->session.DCWDIR) ? GMT->session.DCWDIR : "", GMT_BUFSIZ-1);
gmt_init.c:			strncpy (value, (GMT->session.GSHHGDIR) ? GMT->session.GSHHGDIR : "", GMT_BUFSIZ-1);
gmt_init.c:			strncpy (value, GMT->current.setting.time_system.epoch, GMT_LEN64-1);
gmt_init.c:			if (GMT->current.setting.time_is_interval)
gmt_init.c:				snprintf (value, GMT_LEN256, "%c%d%c", pm[GMT->current.time.truncate.direction], GMT->current.time.truncate.T.step, GMT->current.time.truncate.T.unit);
gmt_init.c:			snprintf (value, GMT_LEN256, "%g", GMT->current.setting.time_interval_fraction);
gmt_init.c:			snprintf (value, GMT_LEN256, "%s", ft[GMT->current.setting.time_leap_seconds]);
gmt_init.c:			if (GMT->current.setting.timer_mode == GMT_NO_TIMER)
gmt_init.c:			else if (GMT->current.setting.timer_mode == GMT_ABS_TIMER)
gmt_init.c:			else if (GMT->current.setting.timer_mode == GMT_ELAPSED_TIMER)
gmt_init.c:			value[0] = GMT->current.setting.time_system.unit;
gmt_init.c:			snprintf (value, GMT_LEN256, "%s", GMT_weekdays[GMT->current.setting.time_week_start]);
gmt_init.c:			snprintf (value, GMT_LEN256, "%d", GMT->current.setting.time_Y2K_offset_year);
gmt_init.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error: Unrecognized keyword %s\n", keyword);
gmt_init.c:	if (GMT_Init_IO (GMT->parent, GMT_IS_DATASET, GMT_IS_TEXT, GMT_OUT, GMT_ADD_DEFAULT, 0, options) != GMT_OK) {	/* Establishes data output */
gmt_init.c:		return (GMT->parent->error);
gmt_init.c:	if (GMT_Begin_IO (GMT->parent, GMT_IS_DATASET, GMT_OUT, GMT_HEADER_ON) != GMT_OK) {
gmt_init.c:		return (GMT->parent->error);	/* Enables data output and sets access mode */
gmt_init.c:	if (GMT_Set_Geometry (GMT->parent, GMT_OUT, GMT_IS_TEXT) != GMT_NOERROR) {	/* Sets output geometry */
gmt_init.c:		return (GMT->parent->error);
gmt_init.c:			GMT_Put_Record (GMT->parent, GMT_WRITE_DATA, &Out);
gmt_init.c:		GMT_Put_Record (GMT->parent, GMT_WRITE_DATA, &Out);		/* Separate lines */
gmt_init.c:	if (GMT_End_IO (GMT->parent, GMT_OUT, 0) != GMT_OK) {	/* Disables further data output */
gmt_init.c:		return (GMT->parent->error);
gmt_init.c:		if (GMT->current.setting.run_mode == GMT_MODERN)	/* Modern mode: Use the workflow directory */
gmt_init.c:			snprintf (path, PATH_MAX, "%s/gmt.conf", GMT->parent->gwf_dir);
gmt_init.c:		else if (GMT->session.TMPDIR)	/* Write GMT->session.TMPDIR/gmt.conf */
gmt_init.c:			snprintf (path, PATH_MAX, "%s/gmt.conf", GMT->session.TMPDIR);
gmt_init.c:		if (GMT->current.setting.run_mode == GMT_MODERN) {	/* Modern mode: Use the workflow directory */
gmt_init.c:			snprintf (path, PATH_MAX, "%s/gmt.conf", GMT->parent->gwf_dir);
gmt_init.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "%s not a valid number and may not be decoded properly.\n", string);
gmt_init.c:	value = atof (string) * GMT->session.u2u[given_unit][target_unit];
gmt_init.c:	if (have_unit) string[len-1] = (char)GMT->session.unit_name[given_unit][0];	/* Put back the (implied) given unit */
gmt_init.c:			GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Length unit %c not supported - revert to default unit [%s]\n", (int)c, GMT->session.unit_name[unit]);
gmt_init.c:	GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Enter: gmt_hash_init\n");
gmt_init.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "%s makes hash-depth exceed hard-wired limit of %d - increment GMT_HASH_MAXDEPTH in gmt_hash.h and recompile GMT\n", keys[i], GMT_HASH_MAXDEPTH);
gmt_init.c:	GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Exit:  gmt_hash_init\n");
gmt_init.c:		strcpy (line, GMT->current.setting.ref_ellipsoid[i].name);
gmt_init.c:	n = sscanf (name, "%lf,%s", &GMT->current.setting.ref_ellipsoid[i].eq_radius, line);
gmt_init.c:		GMT->current.setting.ref_ellipsoid[i].flattening = 0.0; /* Read equatorial radius only ... spherical */
gmt_init.c:		GMT->current.setting.ref_ellipsoid[i].flattening = 1.0 - (pol_radius / GMT->current.setting.ref_ellipsoid[i].eq_radius);
gmt_init.c:		n = sscanf (&line[2], "%lf", &GMT->current.setting.ref_ellipsoid[i].flattening);
gmt_init.c:		n = sscanf (line, "%lf", &GMT->current.setting.ref_ellipsoid[i].flattening);
gmt_init.c:		if (!gmt_M_is_spherical (GMT)) GMT->current.setting.ref_ellipsoid[i].flattening = 1.0 / GMT->current.setting.ref_ellipsoid[i].flattening;
gmt_init.c:		/* Try to open as file first in (1) current dir, then in (2) $GMT->session.SHAREDIR */
gmt_init.c:		GMT_Report (GMT->parent, GMT_MSG_COMPAT, "Assigning PROJ_ELLIPSOID a file name is deprecated, use <a>,<inv_f> instead\n");
gmt_init.c:			n = sscanf (line, "%s %d %lf %lf %lf", GMT->current.setting.ref_ellipsoid[i].name,
gmt_init.c:				&GMT->current.setting.ref_ellipsoid[i].date, &GMT->current.setting.ref_ellipsoid[i].eq_radius,
gmt_init.c:				&pol_radius, &GMT->current.setting.ref_ellipsoid[i].flattening);
gmt_init.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error decoding user ellipsoid parameters (%s)\n", line);
gmt_init.c:				GMT->current.setting.ref_ellipsoid[i].flattening = 1.0 - (pol_radius / GMT->current.setting.ref_ellipsoid[i].eq_radius);
gmt_init.c:				GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "user-supplied ellipsoid has implicit flattening of %.8f\n", GMT->current.setting.ref_ellipsoid[i].flattening);
gmt_init.c:			else if ((slop = fabs (GMT->current.setting.ref_ellipsoid[i].flattening - 1.0 +
gmt_init.c:			         (pol_radius/GMT->current.setting.ref_ellipsoid[i].eq_radius))) > 1.0e-8) {
gmt_init.c:				GMT_Report (GMT->parent, GMT_MSG_VERBOSE,
gmt_init.c:	gmt_M_free (GMT, GMT->session.font);
gmt_init.c:	gmt_M_str_free (GMT->init.runtime_bindir);
gmt_init.c:	gmt_M_str_free (GMT->init.runtime_libdir);
gmt_init.c:	gmt_M_str_free (GMT->init.runtime_library);
gmt_init.c:	gmt_M_str_free (GMT->init.runtime_plugindir);
gmt_init.c:		gmt_M_str_free (GMT->current.proj.proj4[i].name);
gmt_init.c:	gmt_M_free (GMT, GMT->current.proj.proj4);
gmt_init.c:		gmt_M_str_free (GMT->init.history[i]);
gmt_init.c:	for (i = 0; i < GMT->common.a.n_aspatial; i++)
gmt_init.c:		gmt_M_str_free (GMT->common.a.name[i]);
gmt_init.c:	gmt_M_str_free (GMT->common.h.title);
gmt_init.c:	gmt_M_str_free (GMT->common.h.remark);
gmt_init.c:	gmt_M_str_free (GMT->common.h.colnames);
gmt_init.c:	if (GMT->current.setting.io_gridfile_shorthand) gmtinit_freeshorthand (GMT);
gmt_init.c:	fflush (GMT->session.std[GMT_OUT]);	/* Make sure output buffer is flushed */
gmt_init.c:	gmtlib_free_ogr (GMT, &(GMT->current.io.OGR), 1);	/* Free up the GMT/OGR structure, if used */
gmt_init.c:	PSL_endsession (GMT->PSL);
gmt_init.c:	gmt_M_str_free (GMT->hidden.mem_keeper);
gmt_init.c:	GMT->hidden.func_level++;		/* This lets us know how deeply we are nested when a GMT module is called */
gmt_init.c:	if (GMT->session.n_user_media) {
gmt_init.c:		Csave->session.n_user_media = GMT->session.n_user_media;
gmt_init.c:		Csave->session.user_media = gmt_M_memory (GMT, NULL, GMT->session.n_user_media, struct GMT_MEDIA);
gmt_init.c:		Csave->session.user_media_name = gmt_M_memory (GMT, NULL, GMT->session.n_user_media, char *);
gmt_init.c:		for (i = 0; i < GMT->session.n_user_media; i++) Csave->session.user_media_name[i] = strdup (GMT->session.user_media_name[i]);
gmt_init.c:	if (GMT->current.plot.n_alloc) {
gmt_init.c:		Csave->current.plot.n_alloc = GMT->current.plot.n_alloc;
gmt_init.c:		Csave->current.plot.x = gmt_M_memory (GMT, NULL, GMT->current.plot.n_alloc, double);
gmt_init.c:		Csave->current.plot.y = gmt_M_memory (GMT, NULL, GMT->current.plot.n_alloc, double);
gmt_init.c:		Csave->current.plot.pen = gmt_M_memory (GMT, NULL, GMT->current.plot.n_alloc, unsigned int);
gmt_init.c:		gmt_M_memcpy (Csave->current.plot.x, GMT->current.plot.x, GMT->current.plot.n_alloc, double);
gmt_init.c:		gmt_M_memcpy (Csave->current.plot.y, GMT->current.plot.y, GMT->current.plot.n_alloc, double);
gmt_init.c:		gmt_M_memcpy (Csave->current.plot.pen, GMT->current.plot.pen, GMT->current.plot.n_alloc, unsigned int);
gmt_init.c:	Csave->current.io.OGR = gmtlib_duplicate_ogr (GMT, GMT->current.io.OGR);	/* Duplicate OGR struct, if set */
gmt_init.c:	gmtlib_free_ogr (GMT, &(GMT->current.io.OGR), 1);		/* Free up the GMT/OGR structure, if used */
gmt_init.c:		if (GMT->current.io.o_format[i]) Csave->current.io.o_format[i] = strdup (GMT->current.io.o_format[i]);
gmt_init.c:	if (GMT->common.U.label) Csave->common.U.label = strdup (GMT->common.U.label);
gmt_init.c:	for (i = 0; i < GMT->common.a.n_aspatial; i++)
gmt_init.c:		if (GMT->common.a.name[i]) Csave->common.a.name[i] = strdup (GMT->common.a.name[i]);
gmt_init.c:	if (GMT->common.h.title) Csave->common.h.title = strdup (GMT->common.h.title);
gmt_init.c:	if (GMT->common.h.remark) Csave->common.h.remark = strdup (GMT->common.h.remark);
gmt_init.c:	if (GMT->common.h.colnames) Csave->common.h.colnames = strdup (GMT->common.h.colnames);
gmt_init.c:	Csave->session.GSHHGDIR = (GMT->session.GSHHGDIR) ? strdup (GMT->session.GSHHGDIR) : NULL;
gmt_init.c:	Csave->session.DCWDIR = (GMT->session.DCWDIR) ? strdup (GMT->session.DCWDIR) : NULL;
gmt_init.c:	Csave->session.SHAREDIR = (GMT->session.SHAREDIR) ? strdup (GMT->session.SHAREDIR) : NULL;
gmt_init.c:	Csave->session.HOMEDIR = (GMT->session.HOMEDIR) ? strdup (GMT->session.HOMEDIR) : NULL;
gmt_init.c:	Csave->session.USERDIR = (GMT->session.USERDIR) ? strdup (GMT->session.USERDIR) : NULL;
gmt_init.c:	Csave->session.CACHEDIR = (GMT->session.CACHEDIR) ? strdup (GMT->session.CACHEDIR) : NULL;
gmt_init.c:	Csave->session.DATADIR = (GMT->session.DATADIR) ? strdup (GMT->session.DATADIR) : NULL;
gmt_init.c:	Csave->session.TMPDIR = (GMT->session.TMPDIR) ? strdup (GMT->session.TMPDIR) : NULL;
gmt_init.c:	Csave->session.CUSTOM_LIBS = (GMT->session.CUSTOM_LIBS) ? strdup (GMT->session.CUSTOM_LIBS) : NULL;
gmt_init.c:	Csave->session.DATASERVER = (GMT->session.DATASERVER) ? strdup (GMT->session.DATASERVER) : NULL;
gmt_init.c:	GMT->common.B.active[GMT_PRIMARY] = GMT->common.B.active[GMT_SECONDARY] = GMT->common.K.active = GMT->common.O.active = false;
gmt_init.c:	GMT->common.P.active = GMT->common.U.active = GMT->common.V.active = false;	GMT->current.setting.map_logo = false;
gmt_init.c:	GMT->common.X.active = GMT->common.Y.active = false;
gmt_init.c:	GMT->common.R.active[RSET] = GMT->common.R.active[ISET] = GMT->common.R.active[GSET] = GMT->common.R.active[FSET] = GMT->common.J.active = false;
gmt_init.c:	GMT->common.a.active = GMT->common.b.active[GMT_IN] = GMT->common.b.active[GMT_OUT] = false;
gmt_init.c:	GMT->common.f.active[GMT_IN] = GMT->common.f.active[GMT_OUT] = GMT->common.g.active = GMT->common.h.active = false;
gmt_init.c:	GMT->common.p.active = GMT->common.s.active = GMT->common.t.active = GMT->common.colon.active = false;
gmt_init.c:	gmt_M_memset (GMT->common.b.ncol, 2, int);
gmt_init.c:	GMT->init.module_name = mod_name;
gmt_init.c:	GMT->init.module_lib  = lib_name;
gmt_init.c:	P = &(API->GMT->current.plot.panel);	/* Lazy shorthand only */
gmt_init.c:				if ((fp = fopen (file, API->GMT->current.io.w_mode)) == NULL) {
gmt_init.c:				if ((fp = fdopen (fd, API->GMT->current.io.w_mode)) == NULL) {
gmt_init.c:				while ((n_read = fread (content, 1, GMT_BUFSIZ, API->GMT->session.std[GMT_IN]))) {
gmt_init.c:			is_PS = API->GMT->current.ps.active;
gmt_init.c:			is_oneliner = API->GMT->current.ps.oneliner;
gmt_init.c:			API->GMT->current.ps.active = API->GMT->current.ps.oneliner = false;	/* To avoid gmtinfo from ending things */
gmt_init.c:			API->GMT->current.ps.active = is_PS;
gmt_init.c:			API->GMT->current.ps.oneliner = is_oneliner;
gmt_init.c:	while ((E = GMT_Find_Option (GMT->parent, 'E', E))) {	/* For all -E options */
gmt_init.c:	if ((opt = GMT_Find_Option (GMT->parent, 'R', options)) == NULL) return false;	/* Should not happen but lets just say Cartesian for now */
gmt_init.c:		if ((G = GMT_Read_Data (GMT->parent, GMT_IS_GRID, GMT_IS_FILE, GMT_IS_SURFACE, GMT_CONTAINER_ONLY, NULL, opt->arg, NULL)) == NULL)	/* Read header */
gmt_init.c:		if (GMT_Destroy_Data (GMT->parent, &G) != GMT_OK)
gmt_init.c:			API->GMT->hidden.func_level++;	/* Must do this here since it has not yet been increased by gmt_begin_module_sub ! */
gmt_init.c:			API->GMT->current.setting.run_mode = GMT_MODERN;
gmt_init.c:			API->GMT->current.ps.oneliner = true;	/* Special flag */
gmt_init.c:			API->GMT->hidden.func_level--;	/* Restore to what we had */
gmt_init.c:	if (fscanf (fp, "%lg %lg", &API->GMT->current.map.last_width, &API->GMT->current.map.last_height) != 2) {
gmt_init.c:	if (API->GMT->current.setting.run_mode == GMT_CLASSIC)  return GMT_NOERROR;	/* Not in modern mode */
gmt_init.c:	if (API->GMT->current.map.width == 0.0) return GMT_NOERROR;	/* No dimensions set yet */
gmt_init.c:	fprintf (fp, "%lg %lg\n", API->GMT->current.map.width, API->GMT->current.map.height);
gmt_init.c:	GMT_Report (API, GMT_MSG_DEBUG, "Modern mode: Func level %d, Updated -J%s to -J%s.\n", API->GMT->hidden.func_level, oldarg, opt_J->arg);
gmt_init.c:		if (GMT->current.setting.run_mode == GMT_MODERN && !(E_flags & 1)) {	/* Just country codes and plot settings, no region specs */
gmt_init.c:			if (!GMT->init.history[id]) id++;		/* No history for -RP, increment to -RG as fallback */
gmt_init.c:			if (GMT->init.history[id]) {	/* There is history for -R so -R will be added below */
gmt_init.c:			if (GMT->current.setting.run_mode == GMT_MODERN) {
gmt_init.c:	GMT->current.ps.active = is_PS;		/* true if module will produce PS */
gmt_init.c:	if (GMT->current.setting.run_mode == GMT_MODERN) {	/* Make sure options conform to this mode's harsh rules: */
gmt_init.c:		GMT->current.ps.initialize = false;	/* Start from scratch */
gmt_init.c:		if (GMT->hidden.func_level == GMT_CONTROLLER) {	/* The -R -J -O -K prohibition only applies to top-level module call */
gmt_init.c:					if (GMT->current.ps.active) {
gmt_init.c:					if (GMT->current.ps.active) {
gmt_init.c:			if (GMT->current.ps.active)	/* true if module will produce PS */
gmt_init.c:				(void)gmt_set_psfilename (GMT);	/* Sets GMT->current.ps.initialize=true if the expected (and hidden) PS plot file cannot be found */
gmt_init.c:		if (GMT->current.ps.active) {	/* Only explore -c settings, etc for plot modules */
gmt_init.c:			if ((inset_status = gmtinit_get_inset_dimensions (API, fig, &GMT->current.plot.inset))) {
gmt_init.c:			if (GMT->hidden.func_level == GMT_CONTROLLER && subplot_status & GMT_SUBPLOT_ACTIVE) {	/* Explore -c setting */
gmt_init.c:			if (strncmp (mod_name, "inset", 5U) && GMT->current.plot.inset.active && got_J) {	/* Map inset and gave -J */
gmt_init.c:				if (build_new_J_option (API, opt_J, NULL, &GMT->current.plot.inset, is_psrose))	/* Found ?-mark(s) and replaced them */
gmt_init.c:					GMT->current.plot.panel.no_scaling = 0;
gmt_init.c:					GMT->current.plot.panel.no_scaling = 1;
gmt_init.c:		if (GMT->current.ps.active && !exceptionp && (P = gmt_subplot_info (API, fig))) {	/* Yes, so set up current panel settings */
gmt_init.c:			if (GMT->hidden.func_level == GMT_CONTROLLER) {	/* Top-level function called by subplot needs to handle positioning and possibly set -J */
gmt_init.c:					GMT->current.plot.panel.no_scaling = 0;
gmt_init.c:					GMT->current.plot.panel.no_scaling = 1;
gmt_init.c:			if (GMT->current.ps.active || !strncmp (mod_name, "pscoast", 7U) || !strncmp (mod_name, "psbasemap", 9U)) {	/* A plotting module (or pscoast -M; psbasemap -A); first check -RP history */
gmt_init.c:				if (!GMT->init.history[id]) id++;	/* No history for -RP, increment to -RG as fallback */
gmt_init.c:			if (GMT->init.history[id]) {	/* There is history for -R */
gmt_init.c:				n_slashes = gmtlib_count_char (GMT, GMT->init.history[id], '/');	/* May need to know if it is 3 (2-D) or 5 (3-D) later regarding -p -JZ */
gmt_init.c:			if ((id = gmt_get_option_id (0, "J")) >= 0 && GMT->init.history[id]) {	/* There is history for -J */
gmt_init.c:				str[1] = GMT->init.history[id][0];
gmt_init.c:				if ((id = gmt_get_option_id (id + 1, str)) >= 0 && GMT->init.history[id]) {	/* There is history for this -J */
gmt_init.c:			if (!got_JZ && (id = gmt_get_option_id (0, "Z")) >= 0 && GMT->init.history[id]) {	/* Did not specify vertical projection but there is history for Z */
gmt_init.c:				str[1] = GMT->init.history[id][0];
gmt_init.c:				if ((id = gmt_get_option_id (0, str)) >= 0 && GMT->init.history[id]) {	/* There is history for this -Jz|Z */
gmt_init.c:			unsigned int level = GMT->hidden.func_level;	/* Since we will need to increment prematurely since gmt_begin_module_sub has not been reached yet */
gmt_init.c:			API->GMT->hidden.func_level++;	/* Must do this here in case gmt_parse_R_option calls mapproject */
gmt_init.c:			API->GMT->hidden.func_level = level;	/* Reset to what it should be */
gmt_init.c:			sgn = (GMT->common.R.wesn[XLO] < 0.0) ? -1.0 : +1.0;
gmt_init.c:			GMT->common.R.wesn[XLO] = sgn * ceil (fabs (GMT->common.R.wesn[XLO]) / res[srtm_res]) * res[srtm_res];
gmt_init.c:			sgn = (GMT->common.R.wesn[XHI] < 0.0) ? -1.0 : +1.0;
gmt_init.c:			GMT->common.R.wesn[XHI] = sgn * ceil  (fabs (GMT->common.R.wesn[XHI]) / res[srtm_res]) * res[srtm_res];
gmt_init.c:			sgn = (GMT->common.R.wesn[YLO] < 0.0) ? -1.0 : +1.0;
gmt_init.c:			GMT->common.R.wesn[YLO] = sgn * ceil (fabs (GMT->common.R.wesn[YLO]) / res[srtm_res]) * res[srtm_res];
gmt_init.c:			sgn = (GMT->common.R.wesn[YHI] < 0.0) ? -1.0 : +1.0;
gmt_init.c:			GMT->common.R.wesn[YHI] = sgn * ceil  (fabs (GMT->common.R.wesn[YHI]) / res[srtm_res]) * res[srtm_res];
gmt_init.c:			list = gmtlib_get_srtmlist (API, GMT->common.R.wesn, srtm_res, ocean);
gmt_init.c:			GMT->common.R.active[RSET] = false;	/* Since we will need to parse it again officially in GMT_Parse_Common */
gmt_init.c:	API->GMT->current.setting.run_mode = GMT_CLASSIC;	/* Since gmt_begin_module is 5.3 or earlier */
gmt_init.c:	unsigned int i, V_level = GMT->current.setting.verbose;	/* Keep copy of currently selected level */
gmt_init.c:	if (GMT->current.gdal_read_in.hCT_fwd)
gmt_init.c:		OCTDestroyCoordinateTransformation(GMT->current.gdal_read_in.hCT_fwd);
gmt_init.c:	if (GMT->current.gdal_read_in.hCT_inv)
gmt_init.c:		OCTDestroyCoordinateTransformation(GMT->current.gdal_read_in.hCT_inv);
gmt_init.c:	GMT->current.gdal_read_in.hCT_fwd = GMT->current.gdal_read_in.hCT_inv = NULL;
gmt_init.c:	if (GMT->hidden.func_level == GMT_TOP_MODULE && GMT->current.ps.oneliner && GMT->current.ps.active) {
gmt_init.c:		GMT->current.ps.oneliner = false;
gmt_init.c:		if ((i = GMT_Call_Module (GMT->parent, "end", GMT_MODULE_CMD, show))) {
gmt_init.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Unable to call module end for a one-liner plot.\n");
gmt_init.c:		GMT->current.setting.run_mode = GMT_CLASSIC;	/* all pau with modern session */
gmt_init.c:	if (GMT->hidden.func_level == GMT_TOP_MODULE && GMT->parent->log_level == GMT_LOG_ONCE) {	/* Reset logging to default at the end of a top-level module */
gmt_init.c:		fclose (GMT->session.std[GMT_ERR]);
gmt_init.c:		GMT->session.std[GMT_ERR] = stderr;
gmt_init.c:		GMT->parent->log_level = GMT_LOG_OFF;
gmt_init.c:	gmtinit_set_last_dimensions (GMT->parent);	/* Save canvas size */
gmt_init.c:	if (GMT->current.proj.n_geodesic_approx) {
gmt_init.c:		GMT_Report(GMT->parent, GMT_MSG_DEBUG, "Of % " PRIu64 " geodesic calls, % " PRIu64 " exceeded the iteration limit of 50.\n",
gmt_init.c:		           GMT->current.proj.n_geodesic_calls, GMT->current.proj.n_geodesic_approx);
gmt_init.c:	gmtapi_garbage_collection (GMT->parent, GMT->hidden.func_level);	/* Free up all registered memory for this module level */
gmt_init.c:	pass_changes_back = (!strncmp (GMT->init.module_name, "gmtset", 6U));	/* gmtset is special as we want it to affect the session */
gmt_init.c:	if (pass_changes_back) gmt_M_memcpy (&saved_settings, &(GMT->current.setting), 1U, struct GMT_DEFAULTS);
gmt_init.c:	if (GMT->current.setting.run_mode == GMT_MODERN && !GMT->current.ps.active && GMT->common.R.active[RSET]) {	/* Modern mode: Add enhanced RG history, if possible */
gmt_init.c:		if (GMT->init.history[id]) gmt_M_str_free (GMT->init.history[id]);
gmt_init.c:		snprintf (RG, GMT_LEN256, "%.16g/%.16g/%.16g/%.16g", GMT->common.R.wesn[XLO], GMT->common.R.wesn[XHI], GMT->common.R.wesn[YLO], GMT->common.R.wesn[YHI]);
gmt_init.c:		if (GMT->common.R.active[ISET]) {	/* Also want grid increment saved */
gmt_init.c:			snprintf (tmp, GMT_LEN64, "+I%.16g/%.16g", GMT->common.R.inc[GMT_X], GMT->common.R.inc[GMT_Y]);
gmt_init.c:		if (GMT->common.R.active[GSET]) {	/* Also want grid registration saved */
gmt_init.c:			snprintf (tmp, GMT_LEN64, "+G%c%c", GMT->common.R.registration == GMT_GRID_PIXEL_REG ? 'P' : 'G', GMT->common.R.row_order == k_nc_start_north ? 'T' : 'B');
gmt_init.c:		GMT->init.history[id] = strdup (RG);
gmt_init.c:		Ccopy->init.history[i] = GMT->init.history[i];
gmt_init.c:	Ccopy->current.ps.clip_level = GMT->current.ps.clip_level;
gmt_init.c:	Ccopy->current.ps.layer = GMT->current.ps.layer;
gmt_init.c:	Ccopy->current.ps.active = GMT->current.ps.active;
gmt_init.c:	Ccopy->current.ps.initialize = GMT->current.ps.initialize;
gmt_init.c:	if (Ccopy->common.U.label != GMT->common.U.label) gmt_M_str_free (Ccopy->common.U.label);
gmt_init.c:	Ccopy->common.U.label = GMT->common.U.label;
gmt_init.c:	for (i = 0; i < GMT->common.a.n_aspatial; i++) gmt_M_str_free (GMT->common.a.name[i]);
gmt_init.c:	gmt_M_str_free (GMT->common.h.title);
gmt_init.c:	gmt_M_str_free (GMT->common.h.remark);
gmt_init.c:	gmt_M_str_free (GMT->common.h.colnames);
gmt_init.c:	if (GMT->common.e.active) gmt_free_text_selection (GMT, &GMT->common.e.select);
gmt_init.c:	gmtlib_free_ogr (GMT, &(GMT->current.io.OGR), 1);	/* Free up the GMT/OGR structure, if used */
gmt_init.c:	if (pass_changes_back) gmt_M_memcpy (&(GMT->current.setting), &saved_settings, 1U, struct GMT_DEFAULTS);
gmt_init.c:	GMT->current.setting.verbose = V_level;	/* Pass the currently selected level back up */
gmt_init.c:	GMT->session.GSHHGDIR = (Ccopy->session.GSHHGDIR) ? strdup (Ccopy->session.GSHHGDIR) : NULL;
gmt_init.c:	GMT->session.DCWDIR = (Ccopy->session.DCWDIR) ? strdup (Ccopy->session.DCWDIR) : NULL;
gmt_init.c:	GMT->session.SHAREDIR = (Ccopy->session.SHAREDIR) ? strdup (Ccopy->session.SHAREDIR) : NULL;
gmt_init.c:	GMT->session.HOMEDIR = (Ccopy->session.HOMEDIR) ? strdup (Ccopy->session.HOMEDIR) : NULL;
gmt_init.c:	GMT->session.USERDIR = (Ccopy->session.USERDIR) ? strdup (Ccopy->session.USERDIR) : NULL;
gmt_init.c:	GMT->session.CACHEDIR = (Ccopy->session.CACHEDIR) ? strdup (Ccopy->session.CACHEDIR) : NULL;
gmt_init.c:	GMT->session.DATADIR = (Ccopy->session.DATADIR) ? strdup (Ccopy->session.DATADIR) : NULL;
gmt_init.c:	GMT->session.TMPDIR = (Ccopy->session.TMPDIR) ? strdup (Ccopy->session.TMPDIR) : NULL;
gmt_init.c:	GMT->session.CUSTOM_LIBS = (Ccopy->session.CUSTOM_LIBS) ? strdup (Ccopy->session.CUSTOM_LIBS) : NULL;
gmt_init.c:	GMT->session.DATASERVER = (Ccopy->session.DATASERVER) ? strdup (Ccopy->session.DATASERVER) : NULL;
gmt_init.c:		GMT->session.n_user_media = Ccopy->session.n_user_media;
gmt_init.c:		GMT->session.user_media = gmt_M_memory (GMT, NULL, Ccopy->session.n_user_media, struct GMT_MEDIA);
gmt_init.c:		GMT->session.user_media_name = gmt_M_memory (GMT, NULL, Ccopy->session.n_user_media, char *);
gmt_init.c:		for (i = 0; i < Ccopy->session.n_user_media; i++) GMT->session.user_media_name[i] = strdup (Ccopy->session.user_media_name[i]);
gmt_init.c:	if (GMT->hidden.func_level == GMT_CONTROLLER) {	/* Only when top-level module ends */
gmt_init.c:		GMT->current.setting.verbose = GMT_MSG_COMPAT;
gmt_init.c:		for (i = 0; i < (unsigned int)GMT->PSL->internal.N_FONTS; i++)
gmt_init.c:			GMT->PSL->internal.font[i].encoded = GMT->PSL->internal.font[i].encoded_orig;
gmt_init.c:		GMT->PSL->current.fontsize = 0;
gmt_init.c:	if (GMT->parent->external) {
gmt_init.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Cannot draw vector heads without specifying at least one of head outline or head fill.\n");
gmt_init.c:	S->v.pen = GMT->current.setting.map_default_pen;
gmt_init.c:	S->v.v_shape = (float)GMT->current.setting.map_vector_shape;	/* Can be overridden with +h<shape> */
gmt_init.c:						GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Bad +g<fill> argument %s\n", &p[1]);
gmt_init.c:					GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Bad +h<shape> modifier value: Must be in -2/+2 range\n");
gmt_init.c:					GMT_Report (GMT->parent, GMT_MSG_NORMAL, "-Sm does not accept +j<just> modifiers.\n");
gmt_init.c:							GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Bad +j<just> modifier %c\n", p[1]);
gmt_init.c:						GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Bad +m<dir> modifier %c\n", p[1]);
gmt_init.c:						GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Vector shrink length limit for geovectors must be given in km!\n");
gmt_init.c:					S->v.v_norm /= (float)GMT->current.proj.DIST_KM_PR_DEG;
gmt_init.c:					S->v.v_norm *= GMT->session.u2u[j][GMT_INCH];
gmt_init.c:					S->v.v_norm *= GMT->session.u2u[GMT->current.setting.proj_length_unit][GMT_INCH];
gmt_init.c:				GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Vector shrink scale v_norm = %g\n", S->v.v_norm);
gmt_init.c:				else if ((j = GMT_Get_Values (GMT->parent, &p[1], value, 2)) != 2) {
gmt_init.c:					GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Bad +o[<plon>/<plat>] argument %s\n", &p[1]);
gmt_init.c:						GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Bad +p<pen> argument %s\n", &p[1]);
gmt_init.c:					GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Bad +t <trim> values %s\n", &p[f]);
gmt_init.c:				S->v.comp_scale = (float)gmt_convert_units (GMT, &p[1], GMT->current.setting.proj_length_unit, GMT_INCH);
gmt_init.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Bad modifier +%c\n", p[0]);
gmt_init.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Cannot combine mid-point vector head (+m) with end-point heads (+b | +e)\n");
gmt_init.c:		p->base = GMT->session.d_NaN;
gmt_init.c:		p->u = GMT->current.setting.proj_length_unit;
gmt_init.c:	p->font = GMT->current.setting.font_annot[GMT_PRIMARY];
gmt_init.c:			//GMT_Report (GMT->parent, GMT_MSG_COMPAT, "bhstBHST vector modifiers is deprecated GMT3/4 syntax; see -S%c for current syntax.\n", text[0]);
gmt_init.c:								GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Bad +p<pen> argument %s\n", &q[1]);
gmt_init.c:					GMT_Report (GMT->parent, GMT_MSG_COMPAT,
gmt_init.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL,
gmt_init.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error in Option -Sf: Neither <gap> nor <ticklength> can be zero!\n");
gmt_init.c:					GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error in Option -Sf: Number of front ticks cannot be zero!\n");
gmt_init.c:					GMT_Report (GMT->parent, GMT_MSG_NORMAL,
gmt_init.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -S%c option\n", symbol_type);
gmt_init.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -S option: Symbol type %c is 3-D only\n", symbol_type);
gmt_init.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -S option: Symbol type %c is 3-D only\n", symbol_type);
gmt_init.c:					GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -S%c option\n", symbol_type);
gmt_init.c:						p->v.v_norm *= GMT->session.u2u[k][GMT_INCH];
gmt_init.c:						p->v.v_norm *= GMT->session.u2u[GMT->current.setting.proj_length_unit][GMT_INCH];
gmt_init.c:				GMT->init.n_custom_symbols = 0;
gmt_init.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -S= option\n");
gmt_init.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -S~ option: No symbol information given\n");
gmt_init.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -S option: Unrecognized symbol type %c\n", symbol_type);
gmt_init.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Internal Error.  Must change GMT_MAX_SYMBOL_COLS\n");
gmt_init.c:		p->base = (GMT->current.proj.xyz_projection[GMT_X] == GMT_LOG10) ? 1.0 : 0.0;
gmt_init.c:		p->base = (GMT->current.proj.xyz_projection[GMT_Y] == GMT_LOG10) ? 1.0 : 0.0;
gmt_init.c:		p->base = (GMT->current.proj.xyz_projection[GMT_Z] == GMT_LOG10) ? 1.0 : 0.0;
gmt_init.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "GMT Unit id must be 0-%d\n", GMT_N_UNITS-1);
gmt_init.c:	switch (GMT->current.setting.proj_length_unit) {
gmt_init.c:	*fwd_scale = 1.0 / GMT->current.proj.m_per_unit[unit];
gmt_init.c:	*inv_scale = GMT->current.proj.m_per_unit[unit];
gmt_init.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "GMT ERROR Option -%c: Only append one of %s|%s\n",
gmt_init.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Bad plot measure selected (%c); use c, i, or p.\n", unit);
gmt_init.c:	GMT->current.setting.proj_length_unit = k;
gmt_init.c:	GMT_Report (GMT->parent, GMT_MSG_COMPAT, "Option -%c[-]<mode>[/<threshold>] is deprecated. Use -n<mode>[+a][+t<threshold>] instead.\n", option);
gmt_init.c:				GMT->common.n.antialias = false; break;
gmt_init.c:				GMT->common.n.interpolant = BCR_NEARNEIGHBOR; break;
gmt_init.c:				GMT->common.n.interpolant = BCR_BILINEAR; break;
gmt_init.c:				GMT->common.n.interpolant = BCR_BSPLINE; break;
gmt_init.c:				GMT->common.n.interpolant = BCR_BICUBIC; break;
gmt_init.c:				GMT->common.n.threshold = atof (&item[j+1]);
gmt_init.c:				if (GMT->common.n.threshold < 0.0 || GMT->common.n.threshold > 1.0) {
gmt_init.c:					GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Interpolation threshold must be in [0,1] range\n");
gmt_init.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error: Specify -%c[-]b|c|l|n[/threshold] to set grid interpolation mode.\n", option);
gmt_init.c:	if (gmt_getinc (GMT, item, GMT->common.R.inc)) {
gmt_init.c:	GMT->common.R.active[ISET] = true;
gmt_init.c:		snprintf(GMT->common.J.proj4string, GMT_LEN256, "%s", item);		/* Copy the proj.4 string */
gmt_init.c:	if (item_t2 && !GMT->current.ps.active && !strcmp(item_t2, "/1:1")) {
gmt_init.c:		GMT->current.proj.projection_GMT = GMT_NO_PROJ;
gmt_init.c:		GMT->current.proj.is_proj4 = true;
gmt_init.c:		GMT->current.proj.pars[14] = 1;
gmt_init.c:			error += (gmt_M_check_condition (GMT, GMT->common.J.active, "Option -J given more than once\n") ||
gmt_init.c:			GMT->current.proj.projection_GMT = GMT_NO_PROJ;
gmt_init.c:				GMT->current.proj.pars[14] = 1;
gmt_init.c:			GMT->current.proj.pars[14] = 1;
gmt_init.c:				case 's': GMT->common.B.active[GMT_SECONDARY] = true; break;
gmt_init.c:				default:  GMT->common.B.active[GMT_PRIMARY] = true; break;
gmt_init.c:				if (GMT->current.setting.run_mode == GMT_MODERN) {
gmt_init.c:			if (GMT->hidden.func_level > GMT_CONTROLLER) return (0);	/* Just skip if we are inside a GMT module. -I is an API common option only */
gmt_init.c:			GMT->common.R.active[ISET] = true;
gmt_init.c:				error += (gmt_M_check_condition (GMT, GMT->common.J.zactive, "Option -JZ|z given more than once\n") ||
gmt_init.c:				GMT->common.J.zactive = true;
gmt_init.c:						GMT_Report (GMT->parent, GMT_MSG_NORMAL, "There is no destiny referencing system after the '+to' keyword.\n");
gmt_init.c:						GMT_Report (GMT->parent, GMT_MSG_NORMAL, "There is no destiny referencing system after the '+to' keyword.\n");
gmt_init.c:				GMT->current.gdal_read_in.hCT_fwd = gmt_OGRCoordinateTransformation (GMT, source, dest);
gmt_init.c:				GMT->current.gdal_read_in.hCT_inv = gmt_OGRCoordinateTransformation (GMT, dest, source);
gmt_init.c:				GMT->current.proj.projection      = GMT_PROJ4_PROJS;		/* This now make it use the proj4 lib */
gmt_init.c:				GMT->common.J.active = true;
gmt_init.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "PROJ.4 can only be used with GDAL linked GMT.\n");
gmt_init.c:				error += (gmt_M_check_condition (GMT, GMT->common.J.active, "Option -J given more than once\n") ||
gmt_init.c:				GMT->common.J.active = true;
gmt_init.c:			i += GMT_more_than_once (GMT, GMT->common.K.active);
gmt_init.c:			GMT->common.K.active = true;
gmt_init.c:			i += GMT_more_than_once (GMT, GMT->common.O.active);
gmt_init.c:			GMT->common.O.active = true;
gmt_init.c:			if (GMT->current.setting.run_mode == GMT_CLASSIC) {
gmt_init.c:				i += GMT_more_than_once (GMT, GMT->common.P.active);
gmt_init.c:				GMT->common.P.active = true;
gmt_init.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Option -%c is not a recognized common option in GMT modern mode\n", option);
gmt_init.c:				GMT_Report (GMT->parent, GMT_MSG_COMPAT, "Option -%c is deprecated. Use -n instead.\n" GMT_COMPAT_INFO, option);
gmt_init.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Option -%c is not a recognized common option\n", option);
gmt_init.c:			error += (GMT_more_than_once (GMT, GMT->common.R.active[RSET]) || gmt_parse_R_option (GMT, item));
gmt_init.c:			GMT->common.R.active[RSET] = true;
gmt_init.c:			error += (GMT_more_than_once (GMT, GMT->common.U.active) || gmtinit_parse_U_option (GMT, item));
gmt_init.c:			GMT->common.U.active = true;
gmt_init.c:			i += GMT_more_than_once (GMT, GMT->common.V.active);
gmt_init.c:			GMT->common.V.active = true;
gmt_init.c:					GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Unknown argument to -V option, -V%c\n", item[0]);
gmt_init.c:				GMT->current.setting.verbose = GMT_MSG_VERBOSE;
gmt_init.c:			error += (GMT_more_than_once (GMT, GMT->common.X.active) || gmtinit_parse_X_option (GMT, item));
gmt_init.c:			GMT->common.X.active = true;
gmt_init.c:			error += (GMT_more_than_once (GMT, GMT->common.Y.active) || gmtinit_parse_Y_option (GMT, item));
gmt_init.c:			GMT->common.Y.active = true;
gmt_init.c:				GMT_Report (GMT->parent, GMT_MSG_COMPAT, "Option -Z[<zlevel>] is deprecated. Use -p<azim>/<elev>[/<zlevel>] instead.\n"
gmt_init.c:					if (gmtinit_get_uservalue (GMT, item, gmt_M_type (GMT, GMT_IN, GMT_Z), &GMT->current.proj.z_level, "-Z zlevel value"))
gmt_init.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Option -%c is not a recognized common option\n", option);
gmt_init.c:			error += (GMT_more_than_once (GMT, GMT->common.a.active) || gmtinit_parse_a_option (GMT, item));
gmt_init.c:			GMT->common.a.active = true;
gmt_init.c:					error += gmt_M_check_condition (GMT, GMT->common.b.active[GMT_IN], "Warning Option -bi given more than once\n");
gmt_init.c:					GMT->common.b.active[GMT_IN] = true;
gmt_init.c:					error += gmt_M_check_condition (GMT, GMT->common.b.active[GMT_OUT], "Warning Option -bo given more than once\n");
gmt_init.c:					GMT->common.b.active[GMT_OUT] = true;
gmt_init.c:					error += gmt_M_check_condition (GMT, GMT->common.b.active[GMT_IN] + GMT->common.b.active[GMT_OUT],
gmt_init.c:					GMT->common.b.active[GMT_IN] = GMT->common.b.active[GMT_OUT] = true;
gmt_init.c:					error += gmt_M_check_condition (GMT, GMT->common.d.active[GMT_IN], "Warning Option -di given more than once\n");
gmt_init.c:					error += gmt_M_check_condition (GMT, GMT->common.d.active[GMT_OUT], "Warning Option -do given more than once\n");
gmt_init.c:					error += gmt_M_check_condition (GMT, GMT->common.d.active[GMT_IN] + GMT->common.d.active[GMT_OUT],
gmt_init.c:			error += (GMT_more_than_once (GMT, GMT->common.e.active) || gmtinit_parse_e_option (GMT, item));
gmt_init.c:			GMT->common.e.active = true;
gmt_init.c:					error += gmt_M_check_condition (GMT, GMT->common.f.active[GMT_IN], "Warning Option -fi given more than once\n");
gmt_init.c:					GMT->common.f.active[GMT_IN] = true;
gmt_init.c:					error += gmt_M_check_condition (GMT, GMT->common.f.active[GMT_OUT], "Warning Option -fo given more than once\n");
gmt_init.c:					GMT->common.f.active[GMT_OUT] = true;
gmt_init.c:					error += gmt_M_check_condition (GMT, GMT->common.f.active[GMT_IN] | GMT->common.f.active[GMT_OUT], "Warning Option -f given more than once\n");
gmt_init.c:					GMT->common.f.active[GMT_IN] = GMT->common.f.active[GMT_OUT] = true;
gmt_init.c:			GMT->common.g.active = true;
gmt_init.c:			error += (GMT_more_than_once (GMT, GMT->common.h.active) || gmtinit_parse_h_option (GMT, item));
gmt_init.c:			GMT->common.h.active = true;
gmt_init.c:			error += (GMT_more_than_once (GMT, GMT->common.i.active) || gmt_parse_i_option (GMT, item));
gmt_init.c:			GMT->common.i.active = true;
gmt_init.c:			error += (GMT_more_than_once (GMT, GMT->common.j.active) || gmt_parse_j_option (GMT, item));
gmt_init.c:			GMT->common.j.active = true;
gmt_init.c:			error += (GMT_more_than_once (GMT, GMT->common.l.active) || gmt_parse_l_option (GMT, item));
gmt_init.c:			GMT->common.l.active = true;
gmt_init.c:				GMT_Report (GMT->parent, GMT_MSG_COMPAT, "Option -%c is deprecated. Segment headers are automatically identified.\n", option);
gmt_init.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Option -%c is not a recognized common option\n", option);
gmt_init.c:			error += (GMT_more_than_once (GMT, GMT->common.n.active) || gmtinit_parse_n_option (GMT, item));
gmt_init.c:			GMT->common.n.active = true;
gmt_init.c:			error += (GMT_more_than_once (GMT, GMT->common.o.active) || gmt_parse_o_option (GMT, item));
gmt_init.c:			GMT->common.o.active = true;
gmt_init.c:			error += (GMT_more_than_once (GMT, GMT->common.p.active) || gmtinit_parse_p_option (GMT, item));
gmt_init.c:			GMT->common.p.active = true;
gmt_init.c:			error += GMT_more_than_once (GMT, GMT->common.R.active[GSET]);
gmt_init.c:			GMT->common.R.active[GSET] = true;
gmt_init.c:					case 'p': GMT->common.R.registration = GMT_GRID_PIXEL_REG; break;
gmt_init.c:					case 'g': GMT->common.R.registration = GMT_GRID_NODE_REG; break;
gmt_init.c:						GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error -r: Syntax is -r[g|p]\n");
gmt_init.c:				GMT->common.R.registration = GMT_GRID_PIXEL_REG;
gmt_init.c:			error += (GMT_more_than_once (GMT, GMT->common.s.active) || gmtinit_parse_s_option (GMT, item));
gmt_init.c:			GMT->common.s.active = true;
gmt_init.c:			error += GMT_more_than_once (GMT, GMT->common.t.active);
gmt_init.c:				GMT->common.t.value = atof (item);
gmt_init.c:				if (GMT->common.t.value < 0.0 || GMT->common.t.value > 100.0) {
gmt_init.c:					GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error -t: Transparency must be in (0-100]%% range!\n");
gmt_init.c:					GMT->common.t.value = 0.0;
gmt_init.c:				else if (GMT->common.t.value <= 1.0) {
gmt_init.c:					GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Transparency is expected in percentage.  Did you mean %g?\n", GMT->common.t.value * 100.0);
gmt_init.c:				GMT->common.t.active = true;
gmt_init.c:			else if (!strncmp (GMT->init.module_name, "psxy", 4U) || !strncmp (GMT->init.module_name, "pstext", 6U)) {	/* Modules psxy, psxyz, and pstext can do variable transparency */
gmt_init.c:				GMT->common.t.active = GMT->common.t.variable = true;
gmt_init.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Option -t was not given any value (please add transparency in (0-100]0%% range)!\n");
gmt_init.c:			error += (GMT_more_than_once (GMT, GMT->common.x.active) || gmtinit_parse_x_option (GMT, item));
gmt_init.c:			GMT->common.x.active = true;
gmt_init.c:			error += (GMT_more_than_once (GMT, GMT->common.colon.active) || gmtinit_parse_colon_option (GMT, item));
gmt_init.c:			GMT->common.colon.active = true;
gmt_init.c:			if (GMT->common.synopsis.active) GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Option - given more than once\n");
gmt_init.c:			GMT->common.synopsis.active = true;
gmt_init.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Option -%c requires a file argument\n", option);
gmt_init.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Option -%c is not a recognized common option\n", option);
gmt_init.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Offending option -%c%s\n", option, item);
gmt_init.c:				GMT_Report (GMT->parent, GMT_MSG_COMPAT, "Unit c (seconds) is deprecated; use s instead.\n");
gmt_init.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "TIME_UNIT is invalid.  Default assumed.\n");
gmt_init.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Choose one only from y o d h m s\n");
gmt_init.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Corresponding to year month day hour minute second\n");
gmt_init.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Note year and month are simply defined (365.2425 days and 1/12 of a year)\n");
gmt_init.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "TIME_EPOCH format is invalid.  Default assumed.\n");
gmt_init.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "    A correct format has the form [-]yyyy-mm-ddThh:mm:ss[.xxx]\n");
gmt_init.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "    or (using ISO weekly calendar)   yyyy-Www-dThh:mm:ss[.xxx]\n");
gmt_init.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "    An example of a correct format is:  2000-01-01T12:00:00\n");
gmt_init.c:	if (GMT->current.setting.run_mode == GMT_CLASSIC) return GMT_NOERROR;	/* Do nothing */
gmt_init.c:	if (GMT->current.ps.active && GMT->current.ps.initialize) return GMT_NOERROR;	/* Cannot use history unless overlay */
gmt_init.c:		if (options[j] == 'R' && GMT->common.R.active[RSET]) continue;	/* Set already */
gmt_init.c:		if (options[j] == 'J' && GMT->common.J.active) continue;	/* Set already */
gmt_init.c:		if (options[j] == 'R' && !GMT->current.ps.active) id++;		/* Examine -RG history if not a plotter */
gmt_init.c:		if (GMT->init.history[id] == NULL) continue;	/* No history for this option */
gmt_init.c:			str[1] = GMT->init.history[id][0];
gmt_init.c:			if (GMT->init.history[id] == NULL) continue;	/* No history for this option */
gmt_init.c:		err += gmt_parse_common_options (GMT, str, options[j], GMT->init.history[id]);
gmt_init.c:	GMT->current.io.pad[XLO] = GMT->current.io.pad[XHI] = GMT->current.io.pad[YLO] = GMT->current.io.pad[YHI] = pad;
gmt_init.c:		snprintf (dir, PATH_MAX, "%s/GDAL_DATA/n%s/proj", API->GMT->session.SHAREDIR, API->GMT->session.SHAREDIR);
gmt_init.c:	GMT->PSL = New_PSL_Ctrl (version);		/* Allocate a PSL control structure */
gmt_init.c:	if (!GMT->PSL) {
gmt_init.c:	GMT->PSL->init.unit = PSL_INCH;					/* We use inches internally in PSL */
gmt_init.c:	PSL_beginsession (GMT->PSL, API->external, GMT->session.SHAREDIR, GMT->session.USERDIR);	/* Initializes the session and sets a few defaults */
gmt_init.c:	PSL_setdefaults (GMT->PSL, GMT->current.setting.ps_magnify, GMT->current.setting.ps_page_rgb, GMT->current.setting.ps_encoding.name);
gmt_init.c:	gmt_hash_init (GMT, GMT->session.rgb_hashnode, gmt_M_color_name, GMT_N_COLOR_NAMES, GMT_N_COLOR_NAMES);
gmt_init.c:	if (API->runmode) GMT->current.setting.run_mode = GMT_MODERN;	/* Enforced at API Creation */
gmt_init.c:	GMT->common.n.antialias = true; GMT->common.n.interpolant = BCR_BICUBIC; GMT->common.n.threshold = 0.5;
gmt_init.c:	if (GMT->current.setting.io_gridfile_shorthand) gmtinit_setshorthand (GMT);	/* Load the short hand mechanism from gmt.io */
gmt_init.c:	/* Returns true if file is a known GMT-distributable file and download is enabled */
gmt_init.c:	if (GMT->current.setting.auto_download == GMT_NO_DOWNLOAD) return false;	/* Not enabled */
gmt_init.c:	GMT_Report (GMT->parent, GMT_MSG_DEBUG, "File %s: Type is %s\n", file, fkind[*kind]);
gmt_init.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error %s: No filename provided\n", message);
gmt_init.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error %s: No such file (%s)\n", message, &file[pos]);
gmt_init.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error %s: Cannot read file (%s) - check permissions\n", message, &file[pos]);
gmt_init.c:	if (GMT->common.b.active[direction]) {	/* User wants native binary i/o */
gmt_init.c:		fp = (direction == 0) ? GMT->session.std[GMT_IN] : GMT->session.std[GMT_OUT];
gmt_init.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Set binary mode for %s\n", IO_direction[direction]);
gmt_init.c:	if (GMT->current.setting.verbose == GMT_MSG_QUIET) return 0;	/* Nothing should be printed if -Vq is used */
gmt_init.c:	GMT->parent->print_func (GMT->session.std[GMT_ERR], line);
gmt_init.c:	if (level > GMT->current.setting.verbose)
gmt_init.c:	module_name = ((GMT->current.setting.run_mode == GMT_MODERN)) ? gmtlib_get_active_name (GMT->parent, GMT->init.module_name) : GMT->init.module_name;
gmt_init.c:	GMT->parent->print_func (GMT->session.std[GMT_ERR], message);
gmt_init.c:		strcpy (formats, gmt_session_format[API->GMT->current.setting.graphics_format]);
gmt_init.c:		strcpy (formats, gmt_session_format[API->GMT->current.setting.graphics_format]);
gmt_init.c:	if ((fp = open_figure_file (GMT->parent, 0, &err)) == NULL && mode < 2) {	/* No such file, nothing to do */
gmt_init.c:		get_session_name_format (GMT->parent, fig[0].prefix, fig[0].formats);
gmt_init.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Failed to read from figure file\n");
gmt_init.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Unable to determine number of figures\n");
gmt_init.c:		if (bad == 0 && strcmp (API->GMT->current.setting.ps_convert, &c[1])) {	/* Got psconvert options, and if different we update defaults */
gmt_init.c:			strncpy (API->GMT->current.setting.ps_convert, &c[1], GMT_LEN256-1);
gmt_init.c:			else if (API->GMT->current.setting.ps_convert[0]) {	/* Supply chosen session settings for psconvert */
gmt_init.c:				while ((gmt_strtok (API->GMT->current.setting.ps_convert, ",", &pos, p))) {
gmt_init.c:				if (not_PS && auto_size && !A_was_given (API->GMT->current.setting.ps_convert))	/* Must always add -A if not PostScript unless when media size is given */
gmt_init.c:			strncpy (formats, gmt_session_format[API->GMT->current.setting.graphics_format], GMT_LEN64-1);
gmt_init.c:	if (API->GMT->current.setting.run_mode == GMT_CLASSIC) return 0;	/* Only available in modern mode */
gmt_init.c:			fprintf (fp, "%c %s\n", type[code], gmt_putpen (API->GMT, &API->GMT->current.setting.map_default_pen));
gmt_init.c:	if (API->GMT->current.setting.run_mode == GMT_CLASSIC) return;	/* Only available in modern mode */
gmt_init.c:		if (pen == NULL) pen = &(API->GMT->current.setting.map_default_pen);	/* Must have pen to draw line */
gmt_init.c:		if (do_line && pen == NULL) pen = &(API->GMT->current.setting.map_default_pen);	/* Must have pen to draw line */
gmt_init.c:	if (API->GMT->current.setting.run_mode == GMT_CLASSIC) return false;	/* This is a modern mode only feature */
gmt_init.c:		*width = ncols * (GMT_LEGEND_DX2_MUL * (*scale) * W_max + N_max * 1.05 * GMT_LET_WIDTH * API->GMT->current.setting.font_annot[GMT_PRIMARY].size / PSL_POINTS_PER_INCH);
gmt_init.c:			API->GMT->current.setting.run_mode = GMT_MODERN;	/* Enable modern mode here so putdefaults can skip writing PS_MEDIA if not PostScript output */
gmt_init.c:			API->GMT->current.setting.history_orig = API->GMT->current.setting.history;	/* Temporarily turn off history so nothing is copied into the workflow dir */
gmt_init.c:			API->GMT->current.setting.history = GMT_HISTORY_OFF;	/* Turn off so that no history is copied into the workflow directory */
gmt_init.c:			API->GMT->current.setting.run_mode = (err == 0) ? GMT_MODERN : GMT_CLASSIC;
gmt_init.c:			API->GMT->current.setting.run_mode = GMT_CLASSIC;	/* Disable modern mode */
gmt_init.c:	if (API->GMT->current.setting.run_mode == GMT_MODERN) {
gmt_init.c:		GMT_Report (API, GMT_MSG_DEBUG, "GMT now running in %s mode [Session ID = %s]\n", type[API->GMT->current.setting.run_mode], API->session_name);
gmt_init.c:		API->GMT->current.setting.use_modern_name = true;
gmt_init.c:	GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "gmt_file_type: File %s returning code = %u, with pos[0] = %u and pos[1] = %u\n", file, code, pos[0], pos[1]);
gmt_init.c:	offset[GMT_OUT] = GMT->current.setting.map_label_offset + GMT->current.setting.map_frame_width;
gmt_init.c:	offset[GMT_IN]  = GMT->current.setting.map_label_offset;
gmt_init.c:	if (GMT->current.setting.run_mode == GMT_CLASSIC) return;	/* No can do */
gmt_init.c:	GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Determined colorbar side = %c and axis = %c\n", side, axis);
gmt_init.c:	snprintf (file, PATH_MAX, "%s/gmt%d.%s/gmt.frame", GMT->parent->session_dir, GMT_MAJOR_VERSION, GMT->parent->session_name);
gmt_init.c:		GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "No file %s with frame information - no adjustments made\n", file);
gmt_init.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "B item = %s\n", p);
gmt_init.c:	if (!axis_set && strchr (GMT->current.setting.map_frame_axes, side)) add_annot = true;
gmt_init.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Adding annotation space\n");
gmt_init.c:		offset[GMT_OUT] += MAX(0,GMT->current.setting.map_tick_length[GMT_ANNOT_UPPER]);	/* Any tick length */
gmt_init.c:		offset[GMT_OUT] += (GMT_LETTER_HEIGHT * GMT->current.setting.font_annot[GMT_PRIMARY].size / PSL_POINTS_PER_INCH) + MAX (0.0, GMT->current.setting.map_annot_offset[GMT_PRIMARY]);	/* Allow for space between axis and annotations */
gmt_init.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Adding label space\n");
gmt_init.c:		offset[GMT_OUT] += (GMT_LETTER_HEIGHT * GMT->current.setting.font_label.size / PSL_POINTS_PER_INCH) + MAX (0.0, GMT->current.setting.map_label_offset);
gmt_init.c:	if (API->GMT->current.setting.run_mode == GMT_MODERN) {	/* Under modern mode we always require an option like -? or -^ to call usage */
gmt_init.c:	bool o_trailing = GMT->current.io.trailing_text[GMT_OUT];	/* Since -i parsing below will wipe any -o setting that excludes trailing text */
gmt_init.c:	for (k = strlen (GMT->common.i.string) - 1; k && !(GMT->common.i.string[k] == ':' || GMT->common.i.string[k] == '-'); k--);	/* Find the last : or - in open-ended sequence */
gmt_init.c:	strncpy (token, GMT->common.i.string, k+1);	/* Get duplicate, this ends with - or : */
gmt_init.c:	if (GMT->common.i.string[k+1] == ',') strcat (token, &GMT->common.i.string[k+1]);	/* Probably trailing text selections */
gmt_init.c:	GMT->common.i.active = false;	/* So we can parse again */
gmt_init.c:	GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Reparse -i%s\n", token);
gmt_init.c:	GMT->current.io.trailing_text[GMT_OUT] = o_trailing;	/* Reset to what was parsed initially */
gmt_init.c:		GMT->current.io.output = gmtlib_ascii_output_trailing_text;	/* Just print trailing text */
gmt_init.c:	for (k = strlen (GMT->common.o.string) - 1; k && !(GMT->common.o.string[k] == ':' || GMT->common.o.string[k] == '-'); k--);	/* Find the last : or - in open-ended sequence */
gmt_init.c:	strncpy (token, GMT->common.o.string, k+1);	/* Get duplicate, this ends with - or : */
gmt_init.c:	if (GMT->common.o.string[k+1] == ',') strcat (token, &GMT->common.o.string[k+1]);	/* Probably trailing text selections */
gmt_init.c:	GMT->common.o.active = false;	/* So we can parse again */
gmt_init.c:	GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Reparse -o%s\n", token);
gmt_io.c: * via the GMT->current.io.input function pointer which either points to the
gmt_io.c: * Similarly, writing of such tables are done via the GMT->current.io.output
gmt_io.c: * GMT->current.io.input/output functions but these are reset in those two
gmt_io.c: *  gmtlib_getuserpath  Get pathname of file in "user directories" (GMT->session.TMPDIR, CWD, HOME, GMT->session.USERDIR, GMT->session.CACHEDIR)
gmt_io.c: *  gmt_getsharepath    Get pathname of file in "share directories" (CWD, GMT->session.USERDIR, GMT->session.SHAREDIR tree)
gmt_io.c:#define return_null(GMT,err) { GMT->parent->error = err; return (NULL);}
gmt_io.c:	if (GMT->common.g.active) return (MAX (n, GMT->common.g.n_col));	/* n or n_col (if larger) */
gmt_io.c:	if (GMT->current.io.need_previous) gmt_M_memcpy (GMT->current.io.prev_rec, GMT->current.io.curr_rec, n_use, double);
gmt_io.c:			GMT_Message (GMT->parent, GMT_TIME_NONE, message);
gmt_io.c:	while (*val > GMT->common.R.wesn[XHI] && (*val - 360.0) >= GMT->common.R.wesn[XLO])
gmt_io.c:	while (*val < GMT->common.R.wesn[XLO] && (*val + 360.0) <= GMT->common.R.wesn[XLO]) *val += 360.0;
gmt_io.c:	if (GMT->current.proj.inv_coord_unit != GMT_IS_METER) {	/* Must first scale to meters */
gmt_io.c:		GMT->current.io.curr_rec[GMT_X] *= GMT->current.proj.m_per_unit[GMT->current.proj.inv_coord_unit];
gmt_io.c:		GMT->current.io.curr_rec[GMT_Y] *= GMT->current.proj.m_per_unit[GMT->current.proj.inv_coord_unit];
gmt_io.c:	(*GMT->current.proj.inv) (GMT, &GMT->current.io.curr_rec[GMT_X], &GMT->current.io.curr_rec[GMT_Y],
gmt_io.c:	                          GMT->current.io.curr_rec[GMT_X], GMT->current.io.curr_rec[GMT_Y]);
gmt_io.c:			value = GMT->session.d_NaN;
gmt_io.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Bad OGR/GMT: @D record has more items than declared by @N\n");
gmt_io.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Bad OGR/GMT: @T record has more items than declared by @N - skipping\n");
gmt_io.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Bad OGR/GMT: @T: No such type: %s - skipping\n", p);
gmt_io.c:	if (GMT->current.io.OGR == NULL) return;		/* No can do */
gmt_io.c:	if (GMT->current.io.OGR->n_aspatial == 0) return;	/* No can do */
gmt_io.c:	if (GMT->common.a.active == false) return;		/* -a not given */
gmt_io.c:	if (GMT->common.a.n_aspatial) {		/* -a parsed and stuff was found; check if -a names are correct */
gmt_io.c:		for (k = 0; k < GMT->common.a.n_aspatial; k++) {
gmt_io.c:			for (kn = 0, found = false; !found && kn < GMT->current.io.OGR->n_aspatial; kn++)
gmt_io.c:				found = (!strcmp (GMT->common.a.name[k], GMT->current.io.OGR->name[kn]));
gmt_io.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error -a: No such named aspatial item: %s.\n", GMT->common.a.name[k]);
gmt_io.c:	GMT->common.a.n_aspatial = GMT->current.io.OGR->n_aspatial;
gmt_io.c:	for (k = kn = 0; k < GMT->common.a.n_aspatial; k++) {
gmt_io.c:		GMT->common.a.col[k] = 2 + kn;
gmt_io.c:		GMT->common.a.ogr[k] = k;
gmt_io.c:		GMT->common.a.type[k] = GMT->current.io.OGR->type[k];
gmt_io.c:		gmt_M_str_free (GMT->common.a.name[k]);	/* Just in case */
gmt_io.c:		GMT->common.a.name[k] = strdup (GMT->current.io.OGR->name[k]);
gmt_io.c:		if (GMT->common.a.type[k] != GMT_TEXT) kn++;	/* Since that is the order in the numerical part of the record */
gmt_io.c:	return (GMT->current.io.ogr_parser (GMT, record));	/* We call either the header or data parser depending on pointer */
gmt_io.c: 	 * We KNOW GMT->current.io.ogr == GMT_OGR_TRUE, i.e., current file is a GMT/OGR file.
gmt_io.c:	 * We also KNOW that GMT->current.io.OGR has been allocated by gmtio_ogr_header_parser.
gmt_io.c:	 * For GMT/OGR files we must parse and store the metadata in GMT->current.io.OGR,
gmt_io.c:	 * If we encounter a parsing error we stop parsing any further by setting GMT->current.io.ogr = GMT_OGR_FALSE.
gmt_io.c:	S = GMT->current.io.OGR;	/* Set S shorthand */
gmt_io.c:				if (!S->geometry) { GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Bad OGR/GMT: @D given but no geometry set\n"); return (false);}
gmt_io.c:					GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "OGR/GMT: Some @D items not specified (set to NULL) near line %" PRIu64 "\n", GMT->current.io.rec_no);
gmt_io.c:					GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "OGR/GMT: Offending record: %s\n", record);
gmt_io.c:					GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Bad OGR/GMT: @P only valid for polygons\n");
gmt_io.c:					GMT->current.io.ogr = GMT_OGR_FALSE;
gmt_io.c:					GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Bad OGR/GMT: @H only valid for polygons\n");
gmt_io.c:					GMT->current.io.ogr = GMT_OGR_FALSE;
gmt_io.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Bad OGR/GMT: Cannot have @%c after FEATURE_DATA\n", p[0]);
gmt_io.c:				GMT->current.io.ogr = GMT_OGR_FALSE;
gmt_io.c:	if (!GMT->common.a.active) return;	/* Nothing selected with -a */
gmt_io.c:	for (k = 0; k < GMT->common.a.n_aspatial; k++) {	/* Process the requested columns */
gmt_io.c:		id = gmt_get_ogr_id (GMT->current.io.OGR, GMT->common.a.name[k]);	/* See what order in the OGR struct this -a column appear */
gmt_io.c:		GMT->common.a.ogr[k] = id;
gmt_io.c: 	 * GMT->current.io.ogr can have three states:
gmt_io.c:	 * For GMT/OGR files we must parse and store the metadata in GMT->current.io.OGR,
gmt_io.c:	 * If we encounter a parsing error we stop parsing any further by setting GMT->current.io.ogr = GMT_OGR_FALSE.
gmt_io.c:	if (GMT->current.io.ogr == GMT_OGR_FALSE) return (false);	/* No point parsing further if we KNOW it is not OGR */
gmt_io.c:	if (GMT->current.io.ogr == GMT_OGR_TRUE && !strncmp (record, "# FEATURE_DATA", 14)) {	/* It IS an OGR file and we found end of OGR header section and start of feature data */
gmt_io.c:		GMT->current.io.ogr_parser = &gmtio_ogr_data_parser;	/* From now on only parse for feature tags */
gmt_io.c:	if (GMT->current.io.ogr == GMT_OGR_UNKNOWN && !strncmp (p, "@VGMT", 5)) {	/* Found the OGR version identifier, look for @G if on the same record */
gmt_io.c:		if (GMT->common.a.output) {	/* Cannot read OGR files when -a is used to define output */
gmt_io.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Cannot read OGR/GMT files when -a is used to define output format\n");
gmt_io.c:		GMT->current.io.ogr = GMT_OGR_TRUE;		/* File is now known to be a GMT/OGR geospatial file */
gmt_io.c:	if (GMT->current.io.ogr != GMT_OGR_TRUE) return (false);	/* No point parsing further since file is not GMT/OGR (at least not yet) */
gmt_io.c:	if (!GMT->current.io.OGR) GMT->current.io.OGR = gmt_M_memory (GMT, NULL, 1, struct GMT_OGR);
gmt_io.c:	S = GMT->current.io.OGR;
gmt_io.c:						GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Bad OGR/GMT: @G unrecognized geometry\n");
gmt_io.c:						GMT->current.io.ogr = GMT_OGR_FALSE;
gmt_io.c:					GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Bad OGR/GMT: @G cannot have different geometries\n");
gmt_io.c:					GMT->current.io.ogr = GMT_OGR_FALSE;
gmt_io.c:				if (!S->geometry) {GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Bad OGR/GMT: @N given but no geometry set\n"); return (false);}
gmt_io.c:					GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Bad OGR/GMT: @N Cannot have more than one per segment\n");
gmt_io.c:					GMT->current.io.ogr = GMT_OGR_FALSE;
gmt_io.c:					GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Bad OGR/GMT: @N number of items vary\n");
gmt_io.c:					GMT->current.io.ogr = GMT_OGR_FALSE;
gmt_io.c:						GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Bad OGR/GMT: @J given unknown format (%c)\n", (int)p[1]);
gmt_io.c:						GMT->current.io.ogr = GMT_OGR_FALSE;
gmt_io.c:					GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Bad OGR/GMT: @R can only appear once\n");
gmt_io.c:					GMT->current.io.ogr = GMT_OGR_FALSE;
gmt_io.c:				if (!S->geometry) { GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Bad OGR/GMT: @T given but no geometry set\n"); return (false);}
gmt_io.c:					GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Bad OGR/GMT: @T Cannot have more than one per segment\n");
gmt_io.c:					GMT->current.io.ogr = GMT_OGR_FALSE;
gmt_io.c:					GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Bad OGR/GMT: @T number of items vary\n");
gmt_io.c:					GMT->current.io.ogr = GMT_OGR_FALSE;
gmt_io.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Bad OGR/GMT: @%c not allowed before FEATURE_DATA\n", (int)p[0]);
gmt_io.c:				GMT->current.io.ogr = GMT_OGR_FALSE;
gmt_io.c:	if (GMT->current.io.ogr != GMT_OGR_TRUE) return (0);	/* No point checking further since file is not GMT/OGR */
gmt_io.c:	for (k = 0; k < GMT->common.a.n_aspatial; k++) {	/* For each item specified in -a */
gmt_io.c:		if (GMT->common.a.col[k] < 0) continue;		/* Not meant for data columns but for segment headers */
gmt_io.c:		if (GMT->current.io.OGR->type[GMT->common.a.ogr[k]] == GMT_TEXT)
gmt_io.c:	if (GMT->current.io.ogr != GMT_OGR_TRUE) return (0);	/* No point checking further since file is not GMT/OGR */
gmt_io.c:	for (k = n = nt = 0; k < GMT->common.a.n_aspatial; k++) {	/* For each item specified in -a */
gmt_io.c:		if (GMT->common.a.col[k] < 0) continue;	/* Not meant for data columns but for segment headers */
gmt_io.c:		if (GMT->current.io.OGR->type[GMT->common.a.ogr[k]] == GMT_TEXT) {	/* Text goes into trailing text */
gmt_io.c:			char *tvalue = GMT->current.io.OGR->tvalue[GMT->common.a.ogr[k]];
gmt_io.c:			if (nt) strcat (GMT->current.io.curr_trailing_text, GMT->current.setting.io_col_separator);
gmt_io.c:			strncat (GMT->current.io.curr_trailing_text, &tvalue[pos], GMT_BUFSIZ-1);
gmt_io.c:			GMT->current.io.record.text = GMT->current.io.curr_trailing_text;	/* Since it may not have been set */
gmt_io.c:			double value = GMT->current.io.OGR->dvalue[GMT->common.a.ogr[k]];
gmt_io.c:			GMT->current.io.curr_rec[GMT->common.a.col[k]] = gmt_convert_col (GMT->current.io.col[GMT_IN][GMT->common.a.col[k]], value);
gmt_io.c:	for (unsigned int k = 0; k < GMT->common.a.n_aspatial; k++) {
gmt_io.c:		sprintf (item, " %s[%s]", GMT->common.a.name[k], GMT_type[GMT->common.a.type[k]]);
gmt_io.c:	while ((gmt_strtok (line, GMT->current.io.scan_separators, &pos, p))) {
gmt_io.c:		GMT->current.io.status = GMT_IO_EOF;
gmt_io.c:/*! Reads the n binary doubles from input and saves to GMT->current.io.curr_rec[] */
gmt_io.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Number of data columns (%d) exceeds limit (GMT_MAX_COLUMNS = %d)\n", n, GMT_MAX_COLUMNS);
gmt_io.c:		if (GMT->current.io.fmt[GMT_IN][i].skip < 0) gmtio_x_read (GMT, fp, -GMT->current.io.fmt[GMT_IN][i].skip);	/* Pre-skip */
gmt_io.c:		if (GMT->current.io.fmt[GMT_IN][i].io (GMT, fp, 1, &GMT->current.io.curr_rec[i]) == GMT_DATA_READ_ERROR) {
gmt_io.c:			GMT->current.io.status = (feof (fp)) ? GMT_IO_EOF : GMT_IO_MISMATCH;
gmt_io.c:			if (GMT->current.io.give_report && GMT->current.io.n_bad_records) {
gmt_io.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "This file had %" PRIu64 " data records with invalid x and/or y values\n", GMT->current.io.n_bad_records);
gmt_io.c:				GMT->current.io.n_bad_records = GMT->current.io.rec_no = GMT->current.io.pt_no = GMT->current.io.n_clean_rec = 0;
gmt_io.c:		if (GMT->current.io.fmt[GMT_IN][i].skip > 0) gmtio_x_read (GMT, fp, GMT->current.io.fmt[GMT_IN][i].skip);	/* Post-skip */
gmt_io.c:	if (GMT->current.setting.io_lonlat_toggle[GMT_OUT])		/* Write lat/lon instead of lon/lat */
gmt_io.c:	n_out = (GMT->common.o.select) ? GMT->common.o.n_cols : n;
gmt_io.c:		col_pos = (GMT->common.o.select) ? GMT->current.io.col[GMT_OUT][i].col : i;	/* Which data column to pick */
gmt_io.c:		val = (col_pos >= n) ? GMT->session.d_NaN : ptr[col_pos];	/* If we request beyond length of array, return NaN */
gmt_io.c:		if (GMT->common.d.active[GMT_OUT] && gmt_M_is_dnan (val)) val = GMT->common.d.nan_proxy[GMT_OUT];	/* Write this value instead of NaNs */
gmt_io.c:		if (gmt_M_type (GMT, GMT_OUT, col_pos) == GMT_IS_LON) gmt_lon_range_adjust (GMT->current.io.geo.range, &val);
gmt_io.c:		if (GMT->current.io.fmt[GMT_OUT][i].skip < 0) gmtio_x_write (GMT, fp, -GMT->current.io.fmt[GMT_OUT][i].skip);	/* Pre-fill */
gmt_io.c:		k += GMT->current.io.fmt[GMT_OUT][i].io (GMT, fp, 1, &val);
gmt_io.c:		if (GMT->current.io.fmt[GMT_OUT][i].skip > 0) gmtio_x_write (GMT, fp, GMT->current.io.fmt[GMT_OUT][i].skip);	/* Post-fill */
gmt_io.c:	n_out = (GMT->common.o.select) ? GMT->common.o.n_cols : n;
gmt_io.c:		if (GMT->common.o.select)	/* Which data column to pick */
gmt_io.c:			col = GMT->current.io.col[GMT_OUT][i].col;
gmt_io.c:		else if (GMT->current.setting.io_lonlat_toggle[GMT_OUT] && i < 2)
gmt_io.c:		val = (col >= n) ? GMT->session.d_NaN : ptr[col];	/* If we request beyond length of array, return NaN */
gmt_io.c:		if (GMT->common.d.active[GMT_OUT] && gmt_M_is_dnan (val))	/* Write this value instead of NaNs */
gmt_io.c:			val = GMT->common.d.nan_proxy[GMT_OUT];
gmt_io.c:		else if (GMT->current.setting.io_col_separator[0])		/* Not last field, and a separator is required */
gmt_io.c:			fprintf (fp, "%s", GMT->current.setting.io_col_separator);
gmt_io.c:	if (GMT->common.o.word) {	/* Must output a specific word from the trailing text only */
gmt_io.c:		while (col != GMT->common.o.w_col && (word = strsep (&trail, GMT_TOKEN_SEPARATORS)) != NULL) {
gmt_io.c:			GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Trailing text did not have %" PRIu64 " words - no trailing word written\n", GMT->common.o.w_col);
gmt_io.c:	n_out = (GMT->common.o.select) ? GMT->common.o.n_cols : n;
gmt_io.c:		if (GMT->common.o.select)	/* Which data column to pick */
gmt_io.c:			col = GMT->current.io.col[GMT_OUT][i].col;
gmt_io.c:		else if (GMT->current.setting.io_lonlat_toggle[GMT_OUT] && i < 2)
gmt_io.c:		val = (col >= n) ? GMT->session.d_NaN : ptr[col];	/* If we request beyond length of array, return NaN */
gmt_io.c:		if (GMT->common.d.active[GMT_OUT] && gmt_M_is_dnan (val))	/* Write this value instead of NaNs */
gmt_io.c:			val = GMT->common.d.nan_proxy[GMT_OUT];
gmt_io.c:		if (GMT->current.setting.io_col_separator[0])		/* Not last field, and a separator is required */
gmt_io.c:			fprintf (fp, "%s", GMT->current.setting.io_col_separator);
gmt_io.c:	if (txt && GMT->current.io.trailing_text[GMT_OUT]) {
gmt_io.c:		if (n == 0 || (GMT->common.o.select && GMT->common.o.n_cols == 0))
gmt_io.c:			GMT->current.io.output = gmtlib_ascii_output_trailing_text;	/* Just print trailing text */
gmt_io.c:			GMT->current.io.output = gmtio_ascii_output_with_text;	/* Have trailing text after numerical output */
gmt_io.c:		return GMT->current.io.output (GMT, fp, n, ptr, txt);
gmt_io.c:		GMT->current.io.output = gmt_ascii_output_no_text;	/* Just numbers */
gmt_io.c:	if (GMT->current.io.output == gmtio_ascii_output_with_text) GMT->current.io.output = gmtio_ascii_output;	/* Go back to being agnostic */
gmt_io.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Column selected for latitude-formatting has values that exceed +/- 90; set to NaN\n");
gmt_io.c:	else gmt_lon_range_adjust (GMT->current.io.geo.range, &geo);	/* Adjust longitudes */
gmt_io.c:	if (GMT->current.io.geo.decimal) {	/* Easy */
gmt_io.c:		f = (GMT->current.io.o_format[is_lat]) ? GMT->current.io.o_format[is_lat] : GMT->current.setting.format_float_out;
gmt_io.c:		if (GMT->current.io.geo.no_sign) {
gmt_io.c:	if (GMT->current.io.geo.wesn) {	/* Trailing WESN */
gmt_io.c:		if (GMT->current.io.geo.wesn == 2) hemi[h_pos++] = ' ';	/* Want space between numbers and hemisphere letter */
gmt_io.c:		if (GMT->current.io.geo.order[k] >= 0) n_items++;	/* How many of d, m, and s are requested as integers */
gmt_io.c:	minus = gmtlib_geo_to_dms (geo, n_items, GMT->current.io.geo.f_sec_to_int, &d, &m, &s, &m_sec);	/* Break up into d, m, s, and remainder */
gmt_io.c:	if (GMT->current.io.geo.n_sec_decimals) {		/* Wanted fraction printed */
gmt_io.c:			sprintf (&text[minus], GMT->current.io.geo.y_format, d, m, s, m_sec, hemi);
gmt_io.c:			sprintf (&text[minus], GMT->current.io.geo.y_format, d, m, m_sec, hemi);
gmt_io.c:			sprintf (&text[minus], GMT->current.io.geo.y_format, d, m_sec, hemi);
gmt_io.c:		sprintf (&text[minus], GMT->current.io.geo.y_format, d, m, s, hemi);
gmt_io.c:		sprintf (&text[minus], GMT->current.io.geo.y_format, d, m, hemi);
gmt_io.c:		sprintf (&text[minus], GMT->current.io.geo.y_format, d, hemi);
gmt_io.c:/* NOTE: In the following we check GMT->current.io.col_type[GMT_IN][2] and GMT->current.io.col_type[GMT_OUT][2] for formatting help for the first column.
gmt_io.c:		GMT->current.io.status = GMT_IO_EOF;
gmt_io.c:			GMT->current.io.status = GMT_IO_EOF;
gmt_io.c:			GMT->current.io.status = GMT_IO_EOF;
gmt_io.c:			GMT->current.io.status = GMT_IO_EOF;
gmt_io.c:			GMT->current.io.status = GMT_IO_EOF;
gmt_io.c:			GMT->current.io.status = GMT_IO_EOF;
gmt_io.c:			GMT->current.io.status = GMT_IO_EOF;
gmt_io.c:			GMT->current.io.status = GMT_IO_EOF;
gmt_io.c:			GMT->current.io.status = GMT_IO_EOF;
gmt_io.c:			GMT->current.io.status = GMT_IO_EOF;
gmt_io.c:			GMT->current.io.status = GMT_IO_EOF;
gmt_io.c:			GMT->current.io.status = GMT_IO_EOF;
gmt_io.c:			GMT->current.io.status = GMT_IO_EOF;
gmt_io.c:			GMT->current.io.status = GMT_IO_EOF;
gmt_io.c:			GMT->current.io.status = GMT_IO_EOF;
gmt_io.c:			GMT->current.io.status = GMT_IO_EOF;
gmt_io.c:			GMT->current.io.status = GMT_IO_EOF;
gmt_io.c:			GMT->current.io.status = GMT_IO_EOF;
gmt_io.c:			GMT->current.io.status = GMT_IO_EOF;
gmt_io.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Unacceptable date template %s\n", text);
gmt_io.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Unacceptable clock template %s\n", text);
gmt_io.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Unacceptable dmmss template %s\n", text);
gmt_io.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Multiple periods in dmmss template %s is likely to lead to confusion\n", text);
gmt_io.c:	k = sscanf (s, GMT->current.io.clock_input.format, &hh, &mm, &ss);
gmt_io.c:	if ((n = sscanf (s, GMT->current.io.date_input.format, &ival[0], &ival[1], &ival[2])) <= 0) return (-1);
gmt_io.c:	if (GMT->current.io.date_input.Y2K_year) {
gmt_io.c:	if (GMT->current.io.date_input.day_of_year) {
gmt_io.c:		if ( (k = sscanf (s, GMT->current.io.date_input.format,
gmt_io.c:			&ival[GMT->current.io.date_input.item_order[0]],
gmt_io.c:			&ival[GMT->current.io.date_input.item_order[1]]) ) == 0) return (-1);
gmt_io.c:			if (!GMT->current.io.date_input.truncated_cal_is_ok) return (-1);
gmt_io.c:		if (GMT->current.io.date_input.Y2K_year) {
gmt_io.c:	if (GMT->current.io.date_input.mw_text) {	/* Have month name abbreviation in data format */
gmt_io.c:		switch (GMT->current.io.date_input.item_pos[1]) {	/* Order of month in data string */
gmt_io.c:				k = sscanf (s, GMT->current.io.date_input.format, month, &ival[GMT->current.io.date_input.item_order[1]],
gmt_io.c:				            &ival[GMT->current.io.date_input.item_order[2]]);
gmt_io.c:				k = sscanf (s, GMT->current.io.date_input.format, &ival[GMT->current.io.date_input.item_order[0]], month,
gmt_io.c:				            &ival[GMT->current.io.date_input.item_order[2]]);
gmt_io.c:				k = sscanf (s, GMT->current.io.date_input.format, &ival[GMT->current.io.date_input.item_order[0]],
gmt_io.c:				            &ival[GMT->current.io.date_input.item_order[1]], month);
gmt_io.c:			if (!strcmp (month, GMT->current.language.month_name[3][i])) ival[1] = i + 1;
gmt_io.c:	else if ((k = sscanf (s, GMT->current.io.date_input.format, &ival[GMT->current.io.date_input.item_order[0]],
gmt_io.c:	                      &ival[GMT->current.io.date_input.item_order[1]], &ival[GMT->current.io.date_input.item_order[2]])) == 0)
gmt_io.c:		if (GMT->current.io.date_input.truncated_cal_is_ok) {
gmt_io.c:	if (GMT->current.io.date_input.Y2K_year) {
gmt_io.c:	if (GMT->current.io.date_input.iso_calendar) return (gmtio_scanf_ISO_calendar (GMT, s, rd));
gmt_io.c:		GMT->current.plot.substitute_pi = true;	/* Used in formatting labels */
gmt_io.c:	   string, but we might allow the user to use that in a data file (in GMT->current.setting.[in/out]put_date_format.
gmt_io.c:		*t = gmt_rdc2dt (GMT, GMT->current.time.today_rata_die, x);
gmt_io.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Bad type passed to gmtio_write_formatted_ogr_value - assumed to be double\n");
gmt_io.c:	if (GMT->common.a.geometry == GMT_IS_POLYGON || GMT->common.a.geometry == GMT_IS_MULTIPOLYGON)
gmt_io.c:	if (GMT->common.a.n_aspatial) {
gmt_io.c:		for (col = 0; col < GMT->common.a.n_aspatial; col++) {
gmt_io.c:			switch (GMT->common.a.col[col]) {
gmt_io.c:					virt_col = abs (GMT->common.a.col[col]) - 1;	/* So -3 becomes 2 etc */
gmt_io.c:					if (gmt_parse_segment_item (GMT, GMT->current.io.segment_header, sflag[virt_col], buffer))
gmt_io.c:					virt_col = abs (GMT->common.a.col[col]) - 1;	/* So -3 becomes 2 etc */
gmt_io.c:					else if (gmt_parse_segment_item (GMT, GMT->current.io.segment_header, sflag[virt_col], buffer))
gmt_io.c:					if (SH->ogr) gmtio_write_formatted_ogr_value (GMT, fp, col, GMT->common.a.type[col], SH->ogr);
gmt_io.c:	T = (seg) ? SH->ogr->tvalue     : GMT->current.io.OGR->tvalue;	/* Input means system OGR, output from segment ogr struct */
gmt_io.c:	n = (seg) ? SH->ogr->n_aspatial : GMT->common.a.n_aspatial;
gmt_io.c:		switch (GMT->common.a.col[col]) {
gmt_io.c:				virt_col = abs (GMT->common.a.col[col]) - 1;	/* So -3 becomes 2 etc */
gmt_io.c:				strncat (buffer, T[GMT->common.a.ogr[col]], GMT_BUFSIZ-1);
gmt_io.c:	if (direction == GMT_IN && GMT->common.a.output) return;	/* Input was not OGR (but output will be) */
gmt_io.c:	n_reg = gmtapi_count_objects (GMT->parent, GMT_IS_DATASET, D->geometry, GMT_OUT, &object_ID);	/* Are there outputs registered already? */
gmt_io.c:		if ((item = gmtapi_validate_id (GMT->parent, GMT_IS_DATASET, object_ID, GMT_OUT)) == GMT_NOTSET)
gmt_io.c:			return (GMT->parent->error);
gmt_io.c:		gmt_M_memcpy (&O, GMT->parent->object[item], 1, struct GMTAPI_DATA_OBJECT);
gmt_io.c:		gmtapi_unregister_io (GMT->parent, object_ID, GMT_OUT);
gmt_io.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Cannot specify more than one output file for OGR\n");
gmt_io.c:	if ((object_ID = GMT_Register_IO (GMT->parent, GMT_IS_DATASET, GMT_IS_REFERENCE, GMT_IS_POINT, GMT_IN, NULL, D)) == GMT_NOTSET) {
gmt_io.c:		return (GMT->parent->error);
gmt_io.c:	if (GMT_Encode_ID (GMT->parent, in_string, object_ID) != GMT_OK) {
gmt_io.c:		return (GMT->parent->error);	/* Make filename with embedded object ID */
gmt_io.c:	if ((object_ID = GMT_Register_IO (GMT->parent, GMT_IS_DATASET, GMT_IS_DUPLICATE, GMT_IS_POINT, GMT_OUT, NULL, NULL)) == GMT_NOTSET) {
gmt_io.c:		return (GMT->parent->error);
gmt_io.c:	if (GMT_Encode_ID (GMT->parent, out_string, object_ID)) {
gmt_io.c:		return (GMT->parent->error);	/* Make filename with embedded object ID */
gmt_io.c:	GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Calling gmtinfo with args %s\n", buffer);
gmt_io.c:	if (GMT_Call_Module (GMT->parent, "gmtinfo", GMT_MODULE_CMD, buffer) != GMT_OK) {	/* Get the extent via gmtinfo */
gmt_io.c:		return (GMT->parent->error);
gmt_io.c:	if ((M = GMT_Retrieve_Data (GMT->parent, object_ID)) == NULL) {
gmt_io.c:		return (GMT->parent->error);
gmt_io.c:	if ((object_ID = GMT_Register_IO (GMT->parent, GMT_IS_DATASET, GMT_IS_FILE, GMT_IS_POINT, GMT_OUT, NULL, D)) == GMT_NOTSET) {
gmt_io.c:		return (GMT->parent->error);
gmt_io.c:	if ((item = gmtapi_validate_id (GMT->parent, GMT_IS_DATASET, object_ID, GMT_OUT)) == GMT_NOTSET) {
gmt_io.c:		return (GMT->parent->error);
gmt_io.c:	gmt_M_memcpy (GMT->parent->object[item], &O, 1, struct GMTAPI_DATA_OBJECT);	/* Restore what we had before */
gmt_io.c:	if (GMT_Destroy_Data (GMT->parent, &M) != GMT_OK) {
gmt_io.c:		return (GMT->parent->error);
gmt_io.c:	TH->ogr->geometry = GMT->common.a.geometry;
gmt_io.c:	TH->ogr->n_aspatial = GMT->common.a.n_aspatial;
gmt_io.c:			TH->ogr->name[k] = strdup (GMT->common.a.name[k]);
gmt_io.c:			TH->ogr->type[k] = GMT->common.a.type[k];
gmt_io.c:				col = GMT->common.a.col[k];
gmt_io.c:					GMT_Report (GMT->parent, GMT_MSG_NORMAL, "The -a option specified a constant column but its contents vary!\n");
gmt_io.c:				if (GMT->common.a.col[k] > 0)
gmt_io.c:					gmt_M_free (GMT, S->data[GMT->common.a.col[k]]);
gmt_io.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "The -a option specified [M]POLY but open segments were detected!\n");
gmt_io.c:				GMT_Destroy_Data (GMT->parent, &D[GMT_OUT]);
gmt_io.c:			GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Feature %" PRIu64 " crosses the Dateline\n", seg);
gmt_io.c:			if (!GMT->common.a.clip) continue;	/* Not asked to clip */
gmt_io.c:	GMT->current.io.geo.range = GMT_IS_M180_TO_P180_RANGE;	/* Select the -180/180 output range format */
gmt_io.c:	n = (GMT->current.io.OGR) ? GMT->current.io.OGR->n_aspatial : GMT->common.a.n_aspatial;
gmt_io.c:	/* General binary read function which calls function pointed to by GMT->current.io.read_binary to handle
gmt_io.c:	GMT->current.io.status = GMT_IO_DATA_RECORD;
gmt_io.c:		GMT->current.io.rec_no++;
gmt_io.c:	n_read = (GMT->common.i.select) ? gmtlib_bin_colselect (GMT) : *n;	/* We may use -i and select fewer of the input columns */
gmt_io.c:	if (gmtlib_gap_detected (GMT)) { *retval = gmtlib_set_gap (GMT); return (&GMT->current.io.record); }
gmt_io.c:	GMT->current.io.pt_no++;
gmt_io.c:	return (&GMT->current.io.record);
gmt_io.c:		T->segment[seg] = GMT_Alloc_Segment (GMT->parent, smode, nr, n_columns, Tin->segment[seg]->header, NULL);
gmt_io.c:		strncpy (GMT->current.io.curr_text, text, GMT_BUFSIZ-1);
gmt_io.c:		gmt_M_memset (GMT->current.io.curr_text, GMT_BUFSIZ, char);
gmt_io.c:	if (GMT->common.i.select && GMT->common.i.n_cols) {	/* Logical record differs from physical */
gmt_io.c:		for (k = 0; k < GMT->common.i.n_cols; k++) {
gmt_io.c:			if (GMT->current.io.col[GMT_IN][k].col == col)	/* Found one of the physical columns that will be column = order */
gmt_io.c:				return gmt_M_type (GMT, GMT_IN, GMT->current.io.col[GMT_IN][k].order);
gmt_io.c:	if (GMT->common.i.select && GMT->common.i.n_cols) {	/* Logical record differs from physical */
gmt_io.c:		for (k = 0; k < GMT->common.i.n_cols; k++) {
gmt_io.c:			if (GMT->current.io.col[GMT_IN][k].col == col) {	/* Found one of the physical columns that will be column = order */
gmt_io.c:				if (!GMT->current.io.col_set[GMT_IN][GMT->current.io.col[GMT_IN][k].order])
gmt_io.c:					gmt_set_column (GMT, GMT_IN, GMT->current.io.col[GMT_IN][k].order, type);
gmt_io.c:				if (!GMT->current.io.col_set[GMT_OUT][GMT->current.io.col[GMT_IN][k].order])
gmt_io.c:					gmt_set_column (GMT, GMT_OUT, GMT->current.io.col[GMT_IN][k].order, type);
gmt_io.c:		if (!GMT->current.io.col_set[GMT_IN][col])
gmt_io.c:		if (!GMT->current.io.col_set[GMT_OUT][col])
gmt_io.c:	while (!found_text && (gmt_strtok (record, GMT->current.io.scan_separators, &pos, token))) {
gmt_io.c:	if (GMT->common.i.end)	/* Asked for unspecified last column on input (e.g., -i3,2,5:), supply the missing last column number */
gmt_io.c:		if (GMT->current.io.trailing_text[GMT_IN]) ret_val = (*n_columns) ? GMT_READ_MIXED : GMT_READ_TEXT;	/* Possibly update record type */
gmt_io.c:	if (GMT->current.io.OGR) {	/* A few decision specific to OGR files */
gmt_io.c:	GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Source col types: (%s)\n", message);
gmt_io.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "ASCII source scanned: Numerical columns: %" PRIu64 ", Trailing text: %c, Record type: %s\n",
gmt_io.c:		if (GMT->common.i.select && GMT->common.i.n_cols > 0) {	/* Made a selection with -i */
gmt_io.c:			for (pos = 0; pos < GMT->common.i.n_cols; pos++) {
gmt_io.c:			if (GMT->current.io.trailing_text[GMT_IN]) {
gmt_io.c:			GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Selected col types: (%s)\n", message);
gmt_io.c:		if (GMT->common.o.select) {
gmt_io.c:			for (pos = 0; pos < GMT->common.o.n_cols; pos++) {
gmt_io.c:				col = GMT->current.io.col[GMT_OUT][pos].col;
gmt_io.c:			if (GMT->current.io.trailing_text[GMT_OUT]) {
gmt_io.c:			GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Output col types: (%s)\n", message);
gmt_io.c:	if (GMT->common.i.word) {	/* Need to extract a specific column from the trailing text */
gmt_io.c:		char *word = NULL, *orig = strdup (&GMT->current.io.curr_text[start_of_text]), *trail = orig;
gmt_io.c:		while (col != GMT->common.i.w_col && (word = strsep (&trail, GMT_TOKEN_SEPARATORS)) != NULL) {
gmt_io.c:			strncpy (GMT->current.io.curr_trailing_text, word, GMT_BUFSIZ-1);
gmt_io.c:			GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Trailing text did not have %" PRIu64 " words - no trailing word read\n", GMT->common.i.w_col);
gmt_io.c:		strncpy (GMT->current.io.curr_trailing_text, &GMT->current.io.curr_text[start_of_text], GMT_BUFSIZ-1);
gmt_io.c:	 * We return NULL (headers or errors) or pointer to GMT->current.io.curr_rec.
gmt_io.c:		GMT->current.io.rec_no++;		/* Counts up, regardless of what this record is (data, junk, segment header, etc) */
gmt_io.c:		GMT->current.io.rec_in_tbl_no++;	/* Counts up, regardless of what this record is (data, junk, segment header, etc) */
gmt_io.c:		if (GMT->current.setting.io_header[GMT_IN] && GMT->current.io.rec_in_tbl_no <= GMT->current.setting.io_n_header_items) {	/* Must treat first io_n_header_items as headers */
gmt_io.c:			if (GMT->common.h.mode == GMT_COMMENT_IS_RESET) continue;	/* Simplest way to replace headers on output is to ignore them on input */
gmt_io.c:			GMT->current.io.status = GMT_IO_TABLE_HEADER;
gmt_io.c:			GMT->current.setting.io_header[GMT_OUT] = true;	/* Turn on table headers on output PW: No! If we get here via -hi then no header output was requested */
gmt_io.c:		if (GMT->current.setting.io_blankline[GMT_IN]) {	/* Treat blank lines as segment markers, so only read a single line */
gmt_io.c:			GMT->current.io.rec_no++, GMT->current.io.rec_in_tbl_no++;
gmt_io.c:			while ((p = gmt_fgets (GMT, line, GMT_BUFSIZ, fp)) && gmt_is_a_blank_line (line)) GMT->current.io.rec_no++, GMT->current.io.rec_in_tbl_no++;
gmt_io.c:			GMT->current.io.status = GMT_IO_EOF;
gmt_io.c:			if (GMT->current.io.give_report && GMT->current.io.n_bad_records) {	/* Report summary and reset counters */
gmt_io.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "This file had %" PRIu64 " data records with invalid x and/or y values\n",
gmt_io.c:				            GMT->current.io.n_bad_records);
gmt_io.c:				GMT->current.io.n_bad_records = GMT->current.io.pt_no = GMT->current.io.n_clean_rec = 0;
gmt_io.c:				GMT->current.io.rec_no = GMT->current.io.rec_in_tbl_no = 0;
gmt_io.c:		if (line[0] == GMT->current.setting.io_head_marker[GMT_IN]) {	/* Got a file header, copy it and return */
gmt_io.c:			if (GMT->common.h.mode == GMT_COMMENT_IS_RESET) continue;	/* Simplest way to replace headers on output is to ignore them on input */
gmt_io.c:			GMT->current.io.status = GMT_IO_TABLE_HEADER;
gmt_io.c:			GMT->current.io.status = GMT_IO_SEGMENT_HEADER;
gmt_io.c:			GMT->current.io.seg_no++;
gmt_io.c:			GMT->current.io.segment_header[0] = '\0';
gmt_io.c:				if (GMT->current.io.ogr == GMT_OGR_TRUE) {
gmt_io.c:						gmtio_build_text_from_ogr (GMT, NULL, GMT->current.io.segment_header);	/* Fill in the buffer for -D, -G, Z etc */
gmt_io.c:						if (strstr (line, "@H")) strcat (GMT->current.io.segment_header, " -Ph");	/* Sometimes a @P or @H record instead */
gmt_io.c:							if (strstr (line, "@H")) strcat (GMT->current.io.segment_header, " -Ph");	/* Add the hole designation to the polygon option */
gmt_io.c:					strncpy (GMT->current.io.segment_header, gmtlib_trim_segheader (GMT, line), GMT_BUFSIZ-1);
gmt_io.c:		if (GMT->common.a.active && GMT->current.io.ogr == GMT_OGR_FALSE) {	/* Cannot give -a and not be reading an OGR/GMT file */
gmt_io.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Aspatial associations set with -a but input file is not in OGR/GMT format!\n");
gmt_io.c:		if (GMT->common.e.active && gmt_skip_record (GMT, GMT->common.e.select, line)) continue;	/* Fail a grep test */
gmt_io.c:		if (GMT->current.io.first_rec) {	/* Learn from the 1st record what we can about the type of data record this is */
gmt_io.c:			GMT->current.io.record_type[GMT_IN] = gmtio_examine_current_record (GMT, line, &start_of_text, &n_cols_this_record);
gmt_io.c:			if (GMT->current.io.variable_in_columns) {	/* Never finalize # of fields since it can change from rec to rec */
gmt_io.c:				strscan = (GMT->current.io.record_type[GMT_IN] & GMT_READ_TEXT) ? &strsepzp : &strsepz;	/* Need zp scanner to detect trailing text */
gmt_io.c:				GMT->current.io.first_rec = false;
gmt_io.c:				if (GMT->current.io.max_cols_to_read) {	/* A hard column count is enforced at first record */
gmt_io.c:					*n = GMT->current.io.max_cols_to_read;
gmt_io.c:					if (GMT->current.io.max_cols_to_read == n_cols_this_record && start_of_text == 0) {
gmt_io.c:						GMT->current.io.trailing_text[GMT_IN] = false;	/* Turn off reading text since none present */
gmt_io.c:						GMT->current.io.curr_trailing_text[0] = '\0';
gmt_io.c:						GMT->current.io.record.text = NULL;
gmt_io.c:					GMT->current.io.record_type[GMT_IN] = (GMT->current.io.trailing_text[GMT_IN]) ? GMT_READ_MIXED : GMT_READ_DATA;	/* Since otherwise we fail to store the trailing text */
gmt_io.c:					strscan = (GMT->current.io.trailing_text[GMT_IN]) ? &strsepzp : &strsepz;	/* Need zp scanner to detect anything beyond the fixed columns as trailing text */
gmt_io.c:						GMT->current.io.trailing_text[GMT_IN] = false;
gmt_io.c:						GMT->current.io.curr_trailing_text[0] = '\0';
gmt_io.c:						GMT->current.io.record.text = NULL;
gmt_io.c:						GMT->current.io.input = &gmtio_ascii_textinput;	/* Override and use ASCII text mode */
gmt_io.c:						strcpy (GMT->current.io.curr_trailing_text, line);
gmt_io.c:						GMT->current.io.record.text = GMT->current.io.curr_trailing_text;
gmt_io.c:						GMT->current.io.record.data = NULL;
gmt_io.c:						return (&GMT->current.io.record);
gmt_io.c:					*n = (GMT->common.i.select) ? GMT->common.i.n_cols : n_cols_this_record;
gmt_io.c:					strscan = (GMT->current.io.record_type[GMT_IN] & GMT_READ_TEXT) ? &strsepzp : &strsepz;	/* Need zp scanner to detect trailing text */
gmt_io.c:		if (GMT->current.io.variable_in_columns && n_cols_this_record < n_use) n_use = n_cols_this_record;
gmt_io.c:		GMT->current.io.curr_trailing_text[0] = '\0';	/* Start with nuthin. */
gmt_io.c:		while (!bad_record && col_no < n_use && (token = strscan (&stringp, GMT->current.io.scan_separators, &start_of_text)) != NULL) {	/* Get one field at the time until we run out or have issues */
gmt_io.c:			if (GMT->common.i.select) {	/* Must do special column-based processing since the -i option was set */
gmt_io.c:				if (GMT->current.io.col_skip[in_col]) continue;		/* Just skip and not even count this column */
gmt_io.c:				col_pos = GMT->current.io.col[GMT_IN][col_no].order;	/* Which data column will receive this value */
gmt_io.c:				if (GMT->current.setting.io_nan_records || !GMT->current.io.skip_if_NaN[col_pos]) {	/* This field (or all fields) can be NaN so we pass it on */
gmt_io.c:					GMT->current.io.curr_rec[col_pos] = GMT->session.d_NaN;
gmt_io.c:				if (GMT->current.io.skip_if_NaN[col_pos]) set_nan_flag = true;	/* Flag that we found NaN in a column that means we should skip */
gmt_io.c:				GMT->current.io.curr_rec[col_pos] = gmt_convert_col (GMT->current.io.col[GMT_IN][col_no], val);
gmt_io.c:					gmtio_adjust_periodic_lon (GMT, &GMT->current.io.curr_rec[col_pos]);
gmt_io.c:				while (GMT->common.i.select && col_no < GMT->common.i.n_cols && GMT->current.io.col[GMT_IN][col_no].col == GMT->current.io.col[GMT_IN][col_no-1].col) {
gmt_io.c:					col_pos = GMT->current.io.col[GMT_IN][col_no].order;	/* The data column that will receive this value */
gmt_io.c:					GMT->current.io.curr_rec[col_pos] = gmt_convert_col (GMT->current.io.col[GMT_IN][col_no], val);
gmt_io.c:			while (start_of_text < (GMT_BUFSIZ-1) && GMT->current.io.curr_text[start_of_text] && strchr (GMT->current.io.scan_separators, GMT->current.io.curr_text[start_of_text])) start_of_text++;	/* First wind to start of trailing text */
gmt_io.c:			GMT->current.io.record.text = GMT->current.io.curr_trailing_text;
gmt_io.c:			GMT->current.io.n_bad_records++;
gmt_io.c:			if (GMT->current.io.give_report && (GMT->current.io.n_bad_records == 1)) {	/* Report 1st occurrence of bad record */
gmt_io.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Encountered first invalid ASCII data record near/at line # %" PRIu64 "\n",
gmt_io.c:				            GMT->current.io.rec_no);
gmt_io.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Likely causes:\n");
gmt_io.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "(1) Invalid x and/or y values, i.e. NaNs or garbage in text strings.\n");
gmt_io.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "(2) Incorrect data type assumed if -J, -f are not set or set incorrectly.\n");
gmt_io.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "(3) The -: switch is implied but not set.\n");
gmt_io.c:		else if (GMT->current.io.skip_duplicates && GMT->current.io.pt_no) {	/* Test to determine if we should skip repeated duplicate records with same x,y */
gmt_io.c:			done = !(GMT->current.io.curr_rec[GMT_X] == GMT->current.io.prev_rec[GMT_X] &&
gmt_io.c:			         GMT->current.io.curr_rec[GMT_Y] == GMT->current.io.prev_rec[GMT_Y]);	/* Yes, duplicate */
gmt_io.c:	GMT->current.io.status = (GMT->current.io.variable_in_columns || n_ok == n_use || *n == GMT_MAX_COLUMNS) ? 0 : GMT_IO_MISMATCH;	/* Hopefully set status to 0 (OK) */
gmt_io.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Mismatch between actual (%d) and expected (%d) fields near line %" PRIu64 " in file %s\n",
gmt_io.c:		            col_no, *n, GMT->current.io.rec_no, GMT->current.io.filename[GMT_IN]);
gmt_io.c:	if (GMT->current.setting.io_lonlat_toggle[GMT_IN] && col_no >= 2) {
gmt_io.c:		gmt_M_double_swap (GMT->current.io.curr_rec[GMT_X], GMT->current.io.curr_rec[GMT_Y]);	/* Got lat/lon instead of lon/lat */
gmt_io.c:	else if (GMT->current.proj.inv_coordinates)
gmt_io.c:		return (&GMT->current.io.record);
gmt_io.c:	GMT->current.io.pt_no++;	/* Got a valid data record (which is true even if it was a gap) */
gmt_io.c:		GMT->current.io.status |= GMT_IO_NAN;	/* Say we found NaNs */
gmt_io.c:		return (&GMT->current.io.record);	/* Pass back pointer to data array */
gmt_io.c:	return ((GMT->current.io.status) ? NULL : &GMT->current.io.record);	/* Pass back pointer to data array */
gmt_io.c:	if (use_GMT_io) {	/* Use GMT->current.io.info settings to determine if input is ASCII/binary, else it defaults to ASCII */
gmt_io.c:		strcpy (open_mode, (append) ? GMT->current.io.a_mode : GMT->current.io.w_mode);
gmt_io.c:		ASCII = !GMT->common.b.active[GMT_OUT];
gmt_io.c:		GMT->current.io.output = GMT->session.output_ascii;	/* Override and use ASCII mode */
gmt_io.c:	psave = GMT->current.io.output;		/* Save the previous pointer since we need to change it back at the end */
gmt_io.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "pointer 'dest' cannot be NULL here\n");
gmt_io.c:					GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Cannot open file %s\n", &file[append]);
gmt_io.c:			if (fp == NULL) fp = GMT->session.std[GMT_OUT];	/* Default destination */
gmt_io.c:			if (fp == GMT->session.std[GMT_OUT])
gmt_io.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Cannot convert file descriptor %d to stream in gmtio_write_table\n", *fd);
gmt_io.c:			if (fd == NULL) fp = GMT->session.std[GMT_OUT];	/* Default destination */
gmt_io.c:			if (fp == GMT->session.std[GMT_OUT])
gmt_io.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Unrecognized source type %d in gmtio_write_table\n", dest_type);
gmt_io.c:	was = GMT->current.io.multi_segments[GMT_OUT];
gmt_io.c:		if (ASCII && GMT->current.setting.io_header[GMT_OUT]) {
gmt_io.c:		switch (GMT->current.setting.io_first_header) {
gmt_io.c:				GMT->current.io.multi_segments[GMT_OUT] = (n_seg > 1 || (table->n_segments == 1 && table->segment[0]->header));
gmt_io.c:				GMT->current.io.multi_segments[GMT_OUT] = true;
gmt_io.c:				GMT->current.io.multi_segments[GMT_OUT] = (n_seg >1);
gmt_io.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Cannot open file %s\n", out_file);
gmt_io.c:			GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Writing data segment to file %s\n", out_file);
gmt_io.c:			if (ASCII && GMT->current.setting.io_header[GMT_OUT]) {
gmt_io.c:		if (GMT->current.io.multi_segments[GMT_OUT]) {	/* Want to write segment headers */
gmt_io.c:			if (!GMT->common.a.output && SH->ogr) gmtio_build_segheader_from_ogr (GMT, GMT_OUT, S);	/* We have access to OGR metadata */
gmt_io.c:				strncpy (GMT->current.io.segment_header, S->header, GMT_BUFSIZ-1);
gmt_io.c:				GMT->current.io.segment_header[0] = '\0';
gmt_io.c:			if (SH->ogr && GMT->common.a.output) gmtio_write_ogr_segheader (GMT, fp, S);
gmt_io.c:		if (SH->range && SH->range != GMT->current.io.geo.range) {	/* Segment-specific formatting for longitudes */
gmt_io.c:			GMT_Report (GMT->parent, GMT_MSG_DEBUG, "File %s Segment %d changed io.geo.range from %d to %d\n",
gmt_io.c:			            out_file, (int)seg, GMT->current.io.geo.range, SH->range);
gmt_io.c:			save = GMT->current.io.geo.range; GMT->current.io.geo.range = SH->range;
gmt_io.c:			GMT->current.io.output (GMT, fp, S->n_columns, out, txt);
gmt_io.c:		if (SH->range) GMT->current.io.geo.range = save; 	/* Restore formatting */
gmt_io.c:			GMT->current.io.output = psave;	/* Override and use ASCII mode */
gmt_io.c:	if (!use_GMT_io) GMT->current.io.output = psave;	/* Restore former pointers and values */
gmt_io.c:	GMT->current.io.multi_segments[GMT_OUT] = was;
gmt_io.c:	GMT->current.io.status = GMT_IO_DATA_RECORD;
gmt_io.c:		*n = GMT->current.io.ncols;			/* Number of requested columns */
gmt_io.c:	if (GMT->current.io.nrec == 0) {	/* First record, read the entire file and do all scalings */
gmt_io.c:		for (v = 0, col = 0; v < GMT->current.io.nvars && col < n_use; ++v) {	/* For each named variable v ... */
gmt_io.c:				start[k] = GMT->current.io.t_index[v][k];
gmt_io.c:				count[k] = GMT->current.io.count[v][k];
gmt_io.c:			for (k = 0; k < GMT->current.io.count[v][1]; ++col, ++k) {	/* For each column in variable v [typically 1 unless 2-D array] */
gmt_io.c:				nc_get_vara_double (GMT->current.io.ncid, GMT->current.io.varid[v], start, count, GMT->hidden.mem_coord[col]);	/* Read column */
gmt_io.c:				for (row = 0; row < GMT->current.io.ndim; ++row) {	/* Loop over all records (rows) to do scaling */
gmt_io.c:					if (GMT->hidden.mem_coord[col][row] == GMT->current.io.missing_value[v])	/* Nan proxy detected */
gmt_io.c:						GMT->hidden.mem_coord[col][row] = GMT->session.d_NaN;
gmt_io.c:						GMT->hidden.mem_coord[col][row] = GMT->hidden.mem_coord[col][row] * GMT->current.io.scale_factor[v] + GMT->current.io.add_offset[v];
gmt_io.c:					GMT->hidden.mem_coord[col][row] = gmt_convert_col (GMT->current.io.col[GMT_IN][v], GMT->hidden.mem_coord[col][row]);	/* Any additional user scalings */
gmt_io.c:	else if (*n > GMT->current.io.ncols) {
gmt_io.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "gmtio_nc_input is asking for %d columns, but file has only %" PRIu64 "\n",
gmt_io.c:		            *n, GMT->current.io.ncols);
gmt_io.c:		GMT->current.io.status = GMT_IO_MISMATCH;
gmt_io.c:		if (GMT->current.io.nrec == GMT->current.io.ndim) {	/* Reading past last record means EOF for netCDF files */
gmt_io.c:			GMT->current.io.status = GMT_IO_EOF;
gmt_io.c:		for (col = 0; col < GMT->current.io.ncols; ++col)
gmt_io.c:			GMT->current.io.curr_rec[col] = GMT->hidden.mem_coord[col][GMT->current.io.nrec];
gmt_io.c:		GMT->current.io.nrec++;
gmt_io.c:		GMT->current.io.rec_no++;
gmt_io.c:		return (GMT->current.io.curr_rec);
gmt_io.c:	GMT->current.io.pt_no++;
gmt_io.c:	return (&GMT->current.io.record);
gmt_io.c: * all the relevant information in the GMT->current.io struct (ncid, ndim, nrec, varid, add_offset,
gmt_io.c: * Also asigns GMT->current.io.col_type[GMT_IN] based on the variable attributes.
gmt_io.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "gmt_nc_fopen does not support netCDF writing mode\n");
gmt_io.c:	if (nc_open (path, NC_NOWRITE, &GMT->current.io.ncid)) return (NULL);
gmt_io.c:		if (nvars <= 0) nvars = sscanf (GMT->common.b.varnames,
gmt_io.c:		nc_inq_nvars (GMT->current.io.ncid, &GMT->current.io.nvars);
gmt_io.c:		GMT->current.io.nvars = nvars;
gmt_io.c:	GMT->current.io.varid = gmt_M_memory (GMT, NULL, GMT->current.io.nvars, int);
gmt_io.c:	GMT->current.io.scale_factor = gmt_M_memory (GMT, NULL, GMT->current.io.nvars, double);
gmt_io.c:	GMT->current.io.add_offset = gmt_M_memory (GMT, NULL, GMT->current.io.nvars, double);
gmt_io.c:	GMT->current.io.missing_value = gmt_M_memory (GMT, NULL, GMT->current.io.nvars, double);
gmt_io.c:	GMT->current.io.ndim = GMT->current.io.nrec = 0;
gmt_io.c:	for (i = 0; i < GMT->current.io.nvars; i++) {
gmt_io.c:		for (j = 0; j < 5; j++) GMT->current.io.t_index[i][j] = 0, GMT->current.io.count[i][j] = 1;
gmt_io.c:			in = sscanf (&varnm[i][j+1], "%" SCNuS ",%" SCNuS ",%" SCNuS ",%" SCNuS, &GMT->current.io.t_index[i][1],
gmt_io.c:			             &GMT->current.io.t_index[i][2], &GMT->current.io.t_index[i][3], &GMT->current.io.t_index[i][4]);
gmt_io.c:			GMT->current.io.varid[i] = i;
gmt_io.c:			gmt_M_err_fail (GMT, nc_inq_varid (GMT->current.io.ncid, varnm[i], &GMT->current.io.varid[i]), file);
gmt_io.c:		nc_inq_varname (GMT->current.io.ncid, GMT->current.io.varid[i], varname);
gmt_io.c:		gmt_M_err_fail (GMT, nc_inq_varndims (GMT->current.io.ncid, GMT->current.io.varid[i], &ndims), file);
gmt_io.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "NetCDF variable %s has too many dimensions (%d)\n", varname, j);
gmt_io.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "NetCDF variable %s has %" PRIuS " dimensions, cannot specify more than %d indices; ignoring remainder\n", varname, ndims, ndims-1);
gmt_io.c:			for (j = in; j < ndims; j++) GMT->current.io.t_index[i][j] = 0;
gmt_io.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "NetCDF variable %s has %" PRIuS " dimensions, showing only 2\n", varname, ndims);
gmt_io.c:		nc_inq_vardimid(GMT->current.io.ncid, GMT->current.io.varid[i], dimids);
gmt_io.c:		nc_inq_dimlen(GMT->current.io.ncid, dimids[0], &n);
gmt_io.c:		if (GMT->current.io.ndim != 0 && GMT->current.io.ndim != n) {
gmt_io.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "NetCDF variable %s has different dimension (%" PRIuS ") from others (%" PRIuS ")\n",
gmt_io.c:			            varname, n, GMT->current.io.ndim);
gmt_io.c:		GMT->current.io.count[i][0] = GMT->current.io.ndim = n;
gmt_io.c:			nc_inq_dimlen(GMT->current.io.ncid, dimids[1], &n);
gmt_io.c:		GMT->current.io.count[i][1] = n;
gmt_io.c:		GMT->current.io.ncols += (int)n;
gmt_io.c:			nc_inq_dim (GMT->current.io.ncid, dimids[j], dimname, &n);
gmt_io.c:			nc_inq_varid (GMT->current.io.ncid, dimname, &id);
gmt_io.c:			if (nc_get_att_double (GMT->current.io.ncid, id, "actual_range", dummy)) {
gmt_io.c:				nc_get_var1_double (GMT->current.io.ncid, id, &item[0], &dummy[0]);
gmt_io.c:				nc_get_var1_double (GMT->current.io.ncid, id, &item[1], &dummy[1]);
gmt_io.c:			GMT->current.io.t_index[i][j] = lrint((t_value[j] - dummy[0]) / (dummy[1] - dummy[0]));
gmt_io.c:		if (nc_get_att_double (GMT->current.io.ncid, GMT->current.io.varid[i], "scale_factor",
gmt_io.c:		                       &GMT->current.io.scale_factor[i]))
gmt_io.c:			GMT->current.io.scale_factor[i] = 1.0;
gmt_io.c:		if (nc_get_att_double (GMT->current.io.ncid, GMT->current.io.varid[i], "add_offset",
gmt_io.c:		                       &GMT->current.io.add_offset[i]))
gmt_io.c:			GMT->current.io.add_offset[i] = 0.0;
gmt_io.c:		if (nc_get_att_double (GMT->current.io.ncid, GMT->current.io.varid[i], "_FillValue",
gmt_io.c:		                       &GMT->current.io.missing_value[i]) && nc_get_att_double (GMT->current.io.ncid, GMT->current.io.varid[i],
gmt_io.c:		                       "missing_value", &GMT->current.io.missing_value[i]))
gmt_io.c:		    GMT->current.io.missing_value[i] = GMT->session.d_NaN;
gmt_io.c:		if (gmtlib_nc_get_att_text (GMT, GMT->current.io.ncid, GMT->current.io.varid[i], "long_name", long_name, GMT_LEN256)) long_name[0] = 0;
gmt_io.c:		if (gmtlib_nc_get_att_text (GMT, GMT->current.io.ncid, GMT->current.io.varid[i], "units", units, GMT_LEN256)) units[0] = 0;
gmt_io.c:			gmt_M_memcpy (&time_system, &GMT->current.setting.time_system, 1, struct GMT_TIME_SYSTEM);
gmt_io.c:				GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Time units [%s] in NetCDF file not recognised, defaulting to gmt.conf.\n",
gmt_io.c:			GMT->current.io.scale_factor[i] = GMT->current.io.scale_factor[i] * time_system.scale * GMT->current.setting.time_system.i_scale;
gmt_io.c:			GMT->current.io.add_offset[i] *= time_system.scale;	/* Offset in seconds */
gmt_io.c:			GMT->current.io.add_offset[i] += GMT_DAY2SEC_F * ((time_system.rata_die - GMT->current.setting.time_system.rata_die) +
gmt_io.c:			                                 (time_system.epoch_t0 - GMT->current.setting.time_system.epoch_t0));
gmt_io.c:			GMT->current.io.add_offset[i] *= GMT->current.setting.time_system.i_scale;	/* Offset in internal time units */
gmt_io.c:	GMT->current.io.input = gmtio_nc_input;
gmt_io.c:	tmp_pointer = (size_t)(-GMT->current.io.ncid);
gmt_io.c:	gmt_prep_tmp_arrays (GMT, GMT_IN, GMT->current.io.ndim, GMT->current.io.ncols);	/* Preallocate arrays for all netcdf vectors */
gmt_io.c:	GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Unable to read %s (permissions?)\n", path);
gmt_io.c:	if (GMT->current.io.ogr != GMT_OGR_TRUE) return (GMT_OK);	/* No point checking further since file is not GMT/OGR */
gmt_io.c:	for (k = 0; k < GMT->common.a.n_aspatial; k++) if (gmt_get_ogr_id (G, GMT->common.a.name[k])) return (-1);
gmt_io.c:	for (k = n = 0; k < GMT->common.a.n_aspatial; k++) {	/* For each item specified in -a */
gmt_io.c:		if ((id = gmt_get_ogr_id (G, GMT->common.a.name[k])) == GMT_NOTSET) {
gmt_io.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "No aspatial value found for column %s\n", GMT->common.a.name[k]);
gmt_io.c:				GMT->current.io.curr_rec[GMT->common.a.col[k]] = atof (G->tvalue[id]);
gmt_io.c:				gmt_scanf_arg (GMT, G->tvalue[id], GMT_IS_ABSTIME, false, &GMT->current.io.curr_rec[GMT->common.a.col[k]]);
gmt_io.c:			case 'd': *val *= GMT->current.proj.DIST_KM_PR_DEG; break;			/* arc degree */
gmt_io.c:			case 'm': *val *= GMT->current.proj.DIST_KM_PR_DEG * GMT_MIN2DEG; break;	/* arc minutes */
gmt_io.c:			case 's': *val *= GMT->current.proj.DIST_KM_PR_DEG * GMT_SEC2DEG; break;	/* arc seconds */
gmt_io.c:	if (!GMT->common.d.active[GMT_IN]) return false;	/* Not active */
gmt_io.c:	if (GMT->common.d.is_zero[GMT_IN]) return doubleAlmostEqualZero (0.0, value);	/* Change to NaN if value is zero */
gmt_io.c:	return doubleAlmostEqual (GMT->common.d.nan_proxy[GMT_IN], value);		/* Change to NaN if value ~nan_proxy */
gmt_io.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "gmtio_append_ogr_item: No GMT_OGR structure available\n");
gmt_io.c:	if (!GMT->current.setting.io_header[GMT_OUT]) return;	/* No output headers requested */
gmt_io.c:		if (txt[0] != GMT->current.setting.io_head_marker[GMT_OUT]) fputc (GMT->current.setting.io_head_marker[GMT_OUT], fp);	/* Make sure we have # at start ... if not multi-segment */
gmt_io.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Long input record (%d bytes) was truncated to first %d bytes!\n", size+n, size-2);
gmt_io.c:	if (stream == GMT->session.std[GMT_IN])  return (0);
gmt_io.c:	if (stream == GMT->session.std[GMT_OUT]) return (0);
gmt_io.c:	if (stream == GMT->session.std[GMT_ERR]) return (0);
gmt_io.c:	if ((size_t)stream == (size_t)-GMT->current.io.ncid) {
gmt_io.c:		nc_close (GMT->current.io.ncid);
gmt_io.c:		gmt_M_free (GMT, GMT->current.io.varid);
gmt_io.c:		gmt_M_free (GMT, GMT->current.io.add_offset);
gmt_io.c:		gmt_M_free (GMT, GMT->current.io.scale_factor);
gmt_io.c:		gmt_M_free (GMT, GMT->current.io.missing_value);
gmt_io.c:		GMT->current.io.ncols = 0;
gmt_io.c:		GMT->current.io.ncid = GMT->current.io.nvars = 0;
gmt_io.c:		GMT->current.io.ndim = GMT->current.io.nrec = 0;
gmt_io.c:		GMT->current.io.input = GMT->session.input_ascii;
gmt_io.c:	if (GMT->current.io.tempfile[0] && !access (GMT->current.io.tempfile, F_OK)) {
gmt_io.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Remove temporary GMT/OGR file %s\n", GMT->current.io.tempfile);
gmt_io.c:		gmt_remove_file (GMT, GMT->current.io.tempfile);
gmt_io.c:		GMT->current.io.tempfile[0] = '\0';	/* Flag as no longer active */	
gmt_io.c:	GMT->current.io.skip_duplicates = mode;
gmt_io.c:	if (GMT->common.b.active[GMT_IN] || GMT->common.b.active[GMT_OUT]) return (false);	/* Binary, so clearly false */
gmt_io.c:	if (GMT->current.io.ndim > 0) return (false);						/* netCDF, so clearly false */
gmt_io.c:	if (GMT->common.i.select || GMT->common.o.select) return (false);			/* Selected columns via -i and/or -o, so false */
gmt_io.c:	if (GMT->parent->external) {	/* External interface (e.g., mex, Python) so must check if writing files or memory */
gmt_io.c:	if (!GMT->common.g.active || GMT->current.io.pt_no == 0) return (false);	/* Not active or on first point in a segment */
gmt_io.c:	for (i = 0; i < GMT->common.g.n_methods; i++) {	/* Go through each criterion */
gmt_io.c:		if ((GMT->common.g.get_dist[i] (GMT, GMT->common.g.col[i]) > GMT->common.g.gap[i]) != GMT->common.g.match_all)
gmt_io.c:			return (!GMT->common.g.match_all);
gmt_io.c:	return (GMT->common.g.match_all);
gmt_io.c:	GMT->current.io.status = GMT_IO_GAP;
gmt_io.c:	GMT->current.io.seg_no++;
gmt_io.c:	GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Data gap detected via -g; Segment header inserted near/at line # %" PRIu64 "\n",
gmt_io.c:	            GMT->current.io.rec_no);
gmt_io.c:	sprintf (GMT->current.io.segment_header, "Data gap detected via -g; Segment header inserted");
gmt_io.c:	GMT->current.io.multi_segments[direction] = true_false;
gmt_io.c:	GMT->current.setting.io_header[direction] = true_false;
gmt_io.c:	err = GMT->current.io.write_item (GMT, fp, n, data);
gmt_io.c:	if ((*status = GMT->current.io.read_item (GMT, fp, *n, GMT->current.io.curr_rec)) == GMT_DATA_READ_ERROR) {
gmt_io.c:		GMT->current.io.status = GMT_IO_EOF;
gmt_io.c:	if (GMT->common.i.select)	/* We need to scale this single item */
gmt_io.c:		GMT->current.io.curr_rec[GMT_X] = gmt_convert_col (GMT->current.io.col[GMT_IN][GMT_X], GMT->current.io.curr_rec[GMT_X]);
gmt_io.c:	return (&GMT->current.io.record);
gmt_io.c:	/* Here, GMT->current.io.curr_rec has been filled in by fread */
gmt_io.c:		if (!gmt_M_is_dnan (GMT->current.io.curr_rec[col_no])) {	/* Clean data */
gmt_io.c:			if (col_no > 1 && gmt_input_is_nan_proxy (GMT, GMT->current.io.curr_rec[col_no]))	/* Input matched no-data setting, so change to NaN */
gmt_io.c:				GMT->current.io.curr_rec[col_no] = GMT->session.d_NaN;
gmt_io.c:			else if (GMT->common.i.select)	/* Cannot check here, done in gmtlib_bin_colselect instead when order is set */
gmt_io.c:						gmtio_adjust_periodic_lon (GMT, &GMT->current.io.curr_rec[col_no]);
gmt_io.c:						if (GMT->current.io.curr_rec[col_no] < -90.0 || GMT->current.io.curr_rec[col_no] > +90.0) {
gmt_io.c:							GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Latitude (%g) at line # %" PRIu64 " exceeds -|+ 90! - set to NaN\n", GMT->current.io.curr_rec[col_no], GMT->current.io.rec_no);
gmt_io.c:							GMT->current.io.curr_rec[col_no] = GMT->session.d_NaN;
gmt_io.c:						GMT->current.io.curr_rec[col_no] *= GMT->session.u2u[GMT->current.setting.proj_length_unit][GMT_INCH];
gmt_io.c:		if (!GMT->current.setting.io_nan_records && GMT->current.io.skip_if_NaN[col_no]) bad_record = true;	/* This field is not allowed to be NaN */
gmt_io.c:		if (GMT->current.io.skip_if_NaN[col_no]) set_nan_flag = true;
gmt_io.c:	if (!GMT->current.io.status && GMT->current.setting.n_bin_header_cols) {	/* Must have n_read NaNs to qualify as segment header (if enabled) */
gmt_io.c:		if (n_read >= GMT->current.setting.n_bin_header_cols && n_NaN == n_read) {
gmt_io.c:			GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Detected binary segment header near/at line # %" PRIu64 "\n", GMT->current.io.rec_no);
gmt_io.c:			GMT->current.io.status = GMT_IO_SEGMENT_HEADER;
gmt_io.c:			GMT->current.io.segment_header[0] = '\0';
gmt_io.c:			GMT->current.io.seg_no++;
gmt_io.c:			GMT->current.io.pt_no = 0;
gmt_io.c:		GMT->current.io.n_bad_records++;
gmt_io.c:		if (GMT->current.io.give_report && GMT->current.io.n_bad_records == 1) {	/* Report 1st occurrence */
gmt_io.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL,
gmt_io.c:			            "Encountered first invalid binary data record near/at line # %" PRIu64 "\n", GMT->current.io.rec_no);
gmt_io.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Likely causes:\n");
gmt_io.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "(1) Invalid x and/or y values, i.e. NaNs.\n");
gmt_io.c:	else if (GMT->current.io.skip_duplicates && GMT->current.io.pt_no) {	/* Test to determine if we should skip duplicate records with same x,y */
gmt_io.c:		if (GMT->current.io.curr_rec[GMT_X] == GMT->current.io.prev_rec[GMT_X] && GMT->current.io.curr_rec[GMT_Y] == GMT->current.io.prev_rec[GMT_Y]) return (2);	/* Yes, duplicate */
gmt_io.c:	if (GMT->current.setting.io_lonlat_toggle[GMT_IN] && n_read >= 2)
gmt_io.c:		gmt_M_double_swap (GMT->current.io.curr_rec[GMT_X], GMT->current.io.curr_rec[GMT_Y]);	/* Got lat/lon instead of lon/lat */
gmt_io.c:	if (GMT->current.proj.inv_coordinates) gmtio_adjust_projected (GMT);	/* Must apply inverse projection to get lon, lat */
gmt_io.c:	if (set_nan_flag) GMT->current.io.status |= GMT_IO_NAN;
gmt_io.c:	if (use_GMT_io)	/* Use GMT->current.io.info settings to determine if input is ASCII/binary, else it defaults to ASCII */
gmt_io.c:		strcpy (open_mode, (append) ? GMT->current.io.a_mode : GMT->current.io.w_mode);
gmt_io.c:	GMT->current.io.record_type[GMT_OUT] = D->type;
gmt_io.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "'dest' pointer cannot be NULL here\n");
gmt_io.c:					GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Cannot open file %s\n", &file[append]);
gmt_io.c:				GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Write Data Table to file %s\n", &file[append]);
gmt_io.c:			if (fp == NULL) fp = GMT->session.std[GMT_OUT];	/* Default destination */
gmt_io.c:			if (fp == GMT->session.std[GMT_OUT])
gmt_io.c:			GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Write Data Table to %s\n", file);
gmt_io.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Cannot convert file descriptor %d to stream in gmtio_write_table\n", *fd);
gmt_io.c:			if (fd == NULL) fp = GMT->session.std[GMT_OUT];	/* Default destination */
gmt_io.c:			if (fp == GMT->session.std[GMT_OUT])
gmt_io.c:			GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Write Data Table to %s\n", file);
gmt_io.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Unrecognized source type %d in gmtio_write_table\n", dest_type);
gmt_io.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Failed to prepare for OGR output formatting\n");
gmt_io.c:			GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Write Data Table to %s\n", out_file);
gmt_io.c:			n_seg = (unsigned int)((GMT->current.io.skip_headers_on_outout) ? 1 : D->table[tbl]->n_segments);
gmt_io.c:			n_seg = (unsigned int)((GMT->current.io.skip_headers_on_outout) ? 1 : D->n_segments);
gmt_io.c:	if (GMT->common.b.active[GMT_IN]) return true;	/* Clearly a binary file */
gmt_io.c:	if (gmt_M_compat_check (GMT, 4) && GMT->common.b.varnames[0]) return true;	/* Definitely netCDF */
gmt_io.c:	else if (GMT->common.b.active[GMT_IN]) {	/* Definitely not netCDF */
gmt_io.c:	else if (gmt_M_compat_check (GMT, 4) && GMT->common.b.varnames[0])	/* Definitely netCDF */
gmt_io.c:					if (GMT->parent->tmp_dir)	/* Make unique file in temp dir */
gmt_io.c:						snprintf (GMT->current.io.tempfile, PATH_MAX, "%s/gmt_ogr_%d.gmt", GMT->parent->tmp_dir, (int)getpid());
gmt_io.c:						snprintf (GMT->current.io.tempfile, PATH_MAX, "gmt_ogr_%d.gmt", (int)getpid());
gmt_io.c:					GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Convert %s to GMT/OGR file %s\n", c, GMT->current.io.tempfile);
gmt_io.c:					snprintf (cmd, GMT_BUFSIZ+GMT_LEN256, "ogr2ogr -mapFieldType Integer64=Integer -f \"OGR_GMT\" %s %s", GMT->current.io.tempfile, c);
gmt_io.c:					snprintf (cmd, GMT_BUFSIZ+GMT_LEN256, "ogr2ogr -f \"GMT\" %s %s", GMT->current.io.tempfile, c);
gmt_io.c:					GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Running %s\n", cmd);
gmt_io.c:						GMT_Report (GMT->parent, GMT_MSG_NORMAL, "System call [%s] FAILED with error %d.\n", cmd, error);
gmt_io.c:					sprintf (GMT->current.io.filename[GMT_IN], "%s <converted from %s via ogr2ogr>", GMT->current.io.tempfile, c);
gmt_io.c:					c = GMT->current.io.tempfile;	/* Open this temporary instead */
gmt_io.c:	if (GMT->current.setting.verbose < GMT_MSG_VERBOSE) return GMT_OK;	/* Not in verbose mode anyway */
gmt_io.c:	if (!GMT->common.b.active[direction]) return GMT_OK;	/* Not using binary i/o */
gmt_io.c:	if (GMT->common.b.type[direction] == 0) GMT->common.b.type[direction] = (direction == GMT_IN) ? 'd' : letter[GMT->current.setting.export_type];	/* Only happens for external interfaces */
gmt_io.c:	if (GMT->common.b.ncol[direction] == 0) {		/* Number of columns not set yet - delay message */
gmt_io.c:		if (direction == GMT_OUT) GMT->common.b.o_delay = true;
gmt_io.c:	if (direction == GMT_IN && GMT->common.i.select && GMT->common.b.ncol[GMT_IN] < GMT->common.i.n_actual_cols) {
gmt_io.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Number of input columns set by -i exceeds those set by -bi!\n");
gmt_io.c:	if (direction == GMT_OUT && GMT->common.o.select && GMT->common.b.ncol[GMT_OUT] < GMT->common.o.n_cols) {
gmt_io.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Number of output columns set by -o exceeds those set by -bo!\n");
gmt_io.c:	for (col = 0; col < GMT->common.b.ncol[direction]; col++) {	/* For each binary column of data */
gmt_io.c:		if (GMT->current.io.fmt[direction][col].skip < 0) {	/* Must skip n_bytes BEFORE reading this column */
gmt_io.c:			n_bytes = -GMT->current.io.fmt[direction][col].skip;
gmt_io.c:		if (GMT->current.io.fmt[direction][col].type == 0) {	/* Still not set, use the default type */
gmt_io.c:			GMT->current.io.fmt[direction][col].type = gmt_get_io_type (GMT, GMT->common.b.type[direction]);
gmt_io.c:			GMT->current.io.fmt[direction][col].io   = gmtlib_get_io_ptr (GMT, direction, GMT->common.b.swab[direction],
gmt_io.c:			                                                              GMT->common.b.type[direction]);
gmt_io.c:		s[0] = letter[GMT->current.io.fmt[direction][col].type];	/* Get data type code... */
gmt_io.c:		if (GMT->current.io.fmt[direction][col].skip > 0) {	/* Must skip n_bytes AFTER reading this column */
gmt_io.c:			n_bytes = GMT->current.io.fmt[direction][col].skip;
gmt_io.c:	GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "%s %d columns via binary records using format %s\n",
gmt_io.c:	            gmt_direction[direction], GMT->common.b.ncol[direction], message);
gmt_io.c:		n_cols = (GMT->common.i.select) ? GMT->common.i.n_cols : GMT->common.b.ncol[GMT_IN];
gmt_io.c:		uint64_t in_n_cols = (GMT->common.i.select) ? GMT->common.i.n_cols : GMT->common.b.ncol[GMT_IN];
gmt_io.c:		if (GMT->common.b.active[GMT_OUT])
gmt_io.c:			n_cols = (GMT->common.o.select) ? in_n_cols : GMT->common.b.ncol[GMT_OUT];
gmt_io.c:			n_cols = GMT->common.b.ncol[GMT_OUT];
gmt_io.c:	/* Initializes the internal GMT->common.b.ncol[] settings.
gmt_io.c:	if (direction == GMT_IN && GMT->common.b.ncol[direction]) return (GMT_OK);	/* Already set once by -bi */
gmt_io.c:	if (expected == 0 && (direction == GMT_OUT || GMT->common.b.active[direction])) {
gmt_io.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Number of numerical %s columns has been set to 0\n", mode[direction]);
gmt_io.c:	if (GMT->common.b.active[direction]) {	/* Must set uninitialized input/output pointers */
gmt_io.c:		char type = (GMT->common.b.type[direction]) ? GMT->common.b.type[direction] : 'd';
gmt_io.c:			if (!GMT->current.io.fmt[direction][col].io) {
gmt_io.c:				GMT->current.io.fmt[direction][col].io = gmtlib_get_io_ptr (GMT, direction, GMT->common.b.swab[direction], type);
gmt_io.c:				GMT->current.io.fmt[direction][col].type = gmt_get_io_type (GMT, type);
gmt_io.c:		GMT->common.b.ncol[direction] = expected;
gmt_io.c:		GMT->common.b.ncol[direction] = (direction == GMT_IN && expected == 0) ? GMT_MAX_COLUMNS : expected;
gmt_io.c:		if (direction == GMT_IN) GMT->current.io.max_cols_to_read = (unsigned int)expected;
gmt_io.c:	if (direction == GMT_OUT && GMT->common.b.o_delay) {	/* Issue delayed message (see gmtlib_io_banner) */
gmt_io.c:		GMT->common.b.o_delay = false;
gmt_io.c:	//if (direction == GMT_IN && expected && GMT->common.i.select && GMT->common.i.n_cols > expected)
gmt_io.c:	if (direction == GMT_IN && expected && GMT->common.i.select && GMT->common.i.n_actual_cols > expected)
gmt_io.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Number of %s columns required [%" PRIu64 "] is less that implied by -i [%" PRIu64 "]\n",
gmt_io.c:		            mode[GMT_IN], expected, GMT->common.i.n_actual_cols);
gmt_io.c:	 * current directory, home directory and $GMT->session.USERDIR (default ~/.gmt[/cache])
gmt_io.c:	/* In isolation mode (when GMT->session.TMPDIR is defined), we first look there */
gmt_io.c:	if (GMT->session.TMPDIR) {
gmt_io.c:		sprintf (path, "%s/%s", GMT->session.TMPDIR, stem);
gmt_io.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Found file %s\n", stem);
gmt_io.c:	if (GMT->session.HOMEDIR) {
gmt_io.c:		sprintf (path, "%s/%s", GMT->session.HOMEDIR, stem);
gmt_io.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Look for file %s\n", path);
gmt_io.c:			GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Found file %s\n", path);
gmt_io.c:	if (GMT->session.USERDIR) {
gmt_io.c:			sprintf (path, "%s/server/srtm1/%s", GMT->session.USERDIR, stem);
gmt_io.c:			sprintf (path, "%s/server/srtm3/%s", GMT->session.USERDIR, stem);
gmt_io.c:			sprintf (path, "%s/%s", GMT->session.USERDIR, stem);
gmt_io.c:			GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Look for file %s\n", path);
gmt_io.c:				GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Found file %s\n", path);
gmt_io.c:			sprintf (path, "%s/server/%s", GMT->session.USERDIR, stem);
gmt_io.c:			GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Look for file %s\n", path);
gmt_io.c:				GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Found file %s\n", path);
gmt_io.c:	if (GMT->session.CACHEDIR) {
gmt_io.c:		sprintf (path, "%s/%s", GMT->session.CACHEDIR, stem);
gmt_io.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Look for file %s\n", path);
gmt_io.c:			GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Found file %s\n", path);
gmt_io.c:	GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Could not find file %s\n", stem);
gmt_io.c:	char *udir[6] = {GMT->session.USERDIR, GMT->session.DATADIR, GMT->session.CACHEDIR, NULL, NULL, NULL}, dir[PATH_MAX];
gmt_io.c:			GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Found file %s\n", path);
gmt_io.c:	snprintf (serverdir, PATH_MAX, "%s/server", GMT->session.USERDIR);	udir[3] = serverdir;
gmt_io.c:	snprintf (srtm1dir, PATH_MAX, "%s/server/srtm1", GMT->session.USERDIR);	udir[4] = srtm1dir;
gmt_io.c:	snprintf (srtm3dir, PATH_MAX, "%s/server/srtm3", GMT->session.USERDIR);	udir[5] = srtm3dir;
gmt_io.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Look for file %s in %s\n", stem, udir[d]);
gmt_io.c:			GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Found file %s\n", path);
gmt_io.c:	GMT_Report (GMT->parent, GMT_MSG_DEBUG, "GMT: 0. Will try to find subdir=%s stem = %s suffix=%s\n", subdir, stem, suffix);
gmt_io.c:	GMT_Report (GMT->parent, GMT_MSG_DEBUG, "GMT: 1. gmt_getsharepath trying current dir\n");
gmt_io.c:	if (GMT->session.USERDIR) {
gmt_io.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "GMT: 2. gmt_getsharepath trying USERDIR %s\n", GMT->session.USERDIR);
gmt_io.c:		sprintf (path, "%s/%s%s", GMT->session.USERDIR, stem, suffix);
gmt_io.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "GMT: 3. gmt_getsharepath trying USERDIR subdir %s/%s\n", GMT->session.USERDIR, subdir);
gmt_io.c:		sprintf (path, "%s/%s/%s%s", GMT->session.USERDIR, subdir, stem, suffix);
gmt_io.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "GMT: 4. gmt_getsharepath trying SHAREDIR subdir %s/%s\n", GMT->session.SHAREDIR, subdir);
gmt_io.c:		sprintf (path, "%s/%s/%s%s", GMT->session.SHAREDIR, subdir, stem, suffix);
gmt_io.c:	GMT_Report (GMT->parent, GMT_MSG_DEBUG, "GMT: 5. gmt_getsharepath failed\n");
gmt_io.c:	GMT_Report (GMT->parent, GMT_MSG_NORMAL, "GMT: Bad mode (%d) passed to gmt_access\n", mode);
gmt_io.c:	while (*line && (isspace(*line) || *line == GMT->current.setting.io_seg_marker[GMT_IN]))
gmt_io.c:	if (GMT->current.setting.io_blankline[GMT_IN] && gmt_is_a_blank_line (line)) return (2);	/* Treat blank line as segment break */
gmt_io.c:	if (GMT->current.setting.io_nanline[GMT_IN] && gmtio_is_a_NaN_line (GMT, line)) return (2);		/* Treat NaN-records as segment break */
gmt_io.c:	if (line[0] == GMT->current.setting.io_seg_marker[GMT_IN]) return (1);	/* Got a regular GMT segment header */
gmt_io.c:		GMT->current.io.rec_no++;		/* Counts up, regardless of what this record is (data, junk, segment header, etc) */
gmt_io.c:		GMT->current.io.rec_in_tbl_no++;	/* Counts up, regardless of what this record is (data, junk, segment header, etc) */
gmt_io.c:			GMT->current.io.rec_no++;		/* Counts up, regardless of what this record is (data, junk, segment header, etc) */
gmt_io.c:			GMT->current.io.rec_in_tbl_no++;	/* Counts up, regardless of what this record is (data, junk, segment header, etc) */
gmt_io.c:		if (GMT->current.setting.io_header[GMT_IN] && GMT->current.io.rec_in_tbl_no <= GMT->current.setting.io_n_header_items) {	/* Must treat first io_n_header_items as headers */
gmt_io.c:			if (GMT->common.h.mode == GMT_COMMENT_IS_RESET) continue;	/* Simplest way to replace headers on output is to ignore them on input */
gmt_io.c:			GMT->current.io.status = GMT_IO_TABLE_HEADER;
gmt_io.c:			GMT->current.io.status = GMT_IO_EOF;
gmt_io.c:		if (line[0] == GMT->current.setting.io_head_marker[GMT_IN]) {	/* Got a file header, take action and return */
gmt_io.c:			if (GMT->common.h.mode == GMT_COMMENT_IS_RESET) continue;	/* Simplest way to replace headers on output is to ignore them on input */
gmt_io.c:			GMT->current.io.status = GMT_IO_TABLE_HEADER;
gmt_io.c:		if (line[0] == GMT->current.setting.io_seg_marker[GMT_IN]) {	/* Got a segment header, take action and return */
gmt_io.c:			GMT->current.io.status = GMT_IO_SEGMENT_HEADER;
gmt_io.c:			GMT->current.io.seg_no++;
gmt_io.c:			strncpy (GMT->current.io.segment_header, gmtlib_trim_segheader (GMT, line), GMT_BUFSIZ-1);
gmt_io.c:		if (!(GMT->common.e.active && gmt_skip_record (GMT, GMT->common.e.select, line)))	/* Fail a grep test */
gmt_io.c:	strcpy (GMT->current.io.curr_trailing_text, GMT->current.io.curr_text);
gmt_io.c:	GMT->current.io.record.text = GMT->current.io.curr_trailing_text;
gmt_io.c:	GMT->current.io.status = GMT_IO_DATA_RECORD;
gmt_io.c:	GMT->current.io.pt_no++;	/* Got a valid text record */
gmt_io.c:	return (&GMT->current.io.record);
gmt_io.c:	for (col = 0; col < GMT->common.i.n_cols; col++) {
gmt_io.c:		S = &(GMT->current.io.col[GMT_IN][col]);
gmt_io.c:		tmp[order] = gmt_convert_col (GMT->current.io.col[GMT_IN][col], GMT->current.io.curr_rec[S->col]);
gmt_io.c:					GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Latitude (%g) at line # %" PRIu64 " exceeds -|+ 90! - set to NaN\n", tmp[order], GMT->current.io.rec_no);
gmt_io.c:					tmp[S->order] = GMT->session.d_NaN;
gmt_io.c:				tmp[order] *= GMT->session.u2u[GMT->current.setting.proj_length_unit][GMT_INCH];
gmt_io.c:	gmt_M_memcpy (GMT->current.io.curr_rec, tmp, GMT->common.i.n_cols, double);
gmt_io.c:	return (GMT->common.i.n_cols);
gmt_io.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Number of output data columns (%d) exceeds limit (GMT_MAX_COLUMNS = %d)\n", n_cols, GMT_MAX_COLUMNS);
gmt_io.c:	if (GMT->current.setting.io_nan_mode == GMT_IO_NAN_OK) return (false);				/* Normal case; output the record */
gmt_io.c:	if (GMT->current.setting.io_nan_mode == GMT_IO_NAN_ONE) {	/* -sa: Skip records if any NaNs are found */
gmt_io.c:	for (c = n_nan = 0; c < GMT->current.io.io_nan_ncols; c++) {			/* Check each of the specified columns set via -s */
gmt_io.c:		if (GMT->current.io.io_nan_col[c] >= n_cols) continue;			/* Input record does not have this column */
gmt_io.c:		if (gmt_M_is_dnan (cols[GMT->current.io.io_nan_col[c]])) n_nan++;		/* Count the nan columns found */
gmt_io.c:	if (n_nan < GMT->current.io.io_nan_ncols  && GMT->current.setting.io_nan_mode == GMT_IO_NAN_KEEP) return (true);	/* Skip records if -sr and not enough NaNs found */
gmt_io.c:	if (n_nan == GMT->current.io.io_nan_ncols && GMT->current.setting.io_nan_mode == GMT_IO_NAN_SKIP) return (true);	/* Skip records if -s and NaNs in specified columns */
gmt_io.c:	if (GMT->common.b.active[GMT_IN]) {
gmt_io.c:		GMT->current.io.input = &gmtio_bin_input;
gmt_io.c:		strcpy (GMT->current.io.r_mode, "rb");
gmt_io.c:	if (GMT->common.b.active[GMT_OUT]) {
gmt_io.c:		GMT->current.io.output = &gmtio_bin_output;
gmt_io.c:		strcpy (GMT->current.io.w_mode, "wb");
gmt_io.c:		strcpy (GMT->current.io.a_mode, "ab+");
gmt_io.c:	gmt_format_calendar (GMT, date, tclock, &GMT->current.io.date_output, &GMT->current.io.clock_output, false, 1, dt);
gmt_io.c:	sec = dt * GMT->current.setting.time_system.scale;	/* Get seconds */
gmt_io.c:		if (GMT->current.io.clock_output.n_sec_decimals)
gmt_io.c:			snprintf (item, GMT_LEN16, "%0*.*fS", GMT->current.io.clock_output.n_sec_decimals+3, GMT->current.io.clock_output.n_sec_decimals, sec);
gmt_io.c:			if (GMT->current.io.o_format[col])	/* Specific to this column */
gmt_io.c:				sprintf (text, GMT->current.io.o_format[col], x);
gmt_io.c:				sprintf (text, GMT->current.setting.format_float_out, x);
gmt_io.c:			sprintf (text, GMT->current.setting.format_float_out, x);
gmt_io.c:	for (i = 0; i < GMT_MAX_COLUMNS; i++) GMT->current.io.col[dir][i].col = GMT->current.io.col[dir][i].order = i;	/* Default order */
gmt_io.c:	for (i = 0; i < GMT_MAX_COLUMNS; i++) GMT->current.io.col_skip[i] = false;	/* Consider all input columns */
gmt_io.c:	GMT->current.io.input  = GMT->session.input_ascii = &gmtio_ascii_input;
gmt_io.c:	GMT->current.io.output = &gmtio_ascii_output;
gmt_io.c:	GMT->current.io.ogr_parser = &gmtio_ogr_header_parser;		/* Parse OGR header records to start with */
gmt_io.c:	GMT->current.io.scan_separators = GMT_TOKEN_SEPARATORS;		/* Characters that may separate columns in ascii records */
gmt_io.c:	GMT->current.io.give_report = true;
gmt_io.c:	GMT->current.io.seg_no = GMT->current.io.rec_no = GMT->current.io.rec_in_tbl_no = 0;	/* These gets incremented so 1 means 1st record */
gmt_io.c:	GMT->current.io.warn_geo_as_cartesion = true;	/* Not yet read geographic data while in Cartesian mode so we want to warn if we find it */
gmt_io.c:	GMT->current.io.trailing_text[GMT_IN] = GMT->current.io.trailing_text[GMT_OUT] = true;	/* Default reads and writes any trailing text */
gmt_io.c:	GMT->current.setting.io_seg_marker[GMT_IN] = GMT->current.setting.io_seg_marker[GMT_OUT] = '>';
gmt_io.c:	strcpy (GMT->current.io.r_mode, "r");
gmt_io.c:	strcpy (GMT->current.io.w_mode, "w");
gmt_io.c:	strcpy (GMT->current.io.a_mode, "a+");
gmt_io.c:		GMT->current.io.date_input.item_order[i] = GMT->current.io.date_input.item_pos[i] = -1;
gmt_io.c:		GMT->current.io.date_output.item_order[i] = GMT->current.io.date_output.item_pos[i] = -1;
gmt_io.c:		GMT->current.io.clock_input.order[i] = GMT->current.io.clock_output.order[i] = GMT->current.io.geo.order[i] = -1;
gmt_io.c:	strcpy (GMT->current.io.clock_input.ampm_suffix[0],  "am");
gmt_io.c:	strcpy (GMT->current.io.clock_output.ampm_suffix[0], "am");
gmt_io.c:	strcpy (GMT->current.io.clock_input.ampm_suffix[1],  "pm");
gmt_io.c:	strcpy (GMT->current.io.clock_output.ampm_suffix[1], "pm");
gmt_io.c:	for (i = 0; i < 2; i++) GMT->current.io.skip_if_NaN[i] = true;								/* x/y must be non-NaN */
gmt_io.c:	gmt_M_memset (GMT->current.io.col_set[GMT_X], GMT_MAX_COLUMNS, char);	/* This is the initial state of input columns - all available to be changed by modules */
gmt_io.c:	gmt_M_memset (GMT->current.io.col_set[GMT_Y], GMT_MAX_COLUMNS, char);	/* This is the initial state of output columns - all available to be changed by modules */
gmt_io.c:	gmt_M_memset (GMT->current.io.curr_rec, GMT_MAX_COLUMNS, double);	/* Initialize current and previous records to zero */
gmt_io.c:	gmt_M_memset (GMT->current.io.prev_rec, GMT_MAX_COLUMNS, double);
gmt_io.c:	GMT->current.io.record.data = GMT->current.io.curr_rec;
gmt_io.c:	GMT->common.i.select = false;
gmt_io.c:	GMT->current.setting.io_header_orig = GMT->current.setting.io_header[GMT_IN];
gmt_io.c:	GMT->current.setting.io_header[GMT_IN] = false;
gmt_io.c:	if (GMT->common.b.active[GMT_IN]) {	/* Secondary file input requires ascii */
gmt_io.c:		GMT->common.b.active[GMT_IN] = false;
gmt_io.c:		GMT->common.b.bin_primary = true;
gmt_io.c:		GMT->current.io.input = &gmtio_ascii_input;
gmt_io.c:	GMT->common.i.select = GMT->common.i.orig;
gmt_io.c:	GMT->current.setting.io_header[GMT_IN] = GMT->current.setting.io_header_orig;
gmt_io.c:	if (GMT->common.b.bin_primary) {	/* Switch back to primary i/o mode which was binary */
gmt_io.c:		GMT->common.b.active[GMT_IN] = true;
gmt_io.c:		GMT->common.b.bin_primary = false;
gmt_io.c:		GMT->current.io.input = &gmtio_bin_input;
gmt_io.c:		way = (GMT->current.io.geo.range == GMT_IS_0_TO_P360_RANGE) ? 1 : 0;
gmt_io.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Longitude range initialized to %g/%g\n", *W, *E);
gmt_io.c:	GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Longitude range %g/%g + %g/%g = %g/%g\n", WW, EE, w, e, *W, *E);
gmt_io.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Calling gmtlib_determine_pole on an open polygon\n");
gmt_io.c:	GMT_Report (GMT->parent, GMT_MSG_DEBUG, "gmtlib_determine_pole: N = %" PRIu64 " Multiples of 360: %d  Residual: %g Polygon contains %s pole.\n", n, n_360, lon_sum - n_360 * 360.0, pole[type+2]);
gmt_io.c:	if (sep & 1) strcat (record, GMT->current.setting.io_col_separator);
gmt_io.c:	if (sep & 2) strcat (record, GMT->current.setting.io_col_separator);
gmt_io.c:	if (sep & 1) strcat (record, GMT->current.setting.io_col_separator);
gmt_io.c:	if (sep & 2) strcat (record, GMT->current.setting.io_col_separator);
gmt_io.c:	if (!GMT->current.io.multi_segments[GMT_OUT]) return;	/* No output segments requested */
gmt_io.c:	if (GMT->common.b.active[GMT_OUT]) {			/* Binary native file uses all NaNs */
gmt_io.c:		for (col = 0; col < n_cols; col++) GMT->current.io.output (GMT, fp, 1, &GMT->session.d_NaN, NULL);
gmt_io.c:	if (GMT->current.setting.io_blankline[GMT_OUT])	/* Write blank line to indicate segment break */
gmt_io.c:	else if (GMT->current.setting.io_nanline[GMT_OUT]) {	/* Write NaN record to indicate segment break */
gmt_io.c:		if (GMT->common.d.active[GMT_OUT]) {	/* Ah, but NaNs are to be replaced */
gmt_io.c:			gmt_ascii_output_col (GMT, fp, GMT->common.d.nan_proxy[GMT_OUT], GMT_Z);
gmt_io.c:				fprintf (fp, "%s", GMT->current.setting.io_col_separator);
gmt_io.c:				gmt_ascii_output_col (GMT, fp, GMT->common.d.nan_proxy[GMT_OUT], GMT_Z);
gmt_io.c:				fprintf (fp, "NaN%s", GMT->current.setting.io_col_separator);
gmt_io.c:	else if (!GMT->current.io.segment_header[0])		/* No header; perhaps via binary input with NaN-headers */
gmt_io.c:		fprintf (fp, "%c\n", GMT->current.setting.io_seg_marker[GMT_OUT]);
gmt_io.c:		fprintf (fp, "%c %s\n", GMT->current.setting.io_seg_marker[GMT_OUT], GMT->current.io.segment_header);
gmt_io.c:		for (k = 0; k < GMT->current.setting.io_n_header_items; k++) nr += gmt_M_fread (&c, sizeof (char), 1U, fp);
gmt_io.c:		for (k = 0; k < GMT->current.setting.io_n_header_items; k++) gmt_M_fwrite (&c, sizeof (char), 1U, fp);
gmt_io.c:	if (GMT->common.b.active[GMT_OUT]) return;		/* Cannot write text records if binary output */
gmt_io.c:		GMT_Message (GMT->parent, GMT_TIME_NONE, message);
gmt_io.c:		GMT_Message (GMT->parent, GMT_TIME_NONE, message);
gmt_io.c:				GMT_Message (GMT->parent, GMT_TIME_NONE, message);
gmt_io.c:				GMT->current.io.status = GMT_IO_EOF;
gmt_io.c:			GMT_Message (GMT->parent, GMT_TIME_NONE, message);
gmt_io.c:		GMT_Message (GMT->parent, GMT_TIME_NONE, message);
gmt_io.c:				GMT_Message (GMT->parent, GMT_TIME_NONE, message);
gmt_io.c:					GMT_Message (GMT->parent, GMT_TIME_NONE, message);
gmt_io.c:				GMT->current.io.status = GMT_IO_EOF;
gmt_io.c:			GMT_Message (GMT->parent, GMT_TIME_NONE, message);
gmt_io.c:		GMT_Message (GMT->parent, GMT_TIME_NONE, message);
gmt_io.c:			GMT_Message (GMT->parent, GMT_TIME_NONE, message);
gmt_io.c:	GMT_Message (GMT->parent, GMT_TIME_NONE, message);
gmt_io.c:				GMT_Message (GMT->parent, GMT_TIME_NONE, message);
gmt_io.c:			GMT_Message (GMT->parent, GMT_TIME_NONE, message);
gmt_io.c:	GMT->current.io.status = GMT_IO_EOF;
gmt_io.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -Z: Must begin with [TBLR][TBLR]!\n");
gmt_io.c:						GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -Z: Skip must be positive\n");
gmt_io.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -Z: %c not a valid modifier!\n", txt[i]);
gmt_io.c:			GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Valid data type not set [%c]!\n", type);
gmt_io.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "%c not a valid data type!\n", type);
gmt_io.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -Z: %c not a valid format specifier!\n", format[k]);
gmt_io.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -Z: %c not a valid data type!\n", type);
gmt_io.c:	GMT->current.io.read_item  = gmtlib_get_io_ptr (GMT, GMT_IN,  swab, type);	/* Set read pointer depending on data format */
gmt_io.c:	GMT->current.io.write_item = gmtlib_get_io_ptr (GMT, GMT_OUT, swab, type);	/* Set write pointer depending on data format */
gmt_io.c:	GMT->common.b.type[GMT_IN] = GMT->common.b.type[GMT_OUT] = type;		/* Since -b is not setting this */
gmt_io.c:		strcpy (GMT->current.io.r_mode, "rb");
gmt_io.c:		strcpy (GMT->current.io.w_mode, "wb");
gmt_io.c:		strcpy (GMT->current.io.a_mode, "ab+");
gmt_io.c:	struct GMT_GEO_IO *S = &GMT->current.io.geo;
gmt_io.c:	gmtio_get_dms_order (GMT, GMT->current.setting.format_geo_out, S);	/* Get the order of degree, min, sec in output formats */
gmt_io.c:		if (!GMT->current.setting.format_float_out[0]) return (GMT_NOERROR); /* Quietly return and deal with this later in gmt_begin */
gmt_io.c:		sprintf (S->x_format, "%s", GMT->current.setting.format_float_out);
gmt_io.c:		sprintf (S->y_format, "%s", GMT->current.setting.format_float_out);
gmt_io.c:	struct GMT_GEO_IO *S = &GMT->current.plot.calclock.geo;
gmt_io.c:	for (i = 0; i < 3; i++) for (j = 0; j < 2; j++) gmt_M_memset (GMT->current.plot.format[i][j], GMT_LEN256, char);
gmt_io.c:	gmtio_get_dms_order (GMT, GMT->current.setting.format_geo_map, S);	/* Get the order of degree, min, sec in output formats */
gmt_io.c:		if (!GMT->current.setting.format_float_out[0]) return; /* Quietly return and deal with this later in gmt_begin */
gmt_io.c:		len = sprintf (S->x_format, "%s", GMT->current.setting.format_float_out);
gmt_io.c:		      sprintf (S->y_format, "%s", GMT->current.setting.format_float_out);
gmt_io.c:		if (GMT->current.setting.map_degree_symbol != gmt_none)
gmt_io.c:			S->x_format[len] = (char)GMT->current.setting.ps_encoding.code[GMT->current.setting.map_degree_symbol];
gmt_io.c:			S->y_format[len] = (char)GMT->current.setting.ps_encoding.code[GMT->current.setting.map_degree_symbol];
gmt_io.c:		sprintf (GMT->current.plot.format[0][0], "%%d");		/* ddd */
gmt_io.c:			snprintf (GMT->current.plot.format[0][1], GMT_LEN64, "%%d.%%%d.%dd", S->n_sec_decimals, S->n_sec_decimals);
gmt_io.c:			sprintf (GMT->current.plot.format[0][1], "%%d");
gmt_io.c:		if (GMT->current.setting.map_degree_symbol != gmt_none)
gmt_io.c:			snprintf (fmt, GMT_LEN256, "%c", (int)GMT->current.setting.ps_encoding.code[GMT->current.setting.map_degree_symbol]);
gmt_io.c:			strcat (GMT->current.plot.format[0][0], fmt);
gmt_io.c:			strcat (GMT->current.plot.format[0][1], fmt);
gmt_io.c:		sprintf (GMT->current.plot.format[1][0], "%%d");	/* ddd */
gmt_io.c:		sprintf (GMT->current.plot.format[1][1], "%%d");
gmt_io.c:		if (GMT->current.setting.map_degree_symbol != gmt_none)
gmt_io.c:			sprintf (fmt, "%c", (int)GMT->current.setting.ps_encoding.code[GMT->current.setting.map_degree_symbol]);
gmt_io.c:			strcat (GMT->current.plot.format[1][0], fmt);
gmt_io.c:			strcat (GMT->current.plot.format[1][1], fmt);
gmt_io.c:		strcat (GMT->current.plot.format[1][0], "%02d");
gmt_io.c:		strcat (GMT->current.plot.format[1][1], fmt);
gmt_io.c:		if (GMT->current.setting.map_degree_symbol != gmt_none)
gmt_io.c:			if (GMT->current.setting.map_degree_symbol == gmt_colon)
gmt_io.c:				sprintf (fmt, "%c", (int)GMT->current.setting.ps_encoding.code[gmt_colon]);
gmt_io.c:				sprintf (fmt, "%c", (int)GMT->current.setting.ps_encoding.code[gmt_squote]);
gmt_io.c:			strcat (GMT->current.plot.format[1][0], fmt);
gmt_io.c:			strcat (GMT->current.plot.format[1][1], fmt);
gmt_io.c:		sprintf (GMT->current.plot.format[2][0], "%%d");
gmt_io.c:		sprintf (GMT->current.plot.format[2][1], "%%d");
gmt_io.c:		if (GMT->current.setting.map_degree_symbol != gmt_none)
gmt_io.c:			sprintf (fmt, "%c", (int)GMT->current.setting.ps_encoding.code[GMT->current.setting.map_degree_symbol]);
gmt_io.c:			strcat (GMT->current.plot.format[2][0], fmt);
gmt_io.c:			strcat (GMT->current.plot.format[2][1], fmt);
gmt_io.c:		strcat (GMT->current.plot.format[2][0], "%02d");
gmt_io.c:		strcat (GMT->current.plot.format[2][1], "%02d");
gmt_io.c:		if (GMT->current.setting.map_degree_symbol != gmt_none)
gmt_io.c:			if (GMT->current.setting.map_degree_symbol == gmt_colon)
gmt_io.c:				sprintf (fmt, "%c", (int)GMT->current.setting.ps_encoding.code[gmt_colon]);
gmt_io.c:				sprintf (fmt, "%c", (int)GMT->current.setting.ps_encoding.code[gmt_squote]);
gmt_io.c:			strcat (GMT->current.plot.format[2][0], fmt);
gmt_io.c:			strcat (GMT->current.plot.format[2][1], fmt);
gmt_io.c:		strcat (GMT->current.plot.format[2][0], "%02d");
gmt_io.c:		strcat (GMT->current.plot.format[2][1], fmt);
gmt_io.c:		if (GMT->current.setting.map_degree_symbol != gmt_none)
gmt_io.c:			if (GMT->current.setting.map_degree_symbol == gmt_colon)
gmt_io.c:				sprintf (fmt, "%c", (int)GMT->current.setting.ps_encoding.code[gmt_colon]);
gmt_io.c:				sprintf (fmt, "%c", (int)GMT->current.setting.ps_encoding.code[gmt_dquote]);
gmt_io.c:			strcat (GMT->current.plot.format[2][0], fmt);
gmt_io.c:			strcat (GMT->current.plot.format[2][1], fmt);
gmt_io.c:			length = (unsigned int)MAX (1, strlen (GMT->current.plot.format[i][j])) - 1;
gmt_io.c:			if (GMT->current.plot.format[i][j][length] == ':') GMT->current.plot.format[i][j][length] = '\0';	/* Chop off a trailing colon */
gmt_io.c:			strcat (GMT->current.plot.format[i][j], "%s");
gmt_io.c:				if (GMT->current.io.date_input.watch)	/* Watch for shit like 2013-23-OCT */
gmt_io.c:				if (GMT->current.io.date_input.mw_text && GMT->current.io.date_input.delimiter[0][0] && (p2 = strrchr (s, GMT->current.io.date_input.delimiter[0][0])) > p) {
gmt_io.c:			rd = GMT->current.time.today_rata_die;	/* Default to today if no date is given */
gmt_io.c:			if (GMT->current.setting.time_is_interval) {	/* Must truncate and center on time interval */
gmt_io.c:				gmtlib_moment_interval (GMT, &GMT->current.time.truncate.T, *val, true);	/* Get the current interval */
gmt_io.c:				if (GMT->current.time.truncate.direction) {	/* Actually need midpoint of previous interval... */
gmt_io.c:					x = GMT->current.time.truncate.T.dt[0] - 0.5 * (GMT->current.time.truncate.T.dt[1] - GMT->current.time.truncate.T.dt[0]);
gmt_io.c:					gmtlib_moment_interval (GMT, &GMT->current.time.truncate.T, x, true);	/* Get the current interval */
gmt_io.c:				*val = 0.5 * (GMT->current.time.truncate.T.dt[1] + GMT->current.time.truncate.T.dt[0]);
gmt_io.c:			if ((type == GMT_IS_LON) && GMT->current.io.warn_geo_as_cartesion) {
gmt_io.c:				GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "GMT: Longitude input data detected and successfully converted but will be considered Cartesian coordinates.\n");
gmt_io.c:				GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "GMT: If you need longitudes to be processed as periodic in 360 degrees then you must use -fg.\n");
gmt_io.c:				GMT->current.io.warn_geo_as_cartesion = false;	/* OK, done with the warning */
gmt_io.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "GMT_LOGIC_BUG: gmt_scanf() called with invalid expectation.\n");
gmt_io.c:		*val = GMT->session.d_NaN;
gmt_io.c:			*val = GMT->session.d_NaN;
gmt_io.c:				*val = GMT->session.d_NaN;
gmt_io.c:				*val = GMT->session.d_NaN;
gmt_io.c:			*val = GMT->session.d_NaN;
gmt_io.c:	if (GMT->common.a.active) {	/* Use aspatial data instead */
gmt_io.c:		for (col = 0; col < GMT->current.io.OGR->n_aspatial; col++)
gmt_io.c:			fprintf (stderr, "OGR %d: N = %s T = %d\n", col, GMT->current.io.OGR->name[col], GMT->current.io.OGR->type[col]);
gmt_io.c:		for (col = 0; col < GMT->common.a.n_aspatial; col++)
gmt_io.c:			         col, GMT->common.a.col[col], GMT->common.a.ogr[col], GMT->common.a.name[col]);
gmt_io.c:		for (col = 0; col < GMT->common.a.n_aspatial; col++) {
gmt_io.c:			if (GMT->common.a.col[col] >= 0) continue;	/* Skip regular data column fillers */
gmt_io.c:			if (!G && !GMT->current.io.OGR->tvalue) continue;	/* Nothing set yet */
gmt_io.c:			if (!G && !GMT->current.io.OGR->dvalue) continue;	/* Nothing set yet */
gmt_io.c:			ogr_col = GMT->common.a.ogr[col];
gmt_io.c:			txt = (G) ? G->tvalue[ogr_col] : GMT->current.io.OGR->tvalue[col];
gmt_io.c:			z = (G) ? G->dvalue[ogr_col] : GMT->current.io.OGR->dvalue[col];
gmt_io.c:			switch (GMT->common.a.col[col]) {
gmt_io.c:			gmt_get_fill_from_z (GMT, P, GMT->session.d_NaN, fill);
gmt_io.c:	if (processed == 2) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Segment header has both -G and -Z options\n");	/* Giving both -G and -Z is a problem */
gmt_io.c:				GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Label (%s) not terminated by matching quote\n", label);
gmt_io.c:	if (GMT->common.b.active[GMT_OUT]) return;		/* No output headers for binary files */
gmt_io.c:	if (!GMT->current.setting.io_header[GMT_OUT]) return;	/* No output headers requested, so don't bother */
gmt_io.c:	if (GMT->common.h.title) {	/* Optional title(s) provided; could be several lines separated by \n */
gmt_io.c:		gmtio_write_multilines (GMT, fp, GMT->common.h.title, "Title");
gmt_io.c:	if (GMT->common.h.multi_segment) {	/* A multi-segment record */
gmt_io.c:		gmtlib_write_tableheader (GMT, fp, gmtapi_create_header_item (GMT->parent, GMT_COMMENT_IS_MULTISEG, GMT->common.h.multi_segment));
gmt_io.c:	gmtlib_write_tableheader (GMT, fp, gmtapi_create_header_item (GMT->parent, GMT_COMMENT_IS_COMMAND | GMT_COMMENT_IS_OPTION, GMT->current.options));
gmt_io.c:	if (GMT->common.h.remark) {	/* Optional remark(s) provided; could be several lines separated by \n */
gmt_io.c:		gmtio_write_multilines (GMT, fp, GMT->common.h.remark, "Remark");
gmt_io.c:	if (GMT->common.h.add_colnames) {	/* Want output comment with column names */
gmt_io.c:		if (GMT->common.h.colnames)	/* Optional column names already provided */
gmt_io.c:			gmtlib_write_tableheader (GMT, fp, GMT->common.h.colnames);
gmt_io.c:	unsigned int ix = (GMT->current.setting.io_lonlat_toggle[GMT_OUT]) ? 1 : 0, iy;
gmt_io.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "gmtio_finalize_segment: Internal error: S->n_rows > SH->n_alloc!!!");
gmt_io.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "gmtio_finalize_table: Internal error: T->n_segments > TH->n_alloc!!!");
gmt_io.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "gmtlib_finalize_dataset: Internal error: D->n_tables > DH->alloc!!!");
gmt_io.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "gmt_alloc_segment: Cannot reallocate the number of columns in an existing segment");
gmt_io.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "gmt_alloc_segment: Unable to reallocate data column %" PRIu64 " to new length %" PRIu64 "\n", col, n_rows);
gmt_io.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "gmt_alloc_segment: Unable to reallocate string array new length %" PRIu64 "\n", n_rows);
gmt_io.c:	/* Allocates and memcpy over vectors from GMT->hidden.mem_coord.
gmt_io.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "gmtlib_assign_segment: Pass %" PRIu64 " large arrays with length = %"
gmt_io.c:			if (n_rows < GMT->hidden.mem_rows)
gmt_io.c:				GMT->hidden.mem_coord[col] = gmt_M_memory (GMT, GMT->hidden.mem_coord[col], n_rows, double);	/* Trim back */
gmt_io.c:			S->data[col] = GMT->hidden.mem_coord[col];	/* Pass the pointer */
gmt_io.c:			GMT->hidden.mem_coord[col] = NULL;		/* Null this out to start over for next segment */
gmt_io.c:		if (GMT->current.io.record_type[direction] & GMT_READ_TEXT) {
gmt_io.c:			if (n_rows < GMT->hidden.mem_rows)
gmt_io.c:				GMT->hidden.mem_txt = gmt_M_memory (GMT, GMT->hidden.mem_txt, n_rows, char *);	/* Trim back */
gmt_io.c:			S->text = GMT->hidden.mem_txt;	/* Pass the pointer */
gmt_io.c:			GMT->hidden.mem_txt = NULL;		/* Null this out to start over for next segment */
gmt_io.c:		GMT->hidden.mem_cols = 0;	/* Flag that we need to reallocate new temp arrays for next segment, if any */
gmt_io.c:			gmt_M_memcpy (S->data[col], GMT->hidden.mem_coord[col], n_rows, double);
gmt_io.c:		if (GMT->current.io.record_type[direction] & GMT_READ_TEXT) {
gmt_io.c:				S->text[row] = GMT->hidden.mem_txt[row];
gmt_io.c:				GMT->hidden.mem_txt[row] = NULL;
gmt_io.c:	/* Allocates and memcpy over vectors from GMT->hidden.mem_coord.
gmt_io.c:		if (n_rows < GMT->hidden.mem_rows)
gmt_io.c:			GMT->hidden.mem_coord[col] = gmt_M_memory (GMT, GMT->hidden.mem_coord[col], n_rows, double);	/* Trim back */
gmt_io.c:		vector = GMT->hidden.mem_coord[col];	/* Pass the pointer */
gmt_io.c:		GMT->hidden.mem_coord[col] = NULL;	/* Null this out to start over for next segment */
gmt_io.c:		GMT->hidden.mem_cols = 0;	/* Flag that we need to reallocate new temp arrays for next segment, if any */
gmt_io.c:		gmt_M_memcpy (vector, GMT->hidden.mem_coord[col], n_rows, double);
gmt_io.c:	DH->alloc_level = GMT->hidden.func_level;	/* Must be freed at this level. */
gmt_io.c:	DH->id = GMT->parent->unique_var_ID++;		/* Give unique identifier */
gmt_io.c:	if (use_GMT_io) {	/* Use GMT->current.io.info settings to determine if input is ASCII/binary, else it defaults to ASCII */
gmt_io.c:		if (GMT->common.b.active[GMT_IN]) {	/* May return fewer than # of binary columns if -i was set */
gmt_io.c:			n_returned = (GMT->common.i.select) ? GMT->common.i.n_cols : GMT->common.b.ncol[GMT_IN];
gmt_io.c:			n_expected_fields = GMT->common.b.ncol[GMT_IN];
gmt_io.c:		strcpy (open_mode, GMT->current.io.r_mode);
gmt_io.c:		ASCII = !GMT->common.b.active[GMT_IN];
gmt_io.c:		n_expected_fields = GMT_MAX_COLUMNS;	/* GMT->current.io.input will return the number of columns */
gmt_io.c:		psave = GMT->current.io.input;			/* Save the previous pointer since we need to change it back at the end */
gmt_io.c:		GMT->current.io.input = GMT->session.input_ascii;	/* Override and use ASCII mode */
gmt_io.c:		psave = GMT->current.io.input;			/* Save the previous pointer since we need to change it back at the end */
gmt_io.c:		GMT->current.io.input = &gmtio_ascii_textinput;	/* Override and use ASCII text mode */
gmt_io.c:		GMT->current.io.record_type[GMT_IN] = *data_type = GMT_READ_TEXT;
gmt_io.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Cannot open file %s\n", file);
gmt_io.c:			if (!use_GMT_io) GMT->current.io.input = psave;	/* Restore previous setting */
gmt_io.c:		if (fp == NULL) fp = GMT->session.std[GMT_IN];	/* Default input */
gmt_io.c:		if (fp == GMT->session.std[GMT_IN])
gmt_io.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Cannot convert file descriptor %d to stream in gmtlib_read_table\n", *fd);
gmt_io.c:			if (!use_GMT_io) GMT->current.io.input = psave;	/* Restore previous setting */
gmt_io.c:		if (fd == NULL) fp = GMT->session.std[GMT_IN];	/* Default input */
gmt_io.c:		if (fp == GMT->session.std[GMT_IN])
gmt_io.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Unrecognized source type %d in gmtlib_read_table\n", source_type);
gmt_io.c:		if (!use_GMT_io) GMT->current.io.input = psave;	/* Restore previous setting */
gmt_io.c:	if (GMT->common.b.active[GMT_IN]) {
gmt_io.c:		if (GMT->current.setting.io_n_header_items) {
gmt_io.c:	if (GMT->current.io.record.data == NULL) *data_type = GMT_READ_TEXT;
gmt_io.c:	In = GMT->current.io.input (GMT, fp, &n_expected_fields, &status);	/* Get first record */
gmt_io.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "File %s is empty!\n", file);
gmt_io.c:		if (!use_GMT_io) GMT->current.io.input = psave;	/* Restore previous setting */
gmt_io.c:	if (GMT->current.io.ogr == GMT_OGR_TRUE) {	/* Reading an OGR file so we can set the geometry, and possibly poly */
gmt_io.c:		if (GMT->current.io.OGR == NULL) {
gmt_io.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "OGR parsing incomplete (is file missing OGR statements?) - abort\n");
gmt_io.c:		poly = (GMT->current.io.OGR->geometry == GMT_IS_POLYGON || GMT->current.io.OGR->geometry == GMT_IS_MULTIPOLYGON);
gmt_io.c:		*geometry = GMT->current.io.OGR->geometry;
gmt_io.c:			while ((GMT->current.setting.io_header[GMT_IN] && n_read <= GMT->current.setting.io_n_header_items) ||
gmt_io.c:				for (k = 0; GMT->current.io.curr_text[k] == ' '; k++);
gmt_io.c:				T->header[T->n_headers] = strdup (&GMT->current.io.curr_text[k]);
gmt_io.c:				In = GMT->current.io.input (GMT, fp, &n_expected_fields, &status);
gmt_io.c:				if (gmt_parse_segment_item (GMT, GMT->current.io.segment_header, "-D", line)) {	/* Found a potential -D<dist> option in the header */
gmt_io.c:				while (!gmt_M_rec_is_eof (GMT) && (In = GMT->current.io.input (GMT, fp, &n_expected_fields, &status)) == NULL) n_read++;
gmt_io.c:			if (GMT->current.io.record_type[GMT_IN] == GMT_READ_TEXT)
gmt_io.c:			if (strlen (GMT->current.io.segment_header)) {
gmt_io.c:				S->header = strdup (GMT->current.io.segment_header);
gmt_io.c:				if (gmt_parse_segment_item (GMT, GMT->current.io.segment_header, "-L", buffer))
gmt_io.c:			if (GMT->current.io.ogr == GMT_OGR_TRUE) gmtio_copy_ogr_seg (GMT, S, GMT->current.io.OGR);	/* Copy over any feature-specific values */
gmt_io.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "File %s does not have at least 2 columns required for polygons (found %d)\n",
gmt_io.c:			if (!use_GMT_io) GMT->current.io.input = psave;	/* Restore previous setting */
gmt_io.c:		while (! (GMT->current.io.status & (GMT_IO_SEGMENT_HEADER | GMT_IO_GAP | GMT_IO_EOF))) {	/* Keep going until false or find a new segment header */
gmt_io.c:			if (GMT->current.io.status & GMT_IO_MISMATCH) {
gmt_io.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Mismatch between actual (%d) and expected (%d) fields near line %" PRIu64 " in file %s\n",
gmt_io.c:				if (!use_GMT_io) GMT->current.io.input = psave;	/* Restore previous setting */
gmt_io.c:				GMT->hidden.mem_coord[col][row] = In->data[col];
gmt_io.c:					if (greenwich && GMT->hidden.mem_coord[col][row] > 180.0) GMT->hidden.mem_coord[col][row] -= 360.0;
gmt_io.c:					if (!greenwich && GMT->hidden.mem_coord[col][row] < 0.0)  GMT->hidden.mem_coord[col][row] += 360.0;
gmt_io.c:			if (GMT->current.io.record_type[GMT_IN] & GMT_READ_TEXT) {
gmt_io.c:				if (GMT->current.io.record.text) GMT->hidden.mem_txt[row] = strdup (GMT->current.io.record.text);
gmt_io.c:			In = GMT->current.io.input (GMT, fp, &n_expected_fields, &status);
gmt_io.c:			while (gmt_M_rec_is_table_header (GMT)) In = GMT->current.io.input (GMT, fp, &n_expected_fields, &status);	/* Just wind past other comments */
gmt_io.c:		if (pol_check) this_is_poly = (!gmt_polygon_is_open (GMT, GMT->hidden.mem_coord[GMT_X], GMT->hidden.mem_coord[GMT_Y], row));	/* true if this segment is closed polygon */
gmt_io.c:				double dlon = GMT->hidden.mem_coord[GMT_X][0] - GMT->hidden.mem_coord[GMT_X][row-1];
gmt_io.c:				if (!((fabs (dlon) == 0.0 || fabs (dlon) == 360.0) && GMT->hidden.mem_coord[GMT_Y][0] == GMT->hidden.mem_coord[GMT_Y][row-1])) {
gmt_io.c:					for (col = 0; col < S->n_columns; col++) GMT->hidden.mem_coord[col][row] = GMT->hidden.mem_coord[col][0];
gmt_io.c:					GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Explicitly closed open geographic polygon in file %s, segment %" PRIu64 "\n", file, seg);
gmt_io.c:			else if (gmt_polygon_is_open (GMT, GMT->hidden.mem_coord[GMT_X], GMT->hidden.mem_coord[GMT_Y], row)) {	/* Cartesian closure */
gmt_io.c:				for (col = 0; col < S->n_columns; col++) GMT->hidden.mem_coord[col][row] = GMT->hidden.mem_coord[col][0];
gmt_io.c:				GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Explicitly closed open Cartesian polygon in file %s, segment %" PRIu64 "\n", file, seg);
gmt_io.c:		GMT->current.io.status -= (GMT->current.io.status & GMT_IO_GAP);
gmt_io.c:	if (!use_GMT_io) GMT->current.io.input = psave;	/* Restore previous setting */
gmt_io.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Table contains mix of polygons (%" PRIu64 ") and lines (%" PRIu64 ")\n",
gmt_io.c:	struct GMT_DATASEGMENT *Sout = GMT_Alloc_Segment (GMT->parent, GMT_IS_DATASET, Sin->n_rows, Sin->n_columns, Sin->header, NULL);
gmt_io.c:			T->segment[seg] = GMT_Alloc_Segment (GMT->parent, smode, nr, D->n_columns, NULL, NULL);
gmt_io.c:	DH->alloc_level = GMT->hidden.func_level;	/* Must be freed at this level. */
gmt_io.c:	DH->id = GMT->parent->unique_var_ID++;		/* Give unique identifier */
gmt_io.c:	if (!GMT->common.o.select) return;	/* Nutin' to do */
gmt_io.c:	if (GMT->common.o.n_cols > D->n_columns)	/* Must allocate more columns first */
gmt_io.c:	if (GMT->common.o.n_cols != D->n_columns)	/* Must free/realloc some columns afterwards */
gmt_io.c:				S->data = gmt_M_memory (GMT, S->data, GMT->common.o.n_cols, double *);
gmt_io.c:				for (col = D->n_columns; col < GMT->common.o.n_cols; col++)
gmt_io.c:			for (col = 0; col < GMT->common.o.n_cols; col++) {	/* These are final output columns */
gmt_io.c:				src_col = GMT->current.io.col[GMT_OUT][col].col;	/* Corresponding original column */
gmt_io.c:			for (col = 0; col < GMT->common.o.n_cols; col++) {	/* These are again final output columns */
gmt_io.c:				src_col = GMT->current.io.col[GMT_OUT][col].col;	/* Corresponding original column */
gmt_io.c:				S->min  = gmt_M_memory (GMT, S->min, GMT->common.o.n_cols, double);
gmt_io.c:				S->max  = gmt_M_memory (GMT, S->max, GMT->common.o.n_cols, double);
gmt_io.c:				if (!extend) S->data = gmt_M_memory (GMT, S->data, GMT->common.o.n_cols, double *);
gmt_io.c:			S->n_columns = GMT->common.o.n_cols;	/* New column count */
gmt_io.c:			T->min = gmt_M_memory (GMT, T->min, GMT->common.o.n_cols, double);
gmt_io.c:			T->max = gmt_M_memory (GMT, T->max, GMT->common.o.n_cols, double);
gmt_io.c:		T->n_columns = GMT->common.o.n_cols;	/* New column count */
gmt_io.c:		D->min = gmt_M_memory (GMT, D->min, GMT->common.o.n_cols, double);
gmt_io.c:		D->max = gmt_M_memory (GMT, D->max, GMT->common.o.n_cols, double);
gmt_io.c:	D->n_columns = GMT->common.o.n_cols;	/* New column count */
gmt_io.c:	IH->alloc_level = GMT->hidden.func_level;	/* Must be freed at this level. */
gmt_io.c:	IH->id = GMT->parent->unique_var_ID++;		/* Give unique identifier */
gmt_io.c:	if (GMT->current.gdal_read_in.O.mem_layout[0])
gmt_io.c:		gmt_strncpy (I->header->mem_layout, GMT->current.gdal_read_in.O.mem_layout, 4);	/* Set the current memory layout */
gmt_io.c:	GMT_Set_Index (GMT->parent, I->header, GMT_IMAGE_LAYOUT);
gmt_io.c:	/* We expect external memory for input and GMT-allocated memory on output */
gmt_io.c:	VH->alloc_level = GMT->hidden.func_level;	/* Must be freed at this level */
gmt_io.c:	VH->id = GMT->parent->unique_var_ID++;		/* Give unique identifier */
gmt_io.c:	/* We expect external memory for input and GMT-allocated memory on output */
gmt_io.c:	MH->alloc_level = GMT->hidden.func_level;	/* Must be freed at this level. */
gmt_io.c:	MH->id = GMT->parent->unique_var_ID++;		/* Give unique identifier */
gmt_io.c:		default: 		M->shape = GMT->parent->shape; break;	/* Default layout (row vs column) selected by GMT_Create_Session [row-major] */
gmt_io.c:	 * store in GMT->current.io.curr_rec, which is what normal GMT_DATASET processing do.
gmt_io.c:	while (k < ncols && gmt_strtok (record, GMT->current.io.scan_separators, &pos, p)) {	/* Get each field in turn and bail when done */
gmt_io.c:	for (k = 0; k < GMT->common.a.n_aspatial; k++) {	/* For each item specified in -a */
gmt_io.c:		if (scol != GMT->common.a.col[k]) continue;	/* Not the column we want */
gmt_io.c:		id = gmt_get_ogr_id (GMT->current.io.OGR, GMT->common.a.name[k]);	/* Get the ID */
gmt_io.c:		V = (SH && SH->ogr) ? SH->ogr->tvalue[id] : GMT->current.io.OGR->tvalue[id];	/* Either from table or from segment (multi) */
gmt_io.c:		return (gmtio_convert_aspatial_value (GMT, GMT->current.io.OGR->type[id], V));
gmt_io.c:	GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "No aspatial value found for column %d [Return NaN]\n", col);
gmt_io.c:	return (GMT->session.d_NaN);
gmt_io.c:	if (GMT->current.io.ogr != GMT_OGR_TRUE) return (0);		/* No point checking further since file is not GMT/OGR */
gmt_io.c:	for (k = 0; k < GMT->common.a.n_aspatial; k++) {	/* For each item specified in -a */
gmt_io.c:		if (GMT->common.a.col[k] == scol) id = k;			/* ..that matches the given column */
gmt_io.c:	id = gmt_get_ogr_id (G, GMT->common.a.name[id]);
gmt_io.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error opening directory %s\n", path);
gmt_io.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error opening directory %s\n", path);
gmt_io.c:	GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Your OS does not support directory listings\n");
gmt_io.c:	GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Delete %s\n", file);
gmt_io.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Failed to remove %s! [remove error: %s]\n", file, strerror (errno));
gmt_io.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Copying %s -> %s\n", oldfile, newfile);
gmt_io.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Rename %s -> %s\n", oldfile, newfile);
gmt_io.c:		if (mode == GMT_RENAME_FILE) GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Failed to rename %s -> %s! [rename error: %s].  Try copy/delete instead.\n", oldfile, newfile, strerror (errno));
gmt_io.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Failed to create %s! [fopen error: %s]\n", newfile, strerror (errno));
gmt_io.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Failed to open %s! [fopen error: %s]\n", oldfile, strerror (errno));
gmt_io.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Failed to allocate memory! [calloc error: %s]\n", strerror (errno));
gmt_io.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Failed to write %" PRIuS " bytes to %s! [fwrite error: %s]\n", ni, newfile, strerror (errno));
gmt_io.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Failed to close %s! [fwrite error: %s]\n", oldfile, strerror (errno));
gmt_io.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Failed to close %s! [fwrite error: %s]\n", newfile, strerror (errno));
gmt_io.c:			GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Source file %s was empty (?): \n", oldfile);
gmt_io.c:		GMT->current.io.col_type[dir][col] = type;
gmt_io.c:		GMT->current.io.col_set[dir][col] = 1;	/* Flag as having been set and thus should not be automatically changed */
gmt_map.c:#define Return(err) { GMT_Report(GMT->parent,GMT_MSG_NORMAL,"Internal Error = %s\n",VAR_TO_STR(err)); return (err);}
gmt_map.c:	return ((*GMT->current.map.left_edge) (GMT, y));
gmt_map.c:	return ((*GMT->current.map.right_edge) (GMT, y));
gmt_map.c:	if (GMT->current.proj.gave_map_width) {	/* Gave width */
gmt_map.c:		dlon = GMT->common.R.wesn[XHI] - GMT->common.R.wesn[XLO];
gmt_map.c:		width = GMT->current.proj.pars[4] * GMT->session.u2u[GMT->current.setting.proj_length_unit][GMT_M];	/* Convert to meters */
gmt_map.c:		s = (dlon * GMT->current.proj.M_PR_DEG) / width;
gmt_map.c:	else if (GMT->current.proj.units_pr_degree) {	/* Gave scale */
gmt_map.c:		s = GMT->current.proj.M_PR_DEG / (GMT->current.proj.pars[4] * GMT->session.u2u[GMT->current.setting.proj_length_unit][GMT_M]);
gmt_map.c:		s = (1.0 / GMT->current.proj.pars[4]) / GMT->current.proj.unit;
gmt_map.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Using spherical projection with conformal latitudes\n");
gmt_map.c:	d_left  = lon0 - GMT->common.R.wesn[XLO] - 360.0;
gmt_map.c:	d_right = lon0 - GMT->common.R.wesn[XHI] - 360.0;
gmt_map.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Using spherical projection with authalic latitudes\n");
gmt_map.c:	if (doubleAlmostEqual (fabs (GMT->current.proj.pars[1]), 90.0)) {
gmt_map.c:		GMT->current.proj.polar = true;
gmt_map.c:		GMT->current.proj.north_pole = (GMT->current.proj.pars[1] > 0.0);
gmt_map.c:	return (gmt_M_is_dnan (GMT->current.proj.pars[0]));
gmt_map.c:	GMT->current.proj.pars[0] = 0.5 * (GMT->common.R.wesn[XLO] + GMT->common.R.wesn[XHI]);	/* Not set at all, set to middle lon */
gmt_map.c:	GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Central meridian not given, default to %g\n", GMT->current.proj.pars[0]);
gmt_map.c:	else if (GMT->current.map.is_world && (GMT->current.proj.pars[0] == GMT->common.R.wesn[XLO] || GMT->current.proj.pars[0] == GMT->common.R.wesn[XHI])) {
gmt_map.c:			double w = GMT->current.proj.pars[0] - 180.0, e = GMT->current.proj.pars[0] + 180.0;
gmt_map.c:			GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Region for global cylindrical projection had to be reset from %g/%g to %g/%g\n",
gmt_map.c:				GMT->common.R.wesn[XLO], GMT->common.R.wesn[XHI], w, e);
gmt_map.c:			GMT->common.R.wesn[XLO] = w;	GMT->common.R.wesn[XHI] = e;
gmt_map.c:			double new_lon = 0.5 * (GMT->common.R.wesn[XLO] + GMT->common.R.wesn[XHI]);
gmt_map.c:			GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Central meridian for global cylindrical projection had to be reset from %g to %g\n", GMT->current.proj.pars[0], new_lon);
gmt_map.c:			GMT->current.proj.pars[0] = new_lon;
gmt_map.c:	else if (!GMT->current.map.is_world) {	/* For reginal areas we cannot have clon > 180 away from either boundary */
gmt_map.c:		if (fabs (GMT->current.proj.pars[0] - GMT->common.R.wesn[XLO]) > 180.0 || fabs (GMT->current.proj.pars[0] - GMT->common.R.wesn[XHI]) > 180.0) {
gmt_map.c:			double new_lon = 0.5 * (GMT->common.R.wesn[XLO] + GMT->common.R.wesn[XHI]);
gmt_map.c:			GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Central meridian for cylindrical projection had to be reset from %g to %g\n", GMT->current.proj.pars[0], new_lon);
gmt_map.c:			GMT->current.proj.pars[0] = new_lon;
gmt_map.c:	/* Initialize values in GMT->current.proj.lat_swap_vals based on GMT->current.proj.
gmt_map.c:	First compute GMT->current.proj.lat_swap_vals.ra (and rm), the radii to use in
gmt_map.c:	First load GMT->current.proj.lat_swap_vals.c[itype][k], k=0,1,2,3 with the
gmt_map.c:	Also, I made this depend on GMT->current.setting.ref_ellipsoid[GMT->current.setting.proj_ellipsoid]
gmt_map.c:	rather than on GMT->current.proj, so that it will be possible to
gmt_map.c:	/* PW notes: Projections only convert latitudes if GMT->current.proj.GMT_convert_latitudes is true.
gmt_map.c:	f = GMT->current.setting.ref_ellipsoid[GMT->current.setting.proj_ellipsoid].flattening;
gmt_map.c:	a = GMT->current.setting.ref_ellipsoid[GMT->current.setting.proj_ellipsoid].eq_radius;
gmt_map.c:		gmt_M_memset (GMT->current.proj.lat_swap_vals.c, GMT_LATSWAP_N * 4, double);
gmt_map.c:		GMT->current.proj.lat_swap_vals.ra = GMT->current.proj.lat_swap_vals.rm = a;
gmt_map.c:		GMT->current.proj.lat_swap_vals.spherical = true;
gmt_map.c:	GMT->current.proj.lat_swap_vals.spherical = false;
gmt_map.c:	GMT->current.proj.lat_swap_vals.ra = a * sqrt( (1.0 + x) * (1.0 - e2));
gmt_map.c:	GMT->current.proj.lat_swap_vals.rm = a * (1.0 - x);
gmt_map.c:	GMT->current.proj.lat_swap_vals.c[GMT_LATSWAP_G2A][0] = -(e2 / 3.0 + (31.0 * e4 / 180.0 + 59.0 * e6 / 560.0));
gmt_map.c:	GMT->current.proj.lat_swap_vals.c[GMT_LATSWAP_G2A][1] = 17.0 * e4 / 360.0 + 61.0 * e6 / 1260;
gmt_map.c:	GMT->current.proj.lat_swap_vals.c[GMT_LATSWAP_G2A][2] = -383.0 * e6 / 45360.0;
gmt_map.c:	GMT->current.proj.lat_swap_vals.c[GMT_LATSWAP_G2A][3] = 0.0;
gmt_map.c:	GMT->current.proj.lat_swap_vals.c[GMT_LATSWAP_A2G][0] = e2 / 3.0 + (31.0 * e4 / 180.0 + 517.0 * e6 / 5040.0);
gmt_map.c:	GMT->current.proj.lat_swap_vals.c[GMT_LATSWAP_A2G][1] = 23.0 * e4 / 360.0 + 251.0 * e6 / 3780;
gmt_map.c:	GMT->current.proj.lat_swap_vals.c[GMT_LATSWAP_A2G][2] = 761.0 * e6 / 45360.0;
gmt_map.c:	GMT->current.proj.lat_swap_vals.c[GMT_LATSWAP_A2G][3] = 0.0;
gmt_map.c:	GMT->current.proj.lat_swap_vals.c[GMT_LATSWAP_G2C][0] = -(e2 / 2.0 + (5.0 * e4 / 24.0 + (3.0 * e6 / 32.0 + 281.0 * e8 / 5760.0)));
gmt_map.c:	GMT->current.proj.lat_swap_vals.c[GMT_LATSWAP_G2C][1] = 5.0 * e4 / 48.0 + (7.0 * e6 / 80.0 + 697.0 * e8 / 11520.0);
gmt_map.c:	GMT->current.proj.lat_swap_vals.c[GMT_LATSWAP_G2C][2] = -(13.0 * e6 / 480.0 + 461.0 * e8 / 13440.0);
gmt_map.c:	GMT->current.proj.lat_swap_vals.c[GMT_LATSWAP_G2C][3] = 1237.0 * e8 / 161280.0;
gmt_map.c:	GMT->current.proj.lat_swap_vals.c[GMT_LATSWAP_C2G][0] = e2 / 2.0 + (5.0 * e4 / 24.0 + (e6 / 12.0 + 13.0 * e8 / 360.0)) ;
gmt_map.c:	GMT->current.proj.lat_swap_vals.c[GMT_LATSWAP_C2G][1] = 7.0 * e4 / 48.0 + (29.0 * e6 / 240.0 + 811.0 * e8 / 11520.0);
gmt_map.c:	GMT->current.proj.lat_swap_vals.c[GMT_LATSWAP_C2G][2] = 7.0 * e6 / 120.0 + 81.0 * e8 / 1120.0;  /* Bug fixed 13nov07 whfs */
gmt_map.c:	GMT->current.proj.lat_swap_vals.c[GMT_LATSWAP_C2G][3] = 4279.0 * e8 / 161280.0;
gmt_map.c:	GMT->current.proj.lat_swap_vals.c[GMT_LATSWAP_G2M][0] = -(3.0 * xx[0] / 2.0 - 9.0 * xx[2] / 16.0);
gmt_map.c:	GMT->current.proj.lat_swap_vals.c[GMT_LATSWAP_G2M][1] = 15.0 * xx[1] / 16.0 - 15.0 * xx[3] / 32.0;
gmt_map.c:	GMT->current.proj.lat_swap_vals.c[GMT_LATSWAP_G2M][2] = -35.0 * xx[2] / 48.0;
gmt_map.c:	GMT->current.proj.lat_swap_vals.c[GMT_LATSWAP_G2M][3] = 315.0 * xx[3] / 512.0;
gmt_map.c:	GMT->current.proj.lat_swap_vals.c[GMT_LATSWAP_M2G][0] = 3.0 * xx[0] / 2.0 - 27.0 * xx[2] / 32.0;
gmt_map.c:	GMT->current.proj.lat_swap_vals.c[GMT_LATSWAP_M2G][1] = 21.0 * xx[1] / 16.0 - 55.0 * xx[3] / 32.0;
gmt_map.c:	GMT->current.proj.lat_swap_vals.c[GMT_LATSWAP_M2G][2] = 151.0 * xx[2] / 96.0;
gmt_map.c:	GMT->current.proj.lat_swap_vals.c[GMT_LATSWAP_M2G][3] = 1097.0 * xx[3] / 512.0;
gmt_map.c:	GMT->current.proj.lat_swap_vals.c[GMT_LATSWAP_G2P][0] = GMT->current.proj.lat_swap_vals.c[GMT_LATSWAP_P2O][0] = -xx[0];
gmt_map.c:	GMT->current.proj.lat_swap_vals.c[GMT_LATSWAP_G2P][1] = GMT->current.proj.lat_swap_vals.c[GMT_LATSWAP_P2O][1] = xx[1] / 2.0;
gmt_map.c:	GMT->current.proj.lat_swap_vals.c[GMT_LATSWAP_G2P][2] = GMT->current.proj.lat_swap_vals.c[GMT_LATSWAP_P2O][2] = -xx[2] / 3.0;
gmt_map.c:	GMT->current.proj.lat_swap_vals.c[GMT_LATSWAP_G2P][3] = GMT->current.proj.lat_swap_vals.c[GMT_LATSWAP_P2O][3] = xx[3] / 4.0;
gmt_map.c:	GMT->current.proj.lat_swap_vals.c[GMT_LATSWAP_P2G][0] = GMT->current.proj.lat_swap_vals.c[GMT_LATSWAP_O2P][0] = xx[0];
gmt_map.c:	GMT->current.proj.lat_swap_vals.c[GMT_LATSWAP_P2G][1] = GMT->current.proj.lat_swap_vals.c[GMT_LATSWAP_O2P][1] = xx[1] / 2.0;
gmt_map.c:	GMT->current.proj.lat_swap_vals.c[GMT_LATSWAP_P2G][2] = GMT->current.proj.lat_swap_vals.c[GMT_LATSWAP_O2P][2] = xx[2] / 3.0;
gmt_map.c:	GMT->current.proj.lat_swap_vals.c[GMT_LATSWAP_P2G][3] = GMT->current.proj.lat_swap_vals.c[GMT_LATSWAP_O2P][3] = xx[3] / 4.0;
gmt_map.c:	GMT->current.proj.lat_swap_vals.c[GMT_LATSWAP_G2O][0] = -xx[0];
gmt_map.c:	GMT->current.proj.lat_swap_vals.c[GMT_LATSWAP_G2O][1] = xx[1] / 2.0;
gmt_map.c:	GMT->current.proj.lat_swap_vals.c[GMT_LATSWAP_G2O][2] = -xx[2] / 3.0;
gmt_map.c:	GMT->current.proj.lat_swap_vals.c[GMT_LATSWAP_G2O][3] = xx[3] / 4.0;
gmt_map.c:	GMT->current.proj.lat_swap_vals.c[GMT_LATSWAP_O2G][0] = xx[0];
gmt_map.c:	GMT->current.proj.lat_swap_vals.c[GMT_LATSWAP_O2G][1] = xx[1] / 2.0;
gmt_map.c:	GMT->current.proj.lat_swap_vals.c[GMT_LATSWAP_O2G][2] = xx[2] / 3.0;
gmt_map.c:	GMT->current.proj.lat_swap_vals.c[GMT_LATSWAP_O2G][3] = xx[3] / 4.0;
gmt_map.c:		GMT->current.proj.lat_swap_vals.c[i][0] = GMT->current.proj.lat_swap_vals.c[i][0] - GMT->current.proj.lat_swap_vals.c[i][2];
gmt_map.c:		GMT->current.proj.lat_swap_vals.c[i][1] = 2.0 * GMT->current.proj.lat_swap_vals.c[i][1] - 4.0 * GMT->current.proj.lat_swap_vals.c[i][3];
gmt_map.c:		GMT->current.proj.lat_swap_vals.c[i][2] *= 4.0;
gmt_map.c:		GMT->current.proj.lat_swap_vals.c[i][3] *= 8.0;
gmt_map.c:	 * The check GMT->current.map.lon_wrap is include since we need to consider the 360
gmt_map.c:	 * 360 degrees. In that case GMT->current.map.lon_wrap will be temporarily set to false.
gmt_map.c:	if (GMT->current.map.lon_wrap) {
gmt_map.c:		while (lon < GMT->common.R.wesn[XLO] && lon + 360.0 <= GMT->common.R.wesn[XHI]) lon += 360.0;
gmt_map.c:		while (lon > GMT->common.R.wesn[XHI] && lon - 360.0 >= GMT->common.R.wesn[XLO]) lon -= 360.0;
gmt_map.c:	if (GMT->current.map.on_border_is_outside && fabs (lon - GMT->common.R.wesn[XLO]) < GMT_CONV8_LIMIT)
gmt_map.c:		GMT->current.map.this_x_status = -1;
gmt_map.c:	else if (GMT->current.map.on_border_is_outside && fabs (lon - GMT->common.R.wesn[XHI]) < GMT_CONV8_LIMIT)
gmt_map.c:		GMT->current.map.this_x_status = 1;
gmt_map.c:	else if (lon < GMT->common.R.wesn[XLO])
gmt_map.c:		GMT->current.map.this_x_status = -2;
gmt_map.c:	else if (lon > GMT->common.R.wesn[XHI])
gmt_map.c:		GMT->current.map.this_x_status = 2;
gmt_map.c:		GMT->current.map.this_x_status = 0;
gmt_map.c:	if (GMT->current.map.on_border_is_outside && fabs (lat - GMT->common.R.wesn[YLO]) < GMT_CONV8_LIMIT)
gmt_map.c:		GMT->current.map.this_y_status = -1;
gmt_map.c:	else if (GMT->current.map.on_border_is_outside && fabs (lat - GMT->common.R.wesn[YHI]) < GMT_CONV8_LIMIT)
gmt_map.c:		GMT->current.map.this_y_status = 1;
gmt_map.c:	else if (lat < GMT->common.R.wesn[YLO])
gmt_map.c:		GMT->current.map.this_y_status = -2;
gmt_map.c:	else if (lat > GMT->common.R.wesn[YHI])
gmt_map.c:		GMT->current.map.this_y_status = 2;
gmt_map.c:		GMT->current.map.this_y_status = 0;
gmt_map.c:	return (GMT->current.map.this_x_status != 0 || GMT->current.map.this_y_status != 0);
gmt_map.c:	if (!GMT->current.proj.edge[1]) GMT->current.map.this_x_status = 0;	/* 360 degrees, no edge */
gmt_map.c:	if (GMT->current.map.this_y_status < 0 && !GMT->current.proj.edge[0]) GMT->current.map.this_y_status = 0;	/* South pole enclosed */
gmt_map.c:	if (GMT->current.map.this_y_status > 0 && !GMT->current.proj.edge[2]) GMT->current.map.this_y_status = 0;	/* North pole enclosed */
gmt_map.c:	return (GMT->current.map.this_x_status != 0 || GMT->current.map.this_y_status != 0);
gmt_map.c:	GMT->current.map.this_x_status = 0;
gmt_map.c:	dist = gmtlib_great_circle_dist_degree (GMT, lon, lat, GMT->current.proj.central_meridian, GMT->current.proj.pole);
gmt_map.c:	if (GMT->current.map.on_border_is_outside && fabs (dist - GMT->current.proj.f_horizon) < GMT_CONV8_LIMIT)
gmt_map.c:		GMT->current.map.this_y_status = -1;
gmt_map.c:	else if (dist > GMT->current.proj.f_horizon)
gmt_map.c:		GMT->current.map.this_y_status = -2;
gmt_map.c:		GMT->current.map.this_y_status = 0;
gmt_map.c:	return (GMT->current.map.this_y_status != 0);
gmt_map.c:/*	if (fabs (fmod (fabs (*x - GMT->common.R.wesn[XLO]), 360.0)) <= GMT_CONV4_LIMIT)
gmt_map.c:		*x = GMT->common.R.wesn[XLO];
gmt_map.c:	else if (fabs (fmod (fabs (*x - GMT->common.R.wesn[XHI]), 360.0)) <= GMT_CONV4_LIMIT)
gmt_map.c:		*x = GMT->common.R.wesn[XHI]; */
gmt_map.c:	if (fabs (*x - GMT->common.R.wesn[XLO]) <= GMT_CONV8_LIMIT)
gmt_map.c:		*x = GMT->common.R.wesn[XLO];
gmt_map.c:	else if (fabs (*x - GMT->common.R.wesn[XHI]) <= GMT_CONV8_LIMIT)
gmt_map.c:		*x = GMT->common.R.wesn[XHI];
gmt_map.c:	if (fabs (*y - GMT->common.R.wesn[YLO]) <= GMT_CONV8_LIMIT)
gmt_map.c:		*y = GMT->common.R.wesn[YLO];
gmt_map.c:	else if (fabs (*y - GMT->common.R.wesn[YHI]) <= GMT_CONV8_LIMIT)
gmt_map.c:		*y = GMT->common.R.wesn[YHI];
gmt_map.c:	GMT->current.map.corner = 0;
gmt_map.c:	if (doubleAlmostEqualZero (fmod(fabs(x), 360.0), fmod(fabs(GMT->common.R.wesn[XLO]), 360.0))) {
gmt_map.c:		if (doubleAlmostEqualZero (y, GMT->common.R.wesn[YLO]))
gmt_map.c:			GMT->current.map.corner = 1;
gmt_map.c:		else if (doubleAlmostEqualZero (y, GMT->common.R.wesn[YHI]))
gmt_map.c:			GMT->current.map.corner = 4;
gmt_map.c:	else if (doubleAlmostEqualZero (fmod(fabs(x), 360.0), fmod(fabs(GMT->common.R.wesn[XHI]), 360.0))) {
gmt_map.c:		if (doubleAlmostEqualZero (y, GMT->common.R.wesn[YLO]))
gmt_map.c:			GMT->current.map.corner = 2;
gmt_map.c:		else if (doubleAlmostEqualZero (y, GMT->common.R.wesn[YHI]))
gmt_map.c:			GMT->current.map.corner = 3;
gmt_map.c:	return (GMT->current.map.corner > 0);
gmt_map.c:	while (lon < GMT->common.R.wesn[XLO]) lon += 360.0;
gmt_map.c:	while (lon > GMT->common.R.wesn[XHI]) lon -= 360.0;
gmt_map.c:	if (GMT->current.map.lon_wrap) {
gmt_map.c:		while (lon0 < GMT->common.R.wesn[XLO]) lon0 += 360.0;
gmt_map.c:		while (lon0 > GMT->common.R.wesn[XHI]) lon0 -= 360.0;
gmt_map.c:		while (lon1 < GMT->common.R.wesn[XLO]) lon1 += 360.0;
gmt_map.c:		while (lon1 > GMT->common.R.wesn[XHI]) lon1 -= 360.0;
gmt_map.c:	if ((lat0 >= GMT->common.R.wesn[YLO] && lat1 <= GMT->common.R.wesn[YLO]) || (lat1 >= GMT->common.R.wesn[YLO] && lat0 <= GMT->common.R.wesn[YLO])) {
gmt_map.c:		clat[n] = GMT->common.R.wesn[YLO];
gmt_map.c:		if (fabs (d) > 0.0 && map_lon_inside (GMT, clon[n], GMT->common.R.wesn[XLO], GMT->common.R.wesn[XHI])) n++;
gmt_map.c:	if ((lon0 >= GMT->common.R.wesn[XHI] && lon1 <= GMT->common.R.wesn[XHI]) || (lon1 >= GMT->common.R.wesn[XHI] && lon0 <= GMT->common.R.wesn[XHI])) {
gmt_map.c:		clon[n] = GMT->common.R.wesn[XHI];
gmt_map.c:		if (fabs (d) > 0.0 && clat[n] >= GMT->common.R.wesn[YLO] && clat[n] <= GMT->common.R.wesn[YHI]) n++;
gmt_map.c:	if (GMT->current.map.lon_wrap && MAX(lon0, lon1) > GMT->common.R.wesn[XHI]) {
gmt_map.c:	if ((lat0 >= GMT->common.R.wesn[YHI] && lat1 <= GMT->common.R.wesn[YHI]) || (lat1 >= GMT->common.R.wesn[YHI] && lat0 <= GMT->common.R.wesn[YHI])) {
gmt_map.c:		clat[n] = GMT->common.R.wesn[YHI];
gmt_map.c:		if (fabs (d) > 0.0 && map_lon_inside (GMT, clon[n], GMT->common.R.wesn[XLO], GMT->common.R.wesn[XHI])) n++;
gmt_map.c:	if ((lon0 <= GMT->common.R.wesn[XLO] && lon1 >= GMT->common.R.wesn[XLO]) || (lon1 <= GMT->common.R.wesn[XLO] && lon0 >= GMT->common.R.wesn[XLO])) {
gmt_map.c:		clon[n] = GMT->common.R.wesn[XLO];
gmt_map.c:		if (fabs (d) > 0.0 && clat[n] >= GMT->common.R.wesn[YLO] && clat[n] <= GMT->common.R.wesn[YHI]) n++;
gmt_map.c:		if (GMT->current.proj.projection_GMT == GMT_POLAR && sides[i]%2) sides[i] = 4 - sides[i];	/*  toggle 1 <-> 3 */
gmt_map.c:	else if (fabs (*x - GMT->current.proj.rect[XHI]) <= GMT_CONV4_LIMIT)
gmt_map.c:		*x = GMT->current.proj.rect[XHI];
gmt_map.c:	else if (fabs (*y - GMT->current.proj.rect[YHI]) <= GMT_CONV4_LIMIT)
gmt_map.c:		*y = GMT->current.proj.rect[YHI];
gmt_map.c:	else if (fabs (*x - GMT->current.proj.rect[XHI]) <= GMT_CONV8_LIMIT)
gmt_map.c:		*x = GMT->current.proj.rect[XHI];
gmt_map.c:	else if (fabs (*y - GMT->current.proj.rect[YHI]) <= GMT_CONV8_LIMIT)
gmt_map.c:		*y = GMT->current.proj.rect[YHI];
gmt_map.c:	GMT->current.map.corner = -1;
gmt_map.c:	if (doubleAlmostEqualZero (x, GMT->current.proj.rect[XLO])) {
gmt_map.c:		if (doubleAlmostEqualZero (y, GMT->current.proj.rect[YLO]))
gmt_map.c:			GMT->current.map.corner = 1;
gmt_map.c:		else if (doubleAlmostEqualZero (y, GMT->current.proj.rect[YHI]))
gmt_map.c:			GMT->current.map.corner = 4;
gmt_map.c:	else if (doubleAlmostEqualZero (x, GMT->current.proj.rect[XHI])) {
gmt_map.c:		if (doubleAlmostEqualZero (y, GMT->current.proj.rect[YLO]))
gmt_map.c:			GMT->current.map.corner = 2;
gmt_map.c:		else if (doubleAlmostEqualZero (y, GMT->current.proj.rect[YHI]))
gmt_map.c:			GMT->current.map.corner = 3;
gmt_map.c:	return (GMT->current.map.corner > 0);
gmt_map.c:	if ((y0 >= GMT->current.proj.rect[YLO] && y1 <= GMT->current.proj.rect[YLO]) || (y1 >= GMT->current.proj.rect[YLO] && y0 <= GMT->current.proj.rect[YLO])) {
gmt_map.c:		yy[n] = GMT->current.proj.rect[YLO];
gmt_map.c:		if (fabs (d) > 0.0 && xx[n] >= GMT->current.proj.rect[XLO] && xx[n] <= GMT->current.proj.rect[XHI]) n++;
gmt_map.c:	if ((x0 <= GMT->current.proj.rect[XHI] && x1 >= GMT->current.proj.rect[XHI]) || (x1 <= GMT->current.proj.rect[XHI] && x0 >= GMT->current.proj.rect[XHI])) {
gmt_map.c:		xx[n] = GMT->current.proj.rect[XHI];
gmt_map.c:		if (fabs (d) > 0.0 && yy[n] >= GMT->current.proj.rect[YLO] && yy[n] <= GMT->current.proj.rect[YHI]) n++;
gmt_map.c:	if ((y0 <= GMT->current.proj.rect[YHI] && y1 >= GMT->current.proj.rect[YHI]) || (y1 <= GMT->current.proj.rect[YHI] && y0 >= GMT->current.proj.rect[YHI])) {
gmt_map.c:		yy[n] = GMT->current.proj.rect[YHI];
gmt_map.c:		if (fabs (d) > 0.0 && xx[n] >= GMT->current.proj.rect[XLO] && xx[n] <= GMT->current.proj.rect[XHI]) n++;
gmt_map.c:	if ((x0 >= GMT->current.proj.rect[XLO] && x1 <= GMT->current.proj.rect[XLO]) || (x1 >= GMT->current.proj.rect[XLO] && x0 <= GMT->current.proj.rect[XLO])) {
gmt_map.c:		xx[n] = GMT->current.proj.rect[XLO];
gmt_map.c:		if (fabs (d) > 0.0 && yy[n] >= GMT->current.proj.rect[YLO] && yy[n] <= GMT->current.proj.rect[YHI]) n++;
gmt_map.c:	dist1 = gmtlib_great_circle_dist_degree (GMT, GMT->current.proj.central_meridian, GMT->current.proj.pole, lon1, lat1);
gmt_map.c:	dist2 = gmtlib_great_circle_dist_degree (GMT, GMT->current.proj.central_meridian, GMT->current.proj.pole, lon2, lat2);
gmt_map.c:	eps = (doubleAlmostEqualZero (dist1, dist2)) ? 0.0 : (GMT->current.proj.f_horizon - dist1) / delta;
gmt_map.c:	GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error in map_genper_crossing: None of the cases matched crossing scenario");
gmt_map.c:	if (gmt_M_is_cartesian (GMT, GMT_IN) || fabs (GMT->common.R.wesn[XLO] - GMT->common.R.wesn[XHI]) < 90.0) return (0);
gmt_map.c:	half_lon_range = (GMT->common.R.oblique) ? 180.0 : 0.5 * (GMT->common.R.wesn[XHI] - GMT->common.R.wesn[XLO]);
gmt_map.c:	if (gmt_M_is_cartesian (GMT, GMT_IN) || fabs (GMT->common.R.wesn[XLO] - GMT->common.R.wesn[XHI]) < 90.0) return (0);
gmt_map.c:	map_half_height = 0.5 * GMT->current.map.height;	/* We assume this is constant */
gmt_map.c:		double half_lon_range = (GMT->common.R.oblique) ? 180.0 : 0.5 * (GMT->common.R.wesn[XHI] - GMT->common.R.wesn[XLO]);
gmt_map.c:			(*GMT->current.map.get_crossings) (GMT, xx, yy, x2, y2, x1, y1);
gmt_map.c:	lon -= GMT->current.proj.central_meridian;
gmt_map.c:	cc = GMT->current.proj.sinp * s + GMT->current.proj.cosp * c * cosd (lon);
gmt_map.c:		GMT->current.map.this_y_status = -1;
gmt_map.c:		GMT->current.map.this_x_status = 0;
gmt_map.c:		GMT->current.map.this_x_status = GMT->current.map.this_y_status = 0;
gmt_map.c:	return (GMT->current.map.this_y_status != 0);
gmt_map.c:		angle = d_atan2 (y - GMT->current.proj.origin[GMT_Y], x - GMT->current.proj.origin[GMT_X]);
gmt_map.c:		xx[0] = GMT->current.proj.r * c + GMT->current.proj.origin[GMT_X];
gmt_map.c:		yy[0] = GMT->current.proj.r * s + GMT->current.proj.origin[GMT_Y];
gmt_map.c:		angle = d_atan2 (y - GMT->current.proj.origin[GMT_Y], x - GMT->current.proj.origin[GMT_X]);
gmt_map.c:		xx[0] = GMT->current.proj.r * c + GMT->current.proj.origin[GMT_X];
gmt_map.c:		yy[0] = GMT->current.proj.r * s + GMT->current.proj.origin[GMT_Y];
gmt_map.c:	if (GMT->current.map.prev_x_status == GMT->current.map.this_x_status && GMT->current.map.prev_y_status == GMT->current.map.this_y_status) {
gmt_map.c:	else if ((GMT->current.map.prev_x_status == 0 && GMT->current.map.prev_y_status == 0) || (GMT->current.map.this_x_status == 0 && GMT->current.map.this_y_status == 0)) {
gmt_map.c:	else if (!(*GMT->current.map.overlap) (GMT, lon1, lat1, lon2, lat2))	/* Less clearcut case, check for overlap */
gmt_map.c:	GMT->current.map.corner = -1;
gmt_map.c:	return ((*GMT->current.map.crossing) (GMT, lon1, lat1, lon2, lat2, xlon, xlat, xx, yy, sides));
gmt_map.c:	return ( (fabs (x - GMT->current.proj.rect[XLO]) < fabs (x - GMT->current.proj.rect[XHI])) ? GMT->current.proj.rect[XLO] : GMT->current.proj.rect[XHI]);
gmt_map.c:	return ( (fabs (y - GMT->current.proj.rect[YLO]) < fabs (y - GMT->current.proj.rect[YHI])) ? GMT->current.proj.rect[YLO] : GMT->current.proj.rect[YHI]);
gmt_map.c:	if (GMT->current.map.this_x_status == 0 && GMT->current.map.this_y_status == 0) return (1);	/* Completely Inside */
gmt_map.c:	if (!nx && j > 0 && GMT->current.map.this_x_status != GMT->current.map.prev_x_status && GMT->current.map.this_y_status != GMT->current.map.prev_y_status) {	/* Must include corner */
gmt_map.c:		if ((GMT->current.map.this_x_status * GMT->current.map.prev_x_status) == -4 || (GMT->current.map.this_y_status * GMT->current.map.prev_y_status) == -4) {	/* the two points outside on opposite sides */
gmt_map.c:			x_edge[j] = (GMT->current.map.prev_x_status < 0) ? GMT->current.proj.rect[XLO] : ((GMT->current.map.prev_x_status > 0) ? GMT->current.proj.rect[XHI] : map_x_to_corner (GMT, x_edge[j-1]));
gmt_map.c:			y_edge[j] = (GMT->current.map.prev_y_status < 0) ? GMT->current.proj.rect[YLO] : ((GMT->current.map.prev_y_status > 0) ? GMT->current.proj.rect[YHI] : map_y_to_corner (GMT, y_edge[j-1]));
gmt_map.c:			x_edge[j] = (GMT->current.map.this_x_status < 0) ? GMT->current.proj.rect[XLO] : ((GMT->current.map.this_x_status > 0) ? GMT->current.proj.rect[XHI] : map_x_to_corner (GMT, xtmp));
gmt_map.c:			y_edge[j] = (GMT->current.map.this_y_status < 0) ? GMT->current.proj.rect[YLO] : ((GMT->current.map.this_y_status > 0) ? GMT->current.proj.rect[YHI] : map_y_to_corner (GMT, ytmp));
gmt_map.c:			key = MIN (GMT->current.map.this_x_status, GMT->current.map.prev_x_status);
gmt_map.c:			x_edge[j] = (key < 0) ? GMT->current.proj.rect[XLO] : GMT->current.proj.rect[XHI];
gmt_map.c:			key = MIN (GMT->current.map.this_y_status, GMT->current.map.prev_y_status);
gmt_map.c:			y_edge[j] = (key < 0) ? GMT->current.proj.rect[YLO] : GMT->current.proj.rect[YHI];
gmt_map.c:	if (GMT->current.map.outside == map_rect_outside2) {	/* Need special check because this outside2 test is screwed up... */
gmt_map.c:		if (x_edge[j] < GMT->current.proj.rect[XLO]) {
gmt_map.c:			x_edge[j] = GMT->current.proj.rect[XLO];
gmt_map.c:			GMT->current.map.this_x_status = -2;
gmt_map.c:		else if (x_edge[j] > GMT->current.proj.rect[XHI]) {
gmt_map.c:			x_edge[j] = GMT->current.proj.rect[XHI];
gmt_map.c:			GMT->current.map.this_x_status = 2;
gmt_map.c:		if (y_edge[j] < GMT->current.proj.rect[YLO]) {
gmt_map.c:			y_edge[j] = GMT->current.proj.rect[YLO];
gmt_map.c:			GMT->current.map.this_y_status = -2;
gmt_map.c:		else if (y_edge[j] > GMT->current.proj.rect[YHI]) {
gmt_map.c:			y_edge[j] = GMT->current.proj.rect[YHI];
gmt_map.c:			GMT->current.map.this_y_status = 2;
gmt_map.c:		if (GMT->current.map.this_x_status != 0) x_edge[j] = (GMT->current.map.this_x_status < 0) ? GMT->current.proj.rect[XLO] : GMT->current.proj.rect[XHI];
gmt_map.c:		if (GMT->current.map.this_y_status != 0) y_edge[j] = (GMT->current.map.this_y_status < 0) ? GMT->current.proj.rect[YLO] : GMT->current.proj.rect[YHI];
gmt_map.c:	gmt_geo_to_xy (GMT, lon[0], lat[0], &GMT->hidden.mem_coord[GMT_X][0], &GMT->hidden.mem_coord[GMT_Y][0]);
gmt_map.c:	j += map_move_to_rect (GMT, GMT->hidden.mem_coord[GMT_X], GMT->hidden.mem_coord[GMT_Y], 0, 0);
gmt_map.c:			GMT->hidden.mem_coord[GMT_X][j] = xc[k];
gmt_map.c:			GMT->hidden.mem_coord[GMT_Y][j++] = yc[k];
gmt_map.c:		gmt_geo_to_xy (GMT, lon[i], lat[i], &GMT->hidden.mem_coord[GMT_X][j], &GMT->hidden.mem_coord[GMT_Y][j]);
gmt_map.c:		j += map_move_to_rect (GMT, GMT->hidden.mem_coord[GMT_X], GMT->hidden.mem_coord[GMT_Y], j, nx);	/* May add 2 points, which explains the j+2 stuff */
gmt_map.c:	border[GMT_BOTTOM] = border[GMT_LEFT] = 0.0;	border[GMT_RIGHT] = GMT->current.map.width;	border[GMT_TOP] = GMT->current.map.height;
gmt_map.c:		if (GMT->common.R.oblique) {	/* Ensure region corners are added if any poles are enclosed */
gmt_map.c:			if (GMT->current.proj.corner[0] && GMT->current.proj.corner[1])	/* Ensure S pole is included */
gmt_map.c:				ycoord_pole = GMT->current.proj.rect[YLO];
gmt_map.c:			else if (GMT->current.proj.corner[2] && GMT->current.proj.corner[3])	/* Ensure N pole is included */
gmt_map.c:				ycoord_pole = GMT->current.proj.rect[YHI];
gmt_map.c:					if (doubleAlmostEqual (fabs (xtmp[0][i] - xtmp[0][i-1]), GMT->current.map.width))
gmt_map.c:	return ( (fabs (lon - GMT->common.R.wesn[XLO]) < fabs (lon - GMT->common.R.wesn[XHI])) ? GMT->common.R.wesn[XLO] : GMT->common.R.wesn[XHI]);
gmt_map.c:	return ( (fabs (lat - GMT->common.R.wesn[YLO]) < fabs (lat - GMT->common.R.wesn[YHI])) ? GMT->common.R.wesn[YLO] : GMT->common.R.wesn[YHI]);
gmt_map.c:	if (!nx && j > 0 && GMT->current.map.this_x_status != GMT->current.map.prev_x_status && GMT->current.map.this_y_status != GMT->current.map.prev_y_status) {	/* Need corner */
gmt_map.c:		if ((GMT->current.map.this_x_status * GMT->current.map.prev_x_status) == -4 || (GMT->current.map.this_y_status * GMT->current.map.prev_y_status) == -4) {	/* the two points outside on opposite sides */
gmt_map.c:			lon_p = (GMT->current.map.prev_x_status < 0) ? GMT->common.R.wesn[XLO] : ((GMT->current.map.prev_x_status > 0) ? GMT->common.R.wesn[XHI] : map_lon_to_corner (GMT, lon_old));
gmt_map.c:			lat_p = (GMT->current.map.prev_y_status < 0) ? GMT->common.R.wesn[YLO] : ((GMT->current.map.prev_y_status > 0) ? GMT->common.R.wesn[YHI] : map_lat_to_corner (GMT, lat_old));
gmt_map.c:			lon_p = (GMT->current.map.this_x_status < 0) ? GMT->common.R.wesn[XLO] : ((GMT->current.map.this_x_status > 0) ? GMT->common.R.wesn[XHI] : map_lon_to_corner (GMT, lon));
gmt_map.c:			lat_p = (GMT->current.map.this_y_status < 0) ? GMT->common.R.wesn[YLO] : ((GMT->current.map.this_y_status > 0) ? GMT->common.R.wesn[YHI] : map_lat_to_corner (GMT, lat));
gmt_map.c:			key = MIN (GMT->current.map.this_x_status, GMT->current.map.prev_x_status);
gmt_map.c:			lon_p = (key < 0) ? GMT->common.R.wesn[XLO] : GMT->common.R.wesn[XHI];
gmt_map.c:			key = MIN (GMT->current.map.this_y_status, GMT->current.map.prev_y_status);
gmt_map.c:			lat_p = (key < 0) ? GMT->common.R.wesn[YLO] : GMT->common.R.wesn[YHI];
gmt_map.c:	if (GMT->current.map.this_x_status != 0) lon = (GMT->current.map.this_x_status < 0) ? GMT->common.R.wesn[XLO] : GMT->common.R.wesn[XHI];
gmt_map.c:	if (GMT->current.map.this_y_status != 0) lat = (GMT->current.map.this_y_status < 0) ? GMT->common.R.wesn[YLO] : GMT->common.R.wesn[YHI];
gmt_map.c:	j = map_move_to_wesn (GMT, GMT->hidden.mem_coord[GMT_X], GMT->hidden.mem_coord[GMT_Y], lon[0], lat[0], 0.0, 0.0, 0, 0);	/* Add one point */
gmt_map.c:			GMT->hidden.mem_coord[GMT_X][j]   = xc[k];
gmt_map.c:			GMT->hidden.mem_coord[GMT_Y][j++] = yc[k];
gmt_map.c:		j += map_move_to_wesn (GMT, GMT->hidden.mem_coord[GMT_X], GMT->hidden.mem_coord[GMT_Y], lon[i], lat[i], lon[i-1], lat[i-1], j, nx);	/* May add 2 points, which explains the j+2 stuff */
gmt_map.c:		GMT->current.io.output (GMT, fp, 2, out);
gmt_map.c:	periodic = gmt_M_360_range (GMT->common.R.wesn[XLO], GMT->common.R.wesn[XHI]);	/* No point clipping against W and E if periodic map */
gmt_map.c:	border[GMT_BOTTOM] = GMT->common.R.wesn[YLO]; border[GMT_LEFT] = GMT->common.R.wesn[XLO];	border[GMT_RIGHT] = GMT->common.R.wesn[XHI];	border[GMT_TOP] = GMT->common.R.wesn[YHI];
gmt_map.c:	if (GMT->current.map.coastline && periodic) {	/* Make data longitudes have no jumps [This is for pscoast] */
gmt_map.c:	if (!GMT->current.map.coastline) {	/* Not do if pscoast since it has its own oddness */
gmt_map.c:		curved = !((side%2) ? GMT->current.map.meridian_straight : GMT->current.map.parallel_straight);	/* Is this border straight or curved when projected */
gmt_map.c:		if (!GMT->current.map.coastline && side % 2) {	/* Either left or right border */
gmt_map.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error in map_wesn_clip: odd number of crossings?");
gmt_map.c:	da_try = (GMT->current.setting.map_line_step * 360.0) / (TWO_PI * GMT->current.proj.r);	/* Angular step in degrees */
gmt_map.c:		xx[pt] = GMT->current.proj.r * (1.0 + xr);
gmt_map.c:		yy[pt] = GMT->current.proj.r * (1.0 + yr);
gmt_map.c:			end_x[nx] = xc[0] - GMT->current.proj.r;	end_y[nx] = yc[0] - GMT->current.proj.r;
gmt_map.c:	if (x1 - GMT->current.proj.rect[XLO] < -GMT_CONV8_LIMIT || x0 - GMT->current.proj.rect[XHI] > GMT_CONV8_LIMIT) return (false);
gmt_map.c:	if (y1 - GMT->current.proj.rect[YLO] < -GMT_CONV8_LIMIT || y0 - GMT->current.proj.rect[YHI] > GMT_CONV8_LIMIT) return (false);
gmt_map.c:	if (x1 - GMT->current.proj.rect[XLO] < -GMT_CONV8_LIMIT || x0 - GMT->current.proj.rect[XHI] > GMT_CONV8_LIMIT) return (false);
gmt_map.c:	if (y1 - GMT->current.proj.rect[YLO] < -GMT_CONV8_LIMIT || y0 - GMT->current.proj.rect[YHI] > GMT_CONV8_LIMIT) return (false);
gmt_map.c:	if (x0 < GMT->current.proj.rect[XLO] && x1 > GMT->current.proj.rect[XHI]) {	/* Possibly a map jump but is it reasonable? */
gmt_map.c:		if ((x1 - x0)/(GMT->current.proj.rect[XHI] - GMT->current.proj.rect[XLO]) > 10.0) return (false);
gmt_map.c:	if (lon1 - GMT->common.R.wesn[XLO] < -GMT_CONV8_LIMIT) {
gmt_map.c:	else if (lon0 - GMT->common.R.wesn[XHI] > GMT_CONV8_LIMIT) {
gmt_map.c:	if (lon1 - GMT->common.R.wesn[XLO] < -GMT_CONV8_LIMIT || lon0 - GMT->common.R.wesn[XHI] > GMT_CONV8_LIMIT) return (false);
gmt_map.c:	if (lat1 - GMT->common.R.wesn[YLO] < -GMT_CONV8_LIMIT || lat0 - GMT->common.R.wesn[YHI] > GMT_CONV8_LIMIT) return (false);
gmt_map.c:	if (GMT->current.proj.g_debug > 0) GMT_Report (GMT->parent, GMT_MSG_DEBUG, "genper_overlap: overlap called\n");
gmt_map.c:		(*GMT->current.proj.fwd) (GMT, w, s0, &x, &y);
gmt_map.c:		(*GMT->current.proj.fwd) (GMT, w, n0, &x, &y);
gmt_map.c:		(*GMT->current.proj.fwd) (GMT, w0, s, &x, &y);
gmt_map.c:		(*GMT->current.proj.fwd) (GMT, e0, s, &x, &y);
gmt_map.c:	struct GMT_SUBPLOT *P = &(GMT->current.plot.panel);	/* P->active == 1 if a subplot */
gmt_map.c:	struct GMT_INSET *I = &(GMT->current.plot.inset);	/* I->active == 1 if an inset */
gmt_map.c:	GMT->current.proj.rect_m[XLO] = xmin;	GMT->current.proj.rect_m[XHI] = xmax;	/* This is in original meters */
gmt_map.c:	GMT->current.proj.rect_m[YLO] = ymin;	GMT->current.proj.rect_m[YHI] = ymax;
gmt_map.c:	GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Projected values in meters: %g %g %g %g\n", xmin, xmax, ymin, ymax);
gmt_map.c:	GMT->current.proj.rect[XHI] = (xmax - xmin) * GMT->current.proj.scale[GMT_X];
gmt_map.c:	GMT->current.proj.rect[YHI] = (ymax - ymin) * GMT->current.proj.scale[GMT_Y];
gmt_map.c:	GMT->current.proj.origin[GMT_X] = -xmin * GMT->current.proj.scale[GMT_X];
gmt_map.c:	GMT->current.proj.origin[GMT_Y] = -ymin * GMT->current.proj.scale[GMT_Y];
gmt_map.c:	if (!strncmp (GMT->init.module_name, "inset", 5U))
gmt_map.c:	w = GMT->current.proj.rect[XHI];	h = GMT->current.proj.rect[YHI];
gmt_map.c:		if (gmt_M_is_geographic (GMT, GMT_IN) || GMT->current.proj.projection == GMT_POLAR || GMT->current.proj.gave_map_width == 0) {	/* Giving -Jx will end up here with map projections */
gmt_map.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Rescaling map for inset by factors fx = %g fy = %g dx = %g dy = %g\n", fx, fy, I->dx, I->dy);
gmt_map.c:		if (gmt_M_is_geographic (GMT, GMT_IN) || GMT->current.proj.projection == GMT_POLAR || GMT->current.proj.gave_map_width == 0) {	/* Giving -Jx will end up here with map projections */
gmt_map.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Rescaling map for subplot by factors fx = %g fy = %g dx = %g dy = %g\n", fx, fy, P->dx, P->dy);
gmt_map.c:			strcpy (GMT->current.setting.map_annot_ortho, "");	/* All annotations will be parallel to axes */
gmt_map.c:			GMT->current.setting.map_annot_oblique |= GMT_OBL_ANNOT_LAT_PARALLEL;	/* Plot latitude parallel to frame for geo maps */
gmt_map.c:		GMT->current.proj.scale[GMT_X] *= fx;
gmt_map.c:		GMT->current.proj.scale[GMT_Y] *= fy;
gmt_map.c:		GMT->current.proj.w_r *= fx;	/* Only matter for geographic where fx = fy anyway */
gmt_map.c:		GMT->current.proj.rect[XHI] = (xmax - xmin) * GMT->current.proj.scale[GMT_X];
gmt_map.c:		GMT->current.proj.rect[YHI] = (ymax - ymin) * GMT->current.proj.scale[GMT_Y];
gmt_map.c:		GMT->current.proj.origin[GMT_X] = -xmin * GMT->current.proj.scale[GMT_X];
gmt_map.c:		GMT->current.proj.origin[GMT_Y] = -ymin * GMT->current.proj.scale[GMT_Y];
gmt_map.c:	if (GMT->current.map.is_world && doubleAlmostEqualZero (xmax, xmin)) {	/* Safety valve for cases when w & e both project to the same side due to round-off */
gmt_map.c:	w = (xmax - xmin) * GMT->current.proj.scale[GMT_X];
gmt_map.c:	h = (ymax - ymin) * GMT->current.proj.scale[GMT_Y];
gmt_map.c:	if (GMT->current.proj.gave_map_width == 1)	/* Must rescale to given width */
gmt_map.c:	else if (GMT->current.proj.gave_map_width == 2)	/* Must rescale to given height */
gmt_map.c:	else if (GMT->current.proj.gave_map_width == 3)	/* Must rescale to max dimension */
gmt_map.c:	else if (GMT->current.proj.gave_map_width == 4)	/* Must rescale to min dimension */
gmt_map.c:	GMT->current.proj.scale[GMT_X] *= factor;
gmt_map.c:	GMT->current.proj.scale[GMT_Y] *= factor;
gmt_map.c:	GMT->current.proj.w_r *= factor;
gmt_map.c:	if (GMT->current.proj.g_debug > 1) {
gmt_map.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "xmin %7.3f xmax %7.3f ymin %7.4f ymax %7.3f scale %6.3f\n", xmin/1000, xmax/1000, ymin/1000, ymax/1000, scl);
gmt_map.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "gave_map_width %d w %9.4e h %9.4e factor %9.4e\n", GMT->current.proj.gave_map_width, w, h, factor);
gmt_map.c:	switch (GMT->current.setting.proj_mean_radius) {
gmt_map.c:			r = sqrt (0.5 * a * a + 0.5 * b * b * atanh (GMT->current.proj.ECC) / GMT->current.proj.ECC);
gmt_map.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "GMT mean radius not specified\n");
gmt_map.c:	GMT->current.setting.ref_ellipsoid[GMT_N_ELLIPSOIDS - 1].eq_radius =
gmt_map.c:		map_mean_radius (GMT, GMT->current.setting.ref_ellipsoid[GMT->current.setting.proj_ellipsoid].eq_radius, GMT->current.setting.ref_ellipsoid[GMT->current.setting.proj_ellipsoid].flattening);
gmt_map.c:	GMT->current.setting.proj_ellipsoid = GMT_N_ELLIPSOIDS - 1;	/* Custom ellipsoid */
gmt_map.c:	GMT->current.setting.ref_ellipsoid[GMT->current.setting.proj_ellipsoid].flattening = 0.0;
gmt_map.c:	if (notify) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Spherical approximation used!\n");
gmt_map.c:	GMT->current.setting.proj_aux_latitude = GMT_LATSWAP_NONE;	/* No lat swapping for spherical */
gmt_map.c:	gmt_geo_to_xy (GMT, GMT->common.R.wesn[XLO], GMT->common.R.wesn[YLO], &x_ws, &y_ws);
gmt_map.c:	gmt_geo_to_xy (GMT, GMT->common.R.wesn[XLO], GMT->common.R.wesn[YHI], &x_wn, &y_wn);
gmt_map.c:	gmt_geo_to_xy (GMT, GMT->common.R.wesn[XHI], GMT->common.R.wesn[YLO], &x_es, &y_es);
gmt_map.c:	gmt_geo_to_xy (GMT, GMT->common.R.wesn[XHI], GMT->common.R.wesn[YHI], &x_en, &y_en);
gmt_map.c:		return (GMT->current.map.width);
gmt_map.c:	return (GMT->current.map.width);
gmt_map.c:	y -= GMT->current.proj.origin[GMT_Y];
gmt_map.c:	return (GMT->current.map.half_width - d_sqrt (GMT->current.proj.r * GMT->current.proj.r - y * y));
gmt_map.c:	/* y -= GMT->current.proj.r; */
gmt_map.c:	y -= GMT->current.proj.origin[GMT_Y];
gmt_map.c:	return (GMT->current.map.half_width + d_sqrt (GMT->current.proj.r * GMT->current.proj.r - y * y));
gmt_map.c:	y = (y - GMT->current.proj.origin[GMT_Y]) / GMT->current.proj.w_r;	/* Fraction, relative to Equator */
gmt_map.c:	return (GMT->current.map.half_width - 2.0 * GMT->current.proj.w_r * d_sqrt (1.0 - y * y));
gmt_map.c:	y = (y - GMT->current.proj.origin[GMT_Y]) / GMT->current.proj.w_r;	/* Fraction, relative to Equator */
gmt_map.c:	return (GMT->current.map.half_width + 2.0 * GMT->current.proj.w_r * d_sqrt (1.0 - y * y));
gmt_map.c:	az = (dx == 0.0 && dy == 0.0) ? GMT->session.d_NaN : 90.0 - atan2d (dy, dx);
gmt_map.c:	az = (dx == 0.0 && dy == 0.0) ? GMT->session.d_NaN : 90.0 - atan2d (dy, dx);
gmt_map.c:	az = (dx == 0.0 && dy == 0.0) ? GMT->session.d_NaN : 90.0 - atan2d (dy, dx);
gmt_map.c:	f = GMT->current.setting.ref_ellipsoid[GMT->current.setting.proj_ellipsoid].flattening;
gmt_map.c:	if (gmt_M_is_zero (d_lon) && doubleAlmostEqualZero (latS, latE)) return GMT->session.d_NaN;
gmt_map.c:		GMT->current.proj.n_geodesic_approx++;	/* Count inaccurate results */
gmt_map.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Near- or actual antipodal points encountered. Precision may be reduced slightly.\n");
gmt_map.c:	GMT->current.proj.n_geodesic_calls++;
gmt_map.c:	 * correction given by: 1-ECC2=1-2*f + f*f = GMT->current.proj.one_m_ECC2
gmt_map.c:	thg = atan (GMT->current.proj.one_m_ECC2 * tand (latE));
gmt_map.c:	thg = atan (GMT->current.proj.one_m_ECC2 * tand (latS));
gmt_map.c:	(*GMT->current.proj.fwd_x) (GMT, x, x_i);
gmt_map.c:	(*GMT->current.proj.fwd_y) (GMT, y, y_i);
gmt_map.c:	(*GMT->current.proj.inv_x) (GMT, x, x_i);
gmt_map.c:	(*GMT->current.proj.inv_y) (GMT, y, y_i);
gmt_map.c:	GMT->current.map.left_edge  = &map_left_rect;
gmt_map.c:	GMT->current.map.right_edge = &map_right_rect;
gmt_map.c:	GMT->current.proj.fwd = &map_linearxy;
gmt_map.c:	GMT->current.proj.inv = &map_ilinearxy;
gmt_map.c:		GMT->current.proj.central_meridian = 0.5 * (GMT->common.R.wesn[XLO] + GMT->common.R.wesn[XHI]);
gmt_map.c:		GMT->current.map.is_world = gmt_M_360_range (GMT->common.R.wesn[XLO], GMT->common.R.wesn[XHI]);
gmt_map.c:		GMT->current.map.lon_wrap = false;
gmt_map.c:		GMT->current.proj.central_meridian = 0.5 * (GMT->common.R.wesn[YLO] + GMT->common.R.wesn[YHI]);
gmt_map.c:	GMT->current.proj.scale[GMT_X] = GMT->current.proj.pars[0];
gmt_map.c:	GMT->current.proj.scale[GMT_Y] = GMT->current.proj.pars[1];
gmt_map.c:	GMT->current.proj.xyz_pos[GMT_X] = (GMT->current.proj.scale[GMT_X] >= 0.0);	/* False if user wants x to increase left */
gmt_map.c:	GMT->current.proj.xyz_pos[GMT_Y] = (GMT->current.proj.scale[GMT_Y] >= 0.0);	/* False if user wants y to increase down */
gmt_map.c:	switch ( (GMT->current.proj.xyz_projection[GMT_X]%3)) {	/* Modulo 3 so that GMT_TIME (3) maps to GMT_LINEAR (0) */
gmt_map.c:			if (gmt_M_type (GMT, GMT_IN, GMT_X) == GMT_IS_ABSTIME && GMT->current.proj.xyz_projection[GMT_X] != GMT_TIME)
gmt_map.c:				GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning -JX|x option: Your x-column contains absolute time but -JX|x...T was not specified!\n");
gmt_map.c:			GMT->current.proj.fwd_x = ((gmt_M_x_is_lon (GMT, GMT_IN)) ? &gmt_translind  : &gmt_translin);
gmt_map.c:			GMT->current.proj.inv_x = ((gmt_M_x_is_lon (GMT, GMT_IN)) ? &gmt_itranslind : &gmt_itranslin);
gmt_map.c:			if (GMT->current.proj.xyz_pos[GMT_X]) {
gmt_map.c:				(*GMT->current.proj.fwd_x) (GMT, GMT->common.R.wesn[XLO], &xmin);
gmt_map.c:				(*GMT->current.proj.fwd_x) (GMT, GMT->common.R.wesn[XHI], &xmax);
gmt_map.c:				(*GMT->current.proj.fwd_x) (GMT, GMT->common.R.wesn[XHI], &xmin);
gmt_map.c:				(*GMT->current.proj.fwd_x) (GMT, GMT->common.R.wesn[XLO], &xmax);
gmt_map.c:			if (GMT->common.R.wesn[XLO] <= 0.0 || GMT->common.R.wesn[XHI] <= 0.0) {
gmt_map.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -JX|x option:  Limits must be positive for log10 option\n");
gmt_map.c:			xmin = (GMT->current.proj.xyz_pos[GMT_X]) ? d_log10 (GMT, GMT->common.R.wesn[XLO]) : d_log10 (GMT, GMT->common.R.wesn[XHI]);
gmt_map.c:			xmax = (GMT->current.proj.xyz_pos[GMT_X]) ? d_log10 (GMT, GMT->common.R.wesn[XHI]) : d_log10 (GMT, GMT->common.R.wesn[XLO]);
gmt_map.c:			GMT->current.proj.fwd_x = &gmt_translog10;
gmt_map.c:			GMT->current.proj.inv_x = &gmt_itranslog10;
gmt_map.c:			GMT->current.proj.xyz_pow[GMT_X] = GMT->current.proj.pars[2];
gmt_map.c:			GMT->current.proj.xyz_ipow[GMT_X] = 1.0 / GMT->current.proj.pars[2];
gmt_map.c:			positive = !((GMT->current.proj.xyz_pos[GMT_X] + (GMT->current.proj.xyz_pow[GMT_X] > 0.0)) % 2);
gmt_map.c:			xmin = (positive) ? pow (GMT->common.R.wesn[XLO], GMT->current.proj.xyz_pow[GMT_X]) : pow (GMT->common.R.wesn[XHI], GMT->current.proj.xyz_pow[GMT_X]);
gmt_map.c:			xmax = (positive) ? pow (GMT->common.R.wesn[XHI], GMT->current.proj.xyz_pow[GMT_X]) : pow (GMT->common.R.wesn[XLO], GMT->current.proj.xyz_pow[GMT_X]);
gmt_map.c:			GMT->current.proj.fwd_x = &gmt_transpowx;
gmt_map.c:			GMT->current.proj.inv_x = &gmt_itranspowx;
gmt_map.c:	switch (GMT->current.proj.xyz_projection[GMT_Y]%3) {	/* Modulo 3 so that GMT_TIME (3) maps to GMT_LINEAR (0) */
gmt_map.c:			if (gmt_M_type (GMT, GMT_IN, GMT_Y) == GMT_IS_ABSTIME && GMT->current.proj.xyz_projection[GMT_Y] != GMT_TIME)
gmt_map.c:				GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning -JX|x option:  Your y-column contains absolute time but -JX|x...T was not specified!\n");
gmt_map.c:			GMT->current.proj.fwd_y = ((gmt_M_y_is_lon (GMT, GMT_IN)) ? &gmt_translind  : &gmt_translin);
gmt_map.c:			GMT->current.proj.inv_y = ((gmt_M_y_is_lon (GMT, GMT_IN)) ? &gmt_itranslind : &gmt_itranslin);
gmt_map.c:			if (GMT->current.proj.xyz_pos[GMT_Y]) {
gmt_map.c:				(*GMT->current.proj.fwd_y) (GMT, GMT->common.R.wesn[YLO], &ymin);
gmt_map.c:				(*GMT->current.proj.fwd_y) (GMT, GMT->common.R.wesn[YHI], &ymax);
gmt_map.c:				(*GMT->current.proj.fwd_y) (GMT, GMT->common.R.wesn[YHI], &ymin);
gmt_map.c:				(*GMT->current.proj.fwd_y) (GMT, GMT->common.R.wesn[YLO], &ymax);
gmt_map.c:			if (GMT->common.R.wesn[YLO] <= 0.0 || GMT->common.R.wesn[YHI] <= 0.0) {
gmt_map.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -JX|x option:  Limits must be positive for log10 option\n");
gmt_map.c:			ymin = (GMT->current.proj.xyz_pos[GMT_Y]) ? d_log10 (GMT, GMT->common.R.wesn[YLO]) : d_log10 (GMT, GMT->common.R.wesn[YHI]);
gmt_map.c:			ymax = (GMT->current.proj.xyz_pos[GMT_Y]) ? d_log10 (GMT, GMT->common.R.wesn[YHI]) : d_log10 (GMT, GMT->common.R.wesn[YLO]);
gmt_map.c:			GMT->current.proj.fwd_y = &gmt_translog10;
gmt_map.c:			GMT->current.proj.inv_y = &gmt_itranslog10;
gmt_map.c:			GMT->current.proj.xyz_pow[GMT_Y] = GMT->current.proj.pars[3];
gmt_map.c:			GMT->current.proj.xyz_ipow[GMT_Y] = 1.0 / GMT->current.proj.pars[3];
gmt_map.c:			positive = !((GMT->current.proj.xyz_pos[GMT_Y] + (GMT->current.proj.xyz_pow[GMT_Y] > 0.0)) % 2);
gmt_map.c:			ymin = (positive) ? pow (GMT->common.R.wesn[YLO], GMT->current.proj.xyz_pow[GMT_Y]) : pow (GMT->common.R.wesn[YHI], GMT->current.proj.xyz_pow[GMT_Y]);
gmt_map.c:			ymax = (positive) ? pow (GMT->common.R.wesn[YHI], GMT->current.proj.xyz_pow[GMT_Y]) : pow (GMT->common.R.wesn[YLO], GMT->current.proj.xyz_pow[GMT_Y]);
gmt_map.c:			GMT->current.proj.fwd_y = &gmt_transpowy;
gmt_map.c:			GMT->current.proj.inv_y = &gmt_itranspowy;
gmt_map.c:	if (GMT->current.proj.compute_scale[GMT_X]) GMT->current.proj.scale[GMT_X] /= fabs (xmin - xmax);
gmt_map.c:	if (GMT->current.proj.compute_scale[GMT_Y]) GMT->current.proj.scale[GMT_Y] /= fabs (ymin - ymax);
gmt_map.c:	if (GMT->current.proj.scale[GMT_X] == 0) {	/* Must redo x-scaling by using y-scale */
gmt_map.c:		GMT->current.proj.scale[GMT_X] = GMT->current.proj.autoscl[GMT_X] * GMT->current.proj.scale[GMT_Y];
gmt_map.c:		if (GMT->current.proj.autoscl[GMT_X] == -1) GMT->current.proj.xyz_pos[GMT_X] = !GMT->current.proj.xyz_pos[GMT_Y];
gmt_map.c:		switch ( (GMT->current.proj.xyz_projection[GMT_X]%3)) {	/* Modulo 3 so that GMT_TIME (3) maps to GMT_LINEAR (0) */
gmt_map.c:				if (GMT->current.proj.xyz_pos[GMT_X]) {
gmt_map.c:					(*GMT->current.proj.fwd_x) (GMT, GMT->common.R.wesn[XLO], &xmin);
gmt_map.c:					(*GMT->current.proj.fwd_x) (GMT, GMT->common.R.wesn[XHI], &xmax);
gmt_map.c:					(*GMT->current.proj.fwd_x) (GMT, GMT->common.R.wesn[XHI], &xmin);
gmt_map.c:					(*GMT->current.proj.fwd_x) (GMT, GMT->common.R.wesn[XLO], &xmax);
gmt_map.c:				xmin = (GMT->current.proj.xyz_pos[GMT_X]) ? d_log10 (GMT, GMT->common.R.wesn[XLO]) : d_log10 (GMT, GMT->common.R.wesn[XHI]);
gmt_map.c:				xmax = (GMT->current.proj.xyz_pos[GMT_X]) ? d_log10 (GMT, GMT->common.R.wesn[XHI]) : d_log10 (GMT, GMT->common.R.wesn[XLO]);
gmt_map.c:				positive = !((GMT->current.proj.xyz_pos[GMT_X] + (GMT->current.proj.xyz_pow[GMT_X] > 0.0)) % 2);
gmt_map.c:				xmin = (positive) ? pow (GMT->common.R.wesn[XLO], GMT->current.proj.xyz_pow[GMT_X]) : pow (GMT->common.R.wesn[XHI], GMT->current.proj.xyz_pow[GMT_X]);
gmt_map.c:				xmax = (positive) ? pow (GMT->common.R.wesn[XHI], GMT->current.proj.xyz_pow[GMT_X]) : pow (GMT->common.R.wesn[XLO], GMT->current.proj.xyz_pow[GMT_X]);
gmt_map.c:		GMT->current.proj.pars[0] = GMT->current.proj.scale[GMT_X] * fabs (xmin - xmax);
gmt_map.c:	else if (GMT->current.proj.scale[GMT_Y] == 0) {	/* Must redo y-scaling by using x-scale */
gmt_map.c:		GMT->current.proj.scale[GMT_Y] = GMT->current.proj.autoscl[GMT_Y] * GMT->current.proj.scale[GMT_X];
gmt_map.c:		if (GMT->current.proj.autoscl[GMT_Y] == -1) GMT->current.proj.xyz_pos[GMT_Y] = !GMT->current.proj.xyz_pos[GMT_X];
gmt_map.c:		switch (GMT->current.proj.xyz_projection[GMT_Y]%3) {	/* Modulo 3 so that GMT_TIME (3) maps to GMT_LINEAR (0) */
gmt_map.c:				if (GMT->current.proj.xyz_pos[GMT_Y]) {
gmt_map.c:					(*GMT->current.proj.fwd_y) (GMT, GMT->common.R.wesn[YLO], &ymin);
gmt_map.c:					(*GMT->current.proj.fwd_y) (GMT, GMT->common.R.wesn[YHI], &ymax);
gmt_map.c:					(*GMT->current.proj.fwd_y) (GMT, GMT->common.R.wesn[YHI], &ymin);
gmt_map.c:					(*GMT->current.proj.fwd_y) (GMT, GMT->common.R.wesn[YLO], &ymax);
gmt_map.c:				ymin = (GMT->current.proj.xyz_pos[GMT_Y]) ? d_log10 (GMT, GMT->common.R.wesn[YLO]) : d_log10 (GMT, GMT->common.R.wesn[YHI]);
gmt_map.c:				ymax = (GMT->current.proj.xyz_pos[GMT_Y]) ? d_log10 (GMT, GMT->common.R.wesn[YHI]) : d_log10 (GMT, GMT->common.R.wesn[YLO]);
gmt_map.c:				positive = !((GMT->current.proj.xyz_pos[GMT_Y] + (GMT->current.proj.xyz_pow[GMT_Y] > 0.0)) % 2);
gmt_map.c:				ymin = (positive) ? pow (GMT->common.R.wesn[YLO], GMT->current.proj.xyz_pow[GMT_Y]) : pow (GMT->common.R.wesn[YHI], GMT->current.proj.xyz_pow[GMT_Y]);
gmt_map.c:				ymax = (positive) ? pow (GMT->common.R.wesn[YHI], GMT->current.proj.xyz_pow[GMT_Y]) : pow (GMT->common.R.wesn[YLO], GMT->current.proj.xyz_pow[GMT_Y]);
gmt_map.c:		GMT->current.proj.pars[1] = GMT->current.proj.scale[GMT_Y] * fabs (ymin - ymax);
gmt_map.c:	GMT->current.proj.M_PR_DEG = 1.0;
gmt_map.c:	GMT->current.proj.KM_PR_DEG = GMT->current.proj.M_PR_DEG / METERS_IN_A_KM;
gmt_map.c:		GMT->current.map.outside = &map_wesn_outside;
gmt_map.c:		GMT->current.map.crossing = &map_wesn_crossing;
gmt_map.c:		GMT->current.map.overlap = &map_wesn_overlap;
gmt_map.c:		GMT->current.map.clip = &map_wesn_clip;
gmt_map.c:		GMT->current.map.outside = &map_rect_outside;
gmt_map.c:		GMT->current.map.crossing = &map_rect_crossing;
gmt_map.c:		GMT->current.map.overlap = &map_cartesian_overlap;
gmt_map.c:		GMT->current.map.clip = &map_rect_clip;
gmt_map.c:	GMT->current.map.n_lat_nodes = 2;
gmt_map.c:	GMT->current.map.n_lon_nodes = 3;	/* > 2 to avoid map-jumps */
gmt_map.c:	GMT->current.map.frame.check_side = true;
gmt_map.c:	GMT->current.map.frame.horizontal = 1;
gmt_map.c:	GMT->current.map.meridian_straight = GMT->current.map.parallel_straight = 1;
gmt_map.c:	gmt_vpolar (GMT, GMT->current.proj.pars[1]);
gmt_map.c:	if (GMT->current.proj.got_elevations) {	/* Requires s >= 0 and n <= 90 */
gmt_map.c:		if (GMT->common.R.wesn[YLO] < 0.0 || GMT->common.R.wesn[YHI] > 90.0) {
gmt_map.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "-JP...r for elevation plots requires s >= 0 and n <= 90!\n");
gmt_map.c:		if (doubleAlmostEqual (GMT->common.R.wesn[YHI], 90.0))
gmt_map.c:			GMT->current.proj.edge[2] = false;
gmt_map.c:		if (gmt_M_is_zero (GMT->common.R.wesn[YLO]))
gmt_map.c:			GMT->current.proj.edge[0] = false;
gmt_map.c:	if (gmt_M_360_range (GMT->common.R.wesn[XLO], GMT->common.R.wesn[XHI])) GMT->current.proj.edge[1] = GMT->current.proj.edge[3] = false;
gmt_map.c:	GMT->current.map.left_edge = &map_left_circle;
gmt_map.c:	GMT->current.map.right_edge = &map_right_circle;
gmt_map.c:	GMT->current.proj.fwd = &gmt_polar;
gmt_map.c:	GMT->current.proj.inv = &gmt_ipolar;
gmt_map.c:	GMT->current.map.is_world = false;	/* There is no wrapping around here */
gmt_map.c:	map_xy_search (GMT, &xmin, &xmax, &ymin, &ymax, GMT->common.R.wesn[XLO], GMT->common.R.wesn[XHI], GMT->common.R.wesn[YLO], GMT->common.R.wesn[YHI]);
gmt_map.c:	GMT->current.proj.scale[GMT_X] = GMT->current.proj.scale[GMT_Y] = GMT->current.proj.pars[0];
gmt_map.c:	map_setinfo (GMT, xmin, xmax, ymin, ymax, GMT->current.proj.pars[0]);
gmt_map.c:	gmt_geo_to_xy (GMT, GMT->current.proj.central_meridian, GMT->current.proj.pole, &GMT->current.proj.c_x0, &GMT->current.proj.c_y0);
gmt_map.c:	/* GMT->current.proj.r = 0.5 * GMT->current.proj.rect[XHI]; */
gmt_map.c:	GMT->current.proj.r = GMT->current.proj.scale[GMT_Y] * GMT->common.R.wesn[YHI];
gmt_map.c:	GMT->current.map.outside = &map_polar_outside;
gmt_map.c:	GMT->current.map.crossing = &map_wesn_crossing;
gmt_map.c:	GMT->current.map.overlap = &map_wesn_overlap;
gmt_map.c:	GMT->current.map.clip = &map_wesn_clip;
gmt_map.c:	GMT->current.map.frame.horizontal = 1;
gmt_map.c:	if (!GMT->current.proj.got_elevations) GMT->current.plot.r_theta_annot = true;	/* Special labeling case (see gmtlib_get_annot_label) */
gmt_map.c:	GMT->current.map.n_lat_nodes = 2;
gmt_map.c:	GMT->current.map.meridian_straight = 1;
gmt_map.c:	GMT->current.proj.GMT_convert_latitudes = !gmt_M_is_spherical (GMT);
gmt_map.c:	if (GMT->current.proj.GMT_convert_latitudes) {	/* Set fudge factor */
gmt_map.c:		D = GMT->current.setting.ref_ellipsoid[GMT->current.setting.proj_ellipsoid].eq_radius / GMT->current.proj.lat_swap_vals.rm;
gmt_map.c:	if (GMT->common.R.wesn[YLO] <= -90.0 || GMT->common.R.wesn[YHI] >= 90.0) {
gmt_map.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -R option:  Cannot include south/north poles with Mercator projection!\n");
gmt_map.c:	GMT->current.map.is_world = gmt_M_360_range (GMT->common.R.wesn[XLO], GMT->common.R.wesn[XHI]);
gmt_map.c:	gmt_vmerc (GMT, GMT->current.proj.pars[0], GMT->current.proj.pars[1]);
gmt_map.c:	GMT->current.proj.j_x *= D;
gmt_map.c:	GMT->current.proj.j_ix /= D;
gmt_map.c:	GMT->current.proj.fwd = &gmt_merc_sph;
gmt_map.c:	GMT->current.proj.inv = &gmt_imerc_sph;
gmt_map.c:	(*GMT->current.proj.fwd) (GMT, GMT->common.R.wesn[XLO], GMT->common.R.wesn[YLO], &xmin, &ymin);
gmt_map.c:	(*GMT->current.proj.fwd) (GMT, GMT->common.R.wesn[XHI], GMT->common.R.wesn[YHI], &xmax, &ymax);
gmt_map.c:	if (GMT->current.proj.units_pr_degree) GMT->current.proj.pars[2] /= (D * GMT->current.proj.M_PR_DEG);
gmt_map.c:	GMT->current.proj.scale[GMT_X] = GMT->current.proj.scale[GMT_Y] = GMT->current.proj.pars[2];
gmt_map.c:	map_setinfo (GMT, xmin, xmax, ymin, ymax, GMT->current.proj.pars[2]);
gmt_map.c:	GMT->current.map.n_lat_nodes = 2;
gmt_map.c:	GMT->current.map.n_lon_nodes = 3;	/* > 2 to avoid map-jumps */
gmt_map.c:	GMT->current.map.outside = &map_wesn_outside;
gmt_map.c:	GMT->current.map.crossing = &map_wesn_crossing;
gmt_map.c:	GMT->current.map.overlap = &map_wesn_overlap;
gmt_map.c:	GMT->current.map.clip = &map_wesn_clip;
gmt_map.c:	GMT->current.map.left_edge = &map_left_rect;
gmt_map.c:	GMT->current.map.right_edge = &map_right_rect;
gmt_map.c:	GMT->current.map.frame.horizontal = 1;
gmt_map.c:	GMT->current.map.frame.check_side = true;
gmt_map.c:	GMT->current.map.meridian_straight = GMT->current.map.parallel_straight = 1;
gmt_map.c:	GMT->current.proj.Dx = GMT->current.proj.Dy = 0.0;
gmt_map.c:	GMT->current.proj.GMT_convert_latitudes = !gmt_M_is_spherical (GMT);
gmt_map.c:	if (GMT->current.proj.GMT_convert_latitudes) {
gmt_map.c:		slat = GMT->current.proj.pars[1];
gmt_map.c:		GMT->current.proj.pars[1] = gmt_M_latg_to_lata (GMT, GMT->current.proj.pars[1]);
gmt_map.c:		e = GMT->current.proj.ECC;
gmt_map.c:		e2 = GMT->current.proj.ECC2;
gmt_map.c:		k0 = cosd (slat) / d_sqrt (1.0 - e2 * sind (GMT->current.proj.pars[1]) * sind (GMT->current.proj.pars[1]));
gmt_map.c:		D = k0 / cosd (GMT->current.proj.pars[1]);
gmt_map.c:		GMT->current.proj.Dx = D;
gmt_map.c:		GMT->current.proj.Dy = 0.5 * qp / D;
gmt_map.c:	GMT->current.proj.iDx = 1.0 / GMT->current.proj.Dx;
gmt_map.c:	GMT->current.proj.iDy = 1.0 / GMT->current.proj.Dy;
gmt_map.c:	GMT->current.map.is_world = gmt_M_360_range (GMT->common.R.wesn[XLO], GMT->common.R.wesn[XHI]);
gmt_map.c:	gmt_vcyleq (GMT, GMT->current.proj.pars[0], GMT->current.proj.pars[1]);
gmt_map.c:	gmt_cyleq (GMT, GMT->common.R.wesn[XLO], GMT->common.R.wesn[YLO], &xmin, &ymin);
gmt_map.c:	gmt_cyleq (GMT, GMT->common.R.wesn[XHI], GMT->common.R.wesn[YHI], &xmax, &ymax);
gmt_map.c:	if (GMT->current.proj.units_pr_degree) GMT->current.proj.pars[2] /= GMT->current.proj.M_PR_DEG;
gmt_map.c:	GMT->current.proj.scale[GMT_X] = GMT->current.proj.scale[GMT_Y] = GMT->current.proj.pars[2];
gmt_map.c:	map_setinfo (GMT, xmin, xmax, ymin, ymax, GMT->current.proj.pars[2]);
gmt_map.c:	GMT->current.map.n_lat_nodes = 2;
gmt_map.c:	GMT->current.map.n_lon_nodes = 3;	/* > 2 to avoid map-jumps */
gmt_map.c:	GMT->current.proj.fwd = &gmt_cyleq;
gmt_map.c:	GMT->current.proj.inv = &gmt_icyleq;
gmt_map.c:	GMT->current.map.outside = &map_wesn_outside;
gmt_map.c:	GMT->current.map.crossing = &map_wesn_crossing;
gmt_map.c:	GMT->current.map.overlap = &map_wesn_overlap;
gmt_map.c:	GMT->current.map.clip = &map_wesn_clip;
gmt_map.c:	GMT->current.map.left_edge = &map_left_rect;
gmt_map.c:	GMT->current.map.right_edge = &map_right_rect;
gmt_map.c:	GMT->current.map.frame.horizontal = 1;
gmt_map.c:	GMT->current.map.frame.check_side = true;
gmt_map.c:	GMT->current.map.meridian_straight = GMT->current.map.parallel_straight = 1;
gmt_map.c:	GMT->current.map.is_world = gmt_M_360_range (GMT->common.R.wesn[XLO], GMT->common.R.wesn[XHI]);
gmt_map.c:	gmt_vcyleqdist (GMT, GMT->current.proj.pars[0], GMT->current.proj.pars[1]);
gmt_map.c:	gmt_cyleqdist (GMT, GMT->common.R.wesn[XLO], GMT->common.R.wesn[YLO], &xmin, &ymin);
gmt_map.c:	gmt_cyleqdist (GMT, GMT->common.R.wesn[XHI], GMT->common.R.wesn[YHI], &xmax, &ymax);
gmt_map.c:	if (GMT->current.proj.units_pr_degree) GMT->current.proj.pars[2] /= GMT->current.proj.M_PR_DEG;
gmt_map.c:	GMT->current.proj.scale[GMT_X] = GMT->current.proj.scale[GMT_Y] = GMT->current.proj.pars[2];
gmt_map.c:	map_setinfo (GMT, xmin, xmax, ymin, ymax, GMT->current.proj.pars[2]);
gmt_map.c:	GMT->current.map.n_lat_nodes = 2;
gmt_map.c:	GMT->current.map.n_lon_nodes = 3;	/* > 2 to avoid map-jumps */
gmt_map.c:	GMT->current.proj.fwd = &gmt_cyleqdist;
gmt_map.c:	GMT->current.proj.inv = &gmt_icyleqdist;
gmt_map.c:	GMT->current.map.outside = &map_wesn_outside;
gmt_map.c:	GMT->current.map.crossing = &map_wesn_crossing;
gmt_map.c:	GMT->current.map.overlap = &map_wesn_overlap;
gmt_map.c:	GMT->current.map.clip = &map_wesn_clip;
gmt_map.c:	GMT->current.map.left_edge = &map_left_rect;
gmt_map.c:	GMT->current.map.right_edge = &map_right_rect;
gmt_map.c:	GMT->current.map.frame.horizontal = 1;
gmt_map.c:	GMT->current.map.frame.check_side = true;
gmt_map.c:	GMT->current.map.meridian_straight = GMT->current.map.parallel_straight = 1;
gmt_map.c:	GMT->current.map.is_world = gmt_M_360_range (GMT->common.R.wesn[XLO], GMT->common.R.wesn[XHI]);
gmt_map.c:	gmt_vmiller (GMT, GMT->current.proj.pars[0]);
gmt_map.c:	gmt_miller (GMT, GMT->common.R.wesn[XLO], GMT->common.R.wesn[YLO], &xmin, &ymin);
gmt_map.c:	if (GMT->common.R.wesn[YLO] > 0.0) {
gmt_map.c:		gmt_miller (GMT, GMT->common.R.wesn[XLO], GMT->common.R.wesn[YLO], &xmin, &ymin);
gmt_map.c:		gmt_miller (GMT, 0.5 * (GMT->common.R.wesn[XLO] + GMT->common.R.wesn[XHI]), GMT->common.R.wesn[YHI], &xmax, &ymax);
gmt_map.c:		gmt_miller (GMT, GMT->common.R.wesn[XHI], GMT->common.R.wesn[YHI], &xmin, &ymin);
gmt_map.c:		gmt_miller (GMT, 0.5 * (GMT->common.R.wesn[XLO] + GMT->common.R.wesn[XHI]), GMT->common.R.wesn[YLO], &xmax, &ymax);
gmt_map.c:	gmt_miller (GMT, GMT->common.R.wesn[XLO], GMT->common.R.wesn[YLO], &xmin, &ymin);
gmt_map.c:	gmt_miller (GMT, GMT->common.R.wesn[XHI], GMT->common.R.wesn[YHI], &xmax, &ymax);
gmt_map.c:	if (GMT->current.proj.units_pr_degree) GMT->current.proj.pars[1] /= GMT->current.proj.M_PR_DEG;
gmt_map.c:	GMT->current.proj.scale[GMT_X] = GMT->current.proj.scale[GMT_Y] = GMT->current.proj.pars[1];
gmt_map.c:	map_setinfo (GMT, xmin, xmax, ymin, ymax, GMT->current.proj.pars[1]);
gmt_map.c:	GMT->current.map.n_lat_nodes = 2;
gmt_map.c:	GMT->current.map.n_lon_nodes = 3;	/* > 2 to avoid map-jumps */
gmt_map.c:	GMT->current.proj.fwd = &gmt_miller;
gmt_map.c:	GMT->current.proj.inv = &gmt_imiller;
gmt_map.c:	GMT->current.map.outside = &map_wesn_outside;
gmt_map.c:	GMT->current.map.crossing = &map_wesn_crossing;
gmt_map.c:	GMT->current.map.overlap = &map_wesn_overlap;
gmt_map.c:	GMT->current.map.clip = &map_wesn_clip;
gmt_map.c:	GMT->current.map.left_edge = &map_left_rect;
gmt_map.c:	GMT->current.map.right_edge = &map_right_rect;
gmt_map.c:	GMT->current.map.frame.horizontal = 1;
gmt_map.c:	GMT->current.map.frame.check_side = true;
gmt_map.c:	GMT->current.map.meridian_straight = GMT->current.map.parallel_straight = 1;
gmt_map.c:	GMT->current.map.is_world = gmt_M_360_range (GMT->common.R.wesn[XLO], GMT->common.R.wesn[XHI]);
gmt_map.c:	gmt_vcylstereo (GMT, GMT->current.proj.pars[0], GMT->current.proj.pars[1]);
gmt_map.c:	gmt_cylstereo (GMT, GMT->common.R.wesn[XLO], GMT->common.R.wesn[YLO], &xmin, &ymin);
gmt_map.c:	gmt_cylstereo (GMT, GMT->common.R.wesn[XHI], GMT->common.R.wesn[YHI], &xmax, &ymax);
gmt_map.c:	if (GMT->current.proj.units_pr_degree) GMT->current.proj.pars[2] /= GMT->current.proj.M_PR_DEG;
gmt_map.c:	GMT->current.proj.scale[GMT_X] = GMT->current.proj.scale[GMT_Y] = GMT->current.proj.pars[2];
gmt_map.c:	map_setinfo (GMT, xmin, xmax, ymin, ymax, GMT->current.proj.pars[2]);
gmt_map.c:	GMT->current.map.n_lat_nodes = 2;
gmt_map.c:	GMT->current.map.n_lon_nodes = 3;	/* > 2 to avoid map-jumps */
gmt_map.c:	GMT->current.proj.fwd = &gmt_cylstereo;
gmt_map.c:	GMT->current.proj.inv = &gmt_icylstereo;
gmt_map.c:	GMT->current.map.outside = &map_wesn_outside;
gmt_map.c:	GMT->current.map.crossing = &map_wesn_crossing;
gmt_map.c:	GMT->current.map.overlap = &map_wesn_overlap;
gmt_map.c:	GMT->current.map.clip = &map_wesn_clip;
gmt_map.c:	GMT->current.map.left_edge = &map_left_rect;
gmt_map.c:	GMT->current.map.right_edge = &map_right_rect;
gmt_map.c:	GMT->current.map.frame.horizontal = 1;
gmt_map.c:	GMT->current.map.frame.check_side = true;
gmt_map.c:	GMT->current.map.meridian_straight = GMT->current.map.parallel_straight = 1;
gmt_map.c:	GMT->current.proj.GMT_convert_latitudes = !gmt_M_is_spherical (GMT);
gmt_map.c:	latg = GMT->current.proj.pars[1];
gmt_map.c:	if (GMT->current.setting.proj_scale_factor == -1.0) GMT->current.setting.proj_scale_factor = 0.9996;	/* Select default map scale for Stereographic */
gmt_map.c:	if (GMT->current.proj.polar && (lrint (GMT->current.proj.pars[5]) == 1)) GMT->current.setting.proj_scale_factor = 1.0;	/* Gave true scale at given parallel set below */
gmt_map.c:	if (fabs (GMT->current.proj.pars[1]) < GMT_CONV4_LIMIT) GMT->current.proj.pars[1] = 0.001;
gmt_map.c:	gmt_vstereo (GMT, GMT->current.proj.pars[0], GMT->current.proj.pars[1], GMT->current.proj.pars[2]);
gmt_map.c:	if (GMT->current.proj.GMT_convert_latitudes) {	/* Set fudge factors when conformal latitudes are used */
gmt_map.c:		D = GMT->current.setting.ref_ellipsoid[GMT->current.setting.proj_ellipsoid].eq_radius / GMT->current.proj.lat_swap_vals.rm;
gmt_map.c:		if (GMT->current.proj.polar) {
gmt_map.c:			e1p = 1.0 + GMT->current.proj.ECC;	e1m = 1.0 - GMT->current.proj.ECC;
gmt_map.c:			if (lrint (GMT->current.proj.pars[5]) == 1) {	/* Gave true scale at given parallel */
gmt_map.c:				sincosd (fabs (GMT->current.proj.pars[4]), &s, &c);
gmt_map.c:				es = GMT->current.proj.ECC * s;
gmt_map.c:				m_c = c / d_sqrt (1.0 - GMT->current.proj.ECC2 * s * s);
gmt_map.c:				t_c = d_sqrt (((1.0 - s) / (1.0 + s)) * pow ((1.0 + es) / (1.0 - es), GMT->current.proj.ECC));
gmt_map.c:			D *= (c / (GMT->current.proj.cosp * d_sqrt (1.0 - GMT->current.proj.ECC2 * s * s)));
gmt_map.c:	GMT->current.proj.Dx = GMT->current.proj.Dy = D;
gmt_map.c:	GMT->current.proj.iDx = 1.0 / GMT->current.proj.Dx;
gmt_map.c:	GMT->current.proj.iDy = 1.0 / GMT->current.proj.Dy;
gmt_map.c:	if (GMT->current.proj.polar) {	/* Polar aspect */
gmt_map.c:		GMT->current.proj.fwd = &gmt_plrs_sph;
gmt_map.c:		GMT->current.proj.inv = &gmt_iplrs_sph;
gmt_map.c:		if (GMT->current.proj.units_pr_degree) {
gmt_map.c:			(*GMT->current.proj.fwd) (GMT, GMT->current.proj.pars[0], GMT->current.proj.pars[4], &dummy, &radius);
gmt_map.c:			GMT->current.proj.scale[GMT_X] = GMT->current.proj.scale[GMT_Y] = fabs (GMT->current.proj.pars[3] / radius);
gmt_map.c:			GMT->current.proj.scale[GMT_X] = GMT->current.proj.scale[GMT_Y] = GMT->current.proj.pars[3];
gmt_map.c:		GMT->current.map.meridian_straight = 1;
gmt_map.c:		GMT->current.proj.fwd = (gmt_M_is_zero (GMT->current.proj.pole)) ? &gmt_stereo2_sph : &gmt_stereo1_sph;
gmt_map.c:		GMT->current.proj.inv = &gmt_istereo_sph;
gmt_map.c:		if (GMT->current.proj.units_pr_degree) {
gmt_map.c:			gmt_vstereo (GMT, 0.0, 90.0, GMT->current.proj.pars[2]);
gmt_map.c:			(*GMT->current.proj.fwd) (GMT, 0.0, fabs (GMT->current.proj.pars[4]), &dummy, &radius);
gmt_map.c:			GMT->current.proj.scale[GMT_X] = GMT->current.proj.scale[GMT_Y] = fabs (GMT->current.proj.pars[3] / radius);
gmt_map.c:			GMT->current.proj.scale[GMT_X] = GMT->current.proj.scale[GMT_Y] = GMT->current.proj.pars[3];
gmt_map.c:		gmt_vstereo (GMT, GMT->current.proj.pars[0], GMT->current.proj.pars[1], GMT->current.proj.pars[2]);
gmt_map.c:	if (GMT->common.R.oblique) {	/* Rectangular box given */
gmt_map.c:		(*GMT->current.proj.fwd) (GMT, GMT->common.R.wesn[XLO], GMT->common.R.wesn[YLO], &xmin, &ymin);
gmt_map.c:		(*GMT->current.proj.fwd) (GMT, GMT->common.R.wesn[XHI], GMT->common.R.wesn[YHI], &xmax, &ymax);
gmt_map.c:		GMT->current.map.outside = &map_rect_outside2;
gmt_map.c:		GMT->current.map.crossing = &map_rect_crossing;
gmt_map.c:		GMT->current.map.overlap = &map_rect_overlap;
gmt_map.c:		GMT->current.map.clip = &map_rect_clip;
gmt_map.c:		GMT->current.map.left_edge = &map_left_rect;
gmt_map.c:		GMT->current.map.right_edge = &map_right_rect;
gmt_map.c:		GMT->current.map.frame.check_side = !(GMT->current.setting.map_annot_oblique & GMT_OBL_ANNOT_ANYWHERE);
gmt_map.c:		GMT->current.map.frame.horizontal = (fabs (GMT->current.proj.pars[1]) < 30.0 && fabs (GMT->common.R.wesn[YHI] - GMT->common.R.wesn[YLO]) < 30.0) ? 1 : 0;
gmt_map.c:		if (GMT->current.proj.polar) {	/* Polar aspect */
gmt_map.c:			if (GMT->current.proj.north_pole) {
gmt_map.c:				if (GMT->common.R.wesn[YLO] <= -90.0) {
gmt_map.c:					GMT_Report (GMT->parent, GMT_MSG_NORMAL, "South boundary cannot be -90.0 for north polar stereographic projection\n");
gmt_map.c:				if (GMT->common.R.wesn[YHI] >= 90.0) GMT->current.proj.edge[2] = false;
gmt_map.c:				if (GMT->common.R.wesn[YHI] >= 90.0) {
gmt_map.c:					GMT_Report (GMT->parent, GMT_MSG_NORMAL, "North boundary cannot be +90.0 for south polar stereographic projection\n");
gmt_map.c:				if (GMT->common.R.wesn[YLO] <= -90.0) GMT->current.proj.edge[0] = false;
gmt_map.c:			if (gmt_M_360_range (GMT->common.R.wesn[XLO], GMT->common.R.wesn[XHI])
gmt_map.c:					|| doubleAlmostEqualZero (GMT->common.R.wesn[XHI], GMT->common.R.wesn[XLO]))
gmt_map.c:				GMT->current.proj.edge[1] = GMT->current.proj.edge[3] = false;
gmt_map.c:			GMT->current.map.outside = &map_polar_outside;
gmt_map.c:			GMT->current.map.crossing = &map_wesn_crossing;
gmt_map.c:			GMT->current.map.overlap = &map_wesn_overlap;
gmt_map.c:			GMT->current.map.clip = &map_wesn_clip;
gmt_map.c:			GMT->current.map.frame.horizontal = 1;
gmt_map.c:			GMT->current.map.n_lat_nodes = 2;
gmt_map.c:			map_xy_search (GMT, &xmin, &xmax, &ymin, &ymax, GMT->common.R.wesn[XLO], GMT->common.R.wesn[XHI], GMT->common.R.wesn[YLO], GMT->common.R.wesn[YHI]);
gmt_map.c:				GMT->current.map.frame.axis[GMT_X].item[i].active = GMT->current.map.frame.axis[GMT_Y].item[i].active = false,
gmt_map.c:				GMT->current.map.frame.axis[GMT_X].item[i].interval = GMT->current.map.frame.axis[GMT_Y].item[i].interval = 0.0;
gmt_map.c:			GMT->common.R.wesn[XLO] = 0.0;
gmt_map.c:			GMT->common.R.wesn[XHI] = 360.0;
gmt_map.c:			GMT->common.R.wesn[YLO] = -90.0;
gmt_map.c:			GMT->common.R.wesn[YHI] = 90.0;
gmt_map.c:			xmax = ymax = GMT->current.proj.rho_max;
gmt_map.c:			GMT->current.map.outside = &map_radial_outside;
gmt_map.c:			GMT->current.map.crossing = &map_radial_crossing;
gmt_map.c:			GMT->current.map.overlap = &map_radial_overlap;
gmt_map.c:			GMT->current.map.clip = &map_radial_clip;
gmt_map.c:			if (GMT->current.setting.map_frame_type & GMT_IS_FANCY) GMT->current.setting.map_frame_type = GMT_IS_PLAIN;
gmt_map.c:		GMT->current.map.left_edge = &map_left_circle;
gmt_map.c:		GMT->current.map.right_edge = &map_right_circle;
gmt_map.c:	map_setinfo (GMT, xmin, xmax, ymin, ymax, GMT->current.proj.pars[3]);
gmt_map.c:	GMT->current.proj.r = 0.5 * GMT->current.proj.rect[XHI];
gmt_map.c:	gmt_geo_to_xy (GMT, GMT->current.proj.central_meridian, GMT->current.proj.pole, &GMT->current.proj.c_x0, &GMT->current.proj.c_y0);
gmt_map.c:	return (GMT->common.R.oblique);
gmt_map.c:	GMT->current.proj.GMT_convert_latitudes = map_quickconic (GMT);
gmt_map.c:	if (GMT->current.proj.GMT_convert_latitudes) gmtlib_scale_eqrad (GMT);
gmt_map.c:	gmt_vlamb (GMT, GMT->current.proj.pars[0], GMT->current.proj.pars[1], GMT->current.proj.pars[2], GMT->current.proj.pars[3]);
gmt_map.c:	if (GMT->current.proj.units_pr_degree) GMT->current.proj.pars[4] /= GMT->current.proj.M_PR_DEG;
gmt_map.c:	GMT->current.proj.scale[GMT_X] = GMT->current.proj.scale[GMT_Y] = GMT->current.proj.pars[4];
gmt_map.c:	if (gmt_M_is_spherical (GMT) || GMT->current.proj.GMT_convert_latitudes) {	/* Spherical code w/wo conformal latitudes */
gmt_map.c:		GMT->current.proj.fwd = &gmt_lamb_sph;
gmt_map.c:		GMT->current.proj.inv = &gmt_ilamb_sph;
gmt_map.c:		GMT->current.proj.fwd = &gmt_lamb;
gmt_map.c:		GMT->current.proj.inv = &gmt_ilamb;
gmt_map.c:	if (GMT->common.R.oblique) {	/* Rectangular box given*/
gmt_map.c:		(*GMT->current.proj.fwd) (GMT, GMT->common.R.wesn[XLO], GMT->common.R.wesn[YLO], &xmin, &ymin);
gmt_map.c:		(*GMT->current.proj.fwd) (GMT, GMT->common.R.wesn[XHI], GMT->common.R.wesn[YHI], &xmax, &ymax);
gmt_map.c:		GMT->current.map.outside = &map_rect_outside;
gmt_map.c:		GMT->current.map.crossing = &map_rect_crossing;
gmt_map.c:		GMT->current.map.overlap = &map_rect_overlap;
gmt_map.c:		GMT->current.map.clip = &map_rect_clip;
gmt_map.c:		GMT->current.map.left_edge = &map_left_rect;
gmt_map.c:		GMT->current.map.right_edge = &map_right_rect;
gmt_map.c:		GMT->current.map.frame.check_side = true;
gmt_map.c:		map_xy_search (GMT, &xmin, &xmax, &ymin, &ymax, GMT->common.R.wesn[XLO], GMT->common.R.wesn[XHI], GMT->common.R.wesn[YLO], GMT->common.R.wesn[YHI]);
gmt_map.c:		GMT->current.map.outside = &map_wesn_outside;
gmt_map.c:		GMT->current.map.crossing = &map_wesn_crossing;
gmt_map.c:		GMT->current.map.overlap = &map_wesn_overlap;
gmt_map.c:		GMT->current.map.clip = &map_wesn_clip;
gmt_map.c:		GMT->current.map.left_edge = &map_left_conic;
gmt_map.c:		GMT->current.map.right_edge = &map_right_conic;
gmt_map.c:	map_setinfo (GMT, xmin, xmax, ymin, ymax, GMT->current.proj.pars[4]);
gmt_map.c:	GMT->current.map.is_world = gmt_M_360_range (GMT->common.R.wesn[XLO], GMT->common.R.wesn[XHI]);
gmt_map.c:	GMT->current.map.n_lat_nodes = 2;
gmt_map.c:	GMT->current.map.frame.horizontal = 1;
gmt_map.c:	gmt_geo_to_xy (GMT, GMT->current.proj.central_meridian, GMT->current.proj.pole, &GMT->current.proj.c_x0, &GMT->current.proj.c_y0);
gmt_map.c:	GMT->current.map.meridian_straight = 1;
gmt_map.c:	return (GMT->common.R.oblique);
gmt_map.c:	/* Given the pole position in GMT->current.proj, geographical coordinates
gmt_map.c:	sincosd (lon - GMT->current.proj.o_pole_lon, &sin_lon, &cos_lon);
gmt_map.c:	*tlat = d_asind (GMT->current.proj.o_sin_pole_lat * sin_lat + GMT->current.proj.o_cos_pole_lat * cc);
gmt_map.c:	*tlon = GMT->current.proj.o_beta + d_atan2d (cos_lat * sin_lon, GMT->current.proj.o_sin_pole_lat * cc - GMT->current.proj.o_cos_pole_lat * sin_lat);
gmt_map.c:	/* Given the pole position in GMT->current.proj, geographical coordinates
gmt_map.c:	sincosd (tlon - GMT->current.proj.o_beta, &sin_tlon, &cos_tlon);
gmt_map.c:	*lat = d_asind (GMT->current.proj.o_sin_pole_lat * sin_tlat - GMT->current.proj.o_cos_pole_lat * cc);
gmt_map.c:	*lon = GMT->current.proj.o_pole_lon + d_atan2d (cos_tlat * sin_tlon, GMT->current.proj.o_sin_pole_lat * cc + GMT->current.proj.o_cos_pole_lat * sin_tlat);
gmt_map.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Correct projection origin = %g/%g\n", *lon2, *lat2);
gmt_map.c:	GMT->current.proj.o_beta = -beta;
gmt_map.c:	if (plat < 0.0 && GMT->hidden.func_level == 0 && !strncmp (GMT->init.module_name, "mapproject", 10U))	/* Only allowed in mapproject at top level */
gmt_map.c:		GMT->current.proj.o_spole = true;
gmt_map.c:	if (GMT->current.proj.N_hemi && plat < 0.0) {	/* Insist on a Northern hemisphere pole */
gmt_map.c:	GMT->current.proj.o_pole_lon = plon;
gmt_map.c:	GMT->current.proj.o_pole_lat = plat;
gmt_map.c:	sincosd (plat, &GMT->current.proj.o_sin_pole_lat, &GMT->current.proj.o_cos_pole_lat);
gmt_map.c:	GMT->current.proj.o_beta = -beta;
gmt_map.c:	GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Oblique Mercator pole is %.12g %.12g, with beta = %.12g\n", plon, plat, -beta);
gmt_map.c:	if (strncmp (GMT->init.module_name, "mapproject", 10U))
gmt_map.c:		GMT->current.proj.o_spole = false;	/* Only used in mapproject */
gmt_map.c:	if (GMT->current.proj.units_pr_degree) GMT->current.proj.pars[4] /= GMT->current.proj.M_PR_DEG;	/* To get plot-units / m */
gmt_map.c:	o_x = GMT->current.proj.pars[0];	o_y = GMT->current.proj.pars[1];
gmt_map.c:	if (lrint (GMT->current.proj.pars[6]) == 1) {	/* Must get correct origin, then get second point */
gmt_map.c:		p_x = GMT->current.proj.pars[2];	p_y = GMT->current.proj.pars[3];
gmt_map.c:		GMT->current.proj.o_pole_lon = p_x;
gmt_map.c:		GMT->current.proj.o_pole_lat = p_y;
gmt_map.c:		GMT->current.proj.o_sin_pole_lat = sind (p_y);
gmt_map.c:		GMT->current.proj.o_cos_pole_lat = cosd (p_y);
gmt_map.c:		GMT->current.proj.pars[0] = o_x;	GMT->current.proj.pars[1] = o_y;
gmt_map.c:		GMT->current.proj.pars[2] = b_x;	GMT->current.proj.pars[3] = b_y;
gmt_map.c:		b_x = GMT->current.proj.pars[2];	b_y = GMT->current.proj.pars[3];
gmt_map.c:	gmtlib_set_oblique_pole_and_origin (GMT, GMT->current.proj.o_pole_lon, GMT->current.proj.o_pole_lat, o_x, o_y);
gmt_map.c:	gmt_oblmrc (GMT, GMT->current.proj.lon0, GMT->current.proj.lat0, &dummy, &GMT->current.proj.o_shift);
gmt_map.c:	if (GMT->current.proj.o_spole) GMT->current.proj.o_shift = -GMT->current.proj.o_shift;
gmt_map.c:	if (GMT->common.R.oblique) {	/* wesn is lower left and upper right corners in normal lon/lats */
gmt_map.c:		gmt_oblmrc (GMT, GMT->common.R.wesn[XLO], GMT->common.R.wesn[YLO], &xmin, &ymin);
gmt_map.c:		gmt_oblmrc (GMT, GMT->common.R.wesn[XHI], GMT->common.R.wesn[YHI], &xmax, &ymax);
gmt_map.c:		if (gmt_M_360_range (GMT->common.R.wesn[XLO], GMT->common.R.wesn[XHI])) {
gmt_map.c:			GMT->common.R.wesn[XLO] = -180.0;
gmt_map.c:			GMT->common.R.wesn[XHI] = +180.0;
gmt_map.c:		gmt_merc_sph (GMT, GMT->common.R.wesn[XLO], GMT->common.R.wesn[YLO], &xmin, &ymin);
gmt_map.c:		gmt_merc_sph (GMT, GMT->common.R.wesn[XHI], GMT->common.R.wesn[YHI], &xmax, &ymax);
gmt_map.c:		GMT->common.R.oblique = true;	/* Since wesn was oblique, not geographical wesn */
gmt_map.c:	GMT->current.proj.scale[GMT_X] = GMT->current.proj.scale[GMT_Y] = GMT->current.proj.pars[4];
gmt_map.c:	map_setinfo (GMT, xmin, xmax, ymin, ymax, GMT->current.proj.pars[4]);
gmt_map.c:	GMT->current.proj.fwd = &gmt_oblmrc;
gmt_map.c:	GMT->current.proj.inv = &gmt_ioblmrc;
gmt_map.c:	GMT->current.map.outside = &map_rect_outside;
gmt_map.c:	GMT->current.map.crossing = &map_rect_crossing;
gmt_map.c:	GMT->current.map.overlap = &map_rect_overlap;
gmt_map.c:	GMT->current.map.clip = &map_rect_clip;
gmt_map.c:	GMT->current.map.left_edge = &map_left_rect;
gmt_map.c:	GMT->current.map.right_edge = &map_right_rect;
gmt_map.c:	GMT->current.map.is_world = gmt_M_360_range (w, e);
gmt_map.c:	if (GMT->current.map.is_world == false) {	/* Check if one of the poles are inside the area */
gmt_map.c:			GMT->current.map.is_world = true;
gmt_map.c:			GMT->current.map.is_world = true;
gmt_map.c:	if (GMT->current.setting.map_frame_type & GMT_IS_FANCY) GMT->current.setting.map_frame_type = GMT_IS_PLAIN;
gmt_map.c:	GMT->current.map.frame.check_side = !(GMT->current.setting.map_annot_oblique & GMT_OBL_ANNOT_ANYWHERE);
gmt_map.c:	width = 0.5 * GMT->current.map.height;
gmt_map.c:		dy = GMT->current.map.height + jump;
gmt_map.c:		xx[0] = xx[1] = last_x + (GMT->current.map.height - last_y) * dx / dy;
gmt_map.c:		if (xx[0] < 0.0 || xx[0] > GMT->current.proj.rect[XHI]) return (0);
gmt_map.c:		yy[0] = GMT->current.map.height;	yy[1] = 0.0;
gmt_map.c:		dy = GMT->current.map.height - jump;
gmt_map.c:		if (xx[0] < 0.0 || xx[0] > GMT->current.proj.rect[XHI]) return (0);
gmt_map.c:		yy[0] = 0.0;	yy[1] = GMT->current.map.height;
gmt_map.c:	return ((dy = fabs (y1 - y0)) > GMT->current.map.half_height);
gmt_map.c:	if (!GMT->current.map.is_world) return (false);
gmt_map.c:	yb -= GMT->current.map.height;
gmt_map.c:		yc[0] = GMT->current.map.height;
gmt_map.c:		yc[1] = GMT->current.map.height;
gmt_map.c:	if (dy > GMT->current.map.half_height) return (-1);	/* Cross bottom/south boundary */
gmt_map.c:	if (dy < (-GMT->current.map.half_height)) return (1);	/* Cross top/north boundary */
gmt_map.c:	GMT->current.map.wrap_around_check = &map_wrap_around_check_tm;
gmt_map.c:	GMT->current.map.jump = &map_jump_tm;
gmt_map.c:	GMT->current.map.will_it_wrap = &map_will_it_wrap_tm;
gmt_map.c:	GMT->current.map.this_point_wraps = &map_this_point_wraps_tm;
gmt_map.c:	GMT->current.map.get_crossings = &map_get_crossings_tm;
gmt_map.c:	if (GMT->current.setting.proj_scale_factor == -1.0) GMT->current.setting.proj_scale_factor = 1.0;	/* Select default map scale for TM */
gmt_map.c:	GMT->current.proj.GMT_convert_latitudes = map_quicktm (GMT, GMT->current.proj.pars[0], 10.0);
gmt_map.c:	if (GMT->current.proj.GMT_convert_latitudes) gmtlib_scale_eqrad (GMT);
gmt_map.c:	gmt_vtm (GMT, GMT->current.proj.pars[0], GMT->current.proj.pars[1]);
gmt_map.c:	if (GMT->current.proj.units_pr_degree) GMT->current.proj.pars[2] /= GMT->current.proj.M_PR_DEG;
gmt_map.c:	GMT->current.proj.scale[GMT_X] = GMT->current.proj.scale[GMT_Y] = GMT->current.proj.pars[2];
gmt_map.c:	if (gmt_M_is_spherical (GMT) || GMT->current.proj.GMT_convert_latitudes) {	/* Spherical code w/wo conformal latitudes */
gmt_map.c:		GMT->current.proj.fwd = &gmt_tm_sph;
gmt_map.c:		GMT->current.proj.inv = &gmt_itm_sph;
gmt_map.c:		GMT->current.proj.fwd = &gmt_tm;
gmt_map.c:		GMT->current.proj.inv = &gmt_itm;
gmt_map.c:	GMT->current.map.is_world = gmt_M_360_range (GMT->common.R.wesn[XLO], GMT->common.R.wesn[XHI]);
gmt_map.c:	if (GMT->current.map.is_world) {	/* Gave oblique degrees */
gmt_map.c:		w = GMT->current.proj.central_meridian + GMT->common.R.wesn[YLO];
gmt_map.c:		e = GMT->current.proj.central_meridian + GMT->common.R.wesn[YHI];
gmt_map.c:		GMT->common.R.wesn[YLO] = -90;
gmt_map.c:		GMT->common.R.wesn[YHI] = 90;
gmt_map.c:		GMT->common.R.wesn[XHI] = e;
gmt_map.c:		GMT->common.R.wesn[XLO] = w;
gmt_map.c:		gmt_vtm (GMT, GMT->current.proj.pars[0], 0.0);
gmt_map.c:		(*GMT->current.proj.fwd) (GMT, GMT->common.R.wesn[XLO], 0.0, &xmin, &dummy);
gmt_map.c:		(*GMT->current.proj.fwd) (GMT, GMT->common.R.wesn[XHI], 0.0, &xmax, &dummy);
gmt_map.c:		(*GMT->current.proj.fwd) (GMT, GMT->common.R.wesn[XLO], GMT->common.R.wesn[YLO], &dummy, &ymin);
gmt_map.c:		ymax = ymin + (TWO_PI * GMT->current.proj.EQ_RAD * GMT->current.setting.proj_scale_factor);
gmt_map.c:		gmt_vtm (GMT, GMT->current.proj.pars[0], GMT->current.proj.pars[1]);
gmt_map.c:		GMT->current.map.outside = &map_rect_outside;
gmt_map.c:		GMT->current.map.crossing = &map_rect_crossing;
gmt_map.c:		GMT->current.map.overlap = &map_rect_overlap;
gmt_map.c:		GMT->current.map.clip = &map_rect_clip;
gmt_map.c:		GMT->current.map.left_edge = &map_left_rect;
gmt_map.c:		GMT->current.map.right_edge = &map_right_rect;
gmt_map.c:		GMT->current.map.frame.check_side = true;
gmt_map.c:		GMT->current.map.is_world_tm = true;
gmt_map.c:		GMT->common.R.oblique = true;	/* Since wesn was oblique, not geographical wesn */
gmt_map.c:		GMT->common.R.wesn[XHI] = GMT->current.proj.central_meridian + 180.0;
gmt_map.c:		GMT->common.R.wesn[XLO] = GMT->current.proj.central_meridian - 180.0;
gmt_map.c:	else if (!GMT->common.R.oblique) {
gmt_map.c:		map_xy_search (GMT, &xmin, &xmax, &ymin, &ymax, GMT->common.R.wesn[XLO], GMT->common.R.wesn[XHI], GMT->common.R.wesn[YLO], GMT->common.R.wesn[YHI]);
gmt_map.c:		GMT->current.map.outside = &map_wesn_outside;
gmt_map.c:		GMT->current.map.crossing = &map_wesn_crossing;
gmt_map.c:		GMT->current.map.overlap = &map_wesn_overlap;
gmt_map.c:		GMT->current.map.clip = &map_wesn_clip;
gmt_map.c:		GMT->current.map.left_edge = &map_left_rect;
gmt_map.c:		GMT->current.map.right_edge = &map_right_rect;
gmt_map.c:		GMT->current.map.is_world_tm = doubleAlmostEqualZero (GMT->common.R.wesn[YHI], GMT->common.R.wesn[YLO]);
gmt_map.c:		GMT->current.map.is_world = false;
gmt_map.c:		(*GMT->current.proj.fwd) (GMT, GMT->common.R.wesn[XLO], GMT->common.R.wesn[YLO], &xmin, &ymin);
gmt_map.c:		(*GMT->current.proj.fwd) (GMT, GMT->common.R.wesn[XHI], GMT->common.R.wesn[YHI], &xmax, &ymax);
gmt_map.c:		GMT->current.map.outside = &map_rect_outside;
gmt_map.c:		GMT->current.map.crossing = &map_rect_crossing;
gmt_map.c:		GMT->current.map.overlap = &map_rect_overlap;
gmt_map.c:		GMT->current.map.clip = &map_rect_clip;
gmt_map.c:		GMT->current.map.left_edge = &map_left_rect;
gmt_map.c:		GMT->current.map.right_edge = &map_right_rect;
gmt_map.c:		GMT->current.map.frame.check_side = true;
gmt_map.c:		GMT->current.map.is_world_tm = false;
gmt_map.c:		GMT->current.map.is_world = (fabs (GMT->common.R.wesn[YLO] - GMT->common.R.wesn[YHI]) < GMT_CONV4_LIMIT);
gmt_map.c:	GMT->current.map.frame.horizontal = 1;
gmt_map.c:	map_setinfo (GMT, xmin, xmax, ymin, ymax, GMT->current.proj.pars[2]);
gmt_map.c:	if (GMT->current.setting.map_frame_type & GMT_IS_FANCY) GMT->current.setting.map_frame_type = GMT_IS_PLAIN;
gmt_map.c:	return (GMT->common.R.oblique);
gmt_map.c:	 * We pass back via GMT->current.proj.pars[0] the zone number.
gmt_map.c:	clon = 0.5 * (GMT->common.R.wesn[XLO] + GMT->common.R.wesn[XHI]);
gmt_map.c:	GMT->current.proj.lon0 = -180.0 + kx * 6.0 - 3.0;	/* Best centered longitude */
gmt_map.c:	if (GMT->common.R.wesn[YLO] >= 0.0)		/* By doing >= we are implicitly saying that when no info we default to northern hemisphere */
gmt_map.c:		GMT->current.proj.utm_hemisphere = +1;
gmt_map.c:		GMT->current.proj.utm_hemisphere = -1;
gmt_map.c:	GMT->current.proj.utm_zoney = 0;
gmt_map.c:	clat = 0.5 * (GMT->common.R.wesn[YLO] + GMT->common.R.wesn[YHI]);
gmt_map.c:		zone[0] = (GMT->current.proj.lon0 < 0.0) ? 'A' : 'B';
gmt_map.c:		zone[0] = (GMT->current.proj.lon0 < 0.0) ? 'Y' : 'Z';
gmt_map.c:		GMT->current.proj.utm_zoney = 'A' + (char)ky;
gmt_map.c:		if (GMT->current.proj.utm_zoney == 'X') {	/* Deal with funky zone X */
gmt_map.c:		else if (GMT->current.proj.utm_zoney == 'V') {	/* Deal with funky zone V */
gmt_map.c:		snprintf (zone, 4, "%d%c", kx, GMT->current.proj.utm_zoney);
gmt_map.c:	GMT->current.proj.pars[0] = (double)kx;
gmt_map.c:	GMT->current.proj.lat0 = 0.0;
gmt_map.c:	GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "No UTM zone given; zone %s selected\n", zone);
gmt_map.c:	if (GMT->current.setting.proj_scale_factor == -1.0) GMT->current.setting.proj_scale_factor = 0.9996;	/* Select default map scale for UTM */
gmt_map.c:	if (GMT->current.proj.pars[0] < 0.0) map_set_utmzone (GMT);	/* Determine UTM zone from -R */
gmt_map.c:	lon0 = 180.0 + 6.0 * GMT->current.proj.pars[0] - 3.0;	/* Central meridian for this UTM zone */
gmt_map.c:	GMT->current.proj.GMT_convert_latitudes = map_quicktm (GMT, lon0, 10.0);
gmt_map.c:	if (GMT->current.proj.GMT_convert_latitudes) gmtlib_scale_eqrad (GMT);
gmt_map.c:	if (GMT->current.proj.units_pr_degree) GMT->current.proj.pars[1] /= GMT->current.proj.M_PR_DEG;
gmt_map.c:	GMT->current.proj.scale[GMT_X] = GMT->current.proj.scale[GMT_Y] = GMT->current.proj.pars[1];
gmt_map.c:	switch (GMT->current.proj.utm_hemisphere) {	/* Set hemisphere */
gmt_map.c:			GMT->current.proj.north_pole = false;
gmt_map.c:			GMT->current.proj.north_pole = true;
gmt_map.c:			GMT->current.proj.north_pole = (GMT->common.R.wesn[YLO] >= 0.0);
gmt_map.c:	if (gmt_M_is_spherical (GMT) || GMT->current.proj.GMT_convert_latitudes) {	/* Spherical code w/wo conformal latitudes */
gmt_map.c:		GMT->current.proj.fwd = &gmt_utm_sph;
gmt_map.c:		GMT->current.proj.inv = &gmt_iutm_sph;
gmt_map.c:		GMT->current.proj.fwd = &gmt_utm;
gmt_map.c:		GMT->current.proj.inv = &gmt_iutm;
gmt_map.c:	if (fabs (GMT->common.R.wesn[XLO] - GMT->common.R.wesn[XHI]) > 360.0) {	/* -R in UTM meters */
gmt_map.c:		(*GMT->current.proj.inv) (GMT, &GMT->common.R.wesn[XLO], &GMT->common.R.wesn[YLO], GMT->common.R.wesn[XLO], GMT->common.R.wesn[YLO]);
gmt_map.c:		(*GMT->current.proj.inv) (GMT, &GMT->common.R.wesn[XHI], &GMT->common.R.wesn[YHI], GMT->common.R.wesn[XHI], GMT->common.R.wesn[YHI]);
gmt_map.c:		GMT->common.R.oblique = true;
gmt_map.c:	if (GMT->common.R.oblique) {
gmt_map.c:		(*GMT->current.proj.fwd) (GMT, GMT->common.R.wesn[XLO], GMT->common.R.wesn[YLO], &xmin, &ymin);
gmt_map.c:		(*GMT->current.proj.fwd) (GMT, GMT->common.R.wesn[XHI], GMT->common.R.wesn[YHI], &xmax, &ymax);
gmt_map.c:		GMT->current.map.outside = &map_rect_outside;
gmt_map.c:		GMT->current.map.crossing = &map_rect_crossing;
gmt_map.c:		GMT->current.map.overlap = &map_rect_overlap;
gmt_map.c:		GMT->current.map.clip = &map_rect_clip;
gmt_map.c:		GMT->current.map.left_edge = &map_left_rect;
gmt_map.c:		GMT->current.map.right_edge = &map_right_rect;
gmt_map.c:		GMT->current.map.frame.check_side = true;
gmt_map.c:		map_xy_search (GMT, &xmin, &xmax, &ymin, &ymax, GMT->common.R.wesn[XLO], GMT->common.R.wesn[XHI], GMT->common.R.wesn[YLO], GMT->common.R.wesn[YHI]);
gmt_map.c:		GMT->current.map.outside = &map_wesn_outside;
gmt_map.c:		GMT->current.map.crossing = &map_wesn_crossing;
gmt_map.c:		GMT->current.map.overlap = &map_wesn_overlap;
gmt_map.c:		GMT->current.map.clip = &map_wesn_clip;
gmt_map.c:		GMT->current.map.left_edge = &map_left_rect;
gmt_map.c:		GMT->current.map.right_edge = &map_right_rect;
gmt_map.c:	GMT->current.map.frame.horizontal = 1;
gmt_map.c:	map_setinfo (GMT, xmin, xmax, ymin, ymax, GMT->current.proj.pars[1]);
gmt_map.c:	if (GMT->current.setting.map_frame_type & GMT_IS_FANCY) GMT->current.setting.map_frame_type = GMT_IS_PLAIN;
gmt_map.c:	return (GMT->common.R.oblique);
gmt_map.c:	if ((zone_y < 'A' || zone_y > 'Z') || zone_y < 'I' || zone_y < 'O') return (GMT->session.d_NaN);	/* Bad latitude zone so return NaN*/
gmt_map.c:		if (zone_x == 32 || zone_x == 34 || zone_x == 36) return (GMT->session.d_NaN);	/* Bad latitude zone so return NaN*/
gmt_map.c:	GMT->current.proj.Dx = GMT->current.proj.Dy = 1.0;
gmt_map.c:	GMT->current.proj.GMT_convert_latitudes = !gmt_M_is_spherical (GMT);
gmt_map.c:	if (GMT->current.proj.GMT_convert_latitudes) gmtlib_scale_eqrad (GMT);
gmt_map.c:	gmt_vlambeq (GMT, GMT->current.proj.pars[0], GMT->current.proj.pars[1], GMT->current.proj.pars[2]);
gmt_map.c:	if (GMT->current.proj.GMT_convert_latitudes) {
gmt_map.c:		sincosd (GMT->current.proj.pars[1], &s, &c);
gmt_map.c:		D = (GMT->current.proj.polar) ? 1.0 : (GMT->current.setting.ref_ellipsoid[GMT->current.setting.proj_ellipsoid].eq_radius / GMT->current.proj.lat_swap_vals.ra) * c / (GMT->current.proj.cosp * d_sqrt (1.0 - GMT->current.proj.ECC2 * s * s));
gmt_map.c:		GMT->current.proj.Dx = D;
gmt_map.c:		GMT->current.proj.Dy = 1.0 / D;
gmt_map.c:	GMT->current.proj.iDx = 1.0 / GMT->current.proj.Dx;
gmt_map.c:	GMT->current.proj.iDy = 1.0 / GMT->current.proj.Dy;
gmt_map.c:	GMT->current.proj.fwd = &gmt_lambeq;
gmt_map.c:	GMT->current.proj.inv = &gmt_ilambeq;
gmt_map.c:	if (GMT->current.proj.units_pr_degree) {
gmt_map.c:		gmt_vlambeq (GMT, 0.0, 90.0, GMT->current.proj.pars[2]);
gmt_map.c:		gmt_lambeq (GMT, 0.0, fabs (GMT->current.proj.pars[4]), &dummy, &radius);
gmt_map.c:		GMT->current.proj.scale[GMT_X] = GMT->current.proj.scale[GMT_Y] = fabs (GMT->current.proj.pars[3] / radius);
gmt_map.c:		gmt_vlambeq (GMT, GMT->current.proj.pars[0], GMT->current.proj.pars[1], GMT->current.proj.pars[2]);
gmt_map.c:		GMT->current.proj.scale[GMT_X] = GMT->current.proj.scale[GMT_Y] = GMT->current.proj.pars[3];
gmt_map.c:	if (GMT->common.R.oblique) {	/* Rectangular box given */
gmt_map.c:		(*GMT->current.proj.fwd) (GMT, GMT->common.R.wesn[XLO], GMT->common.R.wesn[YLO], &xmin, &ymin);
gmt_map.c:		(*GMT->current.proj.fwd) (GMT, GMT->common.R.wesn[XHI], GMT->common.R.wesn[YHI], &xmax, &ymax);
gmt_map.c:		GMT->current.map.outside = &map_rect_outside2;
gmt_map.c:		GMT->current.map.crossing = &map_rect_crossing;
gmt_map.c:		GMT->current.map.overlap = &map_rect_overlap;
gmt_map.c:		GMT->current.map.clip = &map_rect_clip;
gmt_map.c:		GMT->current.map.left_edge = &map_left_rect;
gmt_map.c:		GMT->current.map.right_edge = &map_right_rect;
gmt_map.c:		GMT->current.map.frame.check_side = !(GMT->current.setting.map_annot_oblique & GMT_OBL_ANNOT_ANYWHERE);
gmt_map.c:		GMT->current.map.frame.horizontal = (fabs (GMT->current.proj.pars[1]) < 30.0 && fabs (GMT->common.R.wesn[YHI] - GMT->common.R.wesn[YLO]) < 30.0) ? 1 : 0;
gmt_map.c:		if (GMT->current.proj.polar) {	/* Polar aspect */
gmt_map.c:			if (GMT->current.proj.north_pole) {
gmt_map.c:				if (GMT->common.R.wesn[YLO] <= -90.0){
gmt_map.c:					GMT_Report (GMT->parent, GMT_MSG_NORMAL, "South boundary cannot be -90.0 for north polar Lambert azimuthal projection\n");
gmt_map.c:				if (GMT->common.R.wesn[YHI] >= 90.0) GMT->current.proj.edge[2] = false;
gmt_map.c:				if (GMT->common.R.wesn[YHI] >= 90.0) {
gmt_map.c:					GMT_Report (GMT->parent, GMT_MSG_NORMAL, "North boundary cannot be +90.0 for south polar Lambert azimuthal projection\n");
gmt_map.c:				if (GMT->common.R.wesn[YLO] <= -90.0) GMT->current.proj.edge[0] = false;
gmt_map.c:			if (gmt_M_360_range (GMT->common.R.wesn[XLO], GMT->common.R.wesn[XHI])
gmt_map.c:					|| doubleAlmostEqualZero (GMT->common.R.wesn[XHI], GMT->common.R.wesn[XLO]))
gmt_map.c:				GMT->current.proj.edge[1] = GMT->current.proj.edge[3] = false;
gmt_map.c:			GMT->current.map.outside = &map_polar_outside;
gmt_map.c:			GMT->current.map.crossing = &map_wesn_crossing;
gmt_map.c:			GMT->current.map.overlap = &map_wesn_overlap;
gmt_map.c:			GMT->current.map.clip = &map_wesn_clip;
gmt_map.c:			GMT->current.map.frame.horizontal = 1;
gmt_map.c:			GMT->current.map.n_lat_nodes = 2;
gmt_map.c:			map_xy_search (GMT, &xmin, &xmax, &ymin, &ymax, GMT->common.R.wesn[XLO], GMT->common.R.wesn[XHI], GMT->common.R.wesn[YLO], GMT->common.R.wesn[YHI]);
gmt_map.c:				GMT->current.map.frame.axis[GMT_X].item[i].active = GMT->current.map.frame.axis[GMT_Y].item[i].active = false,
gmt_map.c:				GMT->current.map.frame.axis[GMT_X].item[i].interval = GMT->current.map.frame.axis[GMT_Y].item[i].interval = 0.0;
gmt_map.c:			GMT->common.R.wesn[XLO] = 0.0;
gmt_map.c:			GMT->common.R.wesn[XHI] = 360.0;
gmt_map.c:			GMT->common.R.wesn[YLO] = -90.0;
gmt_map.c:			GMT->common.R.wesn[YHI] = 90.0;
gmt_map.c:			xmax = ymax = GMT->current.proj.rho_max;
gmt_map.c:			GMT->current.map.outside = &map_radial_outside;
gmt_map.c:			GMT->current.map.crossing = &map_radial_crossing;
gmt_map.c:			GMT->current.map.overlap = &map_radial_overlap;
gmt_map.c:			GMT->current.map.clip = &map_radial_clip;
gmt_map.c:			if (GMT->current.setting.map_frame_type & GMT_IS_FANCY) GMT->current.setting.map_frame_type = GMT_IS_PLAIN;
gmt_map.c:		GMT->current.map.left_edge = &map_left_circle;
gmt_map.c:		GMT->current.map.right_edge = &map_right_circle;
gmt_map.c:	map_setinfo (GMT, xmin, xmax, ymin, ymax, GMT->current.proj.pars[3]);
gmt_map.c:	GMT->current.proj.r = 0.5 * GMT->current.proj.rect[XHI];
gmt_map.c:	gmt_geo_to_xy (GMT, GMT->current.proj.central_meridian, GMT->current.proj.pole, &GMT->current.proj.c_x0, &GMT->current.proj.c_y0);
gmt_map.c:	if (GMT->current.proj.polar) GMT->current.map.meridian_straight = 1;
gmt_map.c:	return (GMT->common.R.oblique);
gmt_map.c:	if (GMT->current.proj.units_pr_degree) {
gmt_map.c:		gmt_vortho (GMT, 0.0, 90.0, GMT->current.proj.pars[2]);
gmt_map.c:		gmt_ortho (GMT, 0.0, fabs (GMT->current.proj.pars[4]), &dummy, &radius);
gmt_map.c:		GMT->current.proj.scale[GMT_X] = GMT->current.proj.scale[GMT_Y] = fabs (GMT->current.proj.pars[3] / radius);
gmt_map.c:		GMT->current.proj.scale[GMT_X] = GMT->current.proj.scale[GMT_Y] = GMT->current.proj.pars[3];
gmt_map.c:	gmt_vortho (GMT, GMT->current.proj.pars[0], GMT->current.proj.pars[1], GMT->current.proj.pars[2]);
gmt_map.c:	GMT->current.proj.fwd = &gmt_ortho;
gmt_map.c:	GMT->current.proj.inv = &gmt_iortho;
gmt_map.c:	if (GMT->common.R.oblique) {	/* Rectangular box given */
gmt_map.c:		(*GMT->current.proj.fwd) (GMT, GMT->common.R.wesn[XLO], GMT->common.R.wesn[YLO], &xmin, &ymin);
gmt_map.c:		(*GMT->current.proj.fwd) (GMT, GMT->common.R.wesn[XHI], GMT->common.R.wesn[YHI], &xmax, &ymax);
gmt_map.c:		GMT->current.map.outside = &map_rect_outside2;
gmt_map.c:		GMT->current.map.crossing = &map_rect_crossing;
gmt_map.c:		GMT->current.map.overlap = &map_rect_overlap;
gmt_map.c:		GMT->current.map.clip = &map_rect_clip;
gmt_map.c:		GMT->current.map.left_edge = &map_left_rect;
gmt_map.c:		GMT->current.map.right_edge = &map_right_rect;
gmt_map.c:		GMT->current.map.frame.check_side = !(GMT->current.setting.map_annot_oblique & GMT_OBL_ANNOT_ANYWHERE);
gmt_map.c:		GMT->current.map.frame.horizontal = (fabs (GMT->current.proj.pars[1]) < 30.0 && fabs (GMT->common.R.wesn[YHI] - GMT->common.R.wesn[YLO]) < 30.0) ? 1 : 0;
gmt_map.c:		if (GMT->current.proj.polar) {	/* Polar aspect */
gmt_map.c:			if (GMT->current.proj.north_pole) {
gmt_map.c:				if (GMT->common.R.wesn[YLO] < 0.0) {
gmt_map.c:					GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "South boundary cannot be < 0 for north polar orthographic projection (reset to 0)\n");
gmt_map.c:					GMT->common.R.wesn[YLO] = 0.0;
gmt_map.c:				if (GMT->common.R.wesn[YHI] >= 90.0) GMT->current.proj.edge[2] = false;
gmt_map.c:				if (GMT->common.R.wesn[YHI] > 0.0) {
gmt_map.c:					GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "North boundary cannot be > 0 for south polar orthographic projection (reset to 0)\n");
gmt_map.c:					GMT->common.R.wesn[YHI] = 0.0;
gmt_map.c:				if (GMT->common.R.wesn[YLO] <= -90.0) GMT->current.proj.edge[0] = false;
gmt_map.c:			if (gmt_M_360_range (GMT->common.R.wesn[XLO], GMT->common.R.wesn[XHI])
gmt_map.c:					|| doubleAlmostEqualZero (GMT->common.R.wesn[XHI], GMT->common.R.wesn[XLO]))
gmt_map.c:				GMT->current.proj.edge[1] = GMT->current.proj.edge[3] = false;
gmt_map.c:			GMT->current.map.outside = &map_polar_outside;
gmt_map.c:			GMT->current.map.crossing = &map_wesn_crossing;
gmt_map.c:			GMT->current.map.overlap = &map_wesn_overlap;
gmt_map.c:			GMT->current.map.clip = &map_wesn_clip;
gmt_map.c:			GMT->current.map.frame.horizontal = 1;
gmt_map.c:			GMT->current.map.n_lat_nodes = 2;
gmt_map.c:			map_xy_search (GMT, &xmin, &xmax, &ymin, &ymax, GMT->common.R.wesn[XLO], GMT->common.R.wesn[XHI], GMT->common.R.wesn[YLO], GMT->common.R.wesn[YHI]);
gmt_map.c:				GMT->current.map.frame.axis[GMT_X].item[i].active = GMT->current.map.frame.axis[GMT_Y].item[i].active = false,
gmt_map.c:				GMT->current.map.frame.axis[GMT_X].item[i].interval = GMT->current.map.frame.axis[GMT_Y].item[i].interval = 0.0;
gmt_map.c:			GMT->common.R.wesn[XLO] = 0.0;
gmt_map.c:			GMT->common.R.wesn[XHI] = 360.0;
gmt_map.c:			GMT->common.R.wesn[YLO] = -90.0;
gmt_map.c:			GMT->common.R.wesn[YHI] = 90.0;
gmt_map.c:			xmax = ymax = GMT->current.proj.rho_max * GMT->current.proj.EQ_RAD;
gmt_map.c:			GMT->current.map.outside = &map_radial_outside;
gmt_map.c:			GMT->current.map.crossing = &map_radial_crossing;
gmt_map.c:			GMT->current.map.overlap = &map_radial_overlap;
gmt_map.c:			GMT->current.map.clip = &map_radial_clip;
gmt_map.c:			if (GMT->current.setting.map_frame_type & GMT_IS_FANCY) GMT->current.setting.map_frame_type = GMT_IS_PLAIN;
gmt_map.c:		GMT->current.map.left_edge = &map_left_circle;
gmt_map.c:		GMT->current.map.right_edge = &map_right_circle;
gmt_map.c:	map_setinfo (GMT, xmin, xmax, ymin, ymax, GMT->current.proj.pars[3]);
gmt_map.c:	GMT->current.proj.r = 0.5 * GMT->current.proj.rect[XHI];
gmt_map.c:	gmt_geo_to_xy (GMT, GMT->current.proj.central_meridian, GMT->current.proj.pole, &GMT->current.proj.c_x0, &GMT->current.proj.c_y0);
gmt_map.c:	if (GMT->current.proj.polar) GMT->current.map.meridian_straight = 1;
gmt_map.c:	return (GMT->common.R.oblique);
gmt_map.c:	return (MIN (GMT->current.map.width, map_right_circle (GMT, y)));
gmt_map.c:	units = GMT->current.proj.pars[2];
gmt_map.c:	scale = GMT->current.proj.pars[3];
gmt_map.c:	alt = GMT->current.proj.pars[4];
gmt_map.c:	azimuth = GMT->current.proj.pars[5];
gmt_map.c:	tilt = GMT->current.proj.pars[6];
gmt_map.c:	twist = GMT->current.proj.pars[7];
gmt_map.c:	width = GMT->current.proj.pars[8];
gmt_map.c:	height = GMT->current.proj.pars[9];
gmt_map.c:	if (GMT->current.proj.g_sphere) map_set_spherical (GMT, true); /* PW: Force spherical for now */
gmt_map.c:	if (GMT->current.proj.units_pr_degree) {
gmt_map.c:		gmt_genper (GMT, 0.0, fabs (GMT->current.proj.pars[3]), &dummy, &radius);
gmt_map.c:		GMT->current.proj.scale[GMT_X] = GMT->current.proj.scale[GMT_Y] = fabs (GMT->current.proj.pars[2] / radius);
gmt_map.c:		GMT->current.proj.scale[GMT_X] = GMT->current.proj.scale[GMT_Y] = GMT->current.proj.pars[2];
gmt_map.c:	if (GMT->current.proj.g_debug > 1) {
gmt_map.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "genper: units_pr_degree %d\n", GMT->current.proj.units_pr_degree);
gmt_map.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "genper: radius %f\n", radius);
gmt_map.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "genper: scale %f units %f\n", scale, units);
gmt_map.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "genper: x scale %f y scale %f\n", GMT->current.proj.scale[GMT_X], GMT->current.proj.scale[GMT_Y]);
gmt_map.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "genper: gave_map_width %d \n",GMT->current.proj.gave_map_width);
gmt_map.c:	gmt_vgenper (GMT, GMT->current.proj.pars[0], GMT->current.proj.pars[1], alt, azimuth, tilt, twist, width, height);
gmt_map.c:	GMT->current.proj.fwd = &gmt_genper;
gmt_map.c:	GMT->current.proj.inv = &gmt_igenper;
gmt_map.c:	GMT->common.R.wesn[XLO] = 0.0;
gmt_map.c:	GMT->common.R.wesn[XHI] = 360.0;
gmt_map.c:	GMT->common.R.wesn[YLO] = -90.0;
gmt_map.c:	GMT->common.R.wesn[YHI] = 90.0;
gmt_map.c:	xmin = GMT->current.proj.g_xmin;
gmt_map.c:	xmax = GMT->current.proj.g_xmax;
gmt_map.c:	ymin = GMT->current.proj.g_ymin;
gmt_map.c:	ymax = GMT->current.proj.g_ymax;
gmt_map.c:	if (GMT->current.proj.g_width != 0.0) {
gmt_map.c:		GMT->common.R.oblique = false;
gmt_map.c:		GMT->current.proj.windowed = true;
gmt_map.c:		if (GMT->current.proj.g_debug > 0) GMT_Report (GMT->parent, GMT_MSG_DEBUG, "using windowed region\n");
gmt_map.c:		GMT->current.map.outside = &map_rect_outside2;
gmt_map.c:		GMT->current.map.crossing = &map_rect_crossing;
gmt_map.c:		GMT->current.map.overlap = &map_rect_overlap;
gmt_map.c:		GMT->current.map.crossing = &map_genper_crossing;
gmt_map.c:		GMT->current.map.overlap = &map_genperw_overlap;
gmt_map.c:		GMT->current.map.left_edge = &map_left_rect;
gmt_map.c:		GMT->current.map.right_edge = &map_right_rect;
gmt_map.c:		GMT->current.map.clip = &map_rect_clip_old;
gmt_map.c:		GMT->current.map.left_edge = &gmt_left_genper;
gmt_map.c:		GMT->current.map.right_edge = &gmt_right_genper;
gmt_map.c:		GMT->current.map.frame.check_side = !(GMT->current.setting.map_annot_oblique & GMT_OBL_ANNOT_ANYWHERE);
gmt_map.c:		GMT->current.map.frame.horizontal = (fabs (GMT->current.proj.pars[1]) < 30.0 && fabs (GMT->common.R.wesn[YHI] - GMT->common.R.wesn[YLO]) < 30.0) ? 1 : 0;
gmt_map.c:		GMT->current.map.jump = &map_jump_not;
gmt_map.c:		if (GMT->current.proj.g_debug > 0) GMT_Report (GMT->parent, GMT_MSG_DEBUG, "using global view\n");
gmt_map.c:			GMT->current.map.frame.axis[GMT_X].item[i].active = GMT->current.map.frame.axis[GMT_Y].item[i].active = false,
gmt_map.c:			GMT->current.map.frame.axis[GMT_X].item[i].interval = GMT->current.map.frame.axis[GMT_Y].item[i].interval = 0.0;
gmt_map.c:		GMT->current.map.overlap = &map_genperg_overlap;
gmt_map.c:		GMT->current.map.crossing = &map_radial_crossing;
gmt_map.c:		GMT->current.map.clip = &map_radial_clip;
gmt_map.c:		GMT->current.map.outside = &map_radial_outside;
gmt_map.c:		GMT->current.map.left_edge = &map_left_circle;
gmt_map.c:		GMT->current.map.right_edge = &map_right_circle;
gmt_map.c:		if (GMT->current.setting.map_frame_type & GMT_IS_FANCY) GMT->current.setting.map_frame_type = GMT_IS_PLAIN;
gmt_map.c:	if (GMT->current.proj.polar) {
gmt_map.c:		if (GMT->current.proj.north_pole) {
gmt_map.c:			if (GMT->common.R.wesn[YLO] < (90.0 - GMT->current.proj.f_horizon)) GMT->common.R.wesn[YLO] = 90.0 - GMT->current.proj.f_horizon;
gmt_map.c:			if (GMT->common.R.wesn[YHI] >= 90.0) GMT->current.proj.edge[2] = false;
gmt_map.c:			if (GMT->common.R.wesn[YHI] > -(90.0 - GMT->current.proj.f_horizon)) GMT->common.R.wesn[YHI] = -(90.0 - GMT->current.proj.f_horizon);
gmt_map.c:			if (GMT->common.R.wesn[YLO] <= -90.0) GMT->current.proj.edge[0] = false;
gmt_map.c:		if (gmt_M_360_range (GMT->common.R.wesn[XLO], GMT->common.R.wesn[XHI])
gmt_map.c:				|| doubleAlmostEqualZero (GMT->common.R.wesn[XHI], GMT->common.R.wesn[XLO]))
gmt_map.c:			GMT->current.proj.edge[1] = GMT->current.proj.edge[3] = false;
gmt_map.c:	if (GMT->current.proj.g_debug > 0) GMT_Report (GMT->parent, GMT_MSG_DEBUG, "xmin %f xmax %f ymin %f ymax %f\n", xmin/1000, xmax/1000, ymin/1000, ymax/1000);
gmt_map.c:	map_setinfo (GMT, xmin, xmax, ymin, ymax, GMT->current.proj.pars[2]);
gmt_map.c:	GMT->current.proj.r = 0.5 * GMT->current.proj.rect[XHI];
gmt_map.c:	gmt_geo_to_xy (GMT, GMT->current.proj.central_meridian, GMT->current.proj.pole, &GMT->current.proj.c_x0, &GMT->current.proj.c_y0);
gmt_map.c:	if (GMT->current.proj.g_debug > 0) {
gmt_map.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "x scale %e y scale %e\n", GMT->current.proj.scale[GMT_X], GMT->current.proj.scale[GMT_Y]);
gmt_map.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "x center %f y center %f\n", GMT->current.proj.c_x0, GMT->current.proj.c_y0);
gmt_map.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "x max %f y max %f\n", GMT->current.proj.rect[XHI], GMT->current.proj.rect[YHI]);
gmt_map.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "x0 %f y0 %f\n\n", GMT->current.proj.origin[GMT_X], GMT->current.proj.origin[GMT_Y]);
gmt_map.c:	if (GMT->current.proj.units_pr_degree) {
gmt_map.c:		gmt_gnomonic (GMT, 0.0, fabs (GMT->current.proj.pars[4]), &dummy, &radius);
gmt_map.c:		GMT->current.proj.scale[GMT_X] = GMT->current.proj.scale[GMT_Y] = fabs (GMT->current.proj.pars[3] / radius);
gmt_map.c:		GMT->current.proj.scale[GMT_X] = GMT->current.proj.scale[GMT_Y] = GMT->current.proj.pars[3];
gmt_map.c:	gmt_vgnomonic (GMT, GMT->current.proj.pars[0], GMT->current.proj.pars[1], GMT->current.proj.pars[2]);
gmt_map.c:	GMT->current.proj.fwd = &gmt_gnomonic;
gmt_map.c:	GMT->current.proj.inv = &gmt_ignomonic;
gmt_map.c:	if (GMT->common.R.oblique) {	/* Rectangular box given */
gmt_map.c:		(*GMT->current.proj.fwd) (GMT, GMT->common.R.wesn[XLO], GMT->common.R.wesn[YLO], &xmin, &ymin);
gmt_map.c:		(*GMT->current.proj.fwd) (GMT, GMT->common.R.wesn[XHI], GMT->common.R.wesn[YHI], &xmax, &ymax);
gmt_map.c:		GMT->current.map.outside = &map_rect_outside2;
gmt_map.c:		GMT->current.map.crossing = &map_rect_crossing;
gmt_map.c:		GMT->current.map.overlap = &map_rect_overlap;
gmt_map.c:		GMT->current.map.clip = &map_rect_clip;
gmt_map.c:		GMT->current.map.left_edge = &map_left_rect;
gmt_map.c:		GMT->current.map.right_edge = &map_right_rect;
gmt_map.c:		GMT->current.map.frame.check_side = !(GMT->current.setting.map_annot_oblique & GMT_OBL_ANNOT_ANYWHERE);
gmt_map.c:		GMT->current.map.frame.horizontal = (fabs (GMT->current.proj.pars[1]) < 30.0 && fabs (GMT->common.R.wesn[YHI] - GMT->common.R.wesn[YLO]) < 30.0) ? 1 : 0;
gmt_map.c:		if (GMT->current.proj.polar) {	/* Polar aspect */
gmt_map.c:			if (GMT->current.proj.north_pole) {
gmt_map.c:				if (GMT->common.R.wesn[YLO] < (90.0 - GMT->current.proj.f_horizon)) GMT->common.R.wesn[YLO] = 90.0 - GMT->current.proj.f_horizon;
gmt_map.c:				if (GMT->common.R.wesn[YHI] >= 90.0) GMT->current.proj.edge[2] = false;
gmt_map.c:				if (GMT->common.R.wesn[YHI] > -(90.0 - GMT->current.proj.f_horizon)) GMT->common.R.wesn[YHI] = -(90.0 - GMT->current.proj.f_horizon);
gmt_map.c:				if (GMT->common.R.wesn[YLO] <= -90.0) GMT->current.proj.edge[0] = false;
gmt_map.c:			if (gmt_M_360_range (GMT->common.R.wesn[XLO], GMT->common.R.wesn[XHI])
gmt_map.c:					|| doubleAlmostEqualZero (GMT->common.R.wesn[XHI], GMT->common.R.wesn[XLO]))
gmt_map.c:				GMT->current.proj.edge[1] = GMT->current.proj.edge[3] = false;
gmt_map.c:			GMT->current.map.outside = &map_polar_outside;
gmt_map.c:			GMT->current.map.crossing = &map_wesn_crossing;
gmt_map.c:			GMT->current.map.overlap = &map_wesn_overlap;
gmt_map.c:			GMT->current.map.clip = &map_wesn_clip;
gmt_map.c:			GMT->current.map.frame.horizontal = 1;
gmt_map.c:			GMT->current.map.n_lat_nodes = 2;
gmt_map.c:			map_xy_search (GMT, &xmin, &xmax, &ymin, &ymax, GMT->common.R.wesn[XLO], GMT->common.R.wesn[XHI], GMT->common.R.wesn[YLO], GMT->common.R.wesn[YHI]);
gmt_map.c:			GMT->common.R.wesn[XLO] = 0.0;
gmt_map.c:			GMT->common.R.wesn[XHI] = 360.0;
gmt_map.c:			GMT->common.R.wesn[YLO] = -90.0;
gmt_map.c:			GMT->common.R.wesn[YHI] = 90.0;
gmt_map.c:			xmax = ymax = GMT->current.proj.rho_max * GMT->current.proj.EQ_RAD;
gmt_map.c:			GMT->current.map.outside = &map_radial_outside;
gmt_map.c:			GMT->current.map.crossing = &map_radial_crossing;
gmt_map.c:			GMT->current.map.overlap = &map_radial_overlap;
gmt_map.c:			GMT->current.map.clip = &map_radial_clip;
gmt_map.c:			if (GMT->current.setting.map_frame_type & GMT_IS_FANCY) GMT->current.setting.map_frame_type = GMT_IS_PLAIN;
gmt_map.c:		GMT->current.map.left_edge = &map_left_circle;
gmt_map.c:		GMT->current.map.right_edge = &map_right_circle;
gmt_map.c:	map_setinfo (GMT, xmin, xmax, ymin, ymax, GMT->current.proj.pars[3]);
gmt_map.c:	GMT->current.proj.r = 0.5 * GMT->current.proj.rect[XHI];
gmt_map.c:	gmt_geo_to_xy (GMT, GMT->current.proj.central_meridian, GMT->current.proj.pole, &GMT->current.proj.c_x0, &GMT->current.proj.c_y0);
gmt_map.c:	return (GMT->common.R.oblique);
gmt_map.c:	if (GMT->current.proj.units_pr_degree) {
gmt_map.c:		gmt_vazeqdist (GMT, 0.0, 90.0, GMT->current.proj.pars[2]);
gmt_map.c:		gmt_azeqdist (GMT, 0.0, fabs (GMT->current.proj.pars[4]), &dummy, &radius);
gmt_map.c:		if (gmt_M_is_zero (radius)) radius = GMT->current.proj.rho_max * GMT->current.proj.EQ_RAD;
gmt_map.c:		GMT->current.proj.scale[GMT_X] = GMT->current.proj.scale[GMT_Y] = fabs (GMT->current.proj.pars[3] / radius);
gmt_map.c:		GMT->current.proj.scale[GMT_X] = GMT->current.proj.scale[GMT_Y] = GMT->current.proj.pars[3];
gmt_map.c:	gmt_vazeqdist (GMT, GMT->current.proj.pars[0], GMT->current.proj.pars[1], GMT->current.proj.pars[2]);
gmt_map.c:	GMT->current.proj.fwd = &gmt_azeqdist;
gmt_map.c:	GMT->current.proj.inv = &gmt_iazeqdist;
gmt_map.c:	if (GMT->common.R.oblique) {	/* Rectangular box given */
gmt_map.c:		(*GMT->current.proj.fwd) (GMT, GMT->common.R.wesn[XLO], GMT->common.R.wesn[YLO], &xmin, &ymin);
gmt_map.c:		(*GMT->current.proj.fwd) (GMT, GMT->common.R.wesn[XHI], GMT->common.R.wesn[YHI], &xmax, &ymax);
gmt_map.c:		GMT->current.map.outside = &map_rect_outside2;
gmt_map.c:		GMT->current.map.crossing = &map_rect_crossing;
gmt_map.c:		GMT->current.map.overlap = &map_rect_overlap;
gmt_map.c:		GMT->current.map.clip = &map_rect_clip;
gmt_map.c:		GMT->current.map.left_edge = &map_left_rect;
gmt_map.c:		GMT->current.map.right_edge = &map_right_rect;
gmt_map.c:		GMT->current.map.frame.check_side = !(GMT->current.setting.map_annot_oblique & GMT_OBL_ANNOT_ANYWHERE);
gmt_map.c:		GMT->current.map.frame.horizontal = (fabs (GMT->current.proj.pars[1]) < 60.0 && fabs (GMT->common.R.wesn[YHI] - GMT->common.R.wesn[YLO]) < 30.0) ? 1 : 0;
gmt_map.c:		if (GMT->current.proj.polar && (GMT->common.R.wesn[YHI] - GMT->common.R.wesn[YLO]) < 180.0) {	/* Polar aspect */
gmt_map.c:			if (!GMT->current.proj.north_pole && GMT->common.R.wesn[YLO] <= -90.0) GMT->current.proj.edge[0] = false;
gmt_map.c:			if (GMT->current.proj.north_pole && GMT->common.R.wesn[YHI] >= 90.0) GMT->current.proj.edge[2] = false;
gmt_map.c:			if (gmt_M_360_range (GMT->common.R.wesn[XLO], GMT->common.R.wesn[XHI])
gmt_map.c:					|| doubleAlmostEqualZero (GMT->common.R.wesn[XHI], GMT->common.R.wesn[XLO]))
gmt_map.c:				GMT->current.proj.edge[1] = GMT->current.proj.edge[3] = false;
gmt_map.c:			GMT->current.map.outside = &map_polar_outside;
gmt_map.c:			GMT->current.map.crossing = &map_wesn_crossing;
gmt_map.c:			GMT->current.map.overlap = &map_wesn_overlap;
gmt_map.c:			GMT->current.map.clip = &map_wesn_clip;
gmt_map.c:			GMT->current.map.frame.horizontal = 1;
gmt_map.c:			GMT->current.map.n_lat_nodes = 2;
gmt_map.c:			map_xy_search (GMT, &xmin, &xmax, &ymin, &ymax, GMT->common.R.wesn[XLO], GMT->common.R.wesn[XHI], GMT->common.R.wesn[YLO], GMT->common.R.wesn[YHI]);
gmt_map.c:				GMT->current.map.frame.axis[GMT_X].item[i].active = GMT->current.map.frame.axis[GMT_Y].item[i].active = false,
gmt_map.c:				GMT->current.map.frame.axis[GMT_X].item[i].interval = GMT->current.map.frame.axis[GMT_Y].item[i].interval = 0.0;
gmt_map.c:			GMT->common.R.wesn[XLO] = 0.0;
gmt_map.c:			GMT->common.R.wesn[XHI] = 360.0;
gmt_map.c:			GMT->common.R.wesn[YLO] = -90.0;
gmt_map.c:			GMT->common.R.wesn[YHI] = 90.0;
gmt_map.c:			xmax = ymax = GMT->current.proj.rho_max * GMT->current.proj.EQ_RAD;
gmt_map.c:			GMT->current.map.outside = &map_radial_outside;
gmt_map.c:			GMT->current.map.crossing = &map_radial_crossing;
gmt_map.c:			GMT->current.map.overlap = &map_radial_overlap;
gmt_map.c:			GMT->current.map.clip = &map_radial_clip;
gmt_map.c:			if (GMT->current.setting.map_frame_type & GMT_IS_FANCY) GMT->current.setting.map_frame_type = GMT_IS_PLAIN;
gmt_map.c:		GMT->current.map.left_edge = &map_left_circle;
gmt_map.c:		GMT->current.map.right_edge = &map_right_circle;
gmt_map.c:	map_setinfo (GMT, xmin, xmax, ymin, ymax, GMT->current.proj.pars[3]);
gmt_map.c:	GMT->current.proj.r = 0.5 * GMT->current.proj.rect[XHI];
gmt_map.c:	gmt_geo_to_xy (GMT, GMT->current.proj.central_meridian, GMT->current.proj.pole, &GMT->current.proj.c_x0, &GMT->current.proj.c_y0);
gmt_map.c:	if (GMT->current.proj.polar) GMT->current.map.meridian_straight = 1;
gmt_map.c:	return (GMT->common.R.oblique);
gmt_map.c:	GMT->current.proj.GMT_convert_latitudes = !gmt_M_is_spherical (GMT);
gmt_map.c:	if (GMT->current.proj.GMT_convert_latitudes) gmtlib_scale_eqrad (GMT);
gmt_map.c:	if (GMT->current.proj.pars[0] < 0.0) GMT->current.proj.pars[0] += 360.0;
gmt_map.c:	GMT->current.map.is_world = gmt_M_360_range (GMT->common.R.wesn[XLO], GMT->common.R.wesn[XHI]);
gmt_map.c:	if (GMT->current.proj.units_pr_degree) GMT->current.proj.pars[1] /= GMT->current.proj.M_PR_DEG;
gmt_map.c:	GMT->current.proj.scale[GMT_X] = GMT->current.proj.scale[GMT_Y] = M_PI * GMT->current.proj.pars[1] / sqrt (8.0);
gmt_map.c:	gmt_vmollweide (GMT, GMT->current.proj.pars[0], GMT->current.proj.pars[1]);
gmt_map.c:	if (GMT->common.R.wesn[YLO] <= -90.0) GMT->current.proj.edge[0] = false;
gmt_map.c:	if (GMT->common.R.wesn[YHI] >= 90.0) GMT->current.proj.edge[2] = false;
gmt_map.c:	if (GMT->common.R.oblique) {
gmt_map.c:		gmt_mollweide (GMT, GMT->common.R.wesn[XLO], GMT->common.R.wesn[YLO], &xmin, &ymin);
gmt_map.c:		gmt_mollweide (GMT, GMT->common.R.wesn[XHI], GMT->common.R.wesn[YHI], &xmax, &ymax);
gmt_map.c:		GMT->current.map.outside = &map_rect_outside;
gmt_map.c:		GMT->current.map.crossing = &map_rect_crossing;
gmt_map.c:		GMT->current.map.overlap = &map_rect_overlap;
gmt_map.c:		GMT->current.map.clip = &map_rect_clip;
gmt_map.c:		GMT->current.map.left_edge = &map_left_rect;
gmt_map.c:		GMT->current.map.right_edge = &map_right_rect;
gmt_map.c:		GMT->current.map.frame.check_side = true;
gmt_map.c:		y = (GMT->common.R.wesn[YLO] * GMT->common.R.wesn[YHI] <= 0.0) ? 0.0 : MIN (fabs (GMT->common.R.wesn[YLO]), fabs (GMT->common.R.wesn[YHI]));
gmt_map.c:		gmt_mollweide (GMT, GMT->common.R.wesn[XLO], y, &xmin, &dummy);
gmt_map.c:		gmt_mollweide (GMT, GMT->common.R.wesn[XHI], y, &xmax, &dummy);
gmt_map.c:		gmt_mollweide (GMT, GMT->current.proj.central_meridian, GMT->common.R.wesn[YLO], &dummy, &ymin);
gmt_map.c:		gmt_mollweide (GMT, GMT->current.proj.central_meridian, GMT->common.R.wesn[YHI], &dummy, &ymax);
gmt_map.c:		GMT->current.map.outside = &map_wesn_outside;
gmt_map.c:		GMT->current.map.crossing = &map_wesn_crossing;
gmt_map.c:		GMT->current.map.overlap = &map_wesn_overlap;
gmt_map.c:		GMT->current.map.clip = &map_wesn_clip;
gmt_map.c:		GMT->current.map.left_edge = &map_left_ellipse;
gmt_map.c:		GMT->current.map.right_edge = &map_right_ellipse;
gmt_map.c:		GMT->current.map.frame.horizontal = 2;
gmt_map.c:		GMT->current.proj.polar = true;
gmt_map.c:	map_setinfo (GMT, xmin, xmax, ymin, ymax, GMT->current.proj.pars[1]);
gmt_map.c:	GMT->current.proj.fwd = &gmt_mollweide;
gmt_map.c:	GMT->current.proj.inv = &gmt_imollweide;
gmt_map.c:	if (GMT->current.setting.map_frame_type & GMT_IS_FANCY) GMT->current.setting.map_frame_type = GMT_IS_PLAIN;
gmt_map.c:	GMT->current.map.parallel_straight = 1;
gmt_map.c:	return (GMT->common.R.oblique);
gmt_map.c:	GMT->current.proj.GMT_convert_latitudes = !gmt_M_is_spherical (GMT);
gmt_map.c:	if (GMT->current.proj.GMT_convert_latitudes) gmtlib_scale_eqrad (GMT);
gmt_map.c:	if (GMT->current.proj.pars[0] < 0.0) GMT->current.proj.pars[0] += 360.0;
gmt_map.c:	GMT->current.map.is_world = gmt_M_360_range (GMT->common.R.wesn[XLO], GMT->common.R.wesn[XHI]);
gmt_map.c:	if (GMT->current.proj.units_pr_degree) GMT->current.proj.pars[1] /= GMT->current.proj.M_PR_DEG;
gmt_map.c:	GMT->current.proj.scale[GMT_X] = GMT->current.proj.scale[GMT_Y] = 0.5 * M_PI * GMT->current.proj.pars[1] / M_SQRT2;
gmt_map.c:	gmt_vhammer (GMT, GMT->current.proj.pars[0], GMT->current.proj.pars[1]);
gmt_map.c:	if (GMT->common.R.wesn[YLO] <= -90.0) GMT->current.proj.edge[0] = false;
gmt_map.c:	if (GMT->common.R.wesn[YHI] >= 90.0) GMT->current.proj.edge[2] = false;
gmt_map.c:	if (GMT->common.R.oblique) {
gmt_map.c:		gmt_hammer (GMT, GMT->common.R.wesn[XLO], GMT->common.R.wesn[YLO], &xmin, &ymin);
gmt_map.c:		gmt_hammer (GMT, GMT->common.R.wesn[XHI], GMT->common.R.wesn[YHI], &xmax, &ymax);
gmt_map.c:		GMT->current.map.outside = &map_rect_outside;
gmt_map.c:		GMT->current.map.crossing = &map_rect_crossing;
gmt_map.c:		GMT->current.map.overlap = &map_rect_overlap;
gmt_map.c:		GMT->current.map.clip = &map_rect_clip;
gmt_map.c:		GMT->current.map.left_edge = &map_left_rect;
gmt_map.c:		GMT->current.map.right_edge = &map_right_rect;
gmt_map.c:		GMT->current.map.frame.check_side = true;
gmt_map.c:		y = (GMT->common.R.wesn[YLO] * GMT->common.R.wesn[YHI] <= 0.0) ? 0.0 : MIN (fabs (GMT->common.R.wesn[YLO]), fabs (GMT->common.R.wesn[YHI]));
gmt_map.c:		x = (fabs (GMT->common.R.wesn[XLO] - GMT->current.proj.central_meridian) > fabs (GMT->common.R.wesn[XHI] - GMT->current.proj.central_meridian)) ? GMT->common.R.wesn[XLO] : GMT->common.R.wesn[XHI];
gmt_map.c:		gmt_hammer (GMT, GMT->common.R.wesn[XLO], y, &xmin, &dummy);
gmt_map.c:		gmt_hammer (GMT, GMT->common.R.wesn[XHI], y, &xmax, &dummy);
gmt_map.c:		gmt_hammer (GMT, x, GMT->common.R.wesn[YLO], &dummy, &ymin);
gmt_map.c:		gmt_hammer (GMT, x, GMT->common.R.wesn[YHI], &dummy, &ymax);
gmt_map.c:		GMT->current.map.outside = &map_wesn_outside;
gmt_map.c:		GMT->current.map.crossing = &map_wesn_crossing;
gmt_map.c:		GMT->current.map.overlap = &map_wesn_overlap;
gmt_map.c:		GMT->current.map.clip = &map_wesn_clip;
gmt_map.c:		GMT->current.map.left_edge = &map_left_ellipse;
gmt_map.c:		GMT->current.map.right_edge = &map_right_ellipse;
gmt_map.c:		GMT->current.map.frame.horizontal = 2;
gmt_map.c:		GMT->current.proj.polar = true;
gmt_map.c:	map_setinfo (GMT, xmin, xmax, ymin, ymax, GMT->current.proj.pars[1]);
gmt_map.c:	GMT->current.proj.fwd = &gmt_hammer;
gmt_map.c:	GMT->current.proj.inv = &gmt_ihammer;
gmt_map.c:	if (GMT->current.setting.map_frame_type & GMT_IS_FANCY) GMT->current.setting.map_frame_type = GMT_IS_PLAIN;
gmt_map.c:	return (GMT->common.R.oblique);
gmt_map.c:	if (GMT->current.proj.pars[0] < 0.0) GMT->current.proj.pars[0] += 360.0;
gmt_map.c:	GMT->current.map.is_world = gmt_M_360_range (GMT->common.R.wesn[XLO], GMT->common.R.wesn[XHI]);
gmt_map.c:	if (GMT->current.proj.units_pr_degree) GMT->current.proj.pars[1] /= GMT->current.proj.M_PR_DEG;
gmt_map.c:	GMT->current.proj.scale[GMT_X] = GMT->current.proj.scale[GMT_Y] = GMT->current.proj.pars[1];
gmt_map.c:	gmt_vgrinten (GMT, GMT->current.proj.pars[0], GMT->current.proj.pars[1]);
gmt_map.c:	if (GMT->common.R.wesn[YLO] <= -90.0) GMT->current.proj.edge[0] = false;
gmt_map.c:	if (GMT->common.R.wesn[YHI] >= 90.0) GMT->current.proj.edge[2] = false;
gmt_map.c:	if (GMT->common.R.oblique) {
gmt_map.c:		gmt_grinten (GMT, GMT->common.R.wesn[XLO], GMT->common.R.wesn[YLO], &xmin, &ymin);
gmt_map.c:		gmt_grinten (GMT, GMT->common.R.wesn[XHI], GMT->common.R.wesn[YHI], &xmax, &ymax);
gmt_map.c:		GMT->current.map.outside = &map_rect_outside;
gmt_map.c:		GMT->current.map.crossing = &map_rect_crossing;
gmt_map.c:		GMT->current.map.overlap = &map_rect_overlap;
gmt_map.c:		GMT->current.map.clip = &map_rect_clip;
gmt_map.c:		GMT->current.map.left_edge = &map_left_rect;
gmt_map.c:		GMT->current.map.right_edge = &map_right_rect;
gmt_map.c:		GMT->current.map.frame.check_side = true;
gmt_map.c:		y = (GMT->common.R.wesn[YLO] * GMT->common.R.wesn[YHI] <= 0.0) ? 0.0 : MIN (fabs (GMT->common.R.wesn[YLO]), fabs (GMT->common.R.wesn[YHI]));
gmt_map.c:		x = (fabs (GMT->common.R.wesn[XLO] - GMT->current.proj.central_meridian) > fabs (GMT->common.R.wesn[XHI] - GMT->current.proj.central_meridian)) ? GMT->common.R.wesn[XLO] : GMT->common.R.wesn[XHI];
gmt_map.c:		gmt_grinten (GMT, GMT->common.R.wesn[XLO], y, &xmin, &dummy);
gmt_map.c:		gmt_grinten (GMT, GMT->common.R.wesn[XHI], y, &xmax, &dummy);
gmt_map.c:		gmt_grinten (GMT, x, GMT->common.R.wesn[YLO], &dummy, &ymin);
gmt_map.c:		gmt_grinten (GMT, x, GMT->common.R.wesn[YHI], &dummy, &ymax);
gmt_map.c:		GMT->current.map.outside = &map_wesn_outside;
gmt_map.c:		GMT->current.map.crossing = &map_wesn_crossing;
gmt_map.c:		GMT->current.map.overlap = &map_wesn_overlap;
gmt_map.c:		GMT->current.map.clip = &map_wesn_clip;
gmt_map.c:		GMT->current.map.left_edge = &map_left_circle;
gmt_map.c:		GMT->current.map.right_edge = &map_right_circle;
gmt_map.c:		GMT->current.map.frame.horizontal = 2;
gmt_map.c:		GMT->current.proj.polar = true;
gmt_map.c:	map_setinfo (GMT, xmin, xmax, ymin, ymax, GMT->current.proj.pars[1]);
gmt_map.c:	GMT->current.proj.r = 0.5 * GMT->current.proj.rect[XHI];
gmt_map.c:	GMT->current.proj.fwd = &gmt_grinten;
gmt_map.c:	GMT->current.proj.inv = &gmt_igrinten;
gmt_map.c:	if (GMT->current.setting.map_frame_type & GMT_IS_FANCY) GMT->current.setting.map_frame_type = GMT_IS_PLAIN;
gmt_map.c:	return (GMT->common.R.oblique);
gmt_map.c:	if (GMT->current.proj.pars[0] < 0.0) GMT->current.proj.pars[0] += 360.0;
gmt_map.c:	GMT->current.map.is_world = gmt_M_360_range (GMT->common.R.wesn[XLO], GMT->common.R.wesn[XHI]);
gmt_map.c:	if (GMT->current.proj.units_pr_degree) GMT->current.proj.pars[1] /= GMT->current.proj.M_PR_DEG;
gmt_map.c:	gmt_vwinkel (GMT, GMT->current.proj.pars[0], GMT->current.proj.pars[1]);
gmt_map.c:	GMT->current.proj.scale[GMT_X] = GMT->current.proj.scale[GMT_Y] = 2.0 * GMT->current.proj.pars[1] / (1.0 + GMT->current.proj.r_cosphi1);
gmt_map.c:	if (GMT->common.R.oblique) {
gmt_map.c:		gmt_winkel (GMT, GMT->common.R.wesn[XLO], GMT->common.R.wesn[YLO], &xmin, &ymin);
gmt_map.c:		gmt_winkel (GMT, GMT->common.R.wesn[XHI], GMT->common.R.wesn[YHI], &xmax, &ymax);
gmt_map.c:		GMT->current.map.outside = &map_rect_outside;
gmt_map.c:		GMT->current.map.crossing = &map_rect_crossing;
gmt_map.c:		GMT->current.map.overlap = &map_rect_overlap;
gmt_map.c:		GMT->current.map.clip = &map_rect_clip;
gmt_map.c:		GMT->current.map.left_edge = &map_left_rect;
gmt_map.c:		GMT->current.map.right_edge = &map_right_rect;
gmt_map.c:		GMT->current.map.frame.check_side = true;
gmt_map.c:		y = (GMT->common.R.wesn[YLO] * GMT->common.R.wesn[YHI] <= 0.0) ? 0.0 : MIN (fabs (GMT->common.R.wesn[YLO]), fabs (GMT->common.R.wesn[YHI]));
gmt_map.c:		x = (fabs (GMT->common.R.wesn[XLO] - GMT->current.proj.central_meridian) > fabs (GMT->common.R.wesn[XHI] - GMT->current.proj.central_meridian)) ? GMT->common.R.wesn[XLO] : GMT->common.R.wesn[XHI];
gmt_map.c:		gmt_winkel (GMT, GMT->common.R.wesn[XLO], y, &xmin, &dummy);
gmt_map.c:		gmt_winkel (GMT, GMT->common.R.wesn[XHI], y, &xmax, &dummy);
gmt_map.c:		gmt_winkel (GMT, x, GMT->common.R.wesn[YLO], &dummy, &ymin);
gmt_map.c:		gmt_winkel (GMT, x, GMT->common.R.wesn[YHI], &dummy, &ymax);
gmt_map.c:		GMT->current.map.outside = &map_wesn_outside;
gmt_map.c:		GMT->current.map.crossing = &map_wesn_crossing;
gmt_map.c:		GMT->current.map.overlap = &map_wesn_overlap;
gmt_map.c:		GMT->current.map.clip = &map_wesn_clip;
gmt_map.c:		GMT->current.map.left_edge = &gmt_left_winkel;
gmt_map.c:		GMT->current.map.right_edge = &gmt_right_winkel;
gmt_map.c:		GMT->current.map.frame.horizontal = 2;
gmt_map.c:	map_setinfo (GMT, xmin, xmax, ymin, ymax, GMT->current.proj.pars[1]);
gmt_map.c:	GMT->current.proj.fwd = &gmt_winkel;
gmt_map.c:	GMT->current.proj.inv = &gmt_iwinkel;
gmt_map.c:	if (GMT->current.setting.map_frame_type & GMT_IS_FANCY) GMT->current.setting.map_frame_type = GMT_IS_PLAIN;
gmt_map.c:	return (GMT->common.R.oblique);
gmt_map.c:	GMT->current.proj.GMT_convert_latitudes = !gmt_M_is_spherical (GMT);
gmt_map.c:	if (GMT->current.proj.GMT_convert_latitudes) gmtlib_scale_eqrad (GMT);
gmt_map.c:	if (GMT->current.proj.pars[0] < 0.0) GMT->current.proj.pars[0] += 360.0;
gmt_map.c:	GMT->current.map.is_world = gmt_M_360_range (GMT->common.R.wesn[XLO], GMT->common.R.wesn[XHI]);
gmt_map.c:	if (GMT->current.proj.units_pr_degree) GMT->current.proj.pars[1] /= GMT->current.proj.M_PR_DEG;
gmt_map.c:	gmt_veckert4 (GMT, GMT->current.proj.pars[0]);
gmt_map.c:	GMT->current.proj.scale[GMT_X] = GMT->current.proj.scale[GMT_Y] = GMT->current.proj.pars[1];
gmt_map.c:	if (GMT->common.R.oblique) {
gmt_map.c:		gmt_eckert4 (GMT, GMT->common.R.wesn[XLO], GMT->common.R.wesn[YLO], &xmin, &ymin);
gmt_map.c:		gmt_eckert4 (GMT, GMT->common.R.wesn[XHI], GMT->common.R.wesn[YHI], &xmax, &ymax);
gmt_map.c:		GMT->current.map.outside = &map_rect_outside;
gmt_map.c:		GMT->current.map.crossing = &map_rect_crossing;
gmt_map.c:		GMT->current.map.overlap = &map_rect_overlap;
gmt_map.c:		GMT->current.map.clip = &map_rect_clip;
gmt_map.c:		GMT->current.map.left_edge = &map_left_rect;
gmt_map.c:		GMT->current.map.right_edge = &map_right_rect;
gmt_map.c:		GMT->current.map.frame.check_side = true;
gmt_map.c:		y = (GMT->common.R.wesn[YLO] * GMT->common.R.wesn[YHI] <= 0.0) ? 0.0 : MIN (fabs (GMT->common.R.wesn[YLO]), fabs (GMT->common.R.wesn[YHI]));
gmt_map.c:		gmt_eckert4 (GMT, GMT->common.R.wesn[XLO], y, &xmin, &dummy);
gmt_map.c:		gmt_eckert4 (GMT, GMT->common.R.wesn[XHI], y, &xmax, &dummy);
gmt_map.c:		gmt_eckert4 (GMT, GMT->current.proj.central_meridian, GMT->common.R.wesn[YLO], &dummy, &ymin);
gmt_map.c:		gmt_eckert4 (GMT, GMT->current.proj.central_meridian, GMT->common.R.wesn[YHI], &dummy, &ymax);
gmt_map.c:		GMT->current.map.outside = &map_wesn_outside;
gmt_map.c:		GMT->current.map.crossing = &map_wesn_crossing;
gmt_map.c:		GMT->current.map.overlap = &map_wesn_overlap;
gmt_map.c:		GMT->current.map.clip = &map_wesn_clip;
gmt_map.c:		GMT->current.map.left_edge = &gmt_left_eckert4;
gmt_map.c:		GMT->current.map.right_edge = &gmt_right_eckert4;
gmt_map.c:		GMT->current.map.frame.horizontal = 2;
gmt_map.c:	map_setinfo (GMT, xmin, xmax, ymin, ymax, GMT->current.proj.pars[1]);
gmt_map.c:	GMT->current.proj.fwd = &gmt_eckert4;
gmt_map.c:	GMT->current.proj.inv = &gmt_ieckert4;
gmt_map.c:	if (GMT->current.setting.map_frame_type & GMT_IS_FANCY) GMT->current.setting.map_frame_type = GMT_IS_PLAIN;
gmt_map.c:	GMT->current.map.parallel_straight = 1;
gmt_map.c:	return (GMT->common.R.oblique);
gmt_map.c:	GMT->current.proj.GMT_convert_latitudes = !gmt_M_is_spherical (GMT);
gmt_map.c:	if (GMT->current.proj.GMT_convert_latitudes) gmtlib_scale_eqrad (GMT);
gmt_map.c:	if (GMT->current.proj.pars[0] < 0.0) GMT->current.proj.pars[0] += 360.0;
gmt_map.c:	GMT->current.map.is_world = gmt_M_360_range (GMT->common.R.wesn[XLO], GMT->common.R.wesn[XHI]);
gmt_map.c:	if (GMT->current.proj.units_pr_degree) GMT->current.proj.pars[1] /= GMT->current.proj.M_PR_DEG;
gmt_map.c:	gmt_veckert6 (GMT, GMT->current.proj.pars[0]);
gmt_map.c:	GMT->current.proj.scale[GMT_X] = GMT->current.proj.scale[GMT_Y] = 0.5 * GMT->current.proj.pars[1] * sqrt (2.0 + M_PI);
gmt_map.c:	if (GMT->common.R.oblique) {
gmt_map.c:		gmt_eckert6 (GMT, GMT->common.R.wesn[XLO], GMT->common.R.wesn[YLO], &xmin, &ymin);
gmt_map.c:		gmt_eckert6 (GMT, GMT->common.R.wesn[XHI], GMT->common.R.wesn[YHI], &xmax, &ymax);
gmt_map.c:		GMT->current.map.outside = &map_rect_outside;
gmt_map.c:		GMT->current.map.crossing = &map_rect_crossing;
gmt_map.c:		GMT->current.map.overlap = &map_rect_overlap;
gmt_map.c:		GMT->current.map.clip = &map_rect_clip;
gmt_map.c:		GMT->current.map.left_edge = &map_left_rect;
gmt_map.c:		GMT->current.map.right_edge = &map_right_rect;
gmt_map.c:		GMT->current.map.frame.check_side = true;
gmt_map.c:		y = (GMT->common.R.wesn[YLO] * GMT->common.R.wesn[YHI] <= 0.0) ? 0.0 : MIN (fabs (GMT->common.R.wesn[YLO]), fabs (GMT->common.R.wesn[YHI]));
gmt_map.c:		gmt_eckert6 (GMT, GMT->common.R.wesn[XLO], y, &xmin, &dummy);
gmt_map.c:		gmt_eckert6 (GMT, GMT->common.R.wesn[XHI], y, &xmax, &dummy);
gmt_map.c:		gmt_eckert6 (GMT, GMT->current.proj.central_meridian, GMT->common.R.wesn[YLO], &dummy, &ymin);
gmt_map.c:		gmt_eckert6 (GMT, GMT->current.proj.central_meridian, GMT->common.R.wesn[YHI], &dummy, &ymax);
gmt_map.c:		GMT->current.map.outside = &map_wesn_outside;
gmt_map.c:		GMT->current.map.crossing = &map_wesn_crossing;
gmt_map.c:		GMT->current.map.overlap = &map_wesn_overlap;
gmt_map.c:		GMT->current.map.clip = &map_wesn_clip;
gmt_map.c:		GMT->current.map.left_edge = &gmt_left_eckert6;
gmt_map.c:		GMT->current.map.right_edge = &gmt_right_eckert6;
gmt_map.c:		GMT->current.map.frame.horizontal = 2;
gmt_map.c:	map_setinfo (GMT, xmin, xmax, ymin, ymax, GMT->current.proj.pars[1]);
gmt_map.c:	GMT->current.proj.fwd = &gmt_eckert6;
gmt_map.c:	GMT->current.proj.inv = &gmt_ieckert6;
gmt_map.c:	if (GMT->current.setting.map_frame_type & GMT_IS_FANCY) GMT->current.setting.map_frame_type = GMT_IS_PLAIN;
gmt_map.c:	GMT->current.map.parallel_straight = 1;
gmt_map.c:	return (GMT->common.R.oblique);
gmt_map.c:	if (GMT->current.proj.pars[0] < 0.0) GMT->current.proj.pars[0] += 360.0;
gmt_map.c:	GMT->current.map.is_world = gmt_M_360_range (GMT->common.R.wesn[XLO], GMT->common.R.wesn[XHI]);
gmt_map.c:	if (GMT->current.proj.units_pr_degree) GMT->current.proj.pars[1] /= GMT->current.proj.M_PR_DEG;
gmt_map.c:	gmt_vrobinson (GMT, GMT->current.proj.pars[0]);
gmt_map.c:	GMT->current.proj.scale[GMT_X] = GMT->current.proj.scale[GMT_Y] = GMT->current.proj.pars[1] / 0.8487;
gmt_map.c:	if (GMT->common.R.oblique) {
gmt_map.c:		gmt_robinson (GMT, GMT->common.R.wesn[XLO], GMT->common.R.wesn[YLO], &xmin, &ymin);
gmt_map.c:		gmt_robinson (GMT, GMT->common.R.wesn[XHI], GMT->common.R.wesn[YHI], &xmax, &ymax);
gmt_map.c:		GMT->current.map.outside = &map_rect_outside;
gmt_map.c:		GMT->current.map.crossing = &map_rect_crossing;
gmt_map.c:		GMT->current.map.overlap = &map_rect_overlap;
gmt_map.c:		GMT->current.map.clip = &map_rect_clip;
gmt_map.c:		GMT->current.map.left_edge = &map_left_rect;
gmt_map.c:		GMT->current.map.right_edge = &map_right_rect;
gmt_map.c:		GMT->current.map.frame.check_side = true;
gmt_map.c:		y = (GMT->common.R.wesn[YLO] * GMT->common.R.wesn[YHI] <= 0.0) ? 0.0 : MIN (fabs (GMT->common.R.wesn[YLO]), fabs (GMT->common.R.wesn[YHI]));
gmt_map.c:		gmt_robinson (GMT, GMT->common.R.wesn[XLO], y, &xmin, &dummy);
gmt_map.c:		gmt_robinson (GMT, GMT->common.R.wesn[XHI], y, &xmax, &dummy);
gmt_map.c:		gmt_robinson (GMT, GMT->current.proj.central_meridian, GMT->common.R.wesn[YLO], &dummy, &ymin);
gmt_map.c:		gmt_robinson (GMT, GMT->current.proj.central_meridian, GMT->common.R.wesn[YHI], &dummy, &ymax);
gmt_map.c:		GMT->current.map.outside = &map_wesn_outside;
gmt_map.c:		GMT->current.map.crossing = &map_wesn_crossing;
gmt_map.c:		GMT->current.map.overlap = &map_wesn_overlap;
gmt_map.c:		GMT->current.map.clip = &map_wesn_clip;
gmt_map.c:		GMT->current.map.left_edge = &gmt_left_robinson;
gmt_map.c:		GMT->current.map.right_edge = &gmt_right_robinson;
gmt_map.c:		GMT->current.map.frame.horizontal = 2;
gmt_map.c:	map_setinfo (GMT, xmin, xmax, ymin, ymax, GMT->current.proj.pars[1]);
gmt_map.c:	GMT->current.proj.fwd = &gmt_robinson;
gmt_map.c:	GMT->current.proj.inv = &gmt_irobinson;
gmt_map.c:	if (GMT->current.setting.map_frame_type & GMT_IS_FANCY) GMT->current.setting.map_frame_type = GMT_IS_PLAIN;
gmt_map.c:	GMT->current.map.parallel_straight = 1;
gmt_map.c:	return (GMT->common.R.oblique);
gmt_map.c:	GMT->current.proj.GMT_convert_latitudes = !gmt_M_is_spherical (GMT);
gmt_map.c:	if (GMT->current.proj.GMT_convert_latitudes) gmtlib_scale_eqrad (GMT);
gmt_map.c:	if (GMT->current.proj.pars[0] < 0.0) GMT->current.proj.pars[0] += 360.0;
gmt_map.c:	GMT->current.map.is_world = gmt_M_360_range (GMT->common.R.wesn[XLO], GMT->common.R.wesn[XHI]);
gmt_map.c:	if (GMT->common.R.wesn[YLO] <= -90.0) GMT->current.proj.edge[0] = false;
gmt_map.c:	if (GMT->common.R.wesn[YHI] >= 90.0) GMT->current.proj.edge[2] = false;
gmt_map.c:	gmt_vsinusoidal (GMT, GMT->current.proj.pars[0]);
gmt_map.c:	if (GMT->current.proj.units_pr_degree) GMT->current.proj.pars[1] /= GMT->current.proj.M_PR_DEG;
gmt_map.c:	GMT->current.proj.scale[GMT_X] = GMT->current.proj.scale[GMT_Y] = GMT->current.proj.pars[1];
gmt_map.c:	GMT->current.proj.fwd = &gmt_sinusoidal;
gmt_map.c:	GMT->current.proj.inv = &gmt_isinusoidal;
gmt_map.c:	if (GMT->current.setting.map_frame_type & GMT_IS_FANCY) GMT->current.setting.map_frame_type = GMT_IS_PLAIN;
gmt_map.c:	if (GMT->common.R.oblique) {
gmt_map.c:		gmt_sinusoidal (GMT, GMT->common.R.wesn[XLO], GMT->common.R.wesn[YLO], &xmin, &ymin);
gmt_map.c:		gmt_sinusoidal (GMT, GMT->common.R.wesn[XHI], GMT->common.R.wesn[YHI], &xmax, &ymax);
gmt_map.c:		GMT->current.map.outside = &map_rect_outside;
gmt_map.c:		GMT->current.map.crossing = &map_rect_crossing;
gmt_map.c:		GMT->current.map.overlap = &map_rect_overlap;
gmt_map.c:		GMT->current.map.clip = &map_rect_clip;
gmt_map.c:		GMT->current.map.left_edge = &map_left_rect;
gmt_map.c:		GMT->current.map.right_edge = &map_right_rect;
gmt_map.c:		GMT->current.map.frame.check_side = true;
gmt_map.c:		y = (GMT->common.R.wesn[YLO] * GMT->common.R.wesn[YHI] <= 0.0) ? 0.0 : MIN (fabs (GMT->common.R.wesn[YLO]), fabs (GMT->common.R.wesn[YHI]));
gmt_map.c:		gmt_sinusoidal (GMT, GMT->current.proj.central_meridian, GMT->common.R.wesn[YLO], &dummy, &ymin);
gmt_map.c:		gmt_sinusoidal (GMT, GMT->current.proj.central_meridian, GMT->common.R.wesn[YHI], &dummy, &ymax);
gmt_map.c:		gmt_sinusoidal (GMT, GMT->common.R.wesn[XLO], y, &xmin, &dummy);
gmt_map.c:		gmt_sinusoidal (GMT, GMT->common.R.wesn[XHI], y, &xmax, &dummy);
gmt_map.c:		GMT->current.map.outside = &map_wesn_outside;
gmt_map.c:		GMT->current.map.crossing = &map_wesn_crossing;
gmt_map.c:		GMT->current.map.overlap = &map_wesn_overlap;
gmt_map.c:		GMT->current.map.clip = &map_wesn_clip;
gmt_map.c:		GMT->current.map.left_edge = &gmt_left_sinusoidal;
gmt_map.c:		GMT->current.map.right_edge = &gmt_right_sinusoidal;
gmt_map.c:		GMT->current.map.frame.horizontal = 2;
gmt_map.c:		GMT->current.proj.polar = true;
gmt_map.c:	map_setinfo (GMT, xmin, xmax, ymin, ymax, GMT->current.proj.pars[1]);
gmt_map.c:	GMT->current.map.parallel_straight = 1;
gmt_map.c:	return (GMT->common.R.oblique);
gmt_map.c:	if ((GMT->current.proj.pars[0] - GMT->common.R.wesn[XLO]) > 90.0 || (GMT->common.R.wesn[XHI] - GMT->current.proj.pars[0]) > 90.0) {
gmt_map.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Max longitude extension away from central meridian is limited to +/- 90 degrees\n");
gmt_map.c:	too_big = map_quicktm (GMT, GMT->current.proj.pars[0], 4.0);
gmt_map.c:	gmt_vcassini (GMT, GMT->current.proj.pars[0], GMT->current.proj.pars[1]);
gmt_map.c:		GMT->current.proj.fwd = &gmt_cassini_sph;
gmt_map.c:		GMT->current.proj.inv = &gmt_icassini_sph;
gmt_map.c:		GMT->current.proj.fwd = &gmt_cassini;
gmt_map.c:		GMT->current.proj.inv = &gmt_icassini;
gmt_map.c:	if (GMT->current.proj.units_pr_degree) GMT->current.proj.pars[2] /= GMT->current.proj.M_PR_DEG;
gmt_map.c:	GMT->current.proj.scale[GMT_X] = GMT->current.proj.scale[GMT_Y] = GMT->current.proj.pars[2];
gmt_map.c:	if (GMT->current.setting.map_frame_type & GMT_IS_FANCY) GMT->current.setting.map_frame_type = GMT_IS_PLAIN;
gmt_map.c:	if (GMT->common.R.oblique) {
gmt_map.c:		(*GMT->current.proj.fwd) (GMT, GMT->common.R.wesn[XLO], GMT->common.R.wesn[YLO], &xmin, &ymin);
gmt_map.c:		(*GMT->current.proj.fwd) (GMT, GMT->common.R.wesn[XHI], GMT->common.R.wesn[YHI], &xmax, &ymax);
gmt_map.c:		GMT->current.map.outside = &map_rect_outside;
gmt_map.c:		GMT->current.map.crossing = &map_rect_crossing;
gmt_map.c:		GMT->current.map.overlap = &map_rect_overlap;
gmt_map.c:		GMT->current.map.clip = &map_rect_clip;
gmt_map.c:		GMT->current.map.left_edge = &map_left_rect;
gmt_map.c:		GMT->current.map.right_edge = &map_right_rect;
gmt_map.c:		GMT->current.map.frame.check_side = true;
gmt_map.c:		map_xy_search (GMT, &xmin, &xmax, &ymin, &ymax, GMT->common.R.wesn[XLO], GMT->common.R.wesn[XHI], GMT->common.R.wesn[YLO], GMT->common.R.wesn[YHI]);
gmt_map.c:		GMT->current.map.outside = &map_wesn_outside;
gmt_map.c:		GMT->current.map.crossing = &map_wesn_crossing;
gmt_map.c:		GMT->current.map.overlap = &map_wesn_overlap;
gmt_map.c:		GMT->current.map.clip = &map_wesn_clip;
gmt_map.c:		GMT->current.map.left_edge = &map_left_conic;
gmt_map.c:		GMT->current.map.right_edge = &map_right_conic;
gmt_map.c:	GMT->current.map.frame.horizontal = 1;
gmt_map.c:	map_setinfo (GMT, xmin, xmax, ymin, ymax, GMT->current.proj.pars[2]);
gmt_map.c:	return (GMT->common.R.oblique);
gmt_map.c:	GMT->current.proj.GMT_convert_latitudes = map_quickconic (GMT);
gmt_map.c:	if (GMT->current.proj.GMT_convert_latitudes) gmtlib_scale_eqrad (GMT);
gmt_map.c:	if (gmt_M_is_spherical (GMT) || GMT->current.proj.GMT_convert_latitudes) {	/* Spherical code w/wo authalic latitudes */
gmt_map.c:		gmt_valbers_sph (GMT, GMT->current.proj.pars[0], GMT->current.proj.pars[1], GMT->current.proj.pars[2], GMT->current.proj.pars[3]);
gmt_map.c:		GMT->current.proj.fwd = &gmt_albers_sph;
gmt_map.c:		GMT->current.proj.inv = &gmt_ialbers_sph;
gmt_map.c:		gmt_valbers (GMT, GMT->current.proj.pars[0], GMT->current.proj.pars[1], GMT->current.proj.pars[2], GMT->current.proj.pars[3]);
gmt_map.c:		GMT->current.proj.fwd = &gmt_albers;
gmt_map.c:		GMT->current.proj.inv = &gmt_ialbers;
gmt_map.c:	if (GMT->current.proj.units_pr_degree) GMT->current.proj.pars[4] /= GMT->current.proj.M_PR_DEG;
gmt_map.c:	GMT->current.proj.scale[GMT_X] = GMT->current.proj.scale[GMT_Y] = GMT->current.proj.pars[4];
gmt_map.c:	if (GMT->common.R.oblique) {
gmt_map.c:		(*GMT->current.proj.fwd) (GMT, GMT->common.R.wesn[XLO], GMT->common.R.wesn[YLO], &xmin, &ymin);
gmt_map.c:		(*GMT->current.proj.fwd) (GMT, GMT->common.R.wesn[XHI], GMT->common.R.wesn[YHI], &xmax, &ymax);
gmt_map.c:		GMT->current.map.outside = &map_rect_outside;
gmt_map.c:		GMT->current.map.crossing = &map_rect_crossing;
gmt_map.c:		GMT->current.map.overlap = &map_rect_overlap;
gmt_map.c:		GMT->current.map.clip = &map_rect_clip;
gmt_map.c:		GMT->current.map.left_edge = &map_left_rect;
gmt_map.c:		GMT->current.map.right_edge = &map_right_rect;
gmt_map.c:		GMT->current.map.frame.check_side = true;
gmt_map.c:		map_xy_search (GMT, &xmin, &xmax, &ymin, &ymax, GMT->common.R.wesn[XLO], GMT->common.R.wesn[XHI], GMT->common.R.wesn[YLO], GMT->common.R.wesn[YHI]);
gmt_map.c:		GMT->current.map.outside = &map_wesn_outside;
gmt_map.c:		GMT->current.map.crossing = &map_wesn_crossing;
gmt_map.c:		GMT->current.map.overlap = &map_wesn_overlap;
gmt_map.c:		GMT->current.map.clip = &map_wesn_clip;
gmt_map.c:		GMT->current.map.left_edge = &map_left_conic;
gmt_map.c:		GMT->current.map.right_edge = &map_right_conic;
gmt_map.c:	GMT->current.map.frame.horizontal = 1;
gmt_map.c:	GMT->current.map.n_lat_nodes = 2;
gmt_map.c:	map_setinfo (GMT, xmin, xmax, ymin, ymax, GMT->current.proj.pars[4]);
gmt_map.c:	gmt_geo_to_xy (GMT, GMT->current.proj.central_meridian, GMT->current.proj.pole, &GMT->current.proj.c_x0, &GMT->current.proj.c_y0);
gmt_map.c:	gmt_geo_to_xy (GMT, GMT->current.proj.central_meridian + 90., GMT->current.proj.pole, &x1, &y1);
gmt_map.c:	dy = y1 - GMT->current.proj.c_y0;
gmt_map.c:	az = 2.0 * d_atan2 (dy, x1 - GMT->current.proj.c_x0);
gmt_map.c:	GMT->current.proj.c_y0 += dy;
gmt_map.c:	GMT->current.map.meridian_straight = 1;
gmt_map.c:	return (GMT->common.R.oblique);
gmt_map.c:	GMT->current.proj.GMT_convert_latitudes = !gmt_M_is_spherical (GMT);
gmt_map.c:	if (GMT->current.proj.GMT_convert_latitudes) gmtlib_scale_eqrad (GMT);
gmt_map.c:	gmt_veconic (GMT, GMT->current.proj.pars[0], GMT->current.proj.pars[1], GMT->current.proj.pars[2], GMT->current.proj.pars[3]);
gmt_map.c:	GMT->current.proj.fwd = &gmt_econic;
gmt_map.c:	GMT->current.proj.inv = &gmt_ieconic;
gmt_map.c:	if (GMT->current.proj.units_pr_degree) GMT->current.proj.pars[4] /= GMT->current.proj.M_PR_DEG;
gmt_map.c:	GMT->current.proj.scale[GMT_X] = GMT->current.proj.scale[GMT_Y] = GMT->current.proj.pars[4];
gmt_map.c:	if (GMT->common.R.oblique) {
gmt_map.c:		(*GMT->current.proj.fwd) (GMT, GMT->common.R.wesn[XLO], GMT->common.R.wesn[YLO], &xmin, &ymin);
gmt_map.c:		(*GMT->current.proj.fwd) (GMT, GMT->common.R.wesn[XHI], GMT->common.R.wesn[YHI], &xmax, &ymax);
gmt_map.c:		GMT->current.map.outside = &map_rect_outside;
gmt_map.c:		GMT->current.map.crossing = &map_rect_crossing;
gmt_map.c:		GMT->current.map.overlap = &map_rect_overlap;
gmt_map.c:		GMT->current.map.clip = &map_rect_clip;
gmt_map.c:		GMT->current.map.left_edge = &map_left_rect;
gmt_map.c:		GMT->current.map.right_edge = &map_right_rect;
gmt_map.c:		map_xy_search (GMT, &xmin, &xmax, &ymin, &ymax, GMT->common.R.wesn[XLO], GMT->common.R.wesn[XHI], GMT->common.R.wesn[YLO], GMT->common.R.wesn[YHI]);
gmt_map.c:		GMT->current.map.outside = &map_wesn_outside;
gmt_map.c:		GMT->current.map.crossing = &map_wesn_crossing;
gmt_map.c:		GMT->current.map.overlap = &map_wesn_overlap;
gmt_map.c:		GMT->current.map.clip = &map_wesn_clip;
gmt_map.c:		GMT->current.map.left_edge = &map_left_conic;
gmt_map.c:		GMT->current.map.right_edge = &map_right_conic;
gmt_map.c:	GMT->current.map.frame.horizontal = 1;
gmt_map.c:	GMT->current.map.n_lat_nodes = 2;
gmt_map.c:	map_setinfo (GMT, xmin, xmax, ymin, ymax, GMT->current.proj.pars[4]);
gmt_map.c:	gmt_geo_to_xy (GMT, GMT->current.proj.central_meridian, GMT->current.proj.pole, &GMT->current.proj.c_x0, &GMT->current.proj.c_y0);
gmt_map.c:	gmt_geo_to_xy (GMT, GMT->current.proj.central_meridian + 90., GMT->current.proj.pole, &x1, &y1);
gmt_map.c:	dy = y1 - GMT->current.proj.c_y0;
gmt_map.c:	az = 2.0 * d_atan2 (dy, x1 - GMT->current.proj.c_x0);
gmt_map.c:	GMT->current.proj.c_y0 += dy;
gmt_map.c:	GMT->current.map.meridian_straight = 1;
gmt_map.c:	return (GMT->common.R.oblique);
gmt_map.c:	GMT->current.map.is_world = gmt_M_360_range (GMT->common.R.wesn[XLO], GMT->common.R.wesn[XHI]);
gmt_map.c:	if (GMT->common.R.wesn[YLO] <= -90.0) GMT->current.proj.edge[0] = false;
gmt_map.c:	if (GMT->common.R.wesn[YHI] >= 90.0) GMT->current.proj.edge[2] = false;
gmt_map.c:	gmt_vpolyconic (GMT, GMT->current.proj.pars[0], GMT->current.proj.pars[1]);
gmt_map.c:	if (GMT->current.proj.units_pr_degree) GMT->current.proj.pars[2] /= GMT->current.proj.M_PR_DEG;
gmt_map.c:	GMT->current.proj.scale[GMT_X] = GMT->current.proj.scale[GMT_Y] = GMT->current.proj.pars[2];
gmt_map.c:	GMT->current.proj.fwd = &gmt_polyconic;
gmt_map.c:	GMT->current.proj.inv = &gmt_ipolyconic;
gmt_map.c:	if (GMT->current.setting.map_frame_type & GMT_IS_FANCY) GMT->current.setting.map_frame_type = GMT_IS_PLAIN;
gmt_map.c:	if (GMT->common.R.oblique) {
gmt_map.c:		(*GMT->current.proj.fwd) (GMT, GMT->common.R.wesn[XLO], GMT->common.R.wesn[YLO], &xmin, &ymin);
gmt_map.c:		(*GMT->current.proj.fwd) (GMT, GMT->common.R.wesn[XHI], GMT->common.R.wesn[YHI], &xmax, &ymax);
gmt_map.c:		GMT->current.map.outside = &map_rect_outside;
gmt_map.c:		GMT->current.map.crossing = &map_rect_crossing;
gmt_map.c:		GMT->current.map.overlap = &map_rect_overlap;
gmt_map.c:		GMT->current.map.clip = &map_rect_clip;
gmt_map.c:		GMT->current.map.left_edge = &map_left_rect;
gmt_map.c:		GMT->current.map.right_edge = &map_right_rect;
gmt_map.c:		GMT->current.map.frame.check_side = true;
gmt_map.c:		y = (GMT->common.R.wesn[YLO] * GMT->common.R.wesn[YHI] <= 0.0) ? 0.0 : MIN (fabs (GMT->common.R.wesn[YLO]), fabs (GMT->common.R.wesn[YHI]));
gmt_map.c:		(*GMT->current.proj.fwd) (GMT, GMT->common.R.wesn[XLO], y, &xmin, &dummy);
gmt_map.c:		(*GMT->current.proj.fwd) (GMT, GMT->common.R.wesn[XHI], y, &xmax, &dummy);
gmt_map.c:		(*GMT->current.proj.fwd) (GMT, GMT->current.proj.central_meridian, GMT->common.R.wesn[YLO], &dummy, &ymin);
gmt_map.c:		(*GMT->current.proj.fwd) (GMT, GMT->current.proj.central_meridian, GMT->common.R.wesn[YHI], &dummy, &ymax);
gmt_map.c:		GMT->current.map.outside = &map_wesn_outside;
gmt_map.c:		GMT->current.map.crossing = &map_wesn_crossing;
gmt_map.c:		GMT->current.map.overlap = &map_wesn_overlap;
gmt_map.c:		GMT->current.map.clip = &map_wesn_clip;
gmt_map.c:		GMT->current.map.left_edge = &gmt_left_polyconic;
gmt_map.c:		GMT->current.map.right_edge = &gmt_right_polyconic;
gmt_map.c:		GMT->current.proj.polar = true;
gmt_map.c:	GMT->current.map.frame.horizontal = 1;
gmt_map.c:	map_setinfo (GMT, xmin, xmax, ymin, ymax, GMT->current.proj.pars[2]);
gmt_map.c:	return (GMT->common.R.oblique);
gmt_map.c:	switch (GMT->current.proj.projection_GMT) {
gmt_map.c:			GMT->current.proj.fwd = &gmt_proj4_fwd;
gmt_map.c:			GMT->current.proj.inv = &gmt_proj4_inv;
gmt_map.c:			GMT->current.proj.scale[GMT_X] = GMT->current.proj.scale[GMT_Y] = GMT->current.proj.proj4_scl;
gmt_map.c:			if (GMT->common.R.oblique) {
gmt_map.c:				gmt_proj4_fwd (GMT, GMT->common.R.wesn[XLO], GMT->common.R.wesn[YLO], &xmin, &ymin);
gmt_map.c:				gmt_proj4_fwd (GMT, GMT->common.R.wesn[XHI], GMT->common.R.wesn[YHI], &xmax, &ymax);
gmt_map.c:				GMT->current.map.outside = &map_rect_outside;
gmt_map.c:				GMT->current.map.crossing = &map_rect_crossing;
gmt_map.c:				GMT->current.map.overlap = &map_rect_overlap;
gmt_map.c:				GMT->current.map.clip = &map_rect_clip;
gmt_map.c:				GMT->current.map.left_edge = &map_left_rect;
gmt_map.c:				GMT->current.map.right_edge = &map_right_rect;
gmt_map.c:				GMT->current.map.frame.check_side = true;
gmt_map.c:				map_xy_search (GMT, &xmin, &xmax, &ymin, &ymax, GMT->common.R.wesn[XLO], GMT->common.R.wesn[XHI], GMT->common.R.wesn[YLO], GMT->common.R.wesn[YHI]);
gmt_map.c:				GMT->current.map.outside = &map_wesn_outside;
gmt_map.c:				GMT->current.map.crossing = &map_wesn_crossing;
gmt_map.c:				GMT->current.map.overlap = &map_wesn_overlap;
gmt_map.c:				GMT->current.map.clip = &map_wesn_clip;
gmt_map.c:				GMT->current.map.left_edge = &map_left_rect;
gmt_map.c:				GMT->current.map.right_edge = &map_right_rect;
gmt_map.c:				GMT->current.map.frame.horizontal = 2;
gmt_map.c:			map_setinfo (GMT, xmin, xmax, ymin, ymax, GMT->current.proj.proj4_scl);
gmt_map.c:			if (GMT->current.setting.map_frame_type & GMT_IS_FANCY) GMT->current.setting.map_frame_type = GMT_IS_PLAIN;
gmt_map.c:	GMT->current.proj.fwd = &gmt_proj4_fwd;
gmt_map.c:	GMT->current.proj.inv = &gmt_proj4_inv;
gmt_map.c:	if (!GMT->current.map.n_lon_nodes) GMT->current.map.n_lon_nodes = urint (GMT->current.map.width / GMT->current.setting.map_line_step);
gmt_map.c:	if (!GMT->current.map.n_lat_nodes) GMT->current.map.n_lat_nodes = urint (GMT->current.map.height / GMT->current.setting.map_line_step);
gmt_map.c:	dx = (xmax - xmin) / GMT->current.map.n_lon_nodes;
gmt_map.c:	dy = (ymax - ymin) / GMT->current.map.n_lat_nodes;
gmt_map.c:	lon = gmt_M_memory (GMT, NULL, 2 * (GMT->current.map.n_lon_nodes + GMT->current.map.n_lat_nodes + 2), double);
gmt_map.c:	for (i = k = 0; i <= GMT->current.map.n_lon_nodes; i++) {
gmt_map.c:		x = (i == GMT->current.map.n_lon_nodes) ? xmax : xmin + i * dx;
gmt_map.c:	for (j = 0; j <= GMT->current.map.n_lat_nodes; j++) {
gmt_map.c:		y = (j == GMT->current.map.n_lat_nodes) ? ymax : ymin + j * dy;
gmt_map.c:	if (GMT->current.proj.projection_GMT == GMT_AZ_EQDIST) {	/* Must be careful since if a pole equals an antipode we get NaNs as coordinates */
gmt_map.c:		gmt_geo_to_xy (GMT, GMT->current.proj.central_meridian, -90.0, &x, &y);
gmt_map.c:		gmt_geo_to_xy (GMT, GMT->current.proj.central_meridian, +90.0, &x, &y);
gmt_map.c:	if (test_pole[0] && !gmt_map_outside (GMT, GMT->current.proj.central_meridian, -90.0)) { s = -90.0; w = 0.0; e = 360.0; }
gmt_map.c:	if (test_pole[1] && !gmt_map_outside (GMT, GMT->current.proj.central_meridian, +90.0)) { n = +90.0; w = 0.0; e = 360.0; }
gmt_map.c:	np = (GMT->current.proj.polar && (GMT->common.R.wesn[YLO] <= -90.0 || GMT->common.R.wesn[YHI] >= 90.0)) ? GMT->current.map.n_lon_nodes + 2: 2 * (GMT->current.map.n_lon_nodes + 1);
gmt_map.c:	if (!gmt_map_outside (GMT, GMT->current.proj.central_meridian, -90.0)) { s = -90.0; w = 0.0; e = 360.0; }
gmt_map.c:	if (!gmt_map_outside (GMT, GMT->current.proj.central_meridian, +90.0)) { n = +90.0; w = 0.0; e = 360.0; }
gmt_map.c:	dx = (xmax - xmin) / GMT->current.map.n_lon_nodes;
gmt_map.c:	dy = (ymax - ymin) / GMT->current.map.n_lat_nodes;
gmt_map.c:	if ((d = gmtlib_great_circle_dist_degree (GMT, GMT->current.proj.central_meridian, GMT->current.proj.pole, w, s)) > GMT->current.proj.f_horizon) beyond = true;
gmt_map.c:	if ((d = gmtlib_great_circle_dist_degree (GMT, GMT->current.proj.central_meridian, GMT->current.proj.pole, e, n)) > GMT->current.proj.f_horizon) beyond = true;
gmt_map.c:	for (i = 0; !beyond && i <= GMT->current.map.n_lon_nodes; i++) {
gmt_map.c:		x = (i == GMT->current.map.n_lon_nodes) ? xmax : xmin + i * dx;
gmt_map.c:		if ((d = gmtlib_great_circle_dist_degree (GMT, GMT->current.proj.central_meridian, GMT->current.proj.pole, lon, lat)) > GMT->current.proj.f_horizon) beyond = true;
gmt_map.c:		if ((d = gmtlib_great_circle_dist_degree (GMT, GMT->current.proj.central_meridian, GMT->current.proj.pole, lon, lat)) > GMT->current.proj.f_horizon) beyond = true;
gmt_map.c:	for (j = 0; !beyond && j <= GMT->current.map.n_lat_nodes; j++) {
gmt_map.c:		y = (j == GMT->current.map.n_lat_nodes) ? ymax : ymin + j * dy;
gmt_map.c:		if ((d = gmtlib_great_circle_dist_degree (GMT, GMT->current.proj.central_meridian, GMT->current.proj.pole, lon, lat)) > GMT->current.proj.f_horizon) beyond = true;
gmt_map.c:		if ((d = gmtlib_great_circle_dist_degree (GMT, GMT->current.proj.central_meridian, GMT->current.proj.pole, lon, lat)) > GMT->current.proj.f_horizon) beyond = true;
gmt_map.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Rectangular region for azimuthal projection extends beyond the horizon\n");
gmt_map.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Please select a region that is completely within the visible hemisphere\n");
gmt_map.c:		dx = GMT->current.map.width + jump;
gmt_map.c:		yy[0] = yy[1] = last_y + (GMT->current.map.width - last_x) * dy / dx;
gmt_map.c:		if (yy[0] < 0.0 || yy[0] > GMT->current.proj.rect[YHI]) return (0);
gmt_map.c:		dx = GMT->current.map.width - jump;
gmt_map.c:		if (yy[0] < 0.0 || yy[0] > GMT->current.proj.rect[YHI]) return (0);
gmt_map.c:	yb -= GMT->current.map.height;	/* Now below the y = 0 line */
gmt_map.c:	yc[1] = GMT->current.map.height;
gmt_map.c:	if (!GMT->current.map.is_world) return (false);
gmt_map.c:	//if (!GMT->current.map.is_world)
gmt_map.c:		i = (x[start] < GMT->current.map.half_width) ? start : start - 1;
gmt_map.c:		i = (x[start] > GMT->current.map.half_width) ? start : start - 1;
gmt_map.c:	if (!GMT->current.plot.n_alloc) gmt_get_plot_array (GMT);
gmt_map.c:	GMT->current.plot.x[0] = x[i];	GMT->current.plot.y[0] = y[i];
gmt_map.c:			(*GMT->current.map.get_crossings) (GMT, xc, yc, x[i1], y[i1], x[i], y[i]);
gmt_map.c:				GMT->current.plot.x[j] = gmtmap_left_boundary (GMT, yc[0]);
gmt_map.c:				GMT->current.plot.x[j] = gmtmap_right_boundary (GMT, yc[0]);
gmt_map.c:			GMT->current.plot.y[j] = yc[0];
gmt_map.c:			if (j >= GMT->current.plot.n_alloc) gmt_get_plot_array (GMT);
gmt_map.c:			GMT->current.plot.x[j] = (x[i] >= GMT->current.map.half_width) ? gmtmap_left_boundary (GMT, y[i]) : x[i];
gmt_map.c:			GMT->current.plot.x[j] = (x[i] < GMT->current.map.half_width) ? gmtmap_right_boundary (GMT, y[i]) : x[i];
gmt_map.c:		GMT->current.plot.y[j] = y[i];
gmt_map.c:		if (j >= GMT->current.plot.n_alloc) gmt_get_plot_array (GMT);
gmt_map.c:		i = (y[start] < GMT->current.map.half_height) ? start : start - 1;
gmt_map.c:		i = (y[start] > GMT->current.map.half_height) ? start : start - 1;
gmt_map.c:		trunc_y = GMT->current.map.height;
gmt_map.c:	if (!GMT->current.plot.n_alloc) gmt_get_plot_array (GMT);
gmt_map.c:	GMT->current.plot.x[0] = x[i];	GMT->current.plot.y[0] = y[i];
gmt_map.c:			GMT->current.plot.x[j] = xc[0];
gmt_map.c:			GMT->current.plot.y[j] = trunc_y;
gmt_map.c:			if (j >= GMT->current.plot.n_alloc) gmt_get_plot_array (GMT);
gmt_map.c:			GMT->current.plot.y[j] = (y[i] >= GMT->current.map.half_height) ? 0.0 : y[i];
gmt_map.c:			GMT->current.plot.y[j] = (y[i] < GMT->current.map.half_height) ? GMT->current.map.height : y[i];
gmt_map.c:		GMT->current.plot.x[j] = x[i];
gmt_map.c:		if (j >= GMT->current.plot.n_alloc) gmt_get_plot_array (GMT);
gmt_map.c:	return (map_flatearth_dist_degree (GMT, x0, y0, x1, y1) * GMT->current.proj.DIST_M_PR_DEG);
gmt_map.c:	if (GMT->current.setting.proj_aux_latitude != GMT_LATSWAP_NONE) {	/* Use selected auxiliary latitude */
gmt_map.c:		lat1 = gmt_lat_swap (GMT, lat1, GMT->current.setting.proj_aux_latitude);
gmt_map.c:		lat2 = gmt_lat_swap (GMT, lat2, GMT->current.setting.proj_aux_latitude);
gmt_map.c:	 * correction given by: 1-ECC2=1-2*F + F*F = GMT->current.proj.one_m_ECC2
gmt_map.c:	thg = atan (GMT->current.proj.one_m_ECC2 * tand (latE));
gmt_map.c:	thg = atan (GMT->current.proj.one_m_ECC2 * tand (latS));
gmt_map.c:	return (2.0 * w * (1.0 + GMT->current.setting.ref_ellipsoid[GMT->current.setting.proj_ellipsoid].flattening * (h1 * sf * (1.0 - sg) - h2 * (1.0 - sf) * sg)));
gmt_map.c:	return (GMT->current.proj.EQ_RAD * map_andoyer_dist_degree (GMT, lon1, lat1, lon2, lat2));
gmt_map.c:	f = GMT->current.setting.ref_ellipsoid[GMT->current.setting.proj_ellipsoid].flattening;
gmt_map.c:		GMT->current.proj.n_geodesic_approx++;	/* Count inaccurate results */
gmt_map.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Near- or actual antipodal points encountered. Precision may be reduced slightly.\n");
gmt_map.c:			GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Near- or actual antipodal points encountered. Precision may be reduced slightly.\n");
gmt_map.c:	GMT->current.proj.n_geodesic_calls++;
gmt_map.c:	return (s * GMT->current.proj.EQ_RAD);
gmt_map.c:	el = GMT->current.proj.ECC2 / GMT->current.proj.one_m_ECC2;
gmt_map.c:	al = tanthi / (e1 * tanthk) + GMT->current.proj.ECC2 * sqrt ((e1 + tanthi * tanthi) / (e1 + tanthk * tanthk));
gmt_map.c:	v1 = GMT->current.proj.EQ_RAD / sqrt (1.0 - GMT->current.proj.ECC2 * sinthk * sinthk);
gmt_map.c:	v2 = GMT->current.proj.EQ_RAD / sqrt (1.0 - GMT->current.proj.ECC2 * sinthi * sinthi);
gmt_map.c:	z1 = v1 * (1.0 - GMT->current.proj.ECC2) * sinthk;
gmt_map.c:	z2 = v2 * (1.0 - GMT->current.proj.ECC2) * sinthi;
gmt_map.c:		if (GMT->current.proj.GMT_convert_latitudes) lat1 = gmt_M_latg_to_latc (GMT, lat1);
gmt_map.c:		if (GMT->current.proj.GMT_convert_latitudes) {
gmt_map.c:	return (map_loxodrome_dist_degree (GMT, lon1, lat1, lon2, lat2) * GMT->current.proj.DIST_M_PR_DEG);
gmt_map.c:		if (GMT->current.proj.GMT_convert_latitudes) {
gmt_map.c:	GMT->current.proj.three_D = (GMT->current.proj.z_project.view_azimuth != 180.0 || GMT->current.proj.z_project.view_elevation != 90.0);
gmt_map.c:	GMT->current.proj.scale[GMT_Z] = GMT->current.proj.z_pars[0];
gmt_map.c:	GMT->current.proj.xyz_pos[GMT_Z] = (GMT->current.proj.scale[GMT_Z] >= 0.0);	/* Increase z up or not */
gmt_map.c:	if (GMT->current.proj.z_level == DBL_MAX) GMT->current.proj.z_level = (GMT->current.proj.xyz_pos[GMT_Z]) ?  GMT->common.R.wesn[ZLO] : GMT->common.R.wesn[ZHI];
gmt_map.c:	switch (GMT->current.proj.xyz_projection[GMT_Z]%3) {	/* Modulo 3 so that GMT_TIME (3) maps to GMT_LINEAR (0) */
gmt_map.c:			zmin = (GMT->current.proj.xyz_pos[GMT_Z]) ? GMT->common.R.wesn[ZLO] : GMT->common.R.wesn[ZHI];
gmt_map.c:			zmax = (GMT->current.proj.xyz_pos[GMT_Z]) ? GMT->common.R.wesn[ZHI] : GMT->common.R.wesn[ZLO];
gmt_map.c:			GMT->current.proj.fwd_z = &gmt_translin;
gmt_map.c:			GMT->current.proj.inv_z = &gmt_itranslin;
gmt_map.c:			if (GMT->common.R.wesn[ZLO] <= 0.0 || GMT->common.R.wesn[ZHI] <= 0.0) {
gmt_map.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error for -Jz -JZ option: limits must be positive for log10 projection\n");
gmt_map.c:			zmin = (GMT->current.proj.xyz_pos[GMT_Z]) ? d_log10 (GMT, GMT->common.R.wesn[ZLO]) : d_log10 (GMT, GMT->common.R.wesn[ZHI]);
gmt_map.c:			zmax = (GMT->current.proj.xyz_pos[GMT_Z]) ? d_log10 (GMT, GMT->common.R.wesn[ZHI]) : d_log10 (GMT, GMT->common.R.wesn[ZLO]);
gmt_map.c:			GMT->current.proj.fwd_z = &gmt_translog10;
gmt_map.c:			GMT->current.proj.inv_z = &gmt_itranslog10;
gmt_map.c:			GMT->current.proj.xyz_pow[GMT_Z] = GMT->current.proj.z_pars[1];
gmt_map.c:			GMT->current.proj.xyz_ipow[GMT_Z] = 1.0 / GMT->current.proj.z_pars[1];
gmt_map.c:			positive = !((GMT->current.proj.xyz_pos[GMT_Z] + (GMT->current.proj.xyz_pow[GMT_Z] > 0.0)) % 2);
gmt_map.c:			zmin = (positive) ? pow (GMT->common.R.wesn[ZLO], GMT->current.proj.xyz_pow[GMT_Z]) : pow (GMT->common.R.wesn[ZHI], GMT->current.proj.xyz_pow[GMT_Z]);
gmt_map.c:			zmax = (positive) ? pow (GMT->common.R.wesn[ZHI], GMT->current.proj.xyz_pow[GMT_Z]) : pow (GMT->common.R.wesn[ZLO], GMT->current.proj.xyz_pow[GMT_Z]);
gmt_map.c:			GMT->current.proj.fwd_z = &gmt_transpowz;
gmt_map.c:			GMT->current.proj.inv_z = &gmt_itranspowz;
gmt_map.c:	if (z_range == 0.0 && GMT->current.proj.compute_scale[GMT_Z])
gmt_map.c:		GMT->current.proj.scale[GMT_Z] = 0.0;	/* No range given, just flat projected map */
gmt_map.c:	else if (GMT->current.proj.compute_scale[GMT_Z])
gmt_map.c:		GMT->current.proj.scale[GMT_Z] /= fabs (z_range);
gmt_map.c:	GMT->current.proj.zmax = z_range * GMT->current.proj.scale[GMT_Z];
gmt_map.c:	GMT->current.proj.origin[GMT_Z] = -zmin * GMT->current.proj.scale[GMT_Z];
gmt_map.c:	if (GMT->current.proj.z_project.view_azimuth >= 360.0) GMT->current.proj.z_project.view_azimuth -= 360.0;
gmt_map.c:	if (GMT->current.proj.z_project.view_azimuth < 0.0)    GMT->current.proj.z_project.view_azimuth += 360.0;
gmt_map.c:	GMT->current.proj.z_project.quadrant = urint (floor (GMT->current.proj.z_project.view_azimuth / 90.0)) + 1;
gmt_map.c:	sincosd (GMT->current.proj.z_project.view_azimuth, &GMT->current.proj.z_project.sin_az, &GMT->current.proj.z_project.cos_az);
gmt_map.c:	sincosd (GMT->current.proj.z_project.view_elevation, &GMT->current.proj.z_project.sin_el, &GMT->current.proj.z_project.cos_el);
gmt_map.c:	switch (GMT->current.proj.projection_GMT) {
gmt_map.c:			easy = GMT->common.R.oblique;
gmt_map.c:	if (!GMT->current.proj.three_D) easy = true;
gmt_map.c:	GMT->current.proj.z_project.xmin = GMT->current.proj.z_project.ymin = DBL_MAX;
gmt_map.c:	GMT->current.proj.z_project.xmax = GMT->current.proj.z_project.ymax = -DBL_MAX;
gmt_map.c:		xx[0] = xx[3] = GMT->current.proj.rect[XLO]; xx[1] = xx[2] = GMT->current.proj.rect[XHI];
gmt_map.c:		yy[0] = yy[1] = GMT->current.proj.rect[YLO]; yy[2] = yy[3] = GMT->current.proj.rect[YHI];
gmt_map.c:			gmt_xy_to_geo (GMT, &GMT->current.proj.z_project.corner_x[i], &GMT->current.proj.z_project.corner_y[i], xx[i], yy[i]);
gmt_map.c:			gmt_xyz_to_xy (GMT, xx[i], yy[i], gmt_z_to_zz(GMT, GMT->common.R.wesn[ZLO]), &x, &y);
gmt_map.c:			GMT->current.proj.z_project.xmin = MIN (GMT->current.proj.z_project.xmin, x);
gmt_map.c:			GMT->current.proj.z_project.xmax = MAX (GMT->current.proj.z_project.xmax, x);
gmt_map.c:			GMT->current.proj.z_project.ymin = MIN (GMT->current.proj.z_project.ymin, y);
gmt_map.c:			GMT->current.proj.z_project.ymax = MAX (GMT->current.proj.z_project.ymax, y);
gmt_map.c:			gmt_xyz_to_xy (GMT, xx[i], yy[i], gmt_z_to_zz(GMT, GMT->common.R.wesn[ZHI]), &x, &y);
gmt_map.c:			GMT->current.proj.z_project.xmin = MIN (GMT->current.proj.z_project.xmin, x);
gmt_map.c:			GMT->current.proj.z_project.xmax = MAX (GMT->current.proj.z_project.xmax, x);
gmt_map.c:			GMT->current.proj.z_project.ymin = MIN (GMT->current.proj.z_project.ymin, y);
gmt_map.c:			GMT->current.proj.z_project.ymax = MAX (GMT->current.proj.z_project.ymax, y);
gmt_map.c:	else if (GMT->current.proj.r > 0.0) {	/* Do not think the next four lines mean anything in this case, just copied from the general case */
gmt_map.c:		GMT->current.proj.z_project.corner_x[0] = GMT->current.proj.z_project.corner_x[3] = (GMT->current.proj.xyz_pos[GMT_X]) ? GMT->common.R.wesn[XLO] : GMT->common.R.wesn[XHI];
gmt_map.c:		GMT->current.proj.z_project.corner_x[1] = GMT->current.proj.z_project.corner_x[2] = (GMT->current.proj.xyz_pos[GMT_X]) ? GMT->common.R.wesn[XHI] : GMT->common.R.wesn[XLO];
gmt_map.c:		GMT->current.proj.z_project.corner_y[0] = GMT->current.proj.z_project.corner_y[1] = (GMT->current.proj.xyz_pos[GMT_Y]) ? GMT->common.R.wesn[YLO] : GMT->common.R.wesn[YHI];
gmt_map.c:		GMT->current.proj.z_project.corner_y[2] = GMT->current.proj.z_project.corner_y[3] = (GMT->current.proj.xyz_pos[GMT_Y]) ? GMT->common.R.wesn[YHI] : GMT->common.R.wesn[YLO];
gmt_map.c:			gmt_xyz_to_xy (GMT, GMT->current.proj.r * (1.0 + x), GMT->current.proj.r * (1.0 + y), gmt_z_to_zz(GMT, GMT->common.R.wesn[ZLO]), &x, &y);
gmt_map.c:			GMT->current.proj.z_project.xmin = MIN (GMT->current.proj.z_project.xmin, x);
gmt_map.c:			GMT->current.proj.z_project.xmax = MAX (GMT->current.proj.z_project.xmax, x);
gmt_map.c:			GMT->current.proj.z_project.ymin = MIN (GMT->current.proj.z_project.ymin, y);
gmt_map.c:			GMT->current.proj.z_project.ymax = MAX (GMT->current.proj.z_project.ymax, y);
gmt_map.c:			gmt_xyz_to_xy (GMT, GMT->current.proj.r * (1.0 + x), GMT->current.proj.r * (1.0 + y), gmt_z_to_zz(GMT, GMT->common.R.wesn[ZHI]), &x, &y);
gmt_map.c:			GMT->current.proj.z_project.xmin = MIN (GMT->current.proj.z_project.xmin, x);
gmt_map.c:			GMT->current.proj.z_project.xmax = MAX (GMT->current.proj.z_project.xmax, x);
gmt_map.c:			GMT->current.proj.z_project.ymin = MIN (GMT->current.proj.z_project.ymin, y);
gmt_map.c:			GMT->current.proj.z_project.ymax = MAX (GMT->current.proj.z_project.ymax, y);
gmt_map.c:		GMT->current.proj.z_project.corner_x[0] = GMT->current.proj.z_project.corner_x[3] = (GMT->current.proj.xyz_pos[GMT_X]) ? GMT->common.R.wesn[XLO] : GMT->common.R.wesn[XHI];
gmt_map.c:		GMT->current.proj.z_project.corner_x[1] = GMT->current.proj.z_project.corner_x[2] = (GMT->current.proj.xyz_pos[GMT_X]) ? GMT->common.R.wesn[XHI] : GMT->common.R.wesn[XLO];
gmt_map.c:		GMT->current.proj.z_project.corner_y[0] = GMT->current.proj.z_project.corner_y[1] = (GMT->current.proj.xyz_pos[GMT_Y]) ? GMT->common.R.wesn[YLO] : GMT->common.R.wesn[YHI];
gmt_map.c:		GMT->current.proj.z_project.corner_y[2] = GMT->current.proj.z_project.corner_y[3] = (GMT->current.proj.xyz_pos[GMT_Y]) ? GMT->common.R.wesn[YHI] : GMT->common.R.wesn[YLO];
gmt_map.c:		for (i = 0; i < GMT->current.map.n_lon_nodes; i++) {	/* S and N */
gmt_map.c:			gmt_geoz_to_xy (GMT, GMT->common.R.wesn[XLO] + i * GMT->current.map.dlon, GMT->common.R.wesn[YLO], GMT->common.R.wesn[ZLO], &x, &y);
gmt_map.c:			GMT->current.proj.z_project.ymin = MIN (GMT->current.proj.z_project.ymin, y);
gmt_map.c:			GMT->current.proj.z_project.ymax = MAX (GMT->current.proj.z_project.ymax, y);
gmt_map.c:			GMT->current.proj.z_project.xmin = MIN (GMT->current.proj.z_project.xmin, x);
gmt_map.c:			GMT->current.proj.z_project.xmax = MAX (GMT->current.proj.z_project.xmax, x);
gmt_map.c:			if (GMT->common.R.wesn[ZHI] != GMT->common.R.wesn[ZLO]) {
gmt_map.c:				gmt_geoz_to_xy (GMT, GMT->common.R.wesn[XLO] + i * GMT->current.map.dlon, GMT->common.R.wesn[YLO], GMT->common.R.wesn[ZHI], &x, &y);
gmt_map.c:				GMT->current.proj.z_project.ymin = MIN (GMT->current.proj.z_project.ymin, y);
gmt_map.c:				GMT->current.proj.z_project.ymax = MAX (GMT->current.proj.z_project.ymax, y);
gmt_map.c:				GMT->current.proj.z_project.xmin = MIN (GMT->current.proj.z_project.xmin, x);
gmt_map.c:				GMT->current.proj.z_project.xmax = MAX (GMT->current.proj.z_project.xmax, x);
gmt_map.c:			gmt_geoz_to_xy (GMT, GMT->common.R.wesn[XLO] + i * GMT->current.map.dlon, GMT->common.R.wesn[YHI], GMT->common.R.wesn[ZLO], &x, &y);
gmt_map.c:			GMT->current.proj.z_project.ymin = MIN (GMT->current.proj.z_project.ymin, y);
gmt_map.c:			GMT->current.proj.z_project.ymax = MAX (GMT->current.proj.z_project.ymax, y);
gmt_map.c:			GMT->current.proj.z_project.xmin = MIN (GMT->current.proj.z_project.xmin, x);
gmt_map.c:			GMT->current.proj.z_project.xmax = MAX (GMT->current.proj.z_project.xmax, x);
gmt_map.c:			if (GMT->common.R.wesn[ZHI] != GMT->common.R.wesn[ZLO]) {
gmt_map.c:				gmt_geoz_to_xy (GMT, GMT->common.R.wesn[XLO] + i * GMT->current.map.dlon, GMT->common.R.wesn[YHI], GMT->common.R.wesn[ZHI], &x, &y);
gmt_map.c:				GMT->current.proj.z_project.ymin = MIN (GMT->current.proj.z_project.ymin, y);
gmt_map.c:				GMT->current.proj.z_project.ymax = MAX (GMT->current.proj.z_project.ymax, y);
gmt_map.c:				GMT->current.proj.z_project.xmin = MIN (GMT->current.proj.z_project.xmin, x);
gmt_map.c:				GMT->current.proj.z_project.xmax = MAX (GMT->current.proj.z_project.xmax, x);
gmt_map.c:		for (i = 0; i < GMT->current.map.n_lat_nodes; i++) {	/* W and E */
gmt_map.c:			gmt_geoz_to_xy (GMT, GMT->common.R.wesn[XLO], GMT->common.R.wesn[YLO] + i * GMT->current.map.dlat, GMT->common.R.wesn[ZLO], &x, &y);
gmt_map.c:			GMT->current.proj.z_project.ymin = MIN (GMT->current.proj.z_project.ymin, y);
gmt_map.c:			GMT->current.proj.z_project.ymax = MAX (GMT->current.proj.z_project.ymax, y);
gmt_map.c:			GMT->current.proj.z_project.xmin = MIN (GMT->current.proj.z_project.xmin, x);
gmt_map.c:			GMT->current.proj.z_project.xmax = MAX (GMT->current.proj.z_project.xmax, x);
gmt_map.c:			if (GMT->common.R.wesn[ZHI] != GMT->common.R.wesn[ZLO]) {
gmt_map.c:				gmt_geoz_to_xy (GMT, GMT->common.R.wesn[XLO], GMT->common.R.wesn[YLO] + i * GMT->current.map.dlat, GMT->common.R.wesn[ZHI], &x, &y);
gmt_map.c:				GMT->current.proj.z_project.ymin = MIN (GMT->current.proj.z_project.ymin, y);
gmt_map.c:				GMT->current.proj.z_project.ymax = MAX (GMT->current.proj.z_project.ymax, y);
gmt_map.c:				GMT->current.proj.z_project.xmin = MIN (GMT->current.proj.z_project.xmin, x);
gmt_map.c:				GMT->current.proj.z_project.xmax = MAX (GMT->current.proj.z_project.xmax, x);
gmt_map.c:			gmt_geoz_to_xy (GMT, GMT->common.R.wesn[XHI], GMT->common.R.wesn[YLO] + i * GMT->current.map.dlat, GMT->common.R.wesn[ZLO], &x, &y);
gmt_map.c:			GMT->current.proj.z_project.ymin = MIN (GMT->current.proj.z_project.ymin, y);
gmt_map.c:			GMT->current.proj.z_project.ymax = MAX (GMT->current.proj.z_project.ymax, y);
gmt_map.c:			GMT->current.proj.z_project.xmin = MIN (GMT->current.proj.z_project.xmin, x);
gmt_map.c:			GMT->current.proj.z_project.xmax = MAX (GMT->current.proj.z_project.xmax, x);
gmt_map.c:			if (GMT->common.R.wesn[ZHI] != GMT->common.R.wesn[ZLO]) {
gmt_map.c:				gmt_geoz_to_xy (GMT, GMT->common.R.wesn[XHI], GMT->common.R.wesn[YLO] + i * GMT->current.map.dlat, GMT->common.R.wesn[ZHI], &x, &y);
gmt_map.c:				GMT->current.proj.z_project.ymin = MIN (GMT->current.proj.z_project.ymin, y);
gmt_map.c:				GMT->current.proj.z_project.ymax = MAX (GMT->current.proj.z_project.ymax, y);
gmt_map.c:				GMT->current.proj.z_project.xmin = MIN (GMT->current.proj.z_project.xmin, x);
gmt_map.c:				GMT->current.proj.z_project.xmax = MAX (GMT->current.proj.z_project.xmax, x);
gmt_map.c:	GMT->current.proj.z_project.face[0] = (GMT->current.proj.z_project.quadrant == 1 || GMT->current.proj.z_project.quadrant == 2) ? 0 : 1;
gmt_map.c:	GMT->current.proj.z_project.face[1] = (GMT->current.proj.z_project.quadrant == 1 || GMT->current.proj.z_project.quadrant == 4) ? 2 : 3;
gmt_map.c:	GMT->current.proj.z_project.face[2] = (GMT->current.proj.z_project.view_elevation >= 0.0) ? 4 : 5;
gmt_map.c:	GMT->current.proj.z_project.draw[0] = (GMT->current.proj.z_project.quadrant == 1 || GMT->current.proj.z_project.quadrant == 4) ? true : false;
gmt_map.c:	GMT->current.proj.z_project.draw[1] = (GMT->current.proj.z_project.quadrant == 3 || GMT->current.proj.z_project.quadrant == 4) ? true : false;
gmt_map.c:	GMT->current.proj.z_project.draw[2] = (GMT->current.proj.z_project.quadrant == 2 || GMT->current.proj.z_project.quadrant == 3) ? true : false;
gmt_map.c:	GMT->current.proj.z_project.draw[3] = (GMT->current.proj.z_project.quadrant == 1 || GMT->current.proj.z_project.quadrant == 2) ? true : false;
gmt_map.c:	GMT->current.proj.z_project.sign[0] = GMT->current.proj.z_project.sign[3] = -1.0;
gmt_map.c:	GMT->current.proj.z_project.sign[1] = GMT->current.proj.z_project.sign[2] = 1.0;
gmt_map.c:	GMT->current.proj.z_project.z_axis = (GMT->current.proj.z_project.quadrant%2) ? GMT->current.proj.z_project.quadrant : GMT->current.proj.z_project.quadrant - 2;
gmt_map.c:	if (GMT->current.proj.z_project.fixed) {
gmt_map.c:		if (!GMT->current.proj.z_project.world_given) {	/* Pick center point of region */
gmt_map.c:			GMT->current.proj.z_project.world_x = (gmt_M_is_geographic (GMT, GMT_IN)) ? GMT->current.proj.central_meridian : 0.5 * (GMT->common.R.wesn[XLO] + GMT->common.R.wesn[XHI]);
gmt_map.c:			GMT->current.proj.z_project.world_y = 0.5 * (GMT->common.R.wesn[YLO] + GMT->common.R.wesn[YHI]);
gmt_map.c:			GMT->current.proj.z_project.world_z = GMT->current.proj.z_level;
gmt_map.c:		gmt_geoz_to_xy (GMT, GMT->current.proj.z_project.world_x, GMT->current.proj.z_project.world_y, GMT->current.proj.z_project.world_z, &x, &y);
gmt_map.c:		if (!GMT->current.proj.z_project.view_given) {	/* Pick center of current page */
gmt_map.c:			GMT->current.proj.z_project.view_x = 0.5 * GMT->current.setting.ps_page_size[0] * GMT->session.u2u[GMT_PT][GMT_INCH];
gmt_map.c:			GMT->current.proj.z_project.view_y = 0.5 * GMT->current.setting.ps_page_size[1] * GMT->session.u2u[GMT_PT][GMT_INCH];
gmt_map.c:		GMT->current.proj.z_project.x_off = GMT->current.proj.z_project.view_x - x;
gmt_map.c:		GMT->current.proj.z_project.y_off = GMT->current.proj.z_project.view_y - y;
gmt_map.c:		GMT->current.proj.z_project.x_off = -GMT->current.proj.z_project.xmin;
gmt_map.c:		GMT->current.proj.z_project.y_off = -GMT->current.proj.z_project.ymin;
gmt_map.c:	GMT->current.proj.z_project.xmin += GMT->current.proj.z_project.x_off;
gmt_map.c:	GMT->current.proj.z_project.xmax += GMT->current.proj.z_project.x_off;
gmt_map.c:	GMT->current.proj.z_project.ymin += GMT->current.proj.z_project.y_off;
gmt_map.c:	GMT->current.proj.z_project.ymax += GMT->current.proj.z_project.y_off;
gmt_map.c:	if (GMT->common.n.periodic[GMT_X] && (dx = fabs (dx)) > GMT->common.n.half_range[GMT_X]) dx = GMT->common.n.range[GMT_X] - dx;
gmt_map.c:	if (GMT->common.n.periodic[GMT_Y] && (dy = fabs (dy)) > GMT->common.n.half_range[GMT_Y]) dy = GMT->common.n.range[GMT_Y] - dy;
gmt_map.c:	int choice = (GMT->current.setting.proj_aux_latitude == GMT_LATSWAP_NONE) ? 0 : 1 + GMT->current.setting.proj_aux_latitude/2;
gmt_map.c:	GMT->current.map.dist[type].scale = 1.0;	/* Default scale */
gmt_map.c:			GMT->current.map.dist[type].func = &gmt_cartesian_dist_periodic;
gmt_map.c:			GMT->current.map.azimuth_func = &map_az_backaz_cartesian;
gmt_map.c:			GMT_Report (GMT->parent, GMT_MSG_DEBUG, "%s distance calculation will be Cartesian [periodic]\n", type_name[type]);
gmt_map.c:			GMT->current.map.dist[type].func = &gmtlib_cartesian_dist;
gmt_map.c:			GMT->current.map.azimuth_func = &map_az_backaz_cartesian;
gmt_map.c:			GMT_Report (GMT->parent, GMT_MSG_DEBUG, "%s distance calculation will be Cartesian\n", type_name[type]);
gmt_map.c:			GMT->current.map.dist[type].func = &map_cartesian_dist2;
gmt_map.c:			GMT->current.map.azimuth_func = &map_az_backaz_cartesian;
gmt_map.c:			GMT_Report (GMT->parent, GMT_MSG_DEBUG, "%s distance calculation will be Cartesian\n", type_name[type]);
gmt_map.c:			GMT->current.map.dist[type].func = &gmtlib_cartesian_dist_proj;
gmt_map.c:			GMT->current.map.azimuth_func = &map_az_backaz_cartesian_proj;
gmt_map.c:			GMT_Report (GMT->parent, GMT_MSG_DEBUG, "%s distance calculation will be Cartesian after first projecting via -J\n", type_name[type]);
gmt_map.c:			GMT->current.map.dist[type].func = &map_cartesian_dist_proj2;
gmt_map.c:			GMT->current.map.azimuth_func = &map_az_backaz_cartesian_proj;
gmt_map.c:			GMT_Report (GMT->parent, GMT_MSG_DEBUG, "%s distance calculation will be Cartesian after first projecting via -J\n", type_name[type]);
gmt_map.c:			GMT->current.map.dist[type].func = &map_flatearth_dist_meter;
gmt_map.c:			GMT->current.map.azimuth_func  = &map_az_backaz_flatearth;
gmt_map.c:			GMT_Report (GMT->parent, GMT_MSG_DEBUG, "%s distance calculation will be Flat Earth in %s\n", type_name[type], unit_name);
gmt_map.c:			GMT->current.map.dist[type].func = &gmt_great_circle_dist_meter;
gmt_map.c:			GMT->current.map.azimuth_func = &map_az_backaz_sphere;
gmt_map.c:			GMT_Report (GMT->parent, GMT_MSG_DEBUG, "%s distance calculation will be using great circle approximation with %s auxiliary latitudes and %s radius = %.4f m, in %s.\n",
gmt_map.c:				type_name[type], aux[choice], rad[GMT->current.setting.proj_mean_radius], GMT->current.proj.mean_radius, unit_name);
gmt_map.c:			GMT->current.map.dist[type].func = GMT->current.map.geodesic_meter;
gmt_map.c:			GMT->current.map.azimuth_func = GMT->current.map.geodesic_az_backaz;
gmt_map.c:			GMT_Report (GMT->parent, GMT_MSG_DEBUG, "%s distance calculation will be using %s geodesics in %s\n", type_name[type], GEOD_TEXT[GMT->current.setting.proj_geodesic], unit_name);
gmt_map.c:			GMT->current.map.dist[type].func = map_flatearth_dist_degree;
gmt_map.c:			GMT->current.map.azimuth_func = &map_az_backaz_flatearth;
gmt_map.c:			GMT_Report (GMT->parent, GMT_MSG_DEBUG, "%s distance calculation will be Flat Earth in %s\n", type_name[type], unit_name);
gmt_map.c:			GMT->current.map.dist[type].func = &gmtlib_great_circle_dist_degree;
gmt_map.c:			GMT->current.map.azimuth_func = &map_az_backaz_sphere;
gmt_map.c:			GMT_Report (GMT->parent, GMT_MSG_DEBUG, "%s distance calculation will be using great circle approximation with %s auxiliary latitudes and return lengths in %s.\n", unit_name,
gmt_map.c:			GMT->current.map.dist[type].func = &map_geodesic_dist_degree;
gmt_map.c:			GMT->current.map.azimuth_func = GMT->current.map.geodesic_az_backaz;
gmt_map.c:			GMT_Report (GMT->parent, GMT_MSG_DEBUG, "%s distance calculation will be using geodesics in %s\n", type_name[type], unit_name);
gmt_map.c:			GMT->current.map.dist[type].func = &map_great_circle_dist_cos;
gmt_map.c:			GMT->current.map.azimuth_func = &map_az_backaz_sphere;
gmt_map.c:			GMT_Report (GMT->parent, GMT_MSG_DEBUG, "%s distance calculation will be using great circle approximation with %s auxiliary latitudes and return cosine of spherical angles.\n",
gmt_map.c:			GMT->current.map.dist[type].func = &map_geodesic_dist_cos;
gmt_map.c:			GMT->current.map.azimuth_func = GMT->current.map.geodesic_az_backaz;
gmt_map.c:			GMT_Report (GMT->parent, GMT_MSG_DEBUG, "%s distance calculation will be using cosine of geodesic angle\n", type_name[type]);
gmt_map.c:			GMT->current.map.dist[type].func = &map_loxodrome_dist_meter;
gmt_map.c:			GMT->current.map.azimuth_func  = &map_az_backaz_loxodrome;
gmt_map.c:			GMT_Report (GMT->parent, GMT_MSG_DEBUG, "%s distance calculation will be along loxodromes in meters\n", type_name[type]);
gmt_map.c:			GMT->current.map.dist[type].func = &map_loxodrome_dist_degree;
gmt_map.c:			GMT->current.map.azimuth_func = &map_az_backaz_loxodrome;
gmt_map.c:			GMT_Report (GMT->parent, GMT_MSG_DEBUG, "%s distance calculation will be along loxodromes with %s auxiliary latitudes and return lengths in degrees.\n",
gmt_map.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Mode (=%d) for distance function is unknown. Must be bug.\n", mode);
gmt_map.c:		GMT->current.map.near_lines_func   = &map_near_lines_cartesian;
gmt_map.c:		GMT->current.map.near_a_line_func  = &map_near_a_line_cartesian;
gmt_map.c:		GMT->current.map.near_point_func   = &map_near_a_point_cartesian;
gmt_map.c:		GMT->current.map.near_lines_func   = &map_near_lines_spherical;
gmt_map.c:		GMT->current.map.near_a_line_func  = &map_near_a_line_spherical;
gmt_map.c:		GMT->current.map.near_point_func   = &map_near_a_point_spherical;
gmt_map.c:	GMT->current.setting.proj_aux_latitude = GMT_LATSWAP_G2O;	/* Geocentric/Geodetic conversion */
gmt_map.c:	GMT->current.setting.proj_mean_radius = GMT_RADIUS_MERIDIONAL;
gmt_map.c:	gmt_geo_to_cart (GMT, plat, plon, GMT->current.proj.o_FP, true);	/* Set forward Cartesian pole o_FP */
gmt_map.c:	gmt_cross3v (GMT, GMT->current.proj.o_FP, P, GMT->current.proj.o_FC);	/* Set forward Cartesian center o_FC */
gmt_map.c:	gmt_normalize3v (GMT, GMT->current.proj.o_FC);
gmt_map.c:	gmt_geo_to_cart (GMT, plat, plon, GMT->current.proj.o_IP, false);	/* Set inverse Cartesian pole o_IP */
gmt_map.c:	gmt_cross3v (GMT, GMT->current.proj.o_IP, P, GMT->current.proj.o_IC);	/* Set inverse Cartesian center o_FC */
gmt_map.c:	gmt_normalize3v (GMT, GMT->current.proj.o_IC);
gmt_map.c:	if (GMT->current.map.on_border_is_outside && fabs (x - GMT->current.proj.rect[XLO]) < GMT_CONV8_LIMIT)
gmt_map.c:		GMT->current.map.this_x_status = -1;
gmt_map.c:	else if (GMT->current.map.on_border_is_outside && fabs (x - GMT->current.proj.rect[XHI]) < GMT_CONV8_LIMIT)
gmt_map.c:		GMT->current.map.this_x_status = 1;
gmt_map.c:	else if (x < GMT->current.proj.rect[XLO] - GMT_CONV8_LIMIT)
gmt_map.c:		GMT->current.map.this_x_status = -2;
gmt_map.c:	else if (x > GMT->current.proj.rect[XHI] + GMT_CONV8_LIMIT)
gmt_map.c:		GMT->current.map.this_x_status = 2;
gmt_map.c:		GMT->current.map.this_x_status = 0;
gmt_map.c:	if (GMT->current.map.on_border_is_outside && fabs (y -GMT->current.proj.rect[YLO]) < GMT_CONV8_LIMIT)
gmt_map.c:		GMT->current.map.this_y_status = -1;
gmt_map.c:	else if (GMT->current.map.on_border_is_outside && fabs (y - GMT->current.proj.rect[YHI]) < GMT_CONV8_LIMIT)
gmt_map.c:		GMT->current.map.this_y_status = 1;
gmt_map.c:	else if (y < GMT->current.proj.rect[YLO] - GMT_CONV8_LIMIT)
gmt_map.c:		GMT->current.map.this_y_status = -2;
gmt_map.c:	else if (y > GMT->current.proj.rect[YHI] + GMT_CONV8_LIMIT)
gmt_map.c:		GMT->current.map.this_y_status = 2;
gmt_map.c:		GMT->current.map.this_y_status = 0;
gmt_map.c:	return ((GMT->current.map.this_x_status != 0 || GMT->current.map.this_y_status != 0) ? true : false);
gmt_map.c:		out_x += GMT->current.map.this_x_status;	/* Completely left of west gives -2 * np, right of east gives + 2 * np */
gmt_map.c:		out_y += GMT->current.map.this_y_status;	/* Completely below south gives -2 * np, above north gives + 2 * np */
gmt_map.c:		out += (abs (GMT->current.map.this_x_status) == 2 || abs (GMT->current.map.this_y_status) == 2);
gmt_map.c:			n = (*GMT->current.map.clip) (GMT, lon, lat, np, x, y, &total_nx);
gmt_map.c:				if (gmt_non_zero_winding (GMT, GMT->common.R.wesn[XLO], GMT->common.R.wesn[YLO], lon, lat, np)) ok = true;		/* true if inside */
gmt_map.c:				if (!ok && gmt_non_zero_winding (GMT, GMT->common.R.wesn[XHI], GMT->common.R.wesn[YLO], lon, lat, np)) ok = true;	/* true if inside */
gmt_map.c:				if (!ok && gmt_non_zero_winding (GMT, GMT->common.R.wesn[XHI], GMT->common.R.wesn[YHI], lon, lat, np)) ok = true;	/* true if inside */
gmt_map.c:				if (!ok && gmt_non_zero_winding (GMT, GMT->common.R.wesn[XLO], GMT->common.R.wesn[YHI], lon, lat, np)) ok = true;	/* true if inside */
gmt_map.c:			else if (GMT->common.R.oblique && GMT->current.proj.projection_GMT == GMT_AZ_EQDIST && n <= 5 && !strncmp (GMT->init.module_name, "pscoast", 7U)) {
gmt_map.c:		n = (*GMT->current.map.clip) (GMT, lon, lat, np, x, y, &total_nx);
gmt_map.c:		L[side] = GMT_Alloc_Segment (GMT->parent, smode, n_alloc, S->n_columns, NULL, NULL);
gmt_map.c:				if (m == n_alloc) L[side] = GMT_Alloc_Segment (GMT->parent, smode, n_alloc << 2, S->n_columns, NULL, L[side]);
gmt_map.c:			if (m == n_alloc) L[side] = GMT_Alloc_Segment (GMT->parent, smode, n_alloc << 2, S->n_columns, NULL, L[side]);
gmt_map.c:		if (m != n_alloc) L[side] = GMT_Alloc_Segment (GMT->parent, smode, m, S->n_columns, NULL, L[side]);
gmt_map.c:	return (GMT->current.map.azimuth_func (GMT, lonE, latE, lonS, latS, baz));
gmt_map.c:	struct GMT_PLOT_AXIS *A = &GMT->current.map.frame.axis[axis];
gmt_map.c:		f = fabs (GMT->current.proj.rect[XHI] - GMT->current.proj.rect[XLO]);
gmt_map.c:		d = fabs (GMT->common.R.wesn[XHI] - GMT->common.R.wesn[XLO]);
gmt_map.c:		f = fabs (GMT->current.proj.rect[YHI] - GMT->current.proj.rect[YLO]);
gmt_map.c:		d = fabs (GMT->common.R.wesn[YHI] - GMT->common.R.wesn[YLO]);
gmt_map.c:		f = fabs (GMT->current.proj.zmax - GMT->current.proj.zmin);
gmt_map.c:		d = fabs (GMT->common.R.wesn[ZHI] - GMT->common.R.wesn[ZLO]);
gmt_map.c:	f *= GMT->session.u2u[GMT_INCH][GMT_PT];	/* Change to points */
gmt_map.c:	d *= MAX (0.05, MIN (5.0 * GMT->current.setting.font_annot[item].size / f, 0.20));
gmt_map.c:		if ((unit == 'H' || unit == 'M') && !strcmp (GMT->current.setting.format_clock_map, "hh:mm:ss")) {
gmt_map.c:			strcpy (GMT->current.setting.format_clock_map, "hh:mm");
gmt_map.c:			gmtlib_clock_C_format (GMT, GMT->current.setting.format_clock_map, &GMT->current.plot.calclock.clock, 2);
gmt_map.c:		else if (unit == 'D' && !strcmp (GMT->current.setting.format_date_map, "yyyy-mm-dd")) {
gmt_map.c:			strcpy (GMT->current.setting.format_date_map, "o dd");
gmt_map.c:			gmtlib_date_C_format (GMT, GMT->current.setting.format_date_map, &GMT->current.plot.calclock.date, 2);
gmt_map.c:		else if (unit == 'O' && !strcmp (GMT->current.setting.format_date_map, "yyyy-mm-dd")) {
gmt_map.c:			strcpy (GMT->current.setting.format_date_map, "o yyyy");
gmt_map.c:			gmtlib_date_C_format (GMT, GMT->current.setting.format_date_map, &GMT->current.plot.calclock.date, 2);
gmt_map.c:	GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Auto-frame interval for axis %d item %d: d = %g  f = %g\n", axis, item, d, f);
gmt_map.c:	GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Auto-frame interval for %c-axis (item %d): %s%s\n", ax_code[axis], item, string, par);
gmt_map.c:	(*GMT->current.proj.fwd_x) (GMT, x, &xx);
gmt_map.c:	return (xx * GMT->current.proj.scale[GMT_X] + GMT->current.proj.origin[GMT_X]);
gmt_map.c:	(*GMT->current.proj.fwd_y) (GMT, y, &yy);
gmt_map.c:	return (yy * GMT->current.proj.scale[GMT_Y] + GMT->current.proj.origin[GMT_Y]);
gmt_map.c:	(*GMT->current.proj.fwd_z) (GMT, z, &zz);
gmt_map.c:	return (zz * GMT->current.proj.scale[GMT_Z] + GMT->current.proj.origin[GMT_Z]);
gmt_map.c:	if (gmt_M_is_dnan (lon) || gmt_M_is_dnan (lat)) {(*x) = (*y) = GMT->session.d_NaN; return true;}	/* Quick and safe way to ensure NaN-input results in NaNs */
gmt_map.c:	(*GMT->current.proj.fwd) (GMT, lon, lat, x, y);
gmt_map.c:	(*x) = (*x) * GMT->current.proj.scale[GMT_X] + GMT->current.proj.origin[GMT_X];
gmt_map.c:	(*y) = (*y) * GMT->current.proj.scale[GMT_Y] + GMT->current.proj.origin[GMT_Y];
gmt_map.c:	if (gmt_M_is_dnan (lon) || gmt_M_is_dnan (lat)) {(*x) = (*y) = GMT->session.d_NaN; return true;}	/* Quick and safe way to ensure NaN-input results in NaNs */
gmt_map.c:	(*GMT->current.proj.fwd) (GMT, lon, lat, x, y);
gmt_map.c:	(*x) = (*x) * GMT->current.proj.scale[GMT_X];
gmt_map.c:	(*y) = (*y) * GMT->current.proj.scale[GMT_Y];
gmt_map.c:	if (gmt_M_is_dnan (lon) || gmt_M_is_dnan (lat)) {(*x) = (*y) = GMT->session.d_NaN; return true;}	/* Quick and safe way to ensure NaN-input results in NaNs */
gmt_map.c:	(*GMT->current.proj.fwd) (GMT, lon, lat, x, y);
gmt_map.c:	if (gmt_M_is_dnan (x) || gmt_M_is_dnan (y)) {(*lon) = (*lat) = GMT->session.d_NaN; return;}	/* Quick and safe way to ensure NaN-input results in NaNs */
gmt_map.c:	x = (x - GMT->current.proj.origin[GMT_X]) * GMT->current.proj.i_scale[GMT_X];
gmt_map.c:	y = (y - GMT->current.proj.origin[GMT_Y]) * GMT->current.proj.i_scale[GMT_Y];
gmt_map.c:	(*GMT->current.proj.inv) (GMT, lon, lat, x, y);
gmt_map.c:	if (gmt_M_is_dnan (x) || gmt_M_is_dnan (y)) {(*lon) = (*lat) = GMT->session.d_NaN; return;}	/* Quick and safe way to ensure NaN-input results in NaNs */
gmt_map.c:	(*GMT->current.proj.inv) (GMT, lon, lat, x, y);
gmt_map.c:	if (gmt_M_is_dnan (x) || gmt_M_is_dnan (y)) {(*lon) = (*lat) = GMT->session.d_NaN; return;}	/* Quick and safe way to ensure NaN-input results in NaNs */
gmt_map.c:	(*GMT->current.proj.inv) (GMT, lon, lat, x, y);
gmt_map.c:	*x_out = - x * GMT->current.proj.z_project.cos_az + y * GMT->current.proj.z_project.sin_az + GMT->current.proj.z_project.x_off;
gmt_map.c:	*y_out = - (x * GMT->current.proj.z_project.sin_az + y * GMT->current.proj.z_project.cos_az) * GMT->current.proj.z_project.sin_el + z * GMT->current.proj.z_project.cos_el + GMT->current.proj.z_project.y_off;
gmt_map.c:	if (GMT->current.proj.projection_GMT == GMT_GENPER && GMT->current.proj.windowed) {
gmt_map.c:			GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Revert to old genper crossing/overlap functions\n");
gmt_map.c:			GMT->current.map.crossing = &map_rect_crossing;
gmt_map.c:			GMT->current.map.overlap = &map_rect_overlap;
gmt_map.c:			GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Switch to new genper crossing/overlap functions\n");
gmt_map.c:			GMT->current.map.crossing = &map_genper_crossing;
gmt_map.c:			GMT->current.map.overlap = &map_genperw_overlap;
gmt_map.c:	GMT->current.map.prev_x_status = GMT->current.map.this_x_status;
gmt_map.c:	GMT->current.map.prev_y_status = GMT->current.map.this_y_status;
gmt_map.c:	if (GMT->current.map.outside == NULL) {
gmt_map.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "gmt_map_outside: FATAL ERROR - the pointer to the projection function is NULL.\n");
gmt_map.c:	return ((*GMT->current.map.outside) (GMT, lon, lat));
gmt_map.c:	switch (GMT->current.proj.projection_GMT) {
gmt_map.c:			if (!GMT->common.R.oblique && GMT->current.map.is_world) {
gmt_map.c:				y -= GMT->current.proj.r;
gmt_map.c:				half_width = d_sqrt (GMT->current.proj.r * GMT->current.proj.r - y * y);
gmt_map.c:				half_width = GMT->current.map.half_width;
gmt_map.c:			if (!GMT->common.R.oblique && gmt_M_360_range (GMT->common.R.wesn[XLO], GMT->common.R.wesn[XHI])) {
gmt_map.c:				y -= GMT->current.proj.r;
gmt_map.c:				half_width = d_sqrt (GMT->current.proj.r * GMT->current.proj.r - y * y);
gmt_map.c:				half_width = GMT->current.map.half_width;
gmt_map.c:			if (!GMT->common.R.oblique && GMT->current.map.is_world)
gmt_map.c:				half_width = gmtmap_right_boundary (GMT, y) - GMT->current.map.half_width;
gmt_map.c:				half_width = GMT->current.map.half_width;
gmt_map.c:			half_width = GMT->current.map.half_width;
gmt_map.c:	if (GMT->current.proj.projection_GMT == GMT_TM)
gmt_map.c:	return (GMT->current.map.dist[id].scale * GMT->current.map.dist[id].func (GMT, lonS, latS, lonE, latE));
gmt_map.c:	return (GMT->current.map.near_point_func (GMT, lon, lat, T, dist));
gmt_map.c:	return (GMT->current.map.near_lines_func (GMT, lon, lat, T, return_mindist, dist_min, x_near, y_near));
gmt_map.c:	return (GMT->current.map.near_a_line_func (GMT, lon, lat, seg, S, return_mindist, dist_min, x_near, y_near));
gmt_map.c:	return (gmtlib_great_circle_dist_degree (GMT, lon1, lat1, lon2, lat2) * GMT->current.proj.DIST_M_PR_DEG);
gmt_map.c:		straddle = (GMT->common.R.wesn[XLO] < 0.0 && GMT->common.R.wesn[XHI] > 0.0);
gmt_map.c:	if (GMT->current.map.meridian_straight == 2) {	/* Special non-sampling for gmtselect/grdlandmask */
gmt_map.c:	if (GMT->current.map.meridian_straight) {	/* Easy, just a straight line connect via quarter-points */
gmt_map.c:	min_gap = 0.1 * GMT->current.setting.map_line_step;
gmt_map.c:	if ((n_alloc = lrint (ceil (fabs (lat2 - lat1) / GMT->current.map.dlat))) == 0) return (0);
gmt_map.c:			if ((*GMT->current.map.jump) (GMT, x0, y0, x1, y1) || (y0 < GMT->current.proj.rect[YLO] || y0 > GMT->current.proj.rect[YHI]))
gmt_map.c:				if (d > GMT->current.setting.map_line_step)
gmt_map.c:	if (GMT->current.map.parallel_straight == 2) {	/* Special non-sampling for gmtselect/grdlandmask */
gmt_map.c:	if (GMT->current.map.parallel_straight) {	/* Easy, just a straight line connection via quarter points */
gmt_map.c:	min_gap = 0.1 * GMT->current.setting.map_line_step;
gmt_map.c:	if ((n_alloc = lrint (ceil (fabs (lon2 - lon1) / GMT->current.map.dlon))) == 0) return (0);	/* Initial guess to path length */
gmt_map.c:			if ((*GMT->current.map.jump) (GMT, x0, y0, x1, y1) || (y0 < GMT->current.proj.rect[YLO] || y0 > GMT->current.proj.rect[YHI]))
gmt_map.c:				if (d > GMT->current.setting.map_line_step)
gmt_map.c:	xm = GMT->current.map.this_x_status - GMT->current.map.prev_x_status;
gmt_map.c:	ym = GMT->current.map.this_y_status - GMT->current.map.prev_y_status;
gmt_map.c:	gmt_M_set_delta_lon (lon0, GMT->current.proj.central_meridian, dlon0);
gmt_map.c:	gmt_M_set_delta_lon (lon1, GMT->current.proj.central_meridian, dlon1);
gmt_map.c:	while (n > GMT->current.plot.n_alloc) gmt_get_plot_array (GMT);
gmt_map.c:		GMT->current.plot.x[0] = last_x;	GMT->current.plot.y[0] = last_y;
gmt_map.c:		GMT->current.plot.pen[np++] = PSL_MOVE;
gmt_map.c:			GMT->current.plot.x[np] = this_x;	GMT->current.plot.y[np] = this_y;
gmt_map.c:			GMT->current.plot.pen[np++] = PSL_MOVE;
gmt_map.c:			if (np == GMT->current.plot.n_alloc) gmt_get_plot_array (GMT);
gmt_map.c:		else if (GMT->current.map.is_world)	/* Check global wrapping if 360 range */
gmt_map.c:			nx = (*GMT->current.map.wrap_around_check) (GMT, dummy, last_x, last_y, this_x, this_y, xx, yy, sides);
gmt_map.c:			GMT->current.plot.x[np] = xx[0];	GMT->current.plot.y[np] = yy[0];
gmt_map.c:			GMT->current.plot.pen[np++] = (this_inside) ? PSL_MOVE|PSL_CLIP : PSL_DRAW|PSL_CLIP;
gmt_map.c:			if (np == GMT->current.plot.n_alloc) gmt_get_plot_array (GMT);
gmt_map.c:				GMT->current.plot.x[np] = xx[0];	GMT->current.plot.y[np] = yy[0];
gmt_map.c:				GMT->current.plot.pen[np++] = (this_inside) ? PSL_DRAW|PSL_CLIP : PSL_MOVE|PSL_CLIP;
gmt_map.c:				if (np == GMT->current.plot.n_alloc) gmt_get_plot_array (GMT);
gmt_map.c:				GMT->current.plot.x[np] = xx[1];	GMT->current.plot.y[np] = yy[1];
gmt_map.c:				GMT->current.plot.pen[np++] = (this_inside) ? PSL_MOVE|PSL_CLIP : PSL_DRAW|PSL_CLIP;
gmt_map.c:				if (np == GMT->current.plot.n_alloc) gmt_get_plot_array (GMT);
gmt_map.c:			if ( np >= GMT->current.plot.n_alloc ) {
gmt_map.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "bad access: cannot access current.plot.x[%" PRIu64 "], np=%" PRIu64 ", GMT->current.plot.n=%" PRIu64 "\n", np, np, GMT->current.plot.n);
gmt_map.c:				GMT->current.plot.x[np] = this_x;	GMT->current.plot.y[np] = this_y;
gmt_map.c:				GMT->current.plot.pen[np++] = PSL_DRAW;
gmt_map.c:			if (np == GMT->current.plot.n_alloc) gmt_get_plot_array (GMT);
gmt_map.c:	if (np) GMT->current.plot.pen[0] |= PSL_MOVE;	/* Sanity override: Gotta start off with new start point */
gmt_map.c:	for (j = n_sections = k = 0; j < np; j++) if (GMT->current.plot.pen[j] & PSL_MOVE) {
gmt_map.c:	if (n_sections == 2 && doubleAlmostEqualZero (GMT->current.plot.x[0], GMT->current.plot.x[np-1]) && doubleAlmostEqualZero (GMT->current.plot.y[0], GMT->current.plot.y[np-1])) {
gmt_map.c:		gmt_M_memcpy (tmp, &GMT->current.plot.x[k], np-k, double);
gmt_map.c:		gmt_M_memcpy (&tmp[np-k], GMT->current.plot.x, k, double);
gmt_map.c:		gmt_M_memcpy (GMT->current.plot.x, tmp, np, double);
gmt_map.c:		gmt_M_memcpy (tmp, &GMT->current.plot.y[k], np-k, double);
gmt_map.c:		gmt_M_memcpy (&tmp[np-k], GMT->current.plot.y, k, double);
gmt_map.c:		gmt_M_memcpy (GMT->current.plot.y, tmp, np, double);
gmt_map.c:		GMT->current.plot.pen[k] = PSL_DRAW;
gmt_map.c:		if (k && GMT->current.plot.pen[k-1] & PSL_CLIP) GMT->current.plot.pen[k-1] = PSL_DRAW;
gmt_map.c:		if (k < (np-1) && GMT->current.plot.pen[k+1] & PSL_CLIP) GMT->current.plot.pen[k+1] = PSL_DRAW;
gmt_map.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "gmt_geo_to_xy_line: Clipping in two separate abutting lines that were joined into a single line\n");
gmt_map.c:	GMT_Report (GMT->parent, GMT_MSG_DEBUG, "gmt_project_init: IN: Inc [%.12g/%.12g] n_columns/n_rows [%u/%u] dpi = %u offset = %u\n",
gmt_map.c:		if (GMT->current.io.inc_code[GMT_X] || GMT->current.io.inc_code[GMT_Y]) {	/* Must convert from distance units to degrees */
gmt_map.c:			GMT->current.io.inc_code[GMT_X] = GMT->current.io.inc_code[GMT_Y] = 0;
gmt_map.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "gmt_project_init: Necessary arguments not set\n");
gmt_map.c:	GMT_Report (GMT->parent, GMT_MSG_DEBUG, "gmt_project_init: OUT: Inc [%.12g/%.12g] n_columns/n_rows [%u/%u] dpi = %u offset = %u\n",
gmt_map.c:	gmt_M_grd_setpad (GMT, header, GMT->current.io.pad);			/* Assign default pad */
gmt_map.c:	GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Grid projection from size %dx%d to %dx%d\n", n_columns, n_rows, header->n_columns, header->n_rows);
gmt_map.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "gmt_grd_project: Input grid does not have sufficient (2) padding\n");
gmt_map.c:	GMT_Report (GMT->parent, GMT_MSG_DEBUG, "gmt_grd_project: In [%.12g/%.12g/%.12g/%.12g] and out [%.12g/%.12g/%.12g/%.12g]\n",
gmt_map.c:	gmt_M_grd_loop (GMT, O, row_out, col_out, ij_out) O->data[ij_out] = GMT->session.f_NaN;	/* So that nodes outside will retain a NaN value */
gmt_map.c:	if (GMT->common.n.antialias) {	/* Blockaverage repeat pixels, at least the first ~32767 of them... */
gmt_map.c:					if (GMT->current.map.outside (GMT, x_in[col_in], y_in[row_in])) continue;	/* Quite possible we are beyond the horizon */
gmt_map.c:				if (GMT->current.proj.projection_GMT == GMT_GENPER && GMT->current.proj.g_outside) continue;	/* We are beyond the horizon */
gmt_map.c:			if (!GMT->common.n.antialias || nz[ij_out] < 2)	/* Just use the interpolated value */
gmt_map.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "gmt_grd_project: Output grid extrema [%g/%g] exceed extrema of input grid [%g/%g] due to resampling\n",
gmt_map.c:		if (GMT->common.n.truncate) {
gmt_map.c:			GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "gmt_grd_project: Output grid clipped to input grid extrema\n");
gmt_map.c:			GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "gmt_grd_project: See option -n+c to clip resampled output range to given input range\n");
gmt_map.c:	if (GMT->common.n.antialias) gmt_M_free (GMT, nz);
gmt_map.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "gmt_img_project: Input image does not have sufficient (2) padding\n");
gmt_map.c:		for (b = 0; b < nb; b++) O->data[nb*ij_out+b] = gmt_M_u255 (GMT->current.setting.color_patch[GMT_NAN][b]);
gmt_map.c:	for (b = 0; b < 4; b++) z_int_bg[b] = gmt_M_u255 (GMT->current.setting.color_patch[GMT_NAN][b]);
gmt_map.c:	if (GMT->common.n.antialias) {	/* Blockaverage repeat pixels, at least the first ~32767 of them... */
gmt_map.c:					if (GMT->current.map.outside (GMT, x_in[col_in], y_in[row_in])) continue;	/* Quite possible we are beyond the horizon */
gmt_map.c:				if (GMT->current.proj.projection_GMT == GMT_GENPER && GMT->current.proj.g_outside) continue;	/* We are beyond the horizon */
gmt_map.c:			if (!GMT->common.n.antialias || nz[ij_out] < 2)	/* Just use the interpolated value */
gmt_map.c:	if (GMT->common.n.antialias) gmt_M_free (GMT, nz);
gmt_map.c:		if (GMT->current.proj.scale[GMT_X] != GMT->current.proj.scale[GMT_Y]) {	/* But allow for different x,y scaling */
gmt_map.c:			angle = d_atan2d (sinaz * GMT->current.proj.scale[GMT_Y], cosaz * GMT->current.proj.scale[GMT_X]);
gmt_map.c:	else if (GMT->current.proj.projection_GMT == GMT_POLAR) {	/* r/theta */
gmt_map.c:	if (gmt_M_360_range (GMT->common.R.wesn[XLO], GMT->common.R.wesn[XHI]) && fabs (dx) > (width = gmt_half_map_width (GMT, y0))) {
gmt_map.c:	if (GMT->common.R.oblique)	/* Rectangular map boundary */
gmt_map.c:		switch (GMT->current.proj.projection_GMT) {
gmt_map.c:				if (GMT->current.proj.got_elevations)
gmt_map.c:					*donut = (GMT->common.R.wesn[YHI] < 90.0 && GMT->current.map.is_world);
gmt_map.c:					*donut = (GMT->common.R.wesn[YLO] > 0.0 && GMT->current.map.is_world);
gmt_map.c:				np = GMT->current.map.n_lon_nodes + 1;
gmt_map.c:				if ((GMT->current.proj.got_elevations && GMT->common.R.wesn[YHI] < 90.0) || (!GMT->current.proj.got_elevations && GMT->common.R.wesn[YLO] > 0.0))	/* Need inside circle segment */
gmt_map.c:				else if (!GMT->current.map.is_world)	/* Need to include origin */
gmt_map.c:				np = (GMT->current.proj.polar && (GMT->common.R.wesn[YLO] <= -90.0 || GMT->common.R.wesn[YHI] >= 90.0)) ? GMT->current.map.n_lon_nodes + 2: 2 * (GMT->current.map.n_lon_nodes + 1);
gmt_map.c:				np = 2 * GMT->current.map.n_lat_nodes + 2;
gmt_map.c:				np = 2 * GMT->current.map.n_lat_nodes + 2;
gmt_map.c:				if (GMT->common.R.wesn[YLO] != -90.0) np += GMT->current.map.n_lon_nodes - 1;
gmt_map.c:				if (GMT->common.R.wesn[YHI] != 90.0) np += GMT->current.map.n_lon_nodes - 1;
gmt_map.c:				np = 2 * (GMT->current.map.n_lon_nodes + GMT->current.map.n_lat_nodes);
gmt_map.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Bad case in gmt_map_clip_path (%d)\n", GMT->current.proj.projection_GMT);
gmt_map.c:	if (GMT->common.R.oblique) {
gmt_map.c:		work_x[0] = work_x[3] = GMT->current.proj.rect[XLO];	work_y[0] = work_y[1] = GMT->current.proj.rect[YLO];
gmt_map.c:		work_x[1] = work_x[2] = GMT->current.proj.rect[XHI];	work_y[2] = work_y[3] = GMT->current.proj.rect[YHI];
gmt_map.c:		switch (GMT->current.proj.projection_GMT) {	/* Fill in clip path */
gmt_map.c:				work_x[0] = work_x[3] = GMT->current.proj.rect[XLO];	work_y[0] = work_y[1] = GMT->current.proj.rect[YLO];
gmt_map.c:				work_x[1] = work_x[2] = GMT->current.proj.rect[XHI];	work_y[2] = work_y[3] = GMT->current.proj.rect[YHI];
gmt_map.c:				for (i = j = 0; i <= GMT->current.map.n_lon_nodes; i++, j++) {
gmt_map.c:					lon = (i == GMT->current.map.n_lon_nodes) ? GMT->common.R.wesn[XHI] : GMT->common.R.wesn[XLO] + i * GMT->current.map.dlon;
gmt_map.c:					gmt_geo_to_xy (GMT, lon, GMT->common.R.wesn[YLO], &work_x[j], &work_y[j]);
gmt_map.c:				for (i = 0; i <= GMT->current.map.n_lon_nodes; i++, j++) {
gmt_map.c:					lon = (i == GMT->current.map.n_lon_nodes) ? GMT->common.R.wesn[XLO] : GMT->common.R.wesn[XHI] - i * GMT->current.map.dlon;
gmt_map.c:					gmt_geo_to_xy (GMT, lon, GMT->common.R.wesn[YHI], &work_x[j], &work_y[j]);
gmt_map.c:				for (i = j = 0; i < GMT->current.map.n_lon_nodes; i++, j++)	/* South */
gmt_map.c:					gmt_geo_to_xy (GMT, GMT->common.R.wesn[XLO] + i * GMT->current.map.dlon, GMT->common.R.wesn[YLO], &work_x[j], &work_y[j]);
gmt_map.c:				for (i = 0; i < GMT->current.map.n_lat_nodes; i++, j++)	/* East */
gmt_map.c:					gmt_geo_to_xy (GMT, GMT->common.R.wesn[XHI], GMT->common.R.wesn[YLO] + i * GMT->current.map.dlat, &work_x[j], &work_y[j]);
gmt_map.c:				for (i = 0; i < GMT->current.map.n_lon_nodes; i++, j++)	/* North */
gmt_map.c:					gmt_geo_to_xy (GMT, GMT->common.R.wesn[XHI] - i * GMT->current.map.dlon, GMT->common.R.wesn[YHI], &work_x[j], &work_y[j]);
gmt_map.c:				for (i = 0; i < GMT->current.map.n_lat_nodes; i++, j++)	/* West */
gmt_map.c:					gmt_geo_to_xy (GMT, GMT->common.R.wesn[XLO], GMT->common.R.wesn[YHI] - i * GMT->current.map.dlat, &work_x[j], &work_y[j]);
gmt_map.c:				r0 = GMT->current.proj.r * GMT->common.R.wesn[YLO] / GMT->common.R.wesn[YHI];
gmt_map.c:						work_x[i] = GMT->current.proj.r * (1.0 + c);
gmt_map.c:						work_y[i] = GMT->current.proj.r * (1.0 + s);
gmt_map.c:						work_x[j] = GMT->current.proj.r + r0 * c;
gmt_map.c:						work_y[j] = GMT->current.proj.r + r0 * s;
gmt_map.c:					da = fabs (GMT->common.R.wesn[XHI] - GMT->common.R.wesn[XLO]) / GMT->current.map.n_lon_nodes;
gmt_map.c:					if (GMT->current.proj.got_elevations) {
gmt_map.c:						for (i = j = 0; i <= GMT->current.map.n_lon_nodes; i++, j++)	/* Draw outer clippath */
gmt_map.c:							gmt_geo_to_xy (GMT, GMT->common.R.wesn[XLO] + i * da, GMT->common.R.wesn[YLO], &work_x[j], &work_y[j]);
gmt_map.c:						if (GMT->common.R.wesn[YHI] < 90.0) {	/* Must do the inner path as well */
gmt_map.c:							for (i = GMT->current.map.n_lon_nodes + 1; i > 0; i--, j++)	/* Draw inner clippath */
gmt_map.c:								gmt_geo_to_xy (GMT, GMT->common.R.wesn[XLO] + (i-1) * da, GMT->common.R.wesn[YHI], &work_x[j], &work_y[j]);
gmt_map.c:						if (doubleAlmostEqual (GMT->common.R.wesn[YHI], 90.0) && !GMT->current.map.is_world)	/* Add origin */
gmt_map.c:							gmt_geo_to_xy (GMT, GMT->common.R.wesn[XLO], GMT->common.R.wesn[YHI], &work_x[j], &work_y[j]);
gmt_map.c:						for (i = j = 0; i <= GMT->current.map.n_lon_nodes; i++, j++)	/* Draw outer clippath */
gmt_map.c:							gmt_geo_to_xy (GMT, GMT->common.R.wesn[XLO] + i * da, GMT->common.R.wesn[YHI], &work_x[j], &work_y[j]);
gmt_map.c:						if (GMT->common.R.wesn[YLO] > 0.0) {	/* Must do the inner path as well */
gmt_map.c:							for (i = GMT->current.map.n_lon_nodes + 1; i > 0; i--, j++)	/* Draw inner clippath */
gmt_map.c:								gmt_geo_to_xy (GMT, GMT->common.R.wesn[XLO] + (i-1) * da, GMT->common.R.wesn[YLO], &work_x[j], &work_y[j]);
gmt_map.c:						if (gmt_M_is_zero (GMT->common.R.wesn[YLO]) && !GMT->current.map.is_world)	/* Add origin */
gmt_map.c:							gmt_geo_to_xy (GMT, GMT->common.R.wesn[XLO], GMT->common.R.wesn[YLO], &work_x[j], &work_y[j]);
gmt_map.c:				do_circle = GMT->current.map.is_world;
gmt_map.c:				if (GMT->current.proj.polar && !do_circle) {
gmt_map.c:					if (GMT->common.R.wesn[YLO] > -90.0) {
gmt_map.c:						for (i = 0; i <= GMT->current.map.n_lon_nodes; i++, j++) {
gmt_map.c:							lon = (i == GMT->current.map.n_lon_nodes) ? GMT->common.R.wesn[XHI] : GMT->common.R.wesn[XLO] + i * GMT->current.map.dlon;
gmt_map.c:							gmt_geo_to_xy (GMT, lon, GMT->common.R.wesn[YLO], &work_x[j], &work_y[j]);
gmt_map.c:						gmt_geo_to_xy (GMT, GMT->common.R.wesn[XLO], -90.0, &work_x[j], &work_y[j]);
gmt_map.c:					if (GMT->common.R.wesn[YHI] < 90.0) {
gmt_map.c:						for (i = 0; i <= GMT->current.map.n_lon_nodes; i++, j++) {
gmt_map.c:							lon = (i == GMT->current.map.n_lon_nodes) ? GMT->common.R.wesn[XLO] : GMT->common.R.wesn[XHI] - i * GMT->current.map.dlon;
gmt_map.c:							gmt_geo_to_xy (GMT, lon, GMT->common.R.wesn[YHI], &work_x[j], &work_y[j]);
gmt_map.c:						gmt_geo_to_xy (GMT, GMT->common.R.wesn[XLO], 90.0, &work_x[j], &work_y[j]);
gmt_map.c:						work_x[i] = GMT->current.proj.r * (1.0 + c);
gmt_map.c:						work_y[i] = GMT->current.proj.r * (1.0 + s);
gmt_map.c:				for (i = j = 0; i <= GMT->current.map.n_lat_nodes; i++, j++) {	/* Right */
gmt_map.c:					lat = (i == GMT->current.map.n_lat_nodes) ? GMT->common.R.wesn[YHI] : GMT->common.R.wesn[YLO] + i * GMT->current.map.dlat;
gmt_map.c:					gmt_geo_to_xy (GMT, GMT->common.R.wesn[XHI], lat, &work_x[j], &work_y[j]);
gmt_map.c:				gmt_geo_to_xy (GMT, GMT->common.R.wesn[XLO], GMT->common.R.wesn[YHI], &work_x[j], &work_y[j]);	j++;
gmt_map.c:				for (i = GMT->current.map.n_lat_nodes; i > 0; j++, i--)	{	/* Left */
gmt_map.c:					gmt_geo_to_xy (GMT, GMT->common.R.wesn[XLO], GMT->common.R.wesn[YLO] + (i-1) * GMT->current.map.dlat, &work_x[j], &work_y[j]);
gmt_map.c:				for (i = j = 0; i <= GMT->current.map.n_lat_nodes; i++, j++) {	/* Right */
gmt_map.c:					lat = (i == GMT->current.map.n_lat_nodes) ? GMT->common.R.wesn[YHI] : GMT->common.R.wesn[YLO] + i * GMT->current.map.dlat;
gmt_map.c:					gmt_geo_to_xy (GMT, GMT->common.R.wesn[XHI], lat, &work_x[j], &work_y[j]);
gmt_map.c:				for (i = 1; GMT->common.R.wesn[YHI] != 90.0 && i < GMT->current.map.n_lon_nodes; i++, j++)
gmt_map.c:					gmt_geo_to_xy (GMT, GMT->common.R.wesn[XHI] - i * GMT->current.map.dlon, GMT->common.R.wesn[YHI], &work_x[j], &work_y[j]);
gmt_map.c:				gmt_geo_to_xy (GMT, GMT->common.R.wesn[XLO], GMT->common.R.wesn[YHI], &work_x[j], &work_y[j]);	j++;
gmt_map.c:				for (i = GMT->current.map.n_lat_nodes; i > 0; j++, i--)	{	/* Left */
gmt_map.c:					gmt_geo_to_xy (GMT, GMT->common.R.wesn[XLO], GMT->common.R.wesn[YLO] + (i-1)* GMT->current.map.dlat, &work_x[j], &work_y[j]);
gmt_map.c:				for (i = 1; GMT->common.R.wesn[YLO] != -90.0 && i < GMT->current.map.n_lon_nodes; i++, j++)
gmt_map.c:					gmt_geo_to_xy (GMT, GMT->common.R.wesn[XLO] + i * GMT->current.map.dlon, GMT->common.R.wesn[YLO], &work_x[j], &work_y[j]);
gmt_map.c:	if (GMT->current.proj.lat_swap_vals.spherical) return (lat);
gmt_map.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "gmt_lat_swap(): Invalid choice, programming bug.\n");
gmt_map.c:	delta = sin2phi * (GMT->current.proj.lat_swap_vals.c[itype][0]
gmt_map.c:		+ cos2phi * (GMT->current.proj.lat_swap_vals.c[itype][1]
gmt_map.c:		+ cos2phi * (GMT->current.proj.lat_swap_vals.c[itype][2]
gmt_map.c:		+ cos2phi * GMT->current.proj.lat_swap_vals.c[itype][3])));
gmt_map.c:	/* Reinitialize GMT->current.proj.EQ_RAD to the appropriate value */
gmt_map.c:	switch (GMT->current.proj.projection_GMT) {
gmt_map.c:			GMT->current.proj.EQ_RAD = GMT->current.proj.lat_swap_vals.rm;
gmt_map.c:			GMT->current.proj.EQ_RAD = GMT->current.proj.lat_swap_vals.ra;
gmt_map.c:	GMT->current.proj.i_EQ_RAD = 1.0 / GMT->current.proj.EQ_RAD;
gmt_map.c:	GMT->current.proj.M_PR_DEG = TWO_PI * GMT->current.proj.EQ_RAD / 360.0;
gmt_map.c:	GMT->current.proj.KM_PR_DEG = GMT->current.proj.M_PR_DEG / METERS_IN_A_KM;
gmt_map.c:	f = GMT->current.setting.ref_ellipsoid[GMT->current.setting.proj_ellipsoid].flattening;
gmt_map.c:	GMT->current.proj.ECC2 = 2.0 * f - f * f;
gmt_map.c:	GMT->current.proj.ECC4 = GMT->current.proj.ECC2 * GMT->current.proj.ECC2;
gmt_map.c:	GMT->current.proj.ECC6 = GMT->current.proj.ECC2 * GMT->current.proj.ECC4;
gmt_map.c:	GMT->current.proj.one_m_ECC2 = 1.0 - GMT->current.proj.ECC2;
gmt_map.c:	GMT->current.proj.i_one_m_ECC2 = 1.0 / GMT->current.proj.one_m_ECC2;
gmt_map.c:	GMT->current.proj.ECC = d_sqrt (GMT->current.proj.ECC2);
gmt_map.c:	GMT->current.proj.half_ECC = 0.5 * GMT->current.proj.ECC;
gmt_map.c:	if (GMT->current.proj.ECC != 0) { /* avoid division by 0 */
gmt_map.c:		GMT->current.proj.i_half_ECC = 0.5 / GMT->current.proj.ECC;	/* Only used in inverse Alberts when e > 0 anyway */
gmt_map.c:	GMT->current.proj.EQ_RAD = GMT->current.setting.ref_ellipsoid[GMT->current.setting.proj_ellipsoid].eq_radius;
gmt_map.c:	GMT->current.proj.i_EQ_RAD = 1.0 / GMT->current.proj.EQ_RAD;
gmt_map.c:	GMT->current.proj.mean_radius = map_mean_radius (GMT, GMT->current.proj.EQ_RAD, f);
gmt_map.c:	GMT->current.proj.M_PR_DEG = TWO_PI * GMT->current.proj.mean_radius / 360.0;
gmt_map.c:	GMT->current.proj.KM_PR_DEG = GMT->current.proj.M_PR_DEG / METERS_IN_A_KM;
gmt_map.c:	GMT->current.proj.DIST_M_PR_DEG = GMT->current.proj.M_PR_DEG;
gmt_map.c:	GMT->current.proj.DIST_KM_PR_DEG = GMT->current.proj.KM_PR_DEG;
gmt_map.c:	switch (GMT->current.setting.proj_geodesic) {
gmt_map.c:			GMT->current.map.geodesic_meter = map_vincenty_dist_meter;
gmt_map.c:			GMT->current.map.geodesic_az_backaz = map_az_backaz_vincenty;
gmt_map.c:			GMT->current.map.geodesic_meter = map_andoyer_dist_meter;
gmt_map.c:			GMT->current.map.geodesic_az_backaz = map_az_backaz_vincenty;	/* This may change later */
gmt_map.c:			GMT->current.map.geodesic_meter = map_rudoe_dist_meter;
gmt_map.c:			GMT->current.map.geodesic_az_backaz = map_az_backaz_rudoe;
gmt_map.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "The PROJ_GEODESIC is not set! - use Vincenty\n");
gmt_map.c:			GMT->current.setting.proj_geodesic = GMT_GEODESIC_VINCENTY;
gmt_map.c:			GMT->current.map.geodesic_meter = map_vincenty_dist_meter;
gmt_map.c:			GMT->current.map.geodesic_az_backaz = map_az_backaz_vincenty;
gmt_map.c:	GMT_Report (GMT->parent, GMT_MSG_DEBUG, "The PROJ_GEODESIC set to %s\n", GEOD_TEXT[GMT->current.setting.proj_geodesic]);
gmt_map.c:	GMT->current.proj.datum.h_given = heights;
gmt_map.c:	gmt_M_memcpy (&GMT->current.proj.datum.from, from, 1, struct GMT_DATUM);
gmt_map.c:	gmt_M_memcpy (&GMT->current.proj.datum.to,   to,   1, struct GMT_DATUM);
gmt_map.c:	GMT->current.proj.datum.da = GMT->current.proj.datum.to.a - GMT->current.proj.datum.from.a;
gmt_map.c:	GMT->current.proj.datum.df = GMT->current.proj.datum.to.f - GMT->current.proj.datum.from.f;
gmt_map.c:		GMT->current.proj.datum.dxyz[k] = -(GMT->current.proj.datum.to.xyz[k] - GMT->current.proj.datum.from.xyz[k]);	/* Since the X, Y, Z are Deltas relative to WGS-84 */
gmt_map.c:	GMT->current.proj.datum.one_minus_f = 1.0 - GMT->current.proj.datum.from.f;
gmt_map.c:	gmt_M_memcpy (&GMT->current.proj.datum.from, D, 1, struct GMT_DATUM);
gmt_map.c:			D->a = GMT->current.setting.ref_ellipsoid[i].eq_radius;
gmt_map.c:			D->f = GMT->current.setting.ref_ellipsoid[i].flattening;
gmt_map.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Malformed <ellipsoid>:<dr> argument!\n");
gmt_map.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Malformed <x>,<y>,<z> OR <x>,<y>,<z>,<wx>,<wy>,<wz>,<sc> arguments!\n");
gmt_map.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Malformed <x>,<y>,<z> argument!\n");
gmt_map.c:			D->a = GMT->current.setting.ref_ellipsoid[i].eq_radius;
gmt_map.c:			D->f = GMT->current.setting.ref_ellipsoid[i].flattening;
gmt_map.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Ellipsoid %s not recognized!\n", ellipsoid);
gmt_map.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Malformed or unrecognized <datum> argument (%s)!\n", text);
gmt_map.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Datum ID (%d) outside valid range (0-%d)!\n", i, GMT_N_DATUMS-1);
gmt_map.c:		if ((k = gmt_get_ellipsoid (GMT, GMT->current.setting.proj_datum[i].ellipsoid)) < 0) {	/* This should not happen... */
gmt_map.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Ellipsoid %s not recognized!\n", GMT->current.setting.proj_datum[i].ellipsoid);
gmt_map.c:		D->a = GMT->current.setting.ref_ellipsoid[k].eq_radius;
gmt_map.c:		D->f = GMT->current.setting.ref_ellipsoid[k].flattening;
gmt_map.c:		for (k = 0; k < 3; k++) D->xyz[k] = GMT->current.setting.proj_datum[i].xyz[k];
gmt_map.c:#define Dx_BF (GMT->current.proj.datum.bursa[0])
gmt_map.c:#define Dy_BF (GMT->current.proj.datum.bursa[1])
gmt_map.c:#define Dz_BF (GMT->current.proj.datum.bursa[2])
gmt_map.c:#define Rx_BF (GMT->current.proj.datum.bursa[3])	/* angles are sec but we need radians */
gmt_map.c:#define Ry_BF (GMT->current.proj.datum.bursa[4])
gmt_map.c:#define Rz_BF (GMT->current.proj.datum.bursa[5])
gmt_map.c:#define M_BF  (GMT->current.proj.datum.bursa[6])
gmt_map.c:	if (GMT->current.proj.datum.bursa[2] && GMT->current.proj.datum.bursa[5]) {	/* Just some cheap heurist to be replaced in final stage */
gmt_map.c:	h = (GMT->current.proj.datum.h_given) ? in[GMT_Z] : 0.0;
gmt_map.c:	M = GMT->current.proj.datum.from.a * (1.0 - GMT->current.proj.datum.from.e_squared) / pow (1.0 - GMT->current.proj.datum.from.e_squared * sin_lat2, 1.5);
gmt_map.c:	N = GMT->current.proj.datum.from.a / sqrt (1.0 - GMT->current.proj.datum.from.e_squared * sin_lat2);
gmt_map.c:	tmp_1 = -GMT->current.proj.datum.dxyz[GMT_X] * sin_lat * cos_lon - GMT->current.proj.datum.dxyz[GMT_Y] * sin_lat * sin_lon + GMT->current.proj.datum.dxyz[GMT_Z] * cos_lat;
gmt_map.c:	tmp_2 = GMT->current.proj.datum.da * (N * GMT->current.proj.datum.from.e_squared * sc_lat) / GMT->current.proj.datum.from.a;
gmt_map.c:	tmp_3 = GMT->current.proj.datum.df * (M / GMT->current.proj.datum.one_minus_f + N * GMT->current.proj.datum.one_minus_f) * sc_lat;
gmt_map.c:	delta_lon = (-GMT->current.proj.datum.dxyz[GMT_X] * sin_lon + GMT->current.proj.datum.dxyz[GMT_Y] * cos_lon) / ((N + h) * cos_lat);
gmt_map.c:	tmp_1 = GMT->current.proj.datum.dxyz[GMT_X] * cos_lat * cos_lon + GMT->current.proj.datum.dxyz[GMT_Y] * cos_lat * sin_lon + GMT->current.proj.datum.dxyz[GMT_Z] * sin_lat;
gmt_map.c:	tmp_2 = -GMT->current.proj.datum.da * GMT->current.proj.datum.from.a / N;
gmt_map.c:	tmp_3 = GMT->current.proj.datum.df * GMT->current.proj.datum.one_minus_f * N * sin_lat2;
gmt_map.c:	if (GMT->current.proj.datum.h_given) out[GMT_Z] = in[GMT_Z] + delta_h;
gmt_map.c:	 * GMT->current.proj.datum.from is always the ellipsoid to use */
gmt_map.c:	N = GMT->current.proj.datum.from.a / d_sqrt (1.0 - GMT->current.proj.datum.from.e_squared * sin_lat * sin_lat);
gmt_map.c:	out[GMT_X] = tmp * cos_lon + GMT->current.proj.datum.from.xyz[GMT_X];
gmt_map.c:	out[GMT_Y] = tmp * sin_lon + GMT->current.proj.datum.from.xyz[GMT_Y];
gmt_map.c:	out[GMT_Z] = (N * (1 - GMT->current.proj.datum.from.e_squared) + in[GMT_Z]) * sin_lat + GMT->current.proj.datum.from.xyz[GMT_Z];
gmt_map.c:	 * GMT->current.proj.datum.from is always the ellipsoid to use */
gmt_map.c:	for (i = 0; i < 3; i++) in_p[i] = in[i] - GMT->current.proj.datum.from.xyz[i];
gmt_map.c:	theta = atan (in_p[GMT_Z] * GMT->current.proj.datum.from.a / (p * GMT->current.proj.datum.from.b));
gmt_map.c:	out[GMT_Y] = atand ((in_p[GMT_Z] + GMT->current.proj.datum.from.ep_squared * GMT->current.proj.datum.from.b * pow (sin_theta, 3.0)) / (p - GMT->current.proj.datum.from.e_squared * GMT->current.proj.datum.from.a * pow (cos_theta, 3.0)));
gmt_map.c:	N = GMT->current.proj.datum.from.a / sqrt (1.0 - GMT->current.proj.datum.from.e_squared * sin_lat * sin_lat);
gmt_map.c:	theta = atan (in[GMT_Z] * GMT->current.proj.datum.to.a / (p * GMT->current.proj.datum.to.b));
gmt_map.c:	out[GMT_Y] = atand ((in[GMT_Z] + GMT->current.proj.datum.to.ep_squared * GMT->current.proj.datum.to.b * pow (sin_theta, 3.0)) / (p - GMT->current.proj.datum.to.e_squared * GMT->current.proj.datum.to.a * pow (cos_theta, 3.0)));
gmt_map.c:	N = GMT->current.proj.datum.to.a / sqrt (1.0 - GMT->current.proj.datum.to.e_squared * sin_lat * sin_lat);
gmt_map.c:	if (project) cum_dist *= GMT->session.u2u[GMT_INCH][GMT->current.setting.proj_length_unit];
gmt_map.c:	if (gmt_M_is_dnan (x[0]) || gmt_M_is_dnan (y[0])) d[0] = GMT->session.d_NaN;
gmt_map.c:			d[this_p] = GMT->session.d_NaN;
gmt_map.c:	if (gmt_M_is_dnan (x[0]) || gmt_M_is_dnan (y[0])) d[0] = GMT->session.d_NaN;
gmt_map.c:					inc = (*GMT->current.map.geodesic_meter) (GMT, x[this_p], y[this_p], x[prev], y[prev]);
gmt_map.c:			d[this_p] = GMT->session.d_NaN;
gmt_map.c:	for (i = 1; i <= GMT->current.map.n_lon_nodes; i++) {
gmt_map.c:		lon = (i == GMT->current.map.n_lon_nodes) ? east + 2.0 * GMT_CONV4_LIMIT : west + i * GMT->current.map.dlon;
gmt_map.c:			if (GMT->current.map.corner > 0) {
gmt_map.c:				X[nc].sides[0] = (GMT->current.map.corner%4 > 1) ? 1 : 3;
gmt_map.c:				if (GMT->current.proj.got_azimuths) X[nc].sides[0] = (X[nc].sides[0] + 2) % 4;
gmt_map.c:				GMT->current.map.corner = 0;
gmt_map.c:		else if (GMT->current.map.is_world)	/* Deal with possibility of wrapping around 360 */
gmt_map.c:			nx = (*GMT->current.map.wrap_around_check) (GMT, X[nc].angle, last_x, last_y, this_x, this_y, X[nc].xx, X[nc].yy, X[nc].sides);
gmt_map.c:		if (nx == 2 && fabs (fabs (X[nc].xx[1] - X[nc].xx[0]) - GMT->current.map.width) < GMT_CONV4_LIMIT && !GMT->current.map.is_world)
gmt_map.c:		else if (nx == 2 && (gap = fabs (X[nc].yy[1] - X[nc].yy[0])) > GMT_CONV4_LIMIT && fabs (gap - GMT->current.map.height) < GMT_CONV4_LIMIT && !GMT->current.map.is_world_tm)
gmt_map.c:	for (j = 1; j <= GMT->current.map.n_lat_nodes; j++) {
gmt_map.c:		lat = (j == GMT->current.map.n_lat_nodes) ? north: south + j * GMT->current.map.dlat;
gmt_map.c:			if (GMT->current.map.corner > 0) {
gmt_map.c:				X[nc].sides[0] = (GMT->current.map.corner < 3) ? 0 : 2;
gmt_map.c:				GMT->current.map.corner = 0;
gmt_map.c:		else if (GMT->current.map.is_world)	/* Deal with possibility of wrapping around 360 */
gmt_map.c:			nx = (*GMT->current.map.wrap_around_check) (GMT, X[nc].angle, last_x, last_y, this_x, this_y, X[nc].xx, X[nc].yy, X[nc].sides);
gmt_map.c:		if (nx == 2 && fabs (fabs (X[nc].xx[1] - X[nc].xx[0]) - GMT->current.map.width) < GMT_CONV4_LIMIT && !GMT->current.map.is_world)
gmt_map.c:		else if (nx == 2 && (gap = fabs (X[nc].yy[1] - X[nc].yy[0])) > GMT_CONV4_LIMIT && fabs (gap - GMT->current.map.height) < GMT_CONV4_LIMIT && !GMT->current.map.is_world_tm)
gmt_map.c:	if (!GMT->common.J.active) {
gmt_map.c:		if (GMT->current.setting.run_mode == GMT_CLASSIC)	/* This is a fatal error in classic mode */
gmt_map.c:		if (!GMT->current.ps.active)
gmt_map.c:		GMT->common.J.active = true;
gmt_map.c:	if (GMT->current.proj.got_elevations) {
gmt_map.c:	if (GMT->common.R.wesn != wesn)		/* In many cases they are both copies of same pointer */
gmt_map.c:		gmt_M_memcpy (GMT->common.R.wesn, wesn, 4, double);
gmt_map.c:	GMT->current.proj.GMT_convert_latitudes = false;
gmt_map.c:	if (GMT->current.proj.gave_map_width) GMT->current.proj.units_pr_degree = false;
gmt_map.c:	GMT->current.map.meridian_straight = GMT->current.map.parallel_straight = 0;
gmt_map.c:	GMT->current.map.n_lon_nodes = GMT->current.map.n_lat_nodes = 0;
gmt_map.c:	GMT->current.map.wrap_around_check = &map_wrap_around_check_x;
gmt_map.c:	GMT->current.map.jump = &map_jump_x;
gmt_map.c:	GMT->current.map.will_it_wrap = &map_will_it_wrap_x;
gmt_map.c:	GMT->current.map.this_point_wraps = &map_this_point_wraps_x;
gmt_map.c:	GMT->current.map.get_crossings = &map_get_crossings_x;
gmt_map.c:	GMT->current.map.lon_wrap = true;
gmt_map.c:	switch (GMT->current.proj.projection) {
gmt_map.c:	if (GMT->current.proj.fwd == NULL)	/* Some wrror in projection projection parameters, return to a horrible death */
gmt_map.c:	GMT->current.proj.search = search;
gmt_map.c:	GMT->current.proj.i_scale[GMT_X] = (GMT->current.proj.scale[GMT_X] != 0.0) ? 1.0 / GMT->current.proj.scale[GMT_X] : 1.0;
gmt_map.c:	GMT->current.proj.i_scale[GMT_Y] = (GMT->current.proj.scale[GMT_Y] != 0.0) ? 1.0 / GMT->current.proj.scale[GMT_Y] : 1.0;
gmt_map.c:	GMT->current.proj.i_scale[GMT_Z] = (GMT->current.proj.scale[GMT_Z] != 0.0) ? 1.0 / GMT->current.proj.scale[GMT_Z] : 1.0;
gmt_map.c:	GMT->current.map.width  = fabs (GMT->current.proj.rect[XHI] - GMT->current.proj.rect[XLO]);
gmt_map.c:	GMT->current.map.height = fabs (GMT->current.proj.rect[YHI] - GMT->current.proj.rect[YLO]);
gmt_map.c:	GMT->current.map.half_width  = 0.5 * GMT->current.map.width;
gmt_map.c:	GMT->current.map.half_height = 0.5 * GMT->current.map.height;
gmt_map.c:		if (GMT->current.proj.central_meridian < GMT->common.R.wesn[XLO] && (GMT->current.proj.central_meridian + 360.0) <= GMT->common.R.wesn[XHI]) GMT->current.proj.central_meridian += 360.0;
gmt_map.c:		if (GMT->current.proj.central_meridian > GMT->common.R.wesn[XHI] && (GMT->current.proj.central_meridian - 360.0) >= GMT->common.R.wesn[XLO]) GMT->current.proj.central_meridian -= 360.0;
gmt_map.c:	if (!GMT->current.map.n_lon_nodes) GMT->current.map.n_lon_nodes = urint (GMT->current.map.width / GMT->current.setting.map_line_step);
gmt_map.c:	if (!GMT->current.map.n_lat_nodes) GMT->current.map.n_lat_nodes = urint (GMT->current.map.height / GMT->current.setting.map_line_step);
gmt_map.c:	search = GMT->current.proj.search;
gmt_map.c:		double_auto[i] = gmt_M_is_geographic (GMT, GMT_IN) && GMT->current.map.frame.set_both &&
gmt_map.c:		GMT->current.map.frame.axis[GMT_X].item[i].active && GMT->current.map.frame.axis[GMT_X].item[i].interval == 0.0 &&
gmt_map.c:		GMT->current.map.frame.axis[GMT_Y].item[i].active && GMT->current.map.frame.axis[GMT_Y].item[i].interval == 0.0;
gmt_map.c:		if (double_auto[i]) GMT->current.map.frame.axis[GMT_X].item[i].interval = GMT->current.map.frame.axis[GMT_Y].item[i].interval =
gmt_map.c:		MAX (GMT->current.map.frame.axis[GMT_X].item[i].interval, GMT->current.map.frame.axis[GMT_Y].item[i].interval);
gmt_map.c:	if (!GMT->current.map.n_lon_nodes) GMT->current.map.n_lon_nodes = urint (GMT->current.map.width / GMT->current.setting.map_line_step);
gmt_map.c:	if (!GMT->current.map.n_lat_nodes) GMT->current.map.n_lat_nodes = urint (GMT->current.map.height / GMT->current.setting.map_line_step);
gmt_map.c:	GMT->current.map.dlon = (GMT->common.R.wesn[XHI] - GMT->common.R.wesn[XLO]) / GMT->current.map.n_lon_nodes;
gmt_map.c:	GMT->current.map.dlat = (GMT->common.R.wesn[YHI] - GMT->common.R.wesn[YLO]) / GMT->current.map.n_lat_nodes;
gmt_map.c:	if (GMT->current.map.width > 400.0 && gmt_M_is_grdmapproject (GMT)) {	/* ***project calling with true scale, probably  */
gmt_map.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "gmt_map_setup perimeter search skipped when using true scale with grdproject or mapproject.\n");
gmt_map.c:		if (GMT->current.proj.projection_GMT == GMT_GENPER)	/* Need special considerations for this projection */
gmt_map.c:			gmtmap_genper_search (GMT, &GMT->common.R.wesn[XLO], &GMT->common.R.wesn[XHI], &GMT->common.R.wesn[YLO], &GMT->common.R.wesn[YHI]);
gmt_map.c:			gmt_wesn_search (GMT, GMT->current.proj.rect[XLO], GMT->current.proj.rect[XHI], GMT->current.proj.rect[YLO], GMT->current.proj.rect[YHI], &GMT->common.R.wesn[XLO], &GMT->common.R.wesn[XHI], &GMT->common.R.wesn[YLO], &GMT->common.R.wesn[YHI]);
gmt_map.c:		GMT->current.map.dlon = (GMT->common.R.wesn[XHI] - GMT->common.R.wesn[XLO]) / GMT->current.map.n_lon_nodes;
gmt_map.c:		GMT->current.map.dlat = (GMT->common.R.wesn[YHI] - GMT->common.R.wesn[YLO]) / GMT->current.map.n_lat_nodes;
gmt_map.c:		if (gmt_M_is_azimuthal(GMT) && GMT->common.R.oblique) map_horizon_search (GMT, wesn[XLO], wesn[XHI], wesn[YLO], wesn[YHI], GMT->current.proj.rect[XLO], GMT->current.proj.rect[XHI], GMT->current.proj.rect[YLO], GMT->current.proj.rect[YHI]);
gmt_map.c:	GMT->current.map.path_step = GMT->current.setting.map_line_step / GMT->current.proj.scale[GMT_X] / GMT->current.proj.M_PR_DEG;
gmt_map.c:	i_scale = 1.0 / (0.0254 * GMT->current.proj.scale[GMT_X]);
gmt_map.c:	scale = 0.001 / (GMT->session.u2u[GMT_INCH][GMT->current.setting.proj_length_unit] * GMT->current.proj.scale[GMT_X]);
gmt_map.c:	GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Map scale is %g km per %s or 1:%g.\n",
gmt_map.c:		scale, GMT->session.unit_name[GMT->current.setting.proj_length_unit], i_scale);
gmt_map.c:		GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Your distance unit (%c) implies geographic data; -fg has been set.\n", unit);
gmt_map.c:	if (gmt_M_is_geographic (GMT, GMT_IN) && GMT->common.j.active) {	/* User specified a -j setting */
gmt_map.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Spherical distance calculation mode: %s.\n", kind[GMT->common.j.active]);
gmt_map.c:			GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Your distance mode (%s) differs from your -j option (%s) which takes precedence.\n", kind[mode], kind[GMT->common.j.active]);
gmt_map.c:		mode = GMT->common.j.mode;	/* Override with what -j said */
gmt_map.c:			GMT->current.map.dist[type].arc = true;	/* Angular measure */
gmt_map.c:			GMT->current.map.dist[type].scale = GMT_DEG2MIN_F;
gmt_map.c:			GMT->current.map.dist[type].arc = true;	/* Angular measure */
gmt_map.c:			GMT->current.map.dist[type].scale = GMT_DEG2SEC_F;
gmt_map.c:			GMT->current.map.dist[type].arc = true;	/* Angular measure */
gmt_map.c:			GMT->current.map.dist[type].scale = 1.0 / METERS_IN_A_FOOT;
gmt_map.c:			GMT->current.map.dist[type].scale = 1.0 / METERS_IN_A_KM;
gmt_map.c:			GMT->current.map.dist[type].scale = 1.0 / METERS_IN_A_MILE;
gmt_map.c:			GMT->current.map.dist[type].scale = 1.0 / METERS_IN_A_NAUTICAL_MILE;
gmt_map.c:			GMT->current.map.dist[type].scale = 1.0 / METERS_IN_A_SURVEY_FOOT;
gmt_map.c:			if (GMT->common.n.periodic[GMT_X] || GMT->common.n.periodic[GMT_Y])
gmt_map.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error: Distance units must be one of %s\n", GMT_LEN_UNITS_DISPLAY);
gmt_map.c:	GMT->current.map.dist[type].init = true;	/* OK, we have now initialized the info for this type */
gmt_map.c:	S = GMT_Alloc_Segment (GMT->parent, GMT_NO_STRINGS, m+4, 2, NULL, NULL);	/* The output segment - allocate array space (+ 4 extra) */
gmt_map.c:				GMT_Report (GMT->parent, GMT_MSG_DEBUG, "gmt_get_smallcircle: Added extra point at %g/%g\n", xx, yy);
gmt_map.c:				GMT_Report (GMT->parent, GMT_MSG_DEBUG, "gmt_get_smallcircle: Added extra point at %g/%g\n", xx, yy);
gmt_map.c:	c = rho / GMT->current.proj.EQ_RAD;
gmt_map.c:	center = (GMT->current.proj.central_meridian < GMT->common.R.wesn[XLO] || GMT->current.proj.central_meridian > GMT->common.R.wesn[XHI]) ? 0.5 * (GMT->common.R.wesn[XLO] + GMT->common.R.wesn[XHI]) : GMT->current.proj.central_meridian;
gmt_map.c:		N = (uint64_t) irint (GMT_ELLIPSE_APPROX * L / GMT->current.setting.map_line_step);
gmt_map.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Ellipse will be approximated by %d-sided polygon\n", N);
gmt_map.c:	S = GMT_Alloc_Segment (GMT->parent, GMT_NO_STRINGS, N+1, 2, NULL, NULL);
gmt_memory.c:	if (!GMT->hidden.mem_set) {
gmt_memory.c:		if (n_cols == 0 && (direction == GMT_NOTSET || (GMT->current.io.record_type[direction] & GMT_READ_DATA))) n_cols = GMT_INITIAL_MEM_COL_ALLOC;	/* Allocate at least this many */
gmt_memory.c:		GMT->hidden.mem_coord  = gmt_M_memory (GMT, GMT->hidden.mem_coord, n_cols, double *);	/* These are all NULL */
gmt_memory.c:		GMT->hidden.mem_cols = n_cols;	/* How many columns we have initialized */
gmt_memory.c:			GMT->hidden.mem_coord[col] = gmt_M_memory (GMT, NULL, GMT_INITIAL_MEM_ROW_ALLOC, double);
gmt_memory.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "GMT memory: Initialize %" PRIuS " temporary column double arrays, each of length : %" PRIuS "\n", GMT->hidden.mem_cols, GMT->hidden.mem_rows);
gmt_memory.c:		GMT->hidden.mem_rows = GMT_INITIAL_MEM_ROW_ALLOC;
gmt_memory.c:	if (direction != GMT_NOTSET && GMT->current.io.record_type[direction] & GMT_READ_TEXT) {	/* For text or mixed records */
gmt_memory.c:		GMT->hidden.mem_txt = gmt_M_memory (GMT, NULL, GMT_INITIAL_MEM_ROW_ALLOC, char *);
gmt_memory.c:		GMT->hidden.mem_rows = GMT_INITIAL_MEM_ROW_ALLOC;
gmt_memory.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "GMT memory: Initialize a temporary column char * array of length : %" PRIuS "\n", GMT->hidden.mem_rows);
gmt_memory.c:	GMT->hidden.mem_set = true;
gmt_memory.c:	GMT->hidden.mem_keeper = M;
gmt_memory.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Could not create log file gmt_memtrack_%d.log\n", pid);
gmt_memory.c:	struct MEMORY_TRACKER *M = GMT->hidden.mem_keeper;
gmt_memory.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Memory tracker reports < 0 bytes allocated!\n");
gmt_memory.c:		fprintf (M->fp, "%s: 0x%zx %10" PRIuS " %7.0lf %s %s\n", mode[kind], (size_t)entry->ptr, entry->size, M->current / 1024.0, GMT->init.module_name, entry->name);
gmt_memory.c:	struct MEMORY_TRACKER *M = GMT->hidden.mem_keeper;
gmt_memory.c:			fprintf (M->fp, "!!!: 0x%zx ---------- %7.0lf %s @%s\n", (size_t)ptr, M->current / 1024.0, GMT->init.module_name, where);
gmt_memory.c:		fprintf (M->fp, "DEL: 0x%zx %10" PRIuS " %7.0lf %s %s\n", (size_t)entry->ptr, entry->size, M->current / 1024.0, GMT->init.module_name, entry->name);
gmt_memory.c:	struct MEMORY_TRACKER *M = GMT->hidden.mem_keeper;
gmt_memory.c:	GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Memory not freed first allocated in %s (ID = %" PRIuS "): %.3f %s [%" PRIuS " bytes]\n", x->name, x->ID, size, unit[u], x->size);
gmt_memory.c:	struct MEMORY_TRACKER *M = GMT->hidden.mem_keeper;
gmt_memory.c:	GMT_Report (GMT->parent, level, "Max total memory allocated was %.3f %s [%" PRIuS " bytes]\n",
gmt_memory.c:	GMT_Report (GMT->parent, level, "Single largest allocation was %.3f %s [%" PRIuS " bytes]\n", size, unit[u], M->largest);
gmt_memory.c:		GMT_Report (GMT->parent, level, "MEMORY NOT FREED: %.3f %s [%" PRIuS " bytes]\n",
gmt_memory.c:	GMT_Report (GMT->parent, level, "Items allocated: %" PRIu64 " reallocated: %" PRIu64 " freed: %" PRIu64 "\n", M->n_allocated, M->n_reallocated, M->n_freed);
gmt_memory.c:		GMT_Report (GMT->parent, level, "Items FREED MULTIPLE TIMES: %" PRIu64 "\n", n_multi_frees);
gmt_memory.c:		GMT_Report (GMT->parent, level, "Items NOT PROPERLY FREED: %" PRIu64 "\n", excess);
gmt_memory.c:	if (GMT->hidden.mem_cols) GMT_Report (GMT->parent, GMT_MSG_DEBUG, "GMT memory: Free %" PRIuS " temporary column arrays, each of length : %" PRIuS "\n", GMT->hidden.mem_cols, GMT->hidden.mem_rows);
gmt_memory.c:	for (col = 0; col < GMT->hidden.mem_cols; col++) {	/* For each column, free an array */
gmt_memory.c:		gmt_M_free (GMT, GMT->hidden.mem_coord[col]);
gmt_memory.c:	gmt_M_free (GMT, GMT->hidden.mem_coord);
gmt_memory.c:	if (GMT->hidden.mem_txt)
gmt_memory.c:		gmt_M_free (GMT, GMT->hidden.mem_txt);
gmt_memory.c:	GMT->hidden.mem_rows = GMT->hidden.mem_cols = 0;
gmt_memory.c:	GMT->hidden.mem_set = false;	/* Back to where we started */
gmt_memory.c:	if (!GMT->hidden.mem_set)
gmt_memory.c:	else if (n_cols > GMT->hidden.mem_cols) {	/* Must allocate more columns, this is expected to happen rarely */
gmt_memory.c:		GMT->hidden.mem_coord = gmt_M_memory (GMT, GMT->hidden.mem_coord, n_cols, double *);	/* New ones are NOT NULL */
gmt_memory.c:		for (col = GMT->hidden.mem_cols; col < n_cols; col++)	/* Explicitly allocate the new additions */
gmt_memory.c:			GMT->hidden.mem_coord[col] = gmt_M_memory (GMT, NULL, GMT->hidden.mem_rows, double);
gmt_memory.c:		GMT->hidden.mem_cols = n_cols;		/* Updated column count */
gmt_memory.c:	if (row < GMT->hidden.mem_rows) return;	/* Nothing to do */
gmt_memory.c:	while (row >= GMT->hidden.mem_rows) GMT->hidden.mem_rows = (size_t)lrint (1.5 * GMT->hidden.mem_rows);	/* Increase by 50% */
gmt_memory.c:	for (col = 0; col < GMT->hidden.mem_cols; col++)	/* Add more memory via realloc */
gmt_memory.c:		GMT->hidden.mem_coord[col] = gmt_M_memory (GMT, GMT->hidden.mem_coord[col], GMT->hidden.mem_rows, double);
gmt_memory.c:	if (direction != GMT_NOTSET && GMT->current.io.record_type[direction] & GMT_READ_TEXT)
gmt_memory.c:		GMT->hidden.mem_txt = gmt_M_memory (GMT, GMT->hidden.mem_txt, GMT->hidden.mem_rows, char *);
gmt_memory.c:	GMT_Report (GMT->parent, GMT_MSG_DEBUG, "GMT memory: Increase %" PRIuS " temporary column arrays to new length : %" PRIuS "\n", GMT->hidden.mem_cols, GMT->hidden.mem_rows);
gmt_memory.c:	if (GMT->hidden.mem_keeper->active)
gmt_memory.c:	if (GMT->hidden.mem_keeper && GMT->hidden.mem_keeper->active) {
gmt_memory.c:	 *	  Allocation size is controlled by GMT->session.min_meminc, unless n > 0 which then is used.
gmt_memory.c:	 *	  previous size, but no more than GMT->session.max_meminc. Note, *ptr[n] is the location
gmt_memory.c:		in_n_alloc = (n == 0) ? GMT->session.min_meminc : n;
gmt_memory.c:		add = MAX (GMT->session.min_meminc, MIN (*n_alloc/2, GMT->session.max_meminc));	/* Suggested increment from 50% rule, but no less than GMT->session.min_meminc */
gmt_memory.c:	return (alloc_level == GMT->hidden.func_level);
gmt_memory.c:	GMT->session.min_meminc = increment;
gmt_memory.c:	GMT->session.min_meminc = GMT_MIN_MEMINC;
gmt_mgg_header2.c:	if ((fp = gmt_fopen (GMT, HH->name, GMT->current.io.r_mode)) == NULL)
gmt_mgg_header2.c:		fp = GMT->session.std[GMT_IN];
gmt_mgg_header2.c:	else if ((fp = gmt_fopen (GMT, HH->name, GMT->current.io.r_mode)) == NULL)
gmt_mgg_header2.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Unrecognized header, expected 0x%04X saw 0x%04X\n",
gmt_mgg_header2.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Invalid grid header size, expected %d, found %d\n",
gmt_mgg_header2.c:		fp = GMT->session.std[GMT_OUT];
gmt_mgg_header2.c:	else if ((fp = gmt_fopen (GMT, HH->name, GMT->current.io.w_mode)) == NULL)
gmt_mgg_header2.c:		fp = GMT->session.std[GMT_IN];
gmt_mgg_header2.c:	else if ((fp = gmt_fopen (GMT, HH->name, GMT->current.io.r_mode)) != NULL) {
gmt_mgg_header2.c:				if (tLong[actual_col[i]] == mggHeader.nanValue) grid[kk] = GMT->session.f_NaN;
gmt_mgg_header2.c:				if (tLong[actual_col[i]] == mggHeader.nanValue) grid[kk] = GMT->session.f_NaN;
gmt_mgg_header2.c:				if (tShort[actual_col[i]] == mggHeader.nanValue) grid[kk] = GMT->session.f_NaN;
gmt_mgg_header2.c:				if (tChar[actual_col[i]] == mggHeader.nanValue) grid[kk] = GMT->session.f_NaN;
gmt_mgg_header2.c:		fp = GMT->session.std[GMT_OUT];
gmt_mgg_header2.c:	else if ((fp = gmt_fopen (GMT, HH->name, GMT->current.io.w_mode)) == NULL)
gmt_modern.c:	if (!API->GMT->current.setting.use_modern_name)
gmt_modern.c:	if (API->GMT->current.setting.use_modern_name || API->GMT->current.setting.run_mode == GMT_MODERN) {	/* Must include the required "gmt " prefix */
gmt_nc.c:		GMT_Report (GMT->parent, level,
gmt_nc.c:	GMT_Report (GMT->parent, GMT_MSG_NORMAL, "%s n_columns:%u n_rows:%u x0:%u y0:%u y-order:%s\n",
gmt_nc.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "stride: %u width: %u\n",
gmt_nc.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "chunked row #%u start-y:%" PRIuS " height:%" PRIuS "\n",
gmt_nc.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "chunked row #%u start-y:%" PRIuS " height:%" PRIuS "\n",
gmt_nc.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE,
gmt_nc.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE,
gmt_nc.c:	if (GMT->current.setting.io_nc4_chunksize[0] == k_netcdf_io_classic)
gmt_nc.c:	if (GMT->current.setting.io_nc4_chunksize[0] != k_netcdf_io_chunked_auto && (
gmt_nc.c:			header->n_rows >= GMT->current.setting.io_nc4_chunksize[0] ||
gmt_nc.c:			header->n_columns >= GMT->current.setting.io_nc4_chunksize[1])) {
gmt_nc.c:		GMT->current.setting.io_nc4_chunksize[0] = k_netcdf_io_classic;
gmt_nc.c:	GMT->current.setting.io_nc4_chunksize[0] = (size_t) ceil (header->n_rows / floor (header->n_rows / chunksize[0]));
gmt_nc.c:	GMT->current.setting.io_nc4_chunksize[1] = (size_t) ceil (header->n_columns / floor (header->n_columns / chunksize[1]));
gmt_nc.c:			if (GMT->current.setting.io_nc4_chunksize[0] != k_netcdf_io_classic) {
gmt_nc.c:				GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "No 2-D array in file %s.  Selecting first 2-D slice in the %d-D array %s\n", HH->name, dim, HH->varname);
gmt_nc.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "\"%s\", %s\n\tIf something bad happens later, try importing via GDAL.\n",
gmt_nc.c:		if (GMT->current.setting.io_nc4_chunksize[0] != k_netcdf_io_classic) {
gmt_nc.c:			gmt_M_err_trap (nc_def_var_chunking (ncid, z_id, NC_CHUNKED, GMT->current.setting.io_nc4_chunksize));
gmt_nc.c:			if (GMT->current.setting.io_nc4_deflation_level) {
gmt_nc.c:				gmt_M_err_trap (nc_def_var_deflate (ncid, ids[1], true, true, GMT->current.setting.io_nc4_deflation_level));
gmt_nc.c:				gmt_M_err_trap (nc_def_var_deflate (ncid, ids[0], true, true, GMT->current.setting.io_nc4_deflation_level));
gmt_nc.c:				gmt_M_err_trap (nc_def_var_deflate (ncid, z_id, true, true, GMT->current.setting.io_nc4_deflation_level));
gmt_nc.c:		} /* GMT->current.setting.io_nc4_chunksize[0] != k_netcdf_io_classic */
gmt_nc.c:					GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "The x-coordinates and range attribute are in conflict; must rely on coordinates only\n");
gmt_nc.c:							GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Grid x-coordinates after pixel registration adjustment have exactly 360 range\n");
gmt_nc.c:					GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "The x-coordinates and range attribute are in conflict but range is exactly 360; we rely on this range\n");
gmt_nc.c:						GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Global longitudes, guessing registration to be %s since nx is odd\n", regtype[header->registration]);
gmt_nc.c:					GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Grid x-coordinates after pixel registration adjustment have exactly 360 range\n");
gmt_nc.c:			GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "No range attribute, guessing registration to be %s\n", regtype[header->registration]);
gmt_nc.c:				GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "No x-coordinates, guessing registration to be %s since nx is odd\n", regtype[header->registration]);
gmt_nc.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "x registration: %u\n", header->registration);
gmt_nc.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "x dummy: %g %g\n", dummy[0], dummy[1]);
gmt_nc.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "x[0] x[nx-1]: %g %g\n", xy[0], xy[header->n_columns-1]);
gmt_nc.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "xinc: %g %g\n", header->inc[GMT_X]);
gmt_nc.c:					GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "The y-coordinates and range attribute are in conflict; must rely on coordinates only\n");
gmt_nc.c:							GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Guessing of registration in conflict between x and y, using %s\n", regtype[header->registration]);
gmt_nc.c:								GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Grid y-coordinates after pixel registration adjustment have exactly 180 range\n");
gmt_nc.c:					GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "The y-coordinates and range attribute are in conflict but range is exactly 180; we rely on this range\n");
gmt_nc.c:						GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Guessing of registration in conflict between x and y, using %s\n", regtype[header->registration]);
gmt_nc.c:					GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Guessing of registration in conflict between x and y, using %s\n", regtype[header->registration]);
gmt_nc.c:					GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Guessing of registration in conflict between x and y, using %s\n", regtype[header->registration]);
gmt_nc.c:						GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Grid y-coordinates after pixel registration adjustment have exactly 180 range\n");
gmt_nc.c:				GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Guessing of registration in conflict between x and y, using %s\n", regtype[header->registration]);
gmt_nc.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "y registration: %u\n", header->registration);
gmt_nc.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "y dummy: %g %g\n", dummy[0], dummy[1]);
gmt_nc.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "y[0] y[ny-1]: %g %g\n", xy[0], xy[header->n_rows-1]);
gmt_nc.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "xinc: %g %g\n", header->inc[GMT_Y]);
gmt_nc.c:			GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "netCDF grid %s information has zmin = zmax = NaN. Reset to 0/0.\n", HH->name);
gmt_nc.c:	GMT_Report (GMT->parent, GMT_MSG_NORMAL, "head->wesn: %g %g %g %g\n",
gmt_nc.c:	GMT_Report (GMT->parent, GMT_MSG_NORMAL, "head->registration:%u\n", header->registration);
gmt_nc.c:	GMT_Report (GMT->parent, GMT_MSG_NORMAL, "head->row_order: %s\n",
gmt_nc.c:	GMT_Report (GMT->parent, GMT_MSG_NORMAL, "head->n_columns: %3d   head->n_rows:%3d\n", header->n_columns, header->n_rows);
gmt_nc.c:	GMT_Report (GMT->parent, GMT_MSG_NORMAL, "head->inc: %g %g\n", header->inc[GMT_X], header->inc[GMT_Y]);
gmt_nc.c:	GMT_Report (GMT->parent, GMT_MSG_NORMAL, "head->mx: %3d   head->my:%3d\n", header->mx, header->my);
gmt_nc.c:	GMT_Report (GMT->parent, GMT_MSG_NORMAL, "head->nm: %3d head->size:%3d\n", header->nm, header->size);
gmt_nc.c:	GMT_Report (GMT->parent, GMT_MSG_NORMAL, "head->t-index %d,%d,%d\n",
gmt_nc.c:	GMT_Report (GMT->parent, GMT_MSG_NORMAL, "head->pad xlo:%u xhi:%u ylo:%u yhi:%u\n",
gmt_nc.c:	GMT_Report (GMT->parent, GMT_MSG_NORMAL, "head->BC  xlo:%u xhi:%u ylo:%u yhi:%u\n",
gmt_nc.c:	GMT_Report (GMT->parent, GMT_MSG_NORMAL, "head->grdtype:%u %u\n", HH->grdtype, GMT_GRID_GEOGRAPHIC_EXACT360_REPEAT);
gmt_nc.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "netCDF Library version: %d\n", *nc_vers);
gmt_nc.c:				GMT_Report(GMT->parent, GMT_MSG_LONG_VERBOSE, "Proj4 string to be converted to WKT:\n\t%s\n", header->ProjRefPROJ4);
gmt_nc.c:					GMT_Report(GMT->parent, GMT_MSG_LONG_VERBOSE, "WKT converted from proj4 string:\n%s\n", header->ProjRefWKT);
gmt_nc.c:					GMT_Report(GMT->parent, GMT_MSG_VERBOSE, "gmtnc_grd_info failed to convert the proj4 string\n%s\n to WKT\n",
gmt_nc.c:		GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Detected %u inconsistent values along east boundary of grid. Values fixed by duplicating west boundary.\n", n_conflicts);
gmt_nc.c:	GMT_Report (GMT->parent, GMT_MSG_NORMAL, "  x-region: %g %g, grid: %g %g\n", wesn[XLO], wesn[XHI], header->wesn[XLO], header->wesn[XHI]);
gmt_nc.c:	GMT_Report (GMT->parent, GMT_MSG_NORMAL, "  y-region: %g %g, grid: %g %g\n", wesn[YLO], wesn[YHI], header->wesn[YLO], header->wesn[YHI]);
gmt_nc.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "col2: %u %u\n", first_col2, last_col2);
gmt_nc.c:	GMT_Report (GMT->parent, GMT_MSG_NORMAL, "-> x-region: %g %g, grid: %g %g\n", wesn[XLO], wesn[XHI], header->wesn[XLO], header->wesn[XHI]);
gmt_nc.c:	GMT_Report (GMT->parent, GMT_MSG_NORMAL, "-> y-region: %g %g, grid: %g %g\n", wesn[YLO], wesn[YHI], header->wesn[YLO], header->wesn[YHI]);
gmt_nc.c:	GMT_Report (GMT->parent, GMT_MSG_NORMAL, "row: %u %u  col: %u %u  r_shift: %d\n", first_row, last_row, first_col, last_col, *n_shift);
gmt_nc.c:	GMT_Report (GMT->parent, GMT_MSG_NORMAL, "origin : %u,%u  dim : %u,%u\n", origin[0], origin[1], dim[0], dim[1]);
gmt_nc.c:	GMT_Report (GMT->parent, GMT_MSG_NORMAL, "origin2: %u,%u  dim2: %u,%u\n", origin2[0], origin2[1], dim2[0], dim2[1]);
gmt_nc.c:			GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "No 2-D array in file %s.  Selecting first 2-D slice in the %d-D array %s\n", HH->name, dim, varname);
gmt_nc.c:	if (GMT->session.grdformat[header->type][0] == 'c')
gmt_nc.c:	else if (GMT->session.grdformat[header->type][0] != 'n')
gmt_nc.c:	GMT_Report (GMT->parent, GMT_MSG_NORMAL, "      wesn: %g %g %g %g\n", wesn[XLO], wesn[XHI], wesn[YLO], wesn[YHI]);
gmt_nc.c:	GMT_Report (GMT->parent, GMT_MSG_NORMAL, "head->wesn: %g %g %g %g\n", header->wesn[XLO], header->wesn[XHI], header->wesn[YLO], header->wesn[YHI]);
gmt_nc.c:	GMT_Report (GMT->parent, GMT_MSG_NORMAL, "head->registration:%u\n", header->registration);
gmt_nc.c:	GMT_Report (GMT->parent, GMT_MSG_NORMAL, "head->row_order: %s\n", HH->row_order == k_nc_start_south ? "S->N" : "N->S");
gmt_nc.c:	GMT_Report (GMT->parent, GMT_MSG_NORMAL, "width:    %3d     height:%3d\n", width, height);
gmt_nc.c:	GMT_Report (GMT->parent, GMT_MSG_NORMAL, "head->n_columns: %3d   head->n_rows:%3d\n", header->n_columns, header->n_rows);
gmt_nc.c:	GMT_Report (GMT->parent, GMT_MSG_NORMAL, "head->mx: %3d   head->my:%3d\n", header->mx, header->my);
gmt_nc.c:	GMT_Report (GMT->parent, GMT_MSG_NORMAL, "head->nm: %3d head->size:%3d\n", header->nm, header->size);
gmt_nc.c:	GMT_Report (GMT->parent, GMT_MSG_NORMAL, "head->t-index %d,%d,%d\n", HH->t_index[0], HH->t_index[1], HH->t_index[2]);
gmt_nc.c:	GMT_Report (GMT->parent, GMT_MSG_NORMAL, "      pad xlo:%u xhi:%u ylo:%u yhi:%u\n", pad[XLO], pad[XHI], pad[YLO], pad[YHI]);
gmt_nc.c:	GMT_Report (GMT->parent, GMT_MSG_NORMAL, "head->pad xlo:%u xhi:%u ylo:%u yhi:%u\n", header->pad[XLO], header->pad[XHI], header->pad[YLO], header->pad[YHI]);
gmt_nc.c:	GMT_Report (GMT->parent, GMT_MSG_NORMAL, "head->BC  xlo:%u xhi:%u ylo:%u yhi:%u\n", HH->BC[XLO], HH->BC[XHI], HH->BC[YLO], HH->BC[YHI]);
gmt_nc.c:	GMT_Report (GMT->parent, GMT_MSG_NORMAL, "head->grdtype:%u %u\n", HH->grdtype, GMT_GRID_GEOGRAPHIC_EXACT360_REPEAT);
gmt_nc.c:	GMT_Report (GMT->parent, GMT_MSG_NORMAL, "imag_offset: %" PRIu64 "\n", imag_offset);
gmt_nc.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "gmtnc_right_shift_grid: %d\n", n_shift);
gmt_nc.c:		GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "No valid values in grid [%s]\n", HH->name);
gmt_nc.c:		GMT_Report (GMT->parent, level,
gmt_nc.c:			GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Precision loss! GMT's internal grid representation is 32-bit float.\n");
gmt_nc.c:			GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "The z-range, [%g,%g], might exceed the significand's precision of 24 bits; round-off errors may occur.\n", header->z_min, header->z_max);
gmt_nc.c:		GMT_Report (GMT->parent, level,
gmt_nc.c:		GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "No valid values in grid [%s]\n", HH->name);
gmt_nc.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Cannot write format %s.\n", GMT->session.grdformat[header->type]);
gmt_nc.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "The packed z-range, [%g,%g], exceeds the maximum representable size. Adjust scale and offset parameters or remove out-of-range values.\n", header->z_min, header->z_max);
gmt_ogrproj.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "OGRPROJ: Translating source SRS failed.\n%s\n", pSrcSRS);
gmt_ogrproj.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "OGRPROJ: Translating target SRS failed.\n%s\n", pDstSRS);
gmt_ogrproj.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Failed to create coordinate transformation between the following\n"
gmt_ogrproj.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Source:\n\n%s\n\n%s\n\n", pszSrcWKT, pszDstWKT);
gmt_ogrproj.c:	gmt_ogrproj_one_pt(GMT->current.gdal_read_in.hCT_fwd, xo, yo, NULL);
gmt_ogrproj.c:	gmt_ogrproj_one_pt(GMT->current.gdal_read_in.hCT_inv, xi, yi, NULL);
gmt_ogrread.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Screammm: No Geometries in this Feature\n");
gmt_ogrread.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Unable to get data from element of a Multi<something>\n");
gmt_ogrread.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Unforeseen case -> unknown geometry type\n");
gmt_ogrread.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Unable to open data source <%s>\n", ogr_filename);
gmt_ogrread.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "No OGR layers available. Bye.\n");
gmt_ogrread.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Importing %lld features from layer <%s>\n",
gmt_parse.c:	GMT_Report (GMT->parent, GMT_MSG_DEBUG, "parse_B_arg_inspector: GMT4 = %d vs. GMT = %d\n", gmt4, gmt5);
gmt_parse.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "parse_B_arg_inspector: Detected GMT >=5 style elements in -B option\n");
gmt_parse.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "parse_B_arg_inspector: Detected GMT 4 style elements in -B option\n");
gmt_parse.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "parse_B_arg_inspector: Detected both GMT 4 and >= style elements in -B option. Unable to parse.\n");
gmt_parse.c:		if (n_slashes) GMT_Report (GMT->parent, GMT_MSG_NORMAL, "parse_B_arg_inspector: Slashes no longer separate axis specifications, use -B[xyz] and repeat\n");
gmt_parse.c:		if (colon_text || n_colons) GMT_Report (GMT->parent, GMT_MSG_NORMAL, "parse_B_arg_inspector: Colons no longer used for titles, labels, prefix, and suffix; see +t, +l, +p, +s\n");
gmt_parse.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "parse_B_arg_inspector: Assume new GMT style format in -B option\n");
gmt_parse.c:			if (!gmt_getinc (GMT, opt->arg, GMT->common.R.inc)) {	/* Successful parsing */
gmt_parse.c:				GMT->common.R.active[ISET] = true;
gmt_parse.c:	if (GMT->common.R.active[ISET])
gmt_parse.c:	GMT_Report (GMT->parent, GMT_MSG_NORMAL, "-R[L|C|R][T|M|B]<x0>/<y0>/<n_columns>/<ny> requires grid spacings via -I\n");
gmt_parse.c:#define Return { GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Found no history for option -%s\n", str); return (-1); }
gmt_parse.c:	remember = (GMT->hidden.func_level == GMT_TOP_MODULE);   /* Only update the history for top level function */
gmt_parse.c:	check_B = (strncmp (GMT->init.module_name, "psscale", 7U) && strncmp (GMT->init.module_name, "docs", 4U));
gmt_parse.c:	if (GMT->current.setting.run_mode == GMT_MODERN && n_B && check_B) {	/* Write gmt.frame file unless module is psscale, overwriting any previous file */
gmt_parse.c:		snprintf (file, PATH_MAX, "%s/gmt%d.%s/gmt.frame", GMT->parent->session_dir, GMT_MAJOR_VERSION, GMT->parent->session_name);
gmt_parse.c:			GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Unable to create file %s\n", file);
gmt_parse.c:		if (GMT->current.setting.run_mode == GMT_MODERN && opt->option == 'B') continue;	/* The -B option is NOT a shorthand option under modern mode */
gmt_parse.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "History: Process -%c%s\n", opt->option, opt->arg);
gmt_parse.c:						gmt_M_str_free (GMT->init.history[z_id]);
gmt_parse.c:						GMT->init.history[z_id] = strdup (&str[1]);
gmt_parse.c:						gmt_M_str_free (GMT->init.history[id]);
gmt_parse.c:						GMT->init.history[id] = strdup (&str[1]);
gmt_parse.c:				if (!GMT->init.history[id]) Return;
gmt_parse.c:				str[1] = GMT->init.history[id][0];
gmt_parse.c:				if (!GMT->init.history[B_id]) Return;
gmt_parse.c:				if (gmt_strtok (GMT->init.history[B_id], B_delim, &pos, p))	/* Get the first argument */
gmt_parse.c:				while (gmt_strtok (GMT->init.history[B_id], B_delim, &pos, p)) {	/* Parse any additional |<component> statements */
gmt_parse.c:					opt2->next = GMT_Make_Option (GMT->parent, 'B', p);	/* Create new struct */
gmt_parse.c:			if (GMT->current.setting.run_mode == GMT_MODERN && opt->option == 'R') {	/* Must deal with both RP and RG under modern mode */
gmt_parse.c:				if (GMT->current.ps.active || !strncmp (GMT->init.module_name, "subplot", 7U) || !strncmp (GMT->init.module_name, "pscoast", 7U) || !strncmp (GMT->init.module_name, "psbasemap", 9U)) {	/* Plotting module plus special options to pscoast and psbasemap: First check RP if it exists */
gmt_parse.c:					if (!GMT->init.history[id]) id++;	/* No RP in the history, try RG next */
gmt_parse.c:					gmt_M_str_free (GMT->init.history[update_id]);
gmt_parse.c:					GMT->init.history[update_id] = strdup (opt->arg);
gmt_parse.c:				if (!GMT->init.history[id]) Return;
gmt_parse.c:				opt->arg = strdup (GMT->init.history[id]);
gmt_parse.c:					if (remember) GMT->init.history[update_id] = strdup (opt->arg);
gmt_parse.c:		gmt_M_str_free (GMT->init.history[B_id]);
gmt_parse.c:		GMT->init.history[B_id] = strdup (B_string);
gmt_parse.c:			API->GMT->current.setting.run_mode = GMT_MODERN;
gmt_parse.c:	if (API->GMT->common.B.mode == 0) API->GMT->common.B.mode = parse_check_b_options (API->GMT, options);	/* Determine the syntax of the -B option(s) */
gmt_parse.c:	API->GMT->current.options = options;
gmt_parse.c:	if (gmt_M_is_geographic (API->GMT, GMT_IN)) API->GMT->current.io.warn_geo_as_cartesion = false;	/* Don't need this warning */
gmt_plot.c:	x_length = GMT->current.proj.rect[XHI] - GMT->current.proj.rect[XLO];
gmt_plot.c:	y_length = GMT->current.proj.rect[YHI] - GMT->current.proj.rect[YLO];
gmt_plot.c:	if (GMT->current.map.frame.draw) {
gmt_plot.c:		if (GMT->current.map.frame.side[W_SIDE]) gmt_xy_axis (GMT, GMT->current.proj.rect[XLO], GMT->current.proj.rect[YLO], y_length, s, n,
gmt_plot.c:			&GMT->current.map.frame.axis[GMT_Y], true, GMT->current.map.frame.side[W_SIDE]);	/* West or left y-axis */
gmt_plot.c:		if (GMT->current.map.frame.side[E_SIDE]) gmt_xy_axis (GMT, GMT->current.proj.rect[XHI], GMT->current.proj.rect[YLO], y_length, s, n,
gmt_plot.c:			&GMT->current.map.frame.axis[GMT_Y], false, GMT->current.map.frame.side[E_SIDE]);	/* East or right y-axis */
gmt_plot.c:		if (GMT->current.map.frame.side[S_SIDE]) gmt_xy_axis (GMT, GMT->current.proj.rect[XLO], GMT->current.proj.rect[YLO], x_length, w, e,
gmt_plot.c:			&GMT->current.map.frame.axis[GMT_X], true, GMT->current.map.frame.side[S_SIDE]);	/* South or lower x-axis */
gmt_plot.c:		if (GMT->current.map.frame.side[N_SIDE]) gmt_xy_axis (GMT, GMT->current.proj.rect[XLO], GMT->current.proj.rect[YHI], x_length, w, e,
gmt_plot.c:			&GMT->current.map.frame.axis[GMT_X], false, GMT->current.map.frame.side[N_SIDE]);	/* North or upper x-axis */
gmt_plot.c:	if (!GMT->current.map.frame.header[0] || GMT->current.map.frame.plotted_header) return;	/* No header today */
gmt_plot.c:	if (!GMT->current.map.frame.draw || GMT->current.map.frame.side[N_SIDE] <= GMT_AXIS_DRAW || GMT->current.setting.map_frame_type == GMT_IS_INSIDE)
gmt_plot.c:		PSL_defunits (PSL, "PSL_H_y", GMT->current.setting.map_title_offset);	/* No ticks or annotations, offset by map_title_offset only */
gmt_plot.c:		PSL_command (PSL, "/PSL_H_y PSL_L_y PSL_LH add %d add def\n", PSL_IZ (PSL, GMT->current.setting.map_title_offset));	/* For title adjustment */
gmt_plot.c:	form = gmt_setfont (GMT, &GMT->current.setting.font_title);
gmt_plot.c:	PSL_plottext (PSL, 0.0, 0.0, -GMT->current.setting.font_title.size, GMT->current.map.frame.header, 0.0, PSL_BC, form);
gmt_plot.c:	GMT->current.map.frame.plotted_header = true;
gmt_plot.c:	if (GMT->hidden.gridline_debug && (GMT->hidden.gridline_kind == 'x' || GMT->hidden.gridline_val != lat)) return;
gmt_plot.c:	if (GMT->hidden.gridline_debug) {
gmt_plot.c:	GMT->current.plot.n = gmt_geo_to_xy_line (GMT, llon, llat, nn);
gmt_plot.c:	if (GMT->hidden.gridline_debug) {
gmt_plot.c:		for (k = 0; k < GMT->current.plot.n; k++) fprintf (fp, "%g\t%g\t%d\n", GMT->current.plot.x[k], GMT->current.plot.y[k], GMT->current.plot.pen[k]);
gmt_plot.c:	if (GMT->current.plot.n > 1) {	/* Need at least 2 points for a line */
gmt_plot.c:		if (GMT->current.map.parallel_straight) {	/* Simplify to a 2-point straight line */
gmt_plot.c:			GMT->current.plot.x[1] = GMT->current.plot.x[GMT->current.plot.n-1];
gmt_plot.c:			GMT->current.plot.y[1] = GMT->current.plot.y[GMT->current.plot.n-1];
gmt_plot.c:			GMT->current.plot.pen[1] = GMT->current.plot.pen[GMT->current.plot.n-1];
gmt_plot.c:			GMT->current.plot.n = 2;
gmt_plot.c:		gmt_plot_line (GMT, GMT->current.plot.x, GMT->current.plot.y, GMT->current.plot.pen, GMT->current.plot.n, PSL_LINEAR);
gmt_plot.c:	if (GMT->hidden.gridline_debug && (GMT->hidden.gridline_kind == 'y' || GMT->hidden.gridline_val != lon)) return;
gmt_plot.c:	if (GMT->hidden.gridline_debug) {
gmt_plot.c:	GMT->current.plot.n = gmt_geo_to_xy_line (GMT, llon, llat, nn);
gmt_plot.c:	if (GMT->hidden.gridline_debug) {
gmt_plot.c:		for (k = 0; k < GMT->current.plot.n; k++) fprintf (fp, "%g\t%g\t%d\n", GMT->current.plot.x[k], GMT->current.plot.y[k], GMT->current.plot.pen[k]);
gmt_plot.c:	if (GMT->current.plot.n > 1) {	/* Need at least 2 points for a line */
gmt_plot.c:		if (GMT->current.map.meridian_straight) {	/* Simplify to a 2-point straight line */
gmt_plot.c:			GMT->current.plot.x[1] = GMT->current.plot.x[GMT->current.plot.n-1];
gmt_plot.c:			GMT->current.plot.y[1] = GMT->current.plot.y[GMT->current.plot.n-1];
gmt_plot.c:			GMT->current.plot.pen[1] = GMT->current.plot.pen[GMT->current.plot.n-1];
gmt_plot.c:			GMT->current.plot.n = 2;
gmt_plot.c:		gmt_plot_line (GMT, GMT->current.plot.x, GMT->current.plot.y, GMT->current.plot.pen, GMT->current.plot.n, PSL_LINEAR);
gmt_plot.c:	p_cap = fabs (GMT->current.setting.map_polar_cap[0]);
gmt_plot.c:	tval = (n - s) * GMT->current.setting.map_line_step / GMT->current.map.height;
gmt_plot.c:	nx = gmtlib_linear_array (GMT, 0.0, TWO_PI, D2R * dval, D2R * GMT->current.map.frame.axis[GMT_X].phase, &x);
gmt_plot.c:			if ((GMT->current.plot.n = gmt_geo_to_xy_line (GMT, &lon[nc1], &lat[nc1], npc)) == 0) continue;
gmt_plot.c:			if ((GMT->current.plot.n = gmt_geo_to_xy_line (GMT, lon, lat, j)) == 0) continue;
gmt_plot.c:		gmt_plot_line (GMT, GMT->current.plot.x, GMT->current.plot.y, GMT->current.plot.pen, GMT->current.plot.n, PSL_LINEAR);
gmt_plot.c:		nx = gmtlib_linear_array (GMT, 0.0, TWO_PI, D2R * GMT->current.setting.map_polar_cap[1], D2R * GMT->current.map.frame.axis[GMT_X].phase, &x);
gmt_plot.c:			if ((GMT->current.plot.n = gmt_geo_to_xy_line (GMT, lon, lat, nc1+1)) > 0)
gmt_plot.c:				gmt_plot_line (GMT, GMT->current.plot.x, GMT->current.plot.y, GMT->current.plot.pen, GMT->current.plot.n, PSL_LINEAR);
gmt_plot.c:			if ((GMT->current.plot.n = gmt_geo_to_xy_line (GMT, &lon[nc2], &lat[nc2], j-nc2)) > 0)
gmt_plot.c:				gmt_plot_line (GMT, GMT->current.plot.x, GMT->current.plot.y, GMT->current.plot.pen, GMT->current.plot.n, PSL_LINEAR);
gmt_plot.c:	if (GMT->current.proj.z_down) {
gmt_plot.c:		ny = gmtlib_linear_array (GMT, 0.0, n-s, dval, GMT->current.map.frame.axis[GMT_Y].phase, &y);
gmt_plot.c:			y[i] = GMT->common.R.wesn[YHI] - y[i];	/* These are the radial values needed for positioning */
gmt_plot.c:		ny = gmtlib_linear_array (GMT, s, n, dval, GMT->current.map.frame.axis[GMT_Y].phase, &y);
gmt_plot.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Draw %s = %g from %g to %g\n", type, y[i], w, e);
gmt_plot.c:	ny = gmtlib_linear_array (GMT, -M_PI_2, M_PI_2, D2R * dval, D2R * GMT->current.map.frame.axis[GMT_Y].phase, &y);
gmt_plot.c:	tval = (e - w) * GMT->current.setting.map_line_step / GMT->current.map.width;
gmt_plot.c:		if ((GMT->current.plot.n = gmt_geo_to_xy_line (GMT, lon, lat, np)) == 0) continue;
gmt_plot.c:		gmt_plot_line (GMT, GMT->current.plot.x, GMT->current.plot.y, GMT->current.plot.pen, GMT->current.plot.n, PSL_LINEAR);
gmt_plot.c:	p_cap = fabs (GMT->current.setting.map_polar_cap[0]);
gmt_plot.c:		p_cap = D2R * GMT->current.setting.map_polar_cap[0];
gmt_plot.c:		if ((GMT->current.plot.n = gmt_geo_to_xy_line (GMT, lon, lat, np)) > 0)
gmt_plot.c:			gmt_plot_line (GMT, GMT->current.plot.x, GMT->current.plot.y, GMT->current.plot.pen, GMT->current.plot.n, PSL_LINEAR);
gmt_plot.c:		if ((GMT->current.plot.n = gmt_geo_to_xy_line (GMT, lon, lat, np)) > 0)
gmt_plot.c:			gmt_plot_line (GMT, GMT->current.plot.x, GMT->current.plot.y, GMT->current.plot.pen, GMT->current.plot.n, PSL_LINEAR);
gmt_plot.c:	nx = gmtlib_time_array (GMT, w, e, &GMT->current.map.frame.axis[GMT_X].item[item], &x);
gmt_plot.c:	ny = gmtlib_time_array (GMT, s, n, &GMT->current.map.frame.axis[GMT_Y].item[item], &y);
gmt_plot.c:	if (!GMT->common.R.oblique) return shift;	/* Return zero if not an oblique projection */
gmt_plot.c:		if (gmt_M_360_range (val, GMT->common.R.wesn_orig[XLO])) val = GMT->common.R.wesn_orig[XLO];
gmt_plot.c:		else if (gmt_M_360_range (val, GMT->common.R.wesn_orig[XHI])) val = GMT->common.R.wesn_orig[XHI];
gmt_plot.c:		if (doubleAlmostEqualZero (val, GMT->common.R.wesn_orig[XLO])) shift = +GMT_CONV4_LIMIT * fabs (GMT->common.R.wesn_orig[XHI] - GMT->common.R.wesn_orig[XLO]);	/* Add this to lon to get a slightly larger longitude to ensure crossing */
gmt_plot.c:		else if (doubleAlmostEqualZero (val, GMT->common.R.wesn_orig[XHI])) shift = -GMT_CONV4_LIMIT * fabs (GMT->common.R.wesn_orig[XHI] - GMT->common.R.wesn_orig[XLO]);	/* Add this to lon to get a slightly smaller longitude to ensure crossing */
gmt_plot.c:		if (doubleAlmostEqualZero (val, GMT->common.R.wesn_orig[YLO])) shift = +GMT_CONV4_LIMIT * fabs (GMT->common.R.wesn_orig[YHI] - GMT->common.R.wesn_orig[YLO]);	/* Add this to lon to get a slightly larger longitude to ensure crossing */
gmt_plot.c:		else if (doubleAlmostEqualZero (val, GMT->common.R.wesn_orig[YHI])) shift = -GMT_CONV4_LIMIT * fabs (GMT->common.R.wesn_orig[YHI] - GMT->common.R.wesn_orig[YLO]);	/* Add this to lon to get a slightly smaller longitude to ensure crossing */
gmt_plot.c:	if (shift != 0.0) GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Adjusted argument %g by %g\n", val, shift);
gmt_plot.c:	shift[0] =  GMT->current.setting.map_frame_width * s;
gmt_plot.c:	shift[1] = -GMT->current.setting.map_frame_width * c;
gmt_plot.c:		T = &GMT->current.map.frame.axis[GMT_X].item[item[k]];
gmt_plot.c:			shade = (urint (floor ((w - GMT->current.map.frame.axis[GMT_X].phase)/ dx))) % 2;
gmt_plot.c:			w1 = floor ((w - GMT->current.map.frame.axis[GMT_X].phase)/ dx) * dx + GMT->current.map.frame.axis[GMT_X].phase;
gmt_plot.c:				PSL_setcolor (PSL, shade ? GMT->current.setting.map_frame_pen.rgb : GMT->PSL->init.page_rgb, PSL_IS_STROKE);
gmt_plot.c:				if (GMT->current.map.frame.side[S_SIDE] & GMT_AXIS_TICK) {
gmt_plot.c:				if (GMT->current.map.frame.side[N_SIDE] & GMT_AXIS_TICK) {
gmt_plot.c:	dr = 0.5 * GMT->current.setting.map_frame_width;
gmt_plot.c:	radius_s = hypot (x1 - GMT->current.proj.c_x0, y1 - GMT->current.proj.c_y0);
gmt_plot.c:	radius_n = hypot (x2 - GMT->current.proj.c_x0, y2 - GMT->current.proj.c_y0);
gmt_plot.c:		T = &GMT->current.map.frame.axis[GMT_X].item[item[k]];
gmt_plot.c:			shade = urint (floor ((w - GMT->current.map.frame.axis[GMT_X].phase) / dx)) % 2;
gmt_plot.c:			w1 = floor ((w - GMT->current.map.frame.axis[GMT_X].phase)/dx) * dx + GMT->current.map.frame.axis[GMT_X].phase;
gmt_plot.c:				PSL_setcolor (PSL, shade ? GMT->current.setting.map_frame_pen.rgb : GMT->PSL->init.page_rgb, PSL_IS_STROKE);
gmt_plot.c:				if (GMT->current.map.frame.side[S_SIDE] & GMT_AXIS_TICK) {
gmt_plot.c:					az1 = d_atan2d (y1 - GMT->current.proj.c_y0, x1 - GMT->current.proj.c_x0);
gmt_plot.c:					az2 = d_atan2d (y2 - GMT->current.proj.c_y0, x2 - GMT->current.proj.c_x0);
gmt_plot.c:					if (GMT->current.proj.north_pole) {
gmt_plot.c:						PSL_plotarc (PSL, GMT->current.proj.c_x0, GMT->current.proj.c_y0, radius_s+scale[k]*dr, az2, az1, PSL_MOVE|PSL_STROKE);
gmt_plot.c:						PSL_plotarc (PSL, GMT->current.proj.c_x0, GMT->current.proj.c_y0, radius_s-scale[k]*dr, az1, az2, PSL_MOVE|PSL_STROKE);
gmt_plot.c:				if (GMT->current.map.frame.side[N_SIDE] & GMT_AXIS_TICK) {
gmt_plot.c:					az1 = d_atan2d (y1 - GMT->current.proj.c_y0, x1 - GMT->current.proj.c_x0);
gmt_plot.c:					az2 = d_atan2d (y2 - GMT->current.proj.c_y0, x2 - GMT->current.proj.c_x0);
gmt_plot.c:					if (GMT->current.proj.north_pole) {
gmt_plot.c:						PSL_plotarc (PSL, GMT->current.proj.c_x0, GMT->current.proj.c_y0, radius_n-scale[k]*dr, az2, az1, PSL_MOVE|PSL_STROKE);
gmt_plot.c:						PSL_plotarc (PSL, GMT->current.proj.c_x0, GMT->current.proj.c_y0, radius_n+scale[k]*dr, az1, az2, PSL_MOVE|PSL_STROKE);
gmt_plot.c:		T = &GMT->current.map.frame.axis[GMT_Y].item[item[k]];
gmt_plot.c:			shade = urint (floor ((s - GMT->current.map.frame.axis[GMT_Y].phase) / dy)) % 2;
gmt_plot.c:			s1 = floor((s - GMT->current.map.frame.axis[GMT_Y].phase)/dy) * dy + GMT->current.map.frame.axis[GMT_Y].phase;
gmt_plot.c:				PSL_setcolor (PSL, shade ? GMT->current.setting.map_frame_pen.rgb : GMT->PSL->init.page_rgb, PSL_IS_STROKE);
gmt_plot.c:				if (GMT->current.map.frame.side[W_SIDE] & GMT_AXIS_TICK) {
gmt_plot.c:				if (GMT->current.map.frame.side[E_SIDE] & GMT_AXIS_TICK) {
gmt_plot.c:	if (!GMT->current.map.frame.side[side]) return;	/* Do not draw this frame side */
gmt_plot.c:	Ldx = (GMT->current.setting.map_frame_type == GMT_IS_ROUNDED) ? 0.0 : GMT->current.setting.map_frame_width * c;
gmt_plot.c:	Ldy = (GMT->current.setting.map_frame_type == GMT_IS_ROUNDED) ? 0.0 : GMT->current.setting.map_frame_width * s;
gmt_plot.c:	dx =  GMT->current.setting.map_frame_width * s;
gmt_plot.c:	dy = -GMT->current.setting.map_frame_width * c;
gmt_plot.c:	if (!GMT->current.map.frame.side[side]) return;
gmt_plot.c:	width = GMT->current.setting.map_frame_width;
gmt_plot.c:	escl = (GMT->current.setting.map_frame_type == GMT_IS_ROUNDED) ? 0.0 : 1.0;	/* Want rounded corners */
gmt_plot.c:	radius = hypot (x1 - GMT->current.proj.c_x0, y1 - GMT->current.proj.c_y0);
gmt_plot.c:	s = ((GMT->current.proj.north_pole && side == 2) || (!GMT->current.proj.north_pole && side == 0)) ? -1.0 : +1.0;	/* North: needs shorter radius.  South: Needs longer radius (opposite in S hemi) */
gmt_plot.c:		PSL_plotarc (PSL, GMT->current.proj.c_x0, GMT->current.proj.c_y0, radius, 0.0, 360.0, PSL_MOVE|PSL_STROKE);
gmt_plot.c:		PSL_plotarc (PSL, GMT->current.proj.c_x0, GMT->current.proj.c_y0, radius + r_inc, 0.0, 360.0, PSL_MOVE|PSL_STROKE);
gmt_plot.c:		if (secondary_too) PSL_plotarc (PSL, GMT->current.proj.c_x0, GMT->current.proj.c_y0, radius + 2.0 * r_inc, 0.0, 360.0, PSL_MOVE|PSL_STROKE);
gmt_plot.c:		az1 = d_atan2d (y1 - GMT->current.proj.c_y0, x1 - GMT->current.proj.c_x0);
gmt_plot.c:		az2 = d_atan2d (y2 - GMT->current.proj.c_y0, x2 - GMT->current.proj.c_x0);
gmt_plot.c:		if (!GMT->current.proj.north_pole) gmt_M_double_swap (az1, az2);	/* In S hemisphere, must draw in opposite direction */
gmt_plot.c:		PSL_plotarc (PSL, GMT->current.proj.c_x0, GMT->current.proj.c_y0, radius, az1-da0, az2+da0, PSL_MOVE|PSL_STROKE);
gmt_plot.c:		PSL_plotarc (PSL, GMT->current.proj.c_x0, GMT->current.proj.c_y0, radius + r_inc, az1-da, az2+da, PSL_MOVE|PSL_STROKE);
gmt_plot.c:			PSL_plotarc (PSL, GMT->current.proj.c_x0, GMT->current.proj.c_y0, radius + r_inc, az1-da, az2+da, PSL_MOVE|PSL_STROKE);
gmt_plot.c:	if (GMT->current.setting.map_frame_type != GMT_IS_ROUNDED) return;	/* Only do this if rounded corners are requested */
gmt_plot.c:	width = ((secondary_too) ? 0.5 : 1.0) * fabs (GMT->current.setting.map_frame_width);
gmt_plot.c:		if (GMT->current.map.frame.side[S_SIDE] && GMT->current.map.frame.side[E_SIDE]) {
gmt_plot.c:		if (GMT->current.map.frame.side[E_SIDE] && GMT->current.map.frame.side[N_SIDE]) {
gmt_plot.c:		if (GMT->current.map.frame.side[N_SIDE] && GMT->current.map.frame.side[W_SIDE]) {
gmt_plot.c:		if (GMT->current.map.frame.side[W_SIDE] && GMT->current.map.frame.side[S_SIDE]) {
gmt_plot.c:		if ((gmt_M_is_azimuthal(GMT) || gmt_M_is_conical(GMT)) && GMT->current.map.frame.side[W_SIDE] && GMT->current.map.frame.side[E_SIDE]) {	/* Round off the pointy head? */
gmt_plot.c:			if (doubleAlmostEqual (GMT->common.R.wesn[YHI], 90.0)) {
gmt_plot.c:			else if (doubleAlmostEqual (GMT->common.R.wesn[YLO], -90.0)) {
gmt_plot.c:	gmt_setpen (GMT, &GMT->current.setting.map_frame_pen);
gmt_plot.c:	if (GMT->current.map.frame.side[W_SIDE] && GMT->current.map.frame.side[E_SIDE] && GMT->current.map.frame.side[S_SIDE] && GMT->current.map.frame.side[N_SIDE]) {
gmt_plot.c:	if (GMT->current.map.frame.side[W_SIDE]) {	/* West */
gmt_plot.c:	if (GMT->current.map.frame.side[E_SIDE]) {	/* East */
gmt_plot.c:	if (GMT->current.map.frame.side[S_SIDE]) {	/* South */
gmt_plot.c:	if (GMT->current.map.frame.side[N_SIDE]) {	/* North */
gmt_plot.c:	gmt_setpen (GMT, &GMT->current.setting.map_frame_pen);
gmt_plot.c:		if (GMT->current.map.frame.side[this]) n_sides++;
gmt_plot.c:	GMT_Report (GMT->parent, GMT_MSG_DEBUG, "plot_wesn_map_boundary n_sides = %" PRIu64 "\n", n_sides);
gmt_plot.c:		if (!GMT->current.map.frame.side[this]) {	/* Side to be skipped */
gmt_plot.c:		if (!GMT->current.map.frame.side[next]) flag |= PSL_STROKE;	/* Must stroke line since a gap follows */
gmt_plot.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "plot_wesn_map_boundary doing side %d with flag = %d\n", this, flag);
gmt_plot.c:	if (!(GMT->current.setting.map_frame_type & GMT_IS_FANCY)) {	/* Draw plain boundary and return */
gmt_plot.c:	PSL_setcolor (PSL, GMT->current.setting.map_frame_pen.rgb, PSL_IS_STROKE);
gmt_plot.c:	fat_pen = fabs (GMT->current.setting.map_frame_width) * GMT->session.u2u[GMT_INCH][GMT_PT];
gmt_plot.c:	if (GMT->current.map.frame.axis[GMT_Y].item[GMT_TICK_LOWER].active) {	/* Need two-layer frame */
gmt_plot.c:	PSL_setcolor (PSL, GMT->current.setting.map_frame_pen.rgb, PSL_IS_STROKE);
gmt_plot.c:	gmt_setpen (GMT, &GMT->current.setting.map_frame_pen);
gmt_plot.c:	if (GMT->current.map.frame.side[W_SIDE] & GMT_AXIS_DRAW) PSL_plotsegment (PSL, x0, y0, x0, y1);	/* West */
gmt_plot.c:	if (GMT->current.map.frame.side[E_SIDE] & GMT_AXIS_DRAW) PSL_plotsegment (PSL, x1, y0, x1, y1);	/* East */
gmt_plot.c:	if (GMT->current.map.frame.side[S_SIDE] & GMT_AXIS_DRAW) PSL_plotsegment (PSL, x0, y0, x1, y0);	/* South */
gmt_plot.c:	if (GMT->current.map.frame.side[N_SIDE] & GMT_AXIS_DRAW) PSL_plotsegment (PSL, x0, y1, x1, y1);	/* North */
gmt_plot.c:	if (GMT->common.R.oblique) { /* Draw rectangular boundary and return */
gmt_plot.c:		plot_rect_map_boundary (GMT, PSL, 0.0, 0.0, GMT->current.proj.rect[XHI], GMT->current.proj.rect[YHI]);
gmt_plot.c:	if (!GMT->current.proj.north_pole && gmt_M_is_Spole (s)) /* Cannot have southern boundary */
gmt_plot.c:		GMT->current.map.frame.side[S_SIDE] = GMT_AXIS_NONE;
gmt_plot.c:	if (GMT->current.proj.north_pole && gmt_M_is_Npole (n)) /* Cannot have northern boundary */
gmt_plot.c:		GMT->current.map.frame.side[N_SIDE] = GMT_AXIS_NONE;
gmt_plot.c:		GMT->current.map.frame.side[E_SIDE] = GMT->current.map.frame.side[W_SIDE] = GMT_AXIS_NONE;
gmt_plot.c:	if (!(GMT->current.setting.map_frame_type & GMT_IS_FANCY)) {	/* Draw plain boundary and return */
gmt_plot.c:	fat_pen = fabs (GMT->current.setting.map_frame_width) * GMT->session.u2u[GMT_INCH][GMT_PT];
gmt_plot.c:	if (GMT->current.map.frame.axis[GMT_Y].item[GMT_TICK_LOWER].active) {	/* Need two-layer frame */
gmt_plot.c:	PSL_setcolor (PSL, GMT->current.setting.map_frame_pen.rgb, PSL_IS_STROKE);
gmt_plot.c:	if (GMT->common.R.oblique) { /* Draw rectangular boundary and return */
gmt_plot.c:		plot_rect_map_boundary (GMT, PSL, 0.0, 0.0, GMT->current.proj.rect[XHI], GMT->current.proj.rect[YHI]);
gmt_plot.c:	if (!(GMT->current.setting.map_frame_type & GMT_IS_FANCY)) {	/* Draw plain boundary and return */
gmt_plot.c:	if (!GMT->current.proj.north_pole && gmt_M_is_Spole (s)) /* Cannot have southern boundary */
gmt_plot.c:		GMT->current.map.frame.side[S_SIDE] = GMT_AXIS_NONE;
gmt_plot.c:	if (GMT->current.proj.north_pole && gmt_M_is_Npole (n)) /* Cannot have northern boundary */
gmt_plot.c:		GMT->current.map.frame.side[N_SIDE] = GMT_AXIS_NONE;
gmt_plot.c:	fat_pen = fabs (GMT->current.setting.map_frame_width) * GMT->session.u2u[GMT_INCH][GMT_PT];
gmt_plot.c:	if (GMT->current.map.frame.axis[GMT_Y].item[GMT_TICK_LOWER].active) {	/* Need two-layer frame */
gmt_plot.c:	PSL_setcolor (PSL, GMT->current.setting.map_frame_pen.rgb, PSL_IS_STROKE);
gmt_plot.c:	plot_rect_map_boundary (GMT, PSL, 0.0, 0.0, GMT->current.proj.rect[XHI], GMT->current.proj.rect[YHI]);
gmt_plot.c:	if (GMT->common.R.oblique) { /* Draw rectangular boundary and return */
gmt_plot.c:		plot_rect_map_boundary (GMT, PSL, 0.0, 0.0, GMT->current.proj.rect[XHI], GMT->current.proj.rect[YHI]);
gmt_plot.c:	if (gmt_M_is_Spole (GMT->common.R.wesn[YLO])) /* Cannot have southern boundary */
gmt_plot.c:		GMT->current.map.frame.side[S_SIDE] = GMT_AXIS_NONE;
gmt_plot.c:	if (gmt_M_is_Npole (GMT->common.R.wesn[YHI])) /* Cannot have northern boundary */
gmt_plot.c:		GMT->current.map.frame.side[N_SIDE] = GMT_AXIS_NONE;
gmt_plot.c:	if (GMT->common.R.oblique) { /* Draw rectangular boundary and return */
gmt_plot.c:		plot_rect_map_boundary (GMT, PSL, 0.0, 0.0, GMT->current.proj.rect[XHI], GMT->current.proj.rect[YHI]);
gmt_plot.c:	if (GMT->common.R.oblique) {	/* Draw rectangular boundary and return */
gmt_plot.c:		plot_rect_map_boundary (GMT, PSL, 0.0, 0.0, GMT->current.proj.rect[XHI], GMT->current.proj.rect[YHI]);
gmt_plot.c:	gmt_setpen (GMT, &GMT->current.setting.map_frame_pen);
gmt_plot.c:	nr = GMT->current.map.n_lon_nodes + GMT->current.map.n_lat_nodes;
gmt_plot.c:	if (nr >= GMT->current.plot.n_alloc) gmt_get_plot_array (GMT);
gmt_plot.c:	if (GMT->current.proj.g_debug > 1) GMT_Report (GMT->parent, GMT_MSG_DEBUG, "genper_map_boundary nr = %" PRIu64 "\n", nr);
gmt_plot.c:	gmtlib_genper_map_clip_path (GMT, nr, GMT->current.plot.x, GMT->current.plot.y);
gmt_plot.c:	PSL_plotline (PSL, GMT->current.plot.x, GMT->current.plot.y, (int)nr, PSL_MOVE|PSL_STROKE);
gmt_plot.c:	if (GMT->common.R.oblique) { /* Draw rectangular boundary and return */
gmt_plot.c:		plot_rect_map_boundary (GMT, PSL, 0.0, 0.0, GMT->current.proj.rect[XHI], GMT->current.proj.rect[YHI]);
gmt_plot.c:	gmt_setpen (GMT, &GMT->current.setting.map_frame_pen);
gmt_plot.c:	PSL_plotarc (PSL, GMT->current.proj.r, GMT->current.proj.r, GMT->current.proj.r, 0.0, 360.0, PSL_MOVE|PSL_STROKE);
gmt_plot.c:	gmt_setpen (GMT, &GMT->current.setting.map_frame_pen);
gmt_plot.c:	if (GMT->current.proj.got_elevations) {
gmt_plot.c:			GMT->current.map.frame.side[N_SIDE] = GMT_AXIS_NONE;	/* No donuts, please */
gmt_plot.c:			GMT->current.map.frame.side[S_SIDE] = GMT_AXIS_NONE;		/* No donuts, please */
gmt_plot.c:		GMT->current.map.frame.side[E_SIDE] = GMT->current.map.frame.side[W_SIDE] = GMT_AXIS_NONE;
gmt_plot.c:	nr = GMT->current.map.n_lon_nodes;
gmt_plot.c:	while (nr > GMT->current.plot.n_alloc) gmt_get_plot_array (GMT);
gmt_plot.c:	da = fabs (GMT->common.R.wesn[XHI] - GMT->common.R.wesn[XLO]) / (nr - 1);
gmt_plot.c:	if (GMT->current.map.frame.side[N_SIDE] & GMT_AXIS_DRAW) {
gmt_plot.c:			a = GMT->common.R.wesn[XLO] + i * da;
gmt_plot.c:			gmt_geo_to_xy (GMT, a, GMT->common.R.wesn[YHI], &GMT->current.plot.x[i], &GMT->current.plot.y[i]);
gmt_plot.c:		PSL_plotline (PSL, GMT->current.plot.x, GMT->current.plot.y, (int)nr, PSL_MOVE|PSL_STROKE|close);
gmt_plot.c:	if (GMT->current.map.frame.side[S_SIDE] & GMT_AXIS_DRAW) {
gmt_plot.c:			a = GMT->common.R.wesn[XLO] + i * da;
gmt_plot.c:			gmt_geo_to_xy (GMT, a, GMT->common.R.wesn[YLO], &GMT->current.plot.x[i], &GMT->current.plot.y[i]);
gmt_plot.c:		PSL_plotline (PSL, GMT->current.plot.x, GMT->current.plot.y, (int)nr, PSL_MOVE|PSL_STROKE|close);
gmt_plot.c:	if (GMT->current.map.frame.side[E_SIDE] & GMT_AXIS_DRAW) {
gmt_plot.c:		gmt_geo_to_xy (GMT, GMT->common.R.wesn[XHI], GMT->common.R.wesn[YLO], &xx[0], &yy[0]);
gmt_plot.c:		gmt_geo_to_xy (GMT, GMT->common.R.wesn[XHI], GMT->common.R.wesn[YHI], &xx[1], &yy[1]);
gmt_plot.c:	if (GMT->current.map.frame.side[W_SIDE] & GMT_AXIS_DRAW) {
gmt_plot.c:		gmt_geo_to_xy (GMT, GMT->common.R.wesn[XLO], GMT->common.R.wesn[YLO], &xx[0], &yy[0]);
gmt_plot.c:		gmt_geo_to_xy (GMT, GMT->common.R.wesn[XLO], GMT->common.R.wesn[YHI], &xx[1], &yy[1]);
gmt_plot.c:	set_angle = ((!GMT->common.R.oblique && !(gmt_M_is_azimuthal(GMT) || gmt_M_is_conical(GMT))) || GMT->common.R.oblique);
gmt_plot.c:	if (!GMT->common.R.oblique && (GMT->current.proj.projection_GMT == GMT_GENPER || GMT->current.proj.projection_GMT == GMT_POLYCONIC)) set_angle = true;
gmt_plot.c:		if (!GMT->current.proj.edge[sides[i]]) continue;
gmt_plot.c:		if ((GMT->current.map.frame.side[sides[i]] & GMT_AXIS_TICK) == 0) continue;
gmt_plot.c:		if (!(GMT->current.setting.map_annot_oblique & GMT_OBL_ANNOT_ANYWHERE) && ((type == 0 && (sides[i] % 2)) || (type == 1 && !(sides[i] % 2)))) continue;
gmt_plot.c:		angle = ((GMT->current.setting.map_annot_oblique & GMT_OBL_ANNOT_NORMAL_TICKS) ? (sides[i] - 1) * 90.0 : angles[i]);
gmt_plot.c:		if (GMT->current.setting.map_annot_oblique & GMT_OBL_ANNOT_EXTEND_TICKS) {
gmt_plot.c:				/* if (fabs (c) > cosd (GMT->current.setting.map_annot_min_angle)) continue; */
gmt_plot.c:				if (fabs (c) < sind (GMT->current.setting.map_annot_min_angle)) continue;
gmt_plot.c:				if (fabs (s) < sind (GMT->current.setting.map_annot_min_angle)) continue;
gmt_plot.c:	if (GMT->current.setting.map_annot_min_spacing <= 0.0) return (false);
gmt_plot.c:	if (d_min < GMT->current.setting.map_annot_min_spacing) return (true);
gmt_plot.c:	double a = GMT->current.setting.map_annot_offset[level];
gmt_plot.c:	if (GMT->current.setting.map_frame_type & GMT_IS_INSIDE) {	/* Inside annotation */
gmt_plot.c:		a -= fabs (GMT->current.setting.map_tick_length[0]);
gmt_plot.c:		double dist = GMT->current.setting.map_tick_length[0];	/* Length of tickmark (could be negative) */
gmt_plot.c:		if (GMT->current.setting.map_frame_type & GMT_IS_FANCY && GMT->current.setting.map_frame_width > dist) dist = GMT->current.setting.map_frame_width;
gmt_plot.c:		if (GMT->current.setting.map_tick_length[0] < 0.0) a += GMT->current.setting.map_tick_length[0];
gmt_plot.c:		if (!(GMT->current.setting.map_annot_oblique & GMT_OBL_ANNOT_ANYWHERE) && ((type == 0 && (sides[i] % 2)) || (type == 1 && !(sides[i] % 2)))) continue;
gmt_plot.c:		tick_length = GMT->current.setting.map_tick_length[GMT_PRIMARY];
gmt_plot.c:		if (!flip && GMT->current.setting.map_annot_oblique & annot_type) o_len = tick_length;
gmt_plot.c:		if (GMT->current.setting.map_annot_oblique & GMT_OBL_ANNOT_EXTEND_TICKS) {
gmt_plot.c:		if (!flip && (GMT->current.setting.map_annot_oblique & annot_type) && GMT->current.setting.map_annot_offset[level] > 0.0) {
gmt_plot.c:				xx[i] += (sides[i] == 1) ? GMT->current.setting.map_annot_offset[level] : -GMT->current.setting.map_annot_offset[level];
gmt_plot.c:				yy[i] += (sides[i] == 2) ? GMT->current.setting.map_annot_offset[level] : -GMT->current.setting.map_annot_offset[level];
gmt_plot.c:			if (GMT->current.proj.three_D && GMT->current.proj.z_project.cos_az > 0) {	/* Rotate annotation when seen "from North" */
gmt_plot.c:			PSL_plottext (PSL, xx[i], yy[i], GMT->current.setting.font_annot[level].size, label, text_angle, justify, form);
gmt_plot.c:	bool flip = (gmt_M_type (GMT, GMT_IN, GMT_X) == GMT_IS_LON && gmt_M_type (GMT, GMT_IN, GMT_Y) != GMT_IS_LAT && GMT->current.proj.scale[GMT_Y] < 0.0);
gmt_plot.c:	min = (plane == GMT_Y) ? GMT->current.proj.rect[XLO] : GMT->current.proj.rect[YLO];
gmt_plot.c:	max = (plane == GMT_Y) ? GMT->current.proj.rect[XHI] : GMT->current.proj.rect[YHI];
gmt_plot.c:		if (GMT->current.setting.map_grid_cross_size[k] > 0.0) continue;
gmt_plot.c:		dz = gmtlib_get_map_interval (GMT, &GMT->current.map.frame.axis[GMT_Z].item[item[k]]);
gmt_plot.c:		if (!GMT->current.map.frame.axis[GMT_Z].item[item[k]].active || fabs(dz) == 0.0) continue;
gmt_plot.c:		gmt_setpen (GMT, &GMT->current.setting.map_grid_pen[k]);
gmt_plot.c:		nz = gmtlib_coordinate_array (GMT, zmin, zmax, &GMT->current.map.frame.axis[GMT_Z].item[item[k]], &z, NULL);
gmt_plot.c:	GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Entering plot_map_gridlines\n");
gmt_plot.c:		if (GMT->current.setting.map_grid_cross_size[k] > 0.0) continue;
gmt_plot.c:		dx = gmtlib_get_map_interval (GMT, &GMT->current.map.frame.axis[GMT_X].item[item[k]]);
gmt_plot.c:		dy = gmtlib_get_map_interval (GMT, &GMT->current.map.frame.axis[GMT_Y].item[item[k]]);
gmt_plot.c:		if (!(GMT->current.map.frame.axis[GMT_X].item[item[k]].active || GMT->current.map.frame.axis[GMT_Y].item[item[k]].active)) continue;
gmt_plot.c:		gmt_setpen (GMT, &GMT->current.setting.map_grid_pen[k]);
gmt_plot.c:		if (GMT->current.map.frame.axis[GMT_X].special == GMT_CUSTOM && (np = gmt_load_custom_annot (GMT, &GMT->current.map.frame.axis[GMT_X], 'g', &v, NULL))) {
gmt_plot.c:		else if (!GMT->current.map.frame.axis[GMT_X].item[item[k]].active || fabs(dx) == 0.0) { /* Nothing */ }
gmt_plot.c:		else if (GMT->current.proj.xyz_projection[GMT_X] == GMT_TIME)
gmt_plot.c:		else if (GMT->current.proj.xyz_projection[GMT_X] == GMT_LOG10)
gmt_plot.c:		else if (GMT->current.proj.xyz_projection[GMT_X] == GMT_POW)
gmt_plot.c:		else if (GMT->current.map.frame.obl_grid)	/* Draw oblique grid lines that go S to N */
gmt_plot.c:		if (GMT->current.map.frame.axis[GMT_Y].special == GMT_CUSTOM && (np = gmt_load_custom_annot (GMT, &GMT->current.map.frame.axis[GMT_Y], 'g', &v, NULL))) {
gmt_plot.c:		else if (!GMT->current.map.frame.axis[GMT_Y].item[item[k]].active || fabs(dy) == 0.0) { /* Nothing */ }
gmt_plot.c:		else if (GMT->current.proj.xyz_projection[GMT_Y] == GMT_TIME)
gmt_plot.c:		else if (GMT->current.proj.xyz_projection[GMT_Y] == GMT_LOG10)
gmt_plot.c:		else if (GMT->current.proj.xyz_projection[GMT_Y] == GMT_POW)
gmt_plot.c:		else if (GMT->current.map.frame.obl_grid)	/* Draw oblique grid lines that go S to N */
gmt_plot.c:	GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Exiting plot_map_gridlines\n");
gmt_plot.c:		if (GMT->current.setting.map_grid_cross_size[k] > 0.0) i++;
gmt_plot.c:	gmt_map_clip_on (GMT, GMT->session.no_rgb, 3);
gmt_plot.c:		if (GMT->current.setting.map_grid_cross_size[k] <= 0.0) continue;
gmt_plot.c:		gmt_setpen (GMT, &GMT->current.setting.map_grid_pen[k]);
gmt_plot.c:		nx = gmtlib_coordinate_array (GMT, w, e, &GMT->current.map.frame.axis[GMT_X].item[item[k]], &x, NULL);
gmt_plot.c:		ny = gmtlib_coordinate_array (GMT, s, n, &GMT->current.map.frame.axis[GMT_Y].item[item[k]], &y, NULL);
gmt_plot.c:		L = 0.5 * GMT->current.setting.map_grid_cross_size[k];
gmt_plot.c:						xi = GMT->current.proj.central_meridian;
gmt_plot.c:						gmt_geo_to_xy (GMT, xi + GMT->current.map.dlon, yj, &x1, &y1);
gmt_plot.c:						gmt_geo_to_xy (GMT, xi, yj - copysign (GMT->current.map.dlat, yj), &x1, &y1);
gmt_plot.c:	if (! (GMT->current.map.frame.axis[GMT_X].item[item].active || GMT->current.map.frame.axis[GMT_Y].item[item].active)) return;
gmt_plot.c:	dx = (GMT->current.map.frame.axis[GMT_X].file_custom) ? 1.0 : gmtlib_get_map_interval (GMT, &GMT->current.map.frame.axis[GMT_X].item[item]);
gmt_plot.c:	dy = (GMT->current.map.frame.axis[GMT_Y].file_custom) ? 1.0 : gmtlib_get_map_interval (GMT, &GMT->current.map.frame.axis[GMT_Y].item[item]);
gmt_plot.c:	do_x = dx > 0.0 && GMT->current.map.frame.axis[GMT_X].item[item].active && (item == GMT_ANNOT_UPPER ||
gmt_plot.c:		(item == GMT_TICK_UPPER && dx != gmtlib_get_map_interval (GMT, &GMT->current.map.frame.axis[GMT_X].item[GMT_ANNOT_UPPER])) ||
gmt_plot.c:		(item == GMT_TICK_LOWER && dx != gmtlib_get_map_interval (GMT, &GMT->current.map.frame.axis[GMT_X].item[GMT_ANNOT_LOWER])));
gmt_plot.c:	do_y = dy > 0.0 && GMT->current.map.frame.axis[GMT_Y].item[item].active && (item == GMT_ANNOT_UPPER ||
gmt_plot.c:		(item == GMT_TICK_UPPER && dy != gmtlib_get_map_interval (GMT, &GMT->current.map.frame.axis[GMT_Y].item[GMT_ANNOT_UPPER])) ||
gmt_plot.c:		(item == GMT_TICK_LOWER && dy != gmtlib_get_map_interval (GMT, &GMT->current.map.frame.axis[GMT_Y].item[GMT_ANNOT_LOWER])));
gmt_plot.c:	len = GMT->current.setting.map_tick_length[item];
gmt_plot.c:	if (GMT->current.setting.map_frame_type & GMT_IS_INSIDE) len = -fabs (len);	/* Negative to become inside */
gmt_plot.c:	GMT->current.map.on_border_is_outside = true;	/* Temporarily, points on the border are outside */
gmt_plot.c:		if (GMT->current.map.frame.axis[GMT_X].file_custom)
gmt_plot.c:			nx = gmtlib_coordinate_array (GMT, w, e, &GMT->current.map.frame.axis[GMT_X].item[item], &val, NULL);
gmt_plot.c:			nx = gmtlib_linear_array (GMT, w, e, dx, GMT->current.map.frame.axis[GMT_X].phase, &val);
gmt_plot.c:		if (GMT->current.proj.z_down) {
gmt_plot.c:			if (GMT->current.map.frame.axis[GMT_Y].file_custom)
gmt_plot.c:				ny = gmtlib_coordinate_array (GMT, 0.0, n-s, &GMT->current.map.frame.axis[GMT_Y].item[item], &val, NULL);
gmt_plot.c:				ny = gmtlib_linear_array (GMT, 0.0, n-s, dy, GMT->current.map.frame.axis[GMT_Y].phase, &val);
gmt_plot.c:				val[i] = GMT->common.R.wesn[YHI] - val[i];	/* These are the radial values needed for positioning */
gmt_plot.c:			if (GMT->current.map.frame.axis[GMT_Y].file_custom)
gmt_plot.c:				ny = gmtlib_coordinate_array (GMT, s, n, &GMT->current.map.frame.axis[GMT_Y].item[item], &val, NULL);
gmt_plot.c:				ny = gmtlib_linear_array (GMT, s, n, dy, GMT->current.map.frame.axis[GMT_Y].phase, &val);
gmt_plot.c:	GMT->current.map.on_border_is_outside = false;	/* Reset back to default */
gmt_plot.c:	if (!(gmt_M_is_geographic (GMT, GMT_IN) || GMT->current.proj.projection_GMT == GMT_POLAR)) return;	/* Tickmarks already done by linear axis */
gmt_plot.c:	gmt_setpen (GMT, &GMT->current.setting.map_tick_pen[GMT_PRIMARY]);
gmt_plot.c:	if (!(GMT->current.setting.map_frame_type & GMT_IS_FANCY)) {	/* Draw plain boundary and return */
gmt_plot.c:		gmt_setpen (GMT, &GMT->current.setting.map_tick_pen[GMT_SECONDARY]);
gmt_plot.c:	if (GMT->current.plot.calclock.geo.order[2] == -1) return (false);			/* Seconds not requested by format */
gmt_plot.c:	if (GMT->current.plot.calclock.geo.n_sec_decimals > 0) return (true);			/* If asked for ss.xxx annotations */
gmt_plot.c:	if (!(gmt_M_x_is_lon (GMT, GMT_IN) || gmt_M_y_is_lat (GMT, GMT_IN) || GMT->current.proj.projection_GMT == GMT_POLAR)) return;	/* Annotations and header already done by plot_linear_map_boundary */
gmt_plot.c:	is_world_save = GMT->current.map.is_world;
gmt_plot.c:	lon_wrap_save = GMT->current.map.lon_wrap;
gmt_plot.c:	if (GMT->current.map.frame.header[0] && !GMT->current.map.frame.plotted_header) {	/* Make plot header for geographic maps */
gmt_plot.c:		if (gmt_M_is_geographic (GMT, GMT_IN) || GMT->current.map.frame.side[N_SIDE] & GMT_AXIS_ANNOT) {
gmt_plot.c:			PSL_setfont (PSL, GMT->current.setting.font_annot[GMT_PRIMARY].id);
gmt_plot.c:			PSL_command (PSL, "/PSL_H_y %d ", PSL_IZ (PSL, GMT->current.setting.map_tick_length[GMT_PRIMARY] + GMT->current.setting.map_annot_offset[GMT_PRIMARY] + GMT->current.setting.map_title_offset));
gmt_plot.c:			if (GMT->current.setting.map_degree_symbol == gmt_none)
gmt_plot.c:				PSL_deftextdim (PSL, "-h", GMT->current.setting.font_annot[GMT_PRIMARY].size, "100");
gmt_plot.c:				snprintf (label, GMT_LEN16, "100%c",  (int)GMT->current.setting.ps_encoding.code[GMT->current.setting.map_degree_symbol]);
gmt_plot.c:				PSL_deftextdim (PSL, "-h", GMT->current.setting.font_annot[GMT_PRIMARY].size, label);
gmt_plot.c:			PSL_defunits (PSL, "PSL_H_y", GMT->current.setting.map_title_offset + GMT->current.setting.map_tick_length[GMT_PRIMARY]);
gmt_plot.c:		PSL_command (PSL, "%d %d PSL_H_y add M\n", PSL_IZ (PSL, GMT->current.proj.rect[XHI] * 0.5), PSL_IZ (PSL, GMT->current.proj.rect[YHI]));
gmt_plot.c:		form = gmt_setfont (GMT, &GMT->current.setting.font_title);
gmt_plot.c:		PSL_plottext (PSL, 0.0, 0.0, -GMT->current.setting.font_title.size, GMT->current.map.frame.header, 0.0, PSL_BC, form);
gmt_plot.c:		GMT->current.map.frame.plotted_header = true;
gmt_plot.c:	if (GMT->current.proj.edge[S_SIDE] || GMT->current.proj.edge[N_SIDE]) {
gmt_plot.c:		dx[0] = gmtlib_get_map_interval (GMT, &GMT->current.map.frame.axis[GMT_X].item[GMT_ANNOT_UPPER]);
gmt_plot.c:		dx[1] = gmtlib_get_map_interval (GMT, &GMT->current.map.frame.axis[GMT_X].item[GMT_ANNOT_LOWER]);
gmt_plot.c:		full_lat_range = (fabs (180.0 - fabs (GMT->common.R.wesn[YHI] - GMT->common.R.wesn[YLO])) < GMT_CONV4_LIMIT);
gmt_plot.c:		proj_A = (GMT->current.proj.projection_GMT == GMT_MERCATOR || GMT->current.proj.projection_GMT == GMT_OBLIQUE_MERC ||
gmt_plot.c:			GMT->current.proj.projection_GMT == GMT_WINKEL || GMT->current.proj.projection_GMT == GMT_ECKERT4 || GMT->current.proj.projection_GMT == GMT_ECKERT6 ||
gmt_plot.c:			GMT->current.proj.projection_GMT == GMT_ROBINSON || GMT->current.proj.projection_GMT == GMT_CYL_EQ || GMT->current.proj.projection_GMT == GMT_CYL_STEREO ||
gmt_plot.c:			GMT->current.proj.projection_GMT == GMT_CYL_EQDIST || GMT->current.proj.projection_GMT == GMT_MILLER || GMT->current.proj.projection_GMT == GMT_LINEAR);
gmt_plot.c:		proj_B = (GMT->current.proj.projection_GMT == GMT_HAMMER || GMT->current.proj.projection_GMT == GMT_MOLLWEIDE ||
gmt_plot.c:			GMT->current.proj.projection_GMT == GMT_SINUSOIDAL);
gmt_plot.c:	if (GMT->current.proj.edge[E_SIDE] || GMT->current.proj.edge[W_SIDE]) {
gmt_plot.c:		dy[0] = gmtlib_get_map_interval (GMT, &GMT->current.map.frame.axis[GMT_Y].item[GMT_ANNOT_UPPER]);
gmt_plot.c:		dy[1] = gmtlib_get_map_interval (GMT, &GMT->current.map.frame.axis[GMT_Y].item[GMT_ANNOT_LOWER]);
gmt_plot.c:	if (GMT->current.map.frame.axis[GMT_X].file_custom) dx[0] = 1.0;	/* To pass checks below */
gmt_plot.c:	if (GMT->current.map.frame.axis[GMT_Y].file_custom) dy[0] = 1.0;	/* To pass checks below */
gmt_plot.c:	check_edges = (!GMT->common.R.oblique && (GMT->current.setting.map_frame_type & GMT_IS_INSIDE));
gmt_plot.c:	form = gmt_setfont (GMT, &GMT->current.setting.font_annot[GMT_PRIMARY]);
gmt_plot.c:	GMT->current.map.on_border_is_outside = true;	/* Temporarily, points on the border are outside */
gmt_plot.c:	if (!GMT->common.R.oblique) {
gmt_plot.c:		GMT->current.map.is_world = false;
gmt_plot.c:		if (!(GMT->current.proj.projection_GMT == GMT_GENPER || GMT->current.proj.projection_GMT == GMT_GNOMONIC)) GMT->current.map.lon_wrap = false;
gmt_plot.c:		if (dx[k] > 0.0 && (gmt_M_x_is_lon (GMT, GMT_IN) || GMT->current.proj.projection_GMT == GMT_POLAR)) {	/* Annotate the S and N boundaries */
gmt_plot.c:			if (GMT->current.map.frame.axis[GMT_X].file_custom)
gmt_plot.c:				nx = gmtlib_coordinate_array (GMT, w, e, &GMT->current.map.frame.axis[GMT_X].item[GMT_ANNOT_UPPER], &val, &label_c);
gmt_plot.c:				nx = gmtlib_linear_array (GMT, w, e, dx[k], GMT->current.map.frame.axis[GMT_X].phase, &val);
gmt_plot.c:		if (dy[k] > 0.0 && (gmt_M_y_is_lat (GMT, GMT_IN) || GMT->current.proj.projection_GMT == GMT_POLAR)) {	/* Annotate W and E boundaries */
gmt_plot.c:			else {	/* Also, we know that GMT->current.setting.format_geo_out = -1 in this case */
gmt_plot.c:			if (GMT->current.proj.z_down) {	/* Want to annotate depth rather than radius */
gmt_plot.c:				if (GMT->current.map.frame.axis[GMT_Y].file_custom)
gmt_plot.c:					ny = gmtlib_coordinate_array (GMT, 0.0, n-s, &GMT->current.map.frame.axis[GMT_Y].item[GMT_ANNOT_UPPER], &tval, &label_c);
gmt_plot.c:					ny = gmtlib_linear_array (GMT, 0.0, n-s, dy[k], GMT->current.map.frame.axis[GMT_Y].phase, &tval);
gmt_plot.c:					val[i] = GMT->common.R.wesn[YHI] - tval[i];	/* These are the radial values needed for positioning */
gmt_plot.c:				if (GMT->current.map.frame.axis[GMT_Y].file_custom)
gmt_plot.c:					ny = gmtlib_coordinate_array (GMT, s, n, &GMT->current.map.frame.axis[GMT_Y].item[GMT_ANNOT_UPPER], &val, &label_c);
gmt_plot.c:					ny = gmtlib_linear_array (GMT, s, n, dy[k], GMT->current.map.frame.axis[GMT_Y].phase, &val);
gmt_plot.c:				if ((GMT->current.proj.polar || GMT->current.proj.projection_GMT == GMT_VANGRINTEN) && doubleAlmostEqual (fabs (val[i]), 90.0))
gmt_plot.c:			if (GMT->current.proj.z_down) gmt_M_free (GMT, tval);
gmt_plot.c:	GMT->current.map.on_border_is_outside = false;	/* Reset back to default */
gmt_plot.c:	GMT->current.map.is_world = is_world_save;
gmt_plot.c:	GMT->current.map.lon_wrap = lon_wrap_save;
gmt_plot.c:	if (!GMT->current.map.frame.draw && GMT->current.proj.projection_GMT != GMT_LINEAR) return;	/* We have a separate check in linear_map_boundary */
gmt_plot.c:	if (GMT->current.map.frame.no_frame) return;	/* Specifically did not want frame */
gmt_plot.c:	switch (GMT->current.proj.projection_GMT) {
gmt_plot.c:			if (GMT->current.proj.polar)
gmt_plot.c: * Scaling and wesn are assumed to be passed through the GMT->current.proj-structure (see GMT_project.h)
gmt_plot.c: * Tickmark info are passed through the GMT->current.map.frame-structure
gmt_plot.c:	switch (GMT->current.proj.projection_GMT) {
gmt_plot.c:			return (!GMT->common.R.oblique);
gmt_plot.c:			return (GMT->current.proj.polar && !GMT->common.R.oblique);
gmt_plot.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error in plot_is_fancy_boundary - notify developers\n");
gmt_plot.c:	PSL_plotbox (PSL, nesw[(quadrant+1)%4], GMT->current.proj.zmin, nesw[(quadrant+3)%4], GMT->current.proj.zmax);
gmt_plot.c:		plot_z_gridlines (GMT, PSL, GMT->common.R.wesn[ZLO], GMT->common.R.wesn[ZHI], plane);
gmt_plot.c:	strftime (text, sizeof(text), GMT->current.setting.format_time_stamp, localtime (&right_now));
gmt_plot.c:	PSL_setfont (PSL, GMT->current.setting.font_logo.id);
gmt_plot.c:	PSL_setfill (PSL, GMT->current.setting.map_default_pen.rgb, true);
gmt_plot.c:	PSL_setfill (PSL, GMT->PSL->init.page_rgb, true);
gmt_plot.c:	PSL_command (PSL, "\n%% PostScript produced by:\n%%@GMT: gmt %s", GMT->init.module_name);
gmt_plot.c:		PSL_setfill (PSL, GMT->current.setting.map_default_pen.rgb, true);
gmt_plot.c:		PSL_setfill (PSL, GMT->PSL->init.page_rgb, true);
gmt_plot.c:	gmt_init_fill (GMT, &f, GMT->current.setting.color_patch[GMT_BGD][0], GMT->current.setting.color_patch[GMT_BGD][1], GMT->current.setting.color_patch[GMT_BGD][2]);
gmt_plot.c:	tlen[0] = GMT->current.setting.map_tick_length[GMT_TICK_UPPER];
gmt_plot.c:	tlen[1] = GMT->current.setting.map_tick_length[GMT_ANNOT_UPPER];
gmt_plot.c:	tlen[2] = 1.5 * GMT->current.setting.map_tick_length[GMT_ANNOT_UPPER];
gmt_plot.c:	GMT->current.plot.r_theta_annot = false;	/* Just in case it was turned on in gmt_map.c */
gmt_plot.c:		gmt_setpen (GMT, &GMT->current.setting.map_tick_pen[level]);
gmt_plot.c:		form = gmt_setfont (GMT, &GMT->current.setting.font_annot[level]);
gmt_plot.c:			x[0] = mr->refpoint->x + (R[level] + GMT->current.setting.map_annot_offset[level]) * c, y[0] =
gmt_plot.c:			       mr->refpoint->y + (R[level] + GMT->current.setting.map_annot_offset[level]) * s;
gmt_plot.c:			if (GMT->current.setting.map_degree_symbol == gmt_none)
gmt_plot.c:				snprintf (label, GMT_LEN16, "%ld%c", lrint (val[i]), (int)GMT->current.setting.ps_encoding.code[GMT->current.setting.map_degree_symbol]);
gmt_plot.c:			PSL_plottext (PSL, x[0], y[0], GMT->current.setting.font_annot[level].size, label, t_angle, just, form);
gmt_plot.c:	gmt_setpen (GMT, &GMT->current.setting.map_tick_pen[GMT_SECONDARY]);
gmt_plot.c:	base = R[GMT_ROSE_SECONDARY] + GMT->current.setting.map_annot_offset[GMT_SECONDARY] + GMT->current.setting.font_annot[GMT_ROSE_SECONDARY].size / PSL_POINTS_PER_INCH;
gmt_plot.c:			x[0] = mr->refpoint->x + (base + 2.0*tlen[2] + GMT->current.setting.map_title_offset + 0.025*mr->size) * c, y[0] = mr->refpoint->y + (base + 2.0*tlen[2] + GMT->current.setting.map_title_offset + 0.025*mr->size) * s;
gmt_plot.c:			x[0] = mr->refpoint->x + (base + 2.0*tlen[2] + GMT->current.setting.map_title_offset) * c, y[0] = mr->refpoint->y + (base + 2.0*tlen[2] + GMT->current.setting.map_title_offset) * s;
gmt_plot.c:			form = gmt_setfont (GMT, &GMT->current.setting.font_title);
gmt_plot.c:			PSL_plottext (PSL, x[0], y[0], GMT->current.setting.font_title.size, mr->label[k], ew_angle, ljust[k], form);
gmt_plot.c:			gmt_setpen (GMT, &GMT->current.setting.map_tick_pen[GMT_SECONDARY]);
gmt_plot.c:	dim[11] = 0.5 * GMT->current.setting.map_default_pen.width;
gmt_plot.c:	PSL_defpen (PSL, "PSL_vecheadpen", GMT->current.setting.map_default_pen.width, GMT->current.setting.map_default_pen.style, GMT->current.setting.map_default_pen.offset, GMT->current.setting.map_default_pen.rgb);
gmt_plot.c:		dim[5] = GMT->current.setting.map_vector_shape, dim[6] = PSL_VEC_END | PSL_VEC_FILL;
gmt_plot.c:		gmt_setpen (GMT, &GMT->current.setting.map_default_pen);
gmt_plot.c:				gmtlib_get_annot_label (GMT, mr->declination, tmpstring, true, false, true, 0, GMT->current.map.is_world);
gmt_plot.c:			form = gmt_setfont (GMT, &GMT->current.setting.font_label);
gmt_plot.c:			PSL_plottext (PSL, x[0], y[0], GMT->current.setting.font_label.size, mr->dlabel, t_angle, PSL_BC, form);
gmt_plot.c:		y[0] = -0.5 * L,		y[1] = -y[0], y[2] = y[3] = 0.0,	y[4] = y[1] + GMT->current.setting.map_annot_offset[GMT_PRIMARY];
gmt_plot.c:		dim[5] = GMT->current.setting.map_vector_shape, dim[6] = PSL_VEC_END | PSL_VEC_FILL;
gmt_plot.c:		PSL_defpen (PSL, "PSL_vecheadpen", GMT->current.setting.map_frame_pen.width, "", 0, f.rgb);
gmt_plot.c:	gmt_init_fill (GMT, &f, GMT->current.setting.color_patch[GMT_BGD][0], GMT->current.setting.color_patch[GMT_BGD][1], GMT->current.setting.color_patch[GMT_BGD][2]);
gmt_plot.c:	gmt_setpen (GMT, &GMT->current.setting.map_tick_pen[GMT_PRIMARY]);
gmt_plot.c:			PSL_setfill (PSL, GMT->PSL->init.page_rgb, true);
gmt_plot.c:			PSL_setfill (PSL, GMT->current.setting.map_default_pen.rgb, true);
gmt_plot.c:		x[0] = x[2] = 0.0, x[1] = L[0] + GMT->current.setting.map_title_offset; x[3] = -x[1];
gmt_plot.c:		y[1] = y[3] = 0.0, y[2] = L[0] + GMT->current.setting.map_title_offset; y[0] = -y[2];
gmt_plot.c:		form = gmt_setfont (GMT, &GMT->current.setting.font_title);
gmt_plot.c:		for (i = 0; i < 4; i++) PSL_plottext (PSL, xp[i], yp[i], GMT->current.setting.font_title.size, mr->label[i], angle, just[i], form);
gmt_plot.c:		y[0] = -0.5 * mr->size, y[1] = -y[0], y[2] = y[3] = 0.0; y[4] = y[1] + GMT->current.setting.map_annot_offset[GMT_PRIMARY];
gmt_plot.c:		x[5] = GMT->current.setting.map_vector_shape, x[6] = PSL_VEC_END | PSL_VEC_FILL;
gmt_plot.c:		PSL_defpen (PSL, "PSL_vecheadpen", GMT->current.setting.map_frame_pen.width, "", 0, f.rgb);
gmt_plot.c:			form = gmt_setfont (GMT, &GMT->current.setting.font_title);
gmt_plot.c:			PSL_plottext (PSL, xp[4], yp[4], GMT->current.setting.font_title.size, mr->label[2], angle, PSL_BC, form);
gmt_plot.c:	struct PSL_CTRL *PSL = GMT->PSL;
gmt_plot.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Unrecognized text variable type (%d) passed to plot_custum_failed_bool_test_string\n", s->var[k]);
gmt_plot.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Unrecognized symbol macro text operator (%d = '%c') passed to gmt_draw_custom_symbol\n", s->operator, (char)s->operator);
gmt_plot.c:				arg[k] = GMT->current.io.curr_rec[GMT_Y];	break;
gmt_plot.c:				arg[k] = GMT->current.io.curr_rec[GMT_X];	break;
gmt_plot.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Unrecognized symbol macro numerical operator (%d = '%c') passed to gmt_draw_custom_symbol\n", s->operator, (char)s->operator);
gmt_plot.c:		strcpy (text, GMT->current.io.curr_trailing_text);
gmt_plot.c:		char *word = NULL, *trail = NULL, *orig = strdup (GMT->current.io.curr_trailing_text);
gmt_plot.c:			GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "No word # %d in the trailing text (%d words) - return all text\n", s->var[0], col);
gmt_plot.c:			strcpy (text, GMT->current.io.curr_trailing_text);
gmt_plot.c:						gmt_ascii_format_col (GMT, tmp, GMT->current.io.curr_rec[n], GMT_IN, n);
gmt_plot.c:							snprintf (tmp, GMT_LEN64, GMT->current.setting.format_float_out, size[n]);
gmt_plot.c:	gmt_setpen (GMT, &GMT->current.setting.map_default_pen);
gmt_plot.c:		PSL_setfill (PSL, GMT->session.no_rgb, PSL_OUTLINE);
gmt_plot.c:			pen[this_seg] = strdup (PSL_makepen (GMT->PSL, L->pen.width, L->pen.rgb, L->pen.style, L->pen.offset));	/* Get pen PSL setting for this segment */
gmt_plot.c:	struct PSL_CTRL *PSL= GMT->PSL;
gmt_plot.c:	else if (gmt_M_is_azimuthal (GMT) || !GMT->current.map.is_world) {	/* Testing without !is_world map to rediscover the original issue */
gmt_plot.c:		if ((GMT->current.plot.n = gmt_clip_to_map (GMT, lon, lat, n, &xp, &yp)) == 0) return 0;		/* All points are outside region */
gmt_plot.c:		//dumpfile (GMT, GMT->current.plot.x, GMT->current.plot.y, GMT->current.plot.pen, GMT->current.plot.n, "raw.txt");
gmt_plot.c:		PSL_plotpolygon (PSL, xp, yp, (unsigned int)GMT->current.plot.n);	/* Fill Cartesian polygon and possibly draw outline */
gmt_plot.c:		total = GMT->current.plot.n;
gmt_plot.c:		if ((GMT->current.plot.n = gmt_geo_to_xy_line (GMT, lon, lat, n)) == 0) return 0;		/* Convert to (x,y,pen) - return if nothing to do */
gmt_plot.c:		//dumpfile (GMT, GMT->current.plot.x, GMT->current.plot.y, GMT->current.plot.pen, GMT->current.plot.n, "raw.txt");
gmt_plot.c:			PSL_plotpolygon (PSL, GMT->current.plot.x, GMT->current.plot.y, (unsigned int)GMT->current.plot.n);
gmt_plot.c:			return GMT->current.plot.n;
gmt_plot.c:		jump = (*GMT->current.map.will_it_wrap) (GMT, GMT->current.plot.x, GMT->current.plot.y, GMT->current.plot.n, &first);	/* Polygon does indeed wrap */
gmt_plot.c:			PSL_plotpolygon (PSL, GMT->current.plot.x, GMT->current.plot.y, (unsigned int)GMT->current.plot.n);
gmt_plot.c:			return GMT->current.plot.n;
gmt_plot.c:		xp = gmt_M_memory (GMT, NULL, GMT->current.plot.n, double);
gmt_plot.c:		for (i = 0, jump = false; i < GMT->current.plot.n; i++) {
gmt_plot.c:			if (GMT->current.plot.pen[i] & PSL_MOVE && i) {
gmt_plot.c:				jump_dir = (GMT->current.plot.x[i] > GMT->current.map.half_width) ? JUMP_R : JUMP_L;
gmt_plot.c:			xp[i] = (jump) ? (*x_on_border[jump_dir]) (GMT, GMT->current.plot.y[i]) : GMT->current.plot.x[i];
gmt_plot.c:		if (GMT->current.map.is_world && doubleAlmostEqualZero (GMT->current.plot.y[0], GMT->current.plot.y[GMT->current.plot.n-1]) && !(gmt_M_is_zero (GMT->current.plot.y[0]) || doubleAlmostEqualZero (GMT->current.plot.y[0], GMT->current.proj.rect[YHI])) ) {
gmt_plot.c:			double w = 1.9 * gmt_half_map_width (GMT, GMT->current.plot.y[0]);
gmt_plot.c:			if (fabs (xp[GMT->current.plot.n-1] - xp[0]) > w) {	/* Does the jump exceed 85% of map width? */
gmt_plot.c:				GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Truncated wrapped polygon still has E-W jump and was skipped. Please report to developers if plot has artifacts.\n");
gmt_plot.c:		//dumpfile (GMT, xp, GMT->current.plot.y, NULL, GMT->current.plot.n, "main.txt");
gmt_plot.c:			PSL_plotpolygon (PSL, xp, GMT->current.plot.y, (unsigned int)GMT->current.plot.n);	/* Paint the truncated polygon */
gmt_plot.c:			total = GMT->current.plot.n;
gmt_plot.c:		jump_dir = (GMT->current.plot.x[first] > GMT->current.map.half_width) ? JUMP_L : JUMP_R;	/* Opposite */
gmt_plot.c:		for (i = k = 0, jump = true; i < GMT->current.plot.n; i++) {
gmt_plot.c:			if ((GMT->current.plot.pen[i] & PSL_MOVE) && i) {
gmt_plot.c:				jump_dir = (GMT->current.plot.x[i] > GMT->current.map.half_width) ? JUMP_R : JUMP_L;
gmt_plot.c:			xp[i] = (jump || jump_dir == JUMP_R) ? (*x_on_border[JUMP_R]) (GMT, GMT->current.plot.y[i]) : GMT->current.plot.x[i], k++;
gmt_plot.c:			//dumpfile (GMT, xp, GMT->current.plot.y, NULL, GMT->current.plot.n, "L.txt");
gmt_plot.c:			PSL_plotpolygon (PSL, xp, GMT->current.plot.y, (unsigned int)GMT->current.plot.n);	/* Paint the truncated polygon */
gmt_plot.c:			total += GMT->current.plot.n;
gmt_plot.c:		jump_dir = (GMT->current.plot.x[first] > GMT->current.map.half_width) ? JUMP_R : JUMP_L;	/* Opposite */
gmt_plot.c:		for (i = k = 0, jump = true; i < GMT->current.plot.n; i++) {
gmt_plot.c:			if ((GMT->current.plot.pen[i] & PSL_MOVE) && i) {
gmt_plot.c:				jump_dir = (GMT->current.plot.x[i] > GMT->current.map.half_width) ? JUMP_R : JUMP_L;
gmt_plot.c:			xp[i] = (jump || jump_dir == JUMP_L) ? (*x_on_border[JUMP_L]) (GMT, GMT->current.plot.y[i]) : GMT->current.plot.x[i], k++;
gmt_plot.c:			//dumpfile (GMT, xp, GMT->current.plot.y, NULL, GMT->current.plot.n, "R.txt");
gmt_plot.c:			PSL_plotpolygon (PSL, xp, GMT->current.plot.y, (unsigned int)GMT->current.plot.n);	/* Paint the truncated polygon */
gmt_plot.c:			total = GMT->current.plot.n;
gmt_plot.c:	GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Make polygon to clockwise\n");
gmt_plot.c:	if (!(gmt_M_is_misc(GMT) || (GMT->current.map.is_world  && (gmt_M_is_cylindrical(GMT) || (gmt_M_is_linear(GMT) && gmt_M_is_geographic(GMT,GMT_IN)))))) return 0;	/* We are only concerned with the global misc projections here */
gmt_plot.c:	GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Try to include %c pole in polar cap path\n", pole[S->pole+1]);
gmt_plot.c:	GMT_Report (GMT->parent, GMT_MSG_DEBUG, "First longitude = %g.  Last longitude = %g\n", S->data[GMT_X][0], S->data[GMT_X][n-1]);
gmt_plot.c:	GMT_Report (GMT->parent, GMT_MSG_DEBUG, "West longitude = %g.  East longitude = %g\n", GMT->common.R.wesn[XLO], GMT->common.R.wesn[XHI]);
gmt_plot.c:	start_lon = GMT->common.R.wesn[XHI];
gmt_plot.c:	stop_lon  = GMT->common.R.wesn[XLO];
gmt_plot.c:		if (k && (GMT->common.R.wesn[XLO]-S->data[GMT_X][k]) >= 0.0 && (GMT->common.R.wesn[XLO]-S->data[GMT_X][k-1]) <= 0.0) k0 = k;
gmt_plot.c:		yc = S->data[GMT_Y][k0-1] - (S->data[GMT_Y][k0] - S->data[GMT_Y][k0-1]) * (S->data[GMT_X][k0-1] - GMT->common.R.wesn[XLO]) / dx;
gmt_plot.c:	GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Crossing at %g,%g\n", GMT->common.R.wesn[XLO], yc);
gmt_plot.c:	GMT_Report (GMT->parent, GMT_MSG_DEBUG, "k at point closest to lon %g is = %d [n = %d]\n", GMT->common.R.wesn[XLO], (int)k0, (int)n);
gmt_plot.c:	if (pole_lat < GMT->common.R.wesn[YLO]) pole_lat = GMT->common.R.wesn[YLO];
gmt_plot.c:	if (pole_lat >GMT->common.R.wesn[YHI])  pole_lat = GMT->common.R.wesn[YHI];
gmt_plot.c:	GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Created path from %g/%g to %g/%g [%d points]\n", start_lon, pole_lat, start_lon, yc, perim_n);
gmt_plot.c:	GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Add perimeter data from k0->n [%d->%d], then 0->k0 [%d]\n", k0, n, k0);
gmt_plot.c:	GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Add path from %g/%g to %g/%g [%d points]\n", stop_lon, yc, stop_lon, pole_lat, perim_n);
gmt_plot.c:	GMT_Report (GMT->parent, GMT_MSG_DEBUG, "New path has %d points, we allocated %d points\n", m, n_new);
gmt_plot.c:	GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Polar cap: %d\n", (int)add_pole);
gmt_plot.c:		if (GMT->common.R.oblique) {	/* Determine if any of the 4 map corners are inside this polygon */
gmt_plot.c:			gmt_xy_to_geo (GMT, &X, &Y, GMT->current.proj.rect[XLO], GMT->current.proj.rect[YLO]);
gmt_plot.c:			GMT->current.proj.corner[0] = gmt_inonout (GMT, X, Y, S);
gmt_plot.c:			gmt_xy_to_geo (GMT, &X, &Y, GMT->current.proj.rect[XHI], GMT->current.proj.rect[YLO]);
gmt_plot.c:			GMT->current.proj.corner[1] = gmt_inonout (GMT, X, Y, S);
gmt_plot.c:			gmt_xy_to_geo (GMT, &X, &Y, GMT->current.proj.rect[XHI], GMT->current.proj.rect[YHI]);
gmt_plot.c:			GMT->current.proj.corner[2] = gmt_inonout (GMT, X, Y, S);
gmt_plot.c:			gmt_xy_to_geo (GMT, &X, &Y, GMT->current.proj.rect[XLO], GMT->current.proj.rect[YHI]);
gmt_plot.c:			GMT->current.proj.corner[3] = gmt_inonout (GMT, X, Y, S);
gmt_plot.c:			GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Path already had a detour to the pole, skip adding another detour\n");
gmt_plot.c:			if (GMT->current.map.path_mode == GMT_RESAMPLE_PATH && (n = gmt_fix_up_path (GMT, &plon, &plat, n, 0.0, 0)) == 0) {
gmt_plot.c:	length = 0.001 * (GMT->common.R.wesn[YHI] - GMT->common.R.wesn[YLO]);		/* 0.1 percent of latitude extent is fairly small */
gmt_plot.c:	if (dx > (0.25 * GMT->current.map.half_width)) dx = GMT->current.map.width - dx;
gmt_plot.c:	if (gmt_M_is_zero (step)) step = GMT->current.map.path_step;	/* Use default map-step if given as 0 */
gmt_plot.c:	if (step == 0 || gmt_M_is_zero (step)) step = GMT->current.map.path_step;	/* Use default map-step if given as 0 */
gmt_plot.c:	w = 0.5 * scale * pen->width * GMT->session.u2u[GMT_PT][GMT_INCH] * S->v.scale;		/* Half-width of pen in degrees */
gmt_plot.c:	step = GMT->current.map.path_step;		/* Use default map-step if given as 0 */
gmt_plot.c:	L = GMT_Alloc_Segment (GMT->parent, GMT_NO_STRINGS, 2*n+1, 2, NULL, NULL);	/* Allocate polygon to draw filled path */
gmt_plot.c:	PSL_command (GMT->PSL, "V\n");
gmt_plot.c:	PSL_setfill (GMT->PSL, pen->rgb, 0);	/* Fill, no outline */
gmt_plot.c:	PSL_command (GMT->PSL, "U\n");
gmt_plot.c:			C->r0 = C->r = length / GMT->current.proj.DIST_KM_PR_DEG;	/* Arch length in spherical degrees */
gmt_plot.c:			C->r0 = C->r = length / GMT->current.proj.DIST_KM_PR_DEG;	/* Arch length in spherical degrees */
gmt_plot.c:			C->r0 = C->r = length / GMT->current.proj.DIST_KM_PR_DEG;	/* Arch length in spherical degrees */
gmt_plot.c:		C->rot = C->r0 = C->r = (angle_1 / GMT->current.proj.DIST_KM_PR_DEG) / sind (C->colat);	/* Opening angle in spherical degrees */
gmt_plot.c:	unsigned int cap = GMT->PSL->internal.line_cap;
gmt_plot.c:	if ((GMT->current.plot.n = gmt_geo_to_xy_line (GMT, xp, yp, n)) == 0) return;	/* All outside, or use plot.x|y array */
gmt_plot.c:	PSL_setlinecap (GMT->PSL, PSL_SQUARE_CAP);	/* In case there are clipped heads and we want to do the best we can with the lines */
gmt_plot.c:	n = GMT->current.plot.n;	/* Possibly fewer points */
gmt_plot.c:		bool close = gmt_polygon_is_open (GMT, GMT->current.plot.x, GMT->current.plot.y, GMT->current.plot.n);
gmt_plot.c:		PSL_command (GMT->PSL, "O0\n");	/* Temporary turn off outline; must draw outline separately when head is split */
gmt_plot.c:		gmt_M_memcpy (xin, GMT->current.plot.x, n, double);
gmt_plot.c:		gmt_M_memcpy (yin, GMT->current.plot.y, n, double);
gmt_plot.c:		gmt_M_memcpy (pin, GMT->current.plot.pen, n, unsigned int);
gmt_plot.c:	if ((*GMT->current.map.will_it_wrap) (GMT, GMT->current.plot.x, GMT->current.plot.y, GMT->current.plot.n, &start)) {	/* Polygon does indeed wrap */
gmt_plot.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Vector head polygon will wrap at periodic boundary and will be split into two sections\n");
gmt_plot.c:		gmt_M_memcpy (xtmp, GMT->current.plot.x, n, double);
gmt_plot.c:		gmt_M_memcpy (ytmp, GMT->current.plot.y, n, double);
gmt_plot.c:		GMT->current.plot.n = gmt_map_truncate (GMT, xtmp, ytmp, n, start, -1);
gmt_plot.c:		n_use = (unsigned int)gmt_compact_line (GMT, GMT->current.plot.x, GMT->current.plot.y, GMT->current.plot.n, false, 0);
gmt_plot.c:		PSL_beginclipping (GMT->PSL, GMT->current.plot.x, GMT->current.plot.y, (int)n_use, GMT->session.no_rgb, 3);
gmt_plot.c:		PSL_plotpolygon (GMT->PSL, GMT->current.plot.x, GMT->current.plot.y, (int)n_use);
gmt_plot.c:		PSL_endclipping (GMT->PSL, 1);
gmt_plot.c:		GMT->current.plot.n = gmt_map_truncate (GMT, xtmp, ytmp, n, start, +1);
gmt_plot.c:		n_use = (unsigned int)gmt_compact_line (GMT, GMT->current.plot.x, GMT->current.plot.y, GMT->current.plot.n, false, 0);
gmt_plot.c:		PSL_beginclipping (GMT->PSL, GMT->current.plot.x, GMT->current.plot.y, (int)n_use, GMT->session.no_rgb, 3);
gmt_plot.c:		PSL_plotpolygon (GMT->PSL, GMT->current.plot.x, GMT->current.plot.y, (int)n_use);
gmt_plot.c:		PSL_endclipping (GMT->PSL, 1);
gmt_plot.c:		PSL_beginclipping (GMT->PSL, GMT->current.plot.x, GMT->current.plot.y, (int)GMT->current.plot.n, GMT->session.no_rgb, 3);
gmt_plot.c:		PSL_plotpolygon (GMT->PSL, GMT->current.plot.x, GMT->current.plot.y, (int)GMT->current.plot.n);
gmt_plot.c:		PSL_endclipping (GMT->PSL, 1);
gmt_plot.c:	PSL_setlinecap (GMT->PSL, cap);
gmt_plot.c:		PSL_command (GMT->PSL, "O1\n");
gmt_plot.c:	PSL_command (GMT->PSL, "V\n");
gmt_plot.c:		PSL_command (GMT->PSL, "O0\n");	/* Turn off outline */
gmt_plot.c:		PSL_command (GMT->PSL, "FQ\n");	/* Turn off vector head fill */
gmt_plot.c:		PSL_setfill (GMT->PSL, rgb, outline);
gmt_plot.c:	PSL_command (GMT->PSL, "U\n");
gmt_plot.c:	PSL_command (GMT->PSL, "V\n");
gmt_plot.c:		PSL_command (GMT->PSL, "O0\n");	/* Turn off outline */
gmt_plot.c:		PSL_command (GMT->PSL, "FQ\n");	/* Turn off vector head fill */
gmt_plot.c:		PSL_setfill (GMT->PSL, rgb, outline);
gmt_plot.c:	PSL_command (GMT->PSL, "U\n");
gmt_plot.c:	bool save_pi = GMT->current.plot.substitute_pi;
gmt_plot.c:	struct PSL_CTRL *PSL= GMT->PSL;
gmt_plot.c:	if (GMT->current.proj.three_D && axis != GMT_Z) {
gmt_plot.c:		switch (GMT->current.proj.z_project.quadrant) {
gmt_plot.c:	else if (strchr (GMT->current.setting.map_annot_ortho, axis_chr[axis][below]))
gmt_plot.c:	if (GMT->current.setting.map_frame_type & GMT_IS_INSIDE) neg = !neg;	/* Annotations go either below or above the axis */
gmt_plot.c:	flip = (GMT->current.setting.map_frame_type & GMT_IS_INSIDE);	/* Inside annotation */
gmt_plot.c:	if (axis != GMT_Z && GMT->current.proj.three_D && GMT->current.proj.z_project.cos_az > 0) {	/* Rotate x/y-annotations when seen "from North" */
gmt_plot.c:	gmt_setpen (GMT, &GMT->current.setting.map_frame_pen);
gmt_plot.c:	if (GMT->current.setting.map_frame_type & GMT_IS_GRAPH) {	/* Extend axis with an arrow */
gmt_plot.c:		gmt_init_fill (GMT, &arrow, GMT->current.setting.map_frame_pen.rgb[0], GMT->current.setting.map_frame_pen.rgb[1], GMT->current.setting.map_frame_pen.rgb[2]);
gmt_plot.c:		vector_width = rint (PSL_DOTS_PER_INCH * GMT->current.setting.map_frame_pen.width / PSL_POINTS_PER_INCH) / PSL_DOTS_PER_INCH;	/* Round off vector width same way as pen width */
gmt_plot.c:		dim[5] = GMT->current.setting.map_vector_shape; dim[6] = PSL_VEC_END | PSL_VEC_FILL;
gmt_plot.c:		dim[11] = 0.5 * GMT->current.setting.map_frame_pen.width;
gmt_plot.c:		PSL_defpen (PSL, "PSL_vecheadpen", GMT->current.setting.map_frame_pen.width, GMT->current.setting.map_frame_pen.style, GMT->current.setting.map_frame_pen.offset, GMT->current.setting.map_frame_pen.rgb);
gmt_plot.c:		if (GMT->current.setting.map_graph_extension_unit == GMT_GRAPH_EXTENSION_UNIT) {	/* Gave scaling in percent */
gmt_plot.c:			g_scale_end = 1.0 + 0.01 * GMT->current.setting.map_graph_extension;
gmt_plot.c:			g_scale_begin = -0.01 * GMT->current.setting.map_graph_extension;
gmt_plot.c:			g_ext = GMT->current.setting.map_graph_extension + dim[3];
gmt_plot.c:			if (GMT->current.proj.xyz_pos[axis]) {
gmt_plot.c:			if (GMT->current.proj.xyz_pos[axis]) {
gmt_plot.c:	GMT->current.plot.substitute_pi = A->substitute_pi;
gmt_plot.c:		PSL_command (PSL, "/PSL_A%d_y %d def\n", k, A->item[k].active || A->item[k+2].active ? PSL_IZ (PSL, MAX(0.0,GMT->current.setting.map_tick_length[k])) : 0);	/* Length of primary/secondary tickmark */
gmt_plot.c:		gmt_setpen (GMT, &GMT->current.setting.map_tick_pen[GMT_PRIMARY]);
gmt_plot.c:				if (GMT->current.setting.map_frame_type & GMT_IS_INSIDE && (fabs (knots[i] - val0) < GMT_CONV8_LIMIT || fabs (knots[i] - val1) < GMT_CONV8_LIMIT)) continue;	/* Skip annotation on edges when MAP_FRAME_TYPE = inside */
gmt_plot.c:					PSL_plotsegment (PSL, x, 0.0, x, ((neg) ? -1.0 : 1.0) * GMT->current.setting.map_tick_length[k]);
gmt_plot.c:					PSL_plotsegment (PSL, 0.0, x, ((neg) ? -1.0 : 1.0) * GMT->current.setting.map_tick_length[k], x);
gmt_plot.c:			font = GMT->current.setting.font_annot[annot_pos];	/* Set the font to use */
gmt_plot.c:				if (axis == GMT_Z && fabs (knots[i] - GMT->current.proj.z_level) < GMT_CONV8_LIMIT) continue;	/* Skip z annotation coinciding with z-level plane */
gmt_plot.c:				if (GMT->current.setting.map_frame_type & GMT_IS_INSIDE && (fabs (knots[i] - val0) < GMT_CONV8_LIMIT || fabs (knots[i] - val1) < GMT_CONV8_LIMIT)) continue;	/* Skip annotation on edges when MAP_FRAME_TYPE = inside */
gmt_plot.c:					gmtlib_get_coordinate_label (GMT, string, &GMT->current.plot.calclock, format, T, knots[i]);	/* Get annotation string */
gmt_plot.c:				PSL_command (PSL, "/PSL_A0_y PSL_A0_y %d add ", PSL_IZ (PSL, GMT->current.setting.map_annot_offset[annot_pos]));
gmt_plot.c:				PSL_command (PSL, "/PSL_A1_y PSL_A0_y PSL_A1_y mx %d add ", PSL_IZ (PSL, GMT->current.setting.map_annot_offset[annot_pos]));
gmt_plot.c:				if (axis == GMT_Z && fabs (knots[i] - GMT->current.proj.z_level) < GMT_CONV8_LIMIT) continue;	/* Skip z annotation coinciding with z-level plane */
gmt_plot.c:				if (GMT->current.setting.map_frame_type & GMT_IS_INSIDE && (fabs (knots[i] - val0) < GMT_CONV8_LIMIT || fabs (knots[i] - val1) < GMT_CONV8_LIMIT)) continue;	/* Skip annotation on edges when MAP_FRAME_TYPE = inside */
gmt_plot.c:					gmtlib_get_coordinate_label (GMT, string, &GMT->current.plot.calclock, format, T, knots[i]);	/* Get annotation string */
gmt_plot.c:		form = gmt_setfont (GMT, &GMT->current.setting.font_label);
gmt_plot.c:		PSL_deftextdim (PSL, "-h", GMT->current.setting.font_label.size, "M");
gmt_plot.c:		PSL_command (PSL, "/PSL_L_y PSL_A0_y PSL_A1_y mx %d add %sdef\n", PSL_IZ (PSL, GMT->current.setting.map_label_offset), (neg == horizontal) ? "PSL_LH add " : "");
gmt_plot.c:			PSL_plottext (PSL, 0.0, 0.0, -GMT->current.setting.font_label.size, this_label, 0.0 + y_angle_add, i, form);
gmt_plot.c:			PSL_plottext (PSL, 0.0, 0.0, -GMT->current.setting.font_label.size, this_label, (horizontal ? 0.0 : 90.0) + angle_add, l_just, form);
gmt_plot.c:	GMT->current.plot.substitute_pi = save_pi;
gmt_plot.c:	if (gmt_M_is_azimuthal (GMT) && !GMT->current.proj.polar) {	/* Not implemented yet */
gmt_plot.c:	else if (GMT->common.R.oblique) {	/* Rectangular box, work with plot units */
gmt_plot.c:		double xx = GMT->current.map.half_width - width;	/* x-coordinate on west boundary for this y */
gmt_plot.c:		xx = GMT->current.map.half_width + width;		/* x-coordinate on east boundary for this y */
gmt_plot.c:		if (y < GMT->current.map.half_height) return 0;		/* Sits on south border */
gmt_plot.c:		if (doubleAlmostEqualZero (lon, GMT->common.R.wesn[XHI])) return 1;
gmt_plot.c:		else if (doubleAlmostEqualZero (lon, GMT->common.R.wesn[XLO])) return 3;
gmt_plot.c:		else if (doubleAlmostEqualZero (lat, GMT->common.R.wesn[YHI])) return 2;
gmt_plot.c:		else if (doubleAlmostEqualZero (lat, GMT->common.R.wesn[YLO])) return 0;
gmt_plot.c:			if (GMT->common.R.oblique) return (0.0);	/* We know it is horizontal */
gmt_plot.c:			del = (GMT->common.R.wesn[XHI] - GMT->common.R.wesn[XLO]) / 360.0;
gmt_plot.c:			if (GMT->common.R.oblique) return (90.0);	/* We know it is vertical */
gmt_plot.c:			del = (GMT->common.R.wesn[YHI] - GMT->common.R.wesn[YLO]) / 180.0;
gmt_plot.c:	double W = 0.5 * GMT->current.setting.ps_penwidth * GMT->session.u2u[GMT_PT][GMT_INCH];	/* Half the current pen width in inches */
gmt_plot.c:			L = GMT->current.map.width;
gmt_plot.c:			L = MIN (fabs (W / tan_angle), GMT->current.map.half_width);	/* L is positive */
gmt_plot.c:			L = GMT->current.map.height;
gmt_plot.c:			L = MIN (fabs (W * tan_angle), GMT->current.map.height);	/* L is positive */
gmt_plot.c:	GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Extend from (%g, %g) to (%g, %g) in direction %g by %g\" on %c side\n", *x_off, *y_off, x_on, y_on, angle, L, side[k]);
gmt_plot.c:	double W = 0.5 * GMT->current.setting.ps_penwidth * GMT->session.u2u[GMT_PT][GMT_INCH];	/* Half the current pen width in inches */
gmt_plot.c:		//L = GMT->current.map.width; /* What we want but still picking up stray horizontal lines, hence L = 0 for now */
gmt_plot.c:		L = MIN (fabs (W / tan_angle), GMT->current.map.half_width);	/* L is positive */
gmt_plot.c:	GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Extend from (%g, %g) to crossing point (%g, %g) in direction %g by %g\" on %c side with border angle %g and delta angle %g\n", *x_off, *y_off, x_on, y_on, angle, L, side[k], border_angle, d_angle);
gmt_plot.c:	struct PSL_CTRL *PSL= GMT->PSL;
gmt_plot.c:	for (j = i + 1, stop = false; !stop && j < n; j++) stop = (pen[j] & PSL_MOVE || (*GMT->current.map.jump) (GMT, x[j-1], y[j-1], x[j], y[j]));
gmt_plot.c:			//bool rect = gmt_M_is_rect_graticule (GMT) || GMT->common.R.oblique;	/* We have a rectangular map boundary */
gmt_plot.c:			bool rect = !(gmt_M_is_azimuthal (GMT) && !GMT->current.proj.polar);
gmt_plot.c:    if (GMT->common.R.oblique) {
gmt_plot.c:        double www = GMT->current.proj.rect[XHI] - GMT->current.proj.rect[XLO];
gmt_plot.c:		if (pen[im1] & PSL_MOVE && pen[i] == PSL_DRAW && (ip1 == n || pen[ip1] & PSL_MOVE) && GMT->current.proj.projection_GMT == GMT_OBLIQUE_MERC && fabs (y[i]-y[im1]) < 0.001) {
gmt_plot.c:				GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Skipping a stray line across map.\n");
gmt_plot.c:		if (pen[i] == pen[im1] && (way = (*GMT->current.map.jump) (GMT, x[im1], y[im1], x[i], y[i]))) {	/* Jumped across the map */
gmt_plot.c:			(*GMT->current.map.get_crossings) (GMT, x_cross, y_cross, x[im1], y[im1], x[i], y[i]);
gmt_plot.c:		if (GMT->current.proj.projection_GMT == GMT_POLAR) {	/* Different for polar graphs since "lat" = 0 is at the center */
gmt_plot.c:			ys = cap_stop[0] = cap_stop[1] = p_cap = 90.0 - GMT->current.setting.map_polar_cap[0];
gmt_plot.c:			p_cap = GMT->current.setting.map_polar_cap[0];
gmt_plot.c:		cap = !doubleAlmostEqual (GMT->current.setting.map_polar_cap[0], 90.0);
gmt_plot.c:	nx = gmtlib_linear_array (GMT, w, e, dval, GMT->current.map.frame.axis[GMT_X].phase, &x);
gmt_plot.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Draw %s = %g from %g to %g\n", type, x[i], ys, yn);
gmt_plot.c:		if (s < -GMT->current.setting.map_polar_cap[0]) {	/* Must draw some or all of the S polar cap */
gmt_plot.c:			nx = gmtlib_linear_array (GMT, w, e, GMT->current.setting.map_polar_cap[1], GMT->current.map.frame.axis[GMT_X].phase, &x);
gmt_plot.c:				GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Draw S polar cap %s = %g from %g to %g\n", type, x[i], ys, yn);
gmt_plot.c:		if (n > GMT->current.setting.map_polar_cap[0]) {	/* Must draw some or all of the N polar cap */
gmt_plot.c:			if (nx == 0) nx = gmtlib_linear_array (GMT, w, e, GMT->current.setting.map_polar_cap[1], GMT->current.map.frame.axis[GMT_X].phase, &x);
gmt_plot.c:				GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Draw N polar cap %s = %g from %g to %g\n", type, x[i], ys, yn);
gmt_plot.c:	struct PSL_CTRL *PSL= GMT->PSL;
gmt_plot.c:	if (!GMT->common.B.active[GMT_PRIMARY] && !GMT->common.B.active[GMT_SECONDARY]) return;
gmt_plot.c:	gmt_setpen (GMT, &GMT->current.setting.map_frame_pen);
gmt_plot.c:	w = GMT->common.R.wesn[XLO], e = GMT->common.R.wesn[XHI], s = GMT->common.R.wesn[YLO], n = GMT->common.R.wesn[YHI];
gmt_plot.c:	if (GMT->current.setting.map_annot_oblique & GMT_OBL_ANNOT_LON_HORIZONTAL) GMT->current.map.frame.horizontal = 2;
gmt_plot.c:	if (GMT->current.map.frame.horizontal == 2) GMT->current.setting.map_annot_oblique |= GMT_OBL_ANNOT_LON_HORIZONTAL;
gmt_plot.c:	if (GMT->current.setting.map_frame_type & GMT_IS_GRAPH && gmt_M_is_geographic (GMT, GMT_IN)) GMT->current.setting.map_frame_type = GMT_IS_PLAIN;
gmt_plot.c:	if (GMT->current.setting.map_frame_type & GMT_IS_FANCY && !plot_is_fancy_boundary(GMT)) GMT->current.setting.map_frame_type = GMT_IS_PLAIN;
gmt_plot.c:	gmt_vertical_axis (GMT, GMT->current.plot.mode_3D);
gmt_plot.c:	if (GMT->current.proj.got_azimuths) gmt_M_uint_swap (GMT->current.map.frame.side[E_SIDE], GMT->current.map.frame.side[W_SIDE]);	/* Temporary swap to trick justify machinery */
gmt_plot.c:	if (GMT->current.setting.map_frame_type & GMT_IS_INSIDE && !GMT->current.map.frame.header[0]) {
gmt_plot.c:		gmt_map_clip_on (GMT, GMT->session.no_rgb, 3);	/* Must clip to ensure things are inside */
gmt_plot.c:	if (GMT->current.proj.got_azimuths) gmt_M_uint_swap (GMT->current.map.frame.side[E_SIDE], GMT->current.map.frame.side[W_SIDE]);	/* Undo temporary swap */
gmt_plot.c:	PSL_setcolor (PSL, GMT->current.setting.map_default_pen.rgb, PSL_IS_STROKE);
gmt_plot.c:	struct PSL_CTRL *PSL= GMT->PSL;
gmt_plot.c:	if (!GMT->current.proj.three_D) return;
gmt_plot.c:	if (!GMT->current.map.frame.drawz) return;
gmt_plot.c:	nesw[0] = GMT->current.proj.rect[YHI], nesw[1] = GMT->current.proj.rect[XHI], nesw[2] = GMT->current.proj.rect[YLO], nesw[3] = GMT->current.proj.rect[XLO];
gmt_plot.c:	old_plane = GMT->current.proj.z_project.plane;
gmt_plot.c:	old_level = GMT->current.proj.z_project.level;
gmt_plot.c:	if (GMT->current.map.frame.draw_box) {
gmt_plot.c:		PSL_setfill (PSL, GMT->session.no_rgb, true);
gmt_plot.c:		gmt_setpen (GMT, &GMT->current.setting.map_grid_pen[GMT_PRIMARY]);
gmt_plot.c:			plot_vertical_wall (GMT, PSL, GMT->current.proj.z_project.quadrant + 3, nesw, false);
gmt_plot.c:			plot_vertical_wall (GMT, PSL, GMT->current.proj.z_project.quadrant    , nesw, false);
gmt_plot.c:			plot_vertical_wall (GMT, PSL, GMT->current.proj.z_project.quadrant + 1, nesw, true);
gmt_plot.c:			plot_vertical_wall (GMT, PSL, GMT->current.proj.z_project.quadrant + 2, nesw, true);
gmt_plot.c:	if (fore && GMT->current.map.frame.side[Z_SIDE]) {
gmt_plot.c:		gmt_M_memcpy (z_axis, GMT->current.map.frame.z_axis, 4, unsigned int);
gmt_plot.c:		if (n_z == 0) z_axis[corner_to_quadrant[GMT->current.proj.z_project.quadrant]-1] = 1;	/* Set the default corner given the quadrant */
gmt_plot.c:			gmt_xyz_to_xy (GMT, nesw[(quadrant/2*2+1)%4], nesw[((quadrant+1)/2*2)%4], GMT->common.R.wesn[ZLO], &xx, &yy);
gmt_plot.c:			az = GMT->current.proj.z_project.view_azimuth - 90.0 - floor ((GMT->current.proj.z_project.view_azimuth - 45.0) / 90.0) * 90.0;
gmt_plot.c:				cosd(az), sind(az) * GMT->current.proj.z_project.sin_el, 0.0, GMT->current.proj.z_project.cos_el, xx * PSL->internal.x2ix, yy * PSL->internal.y2iy);
gmt_plot.c:			gmt_xy_axis (GMT, 0.0, -GMT->common.R.wesn[ZLO], GMT->current.proj.zmax - GMT->current.proj.zmin, GMT->common.R.wesn[ZLO],
gmt_plot.c:				GMT->common.R.wesn[ZHI], &GMT->current.map.frame.axis[GMT_Z], true, GMT->current.map.frame.side[Z_SIDE]);
gmt_plot.c:	if (back && GMT->current.map.frame.header[0] && !GMT->current.map.frame.plotted_header) {	/* No header today */
gmt_plot.c:		form = gmt_setfont (GMT, &GMT->current.setting.font_title);
gmt_plot.c:		PSL_plottext (PSL, 0.5 * (GMT->current.proj.z_project.xmin + GMT->current.proj.z_project.xmax),
gmt_plot.c:			GMT->current.proj.z_project.ymax + GMT->current.setting.map_title_offset,
gmt_plot.c:			GMT->current.setting.font_title.size, GMT->current.map.frame.header, 0.0, -PSL_BC, form);
gmt_plot.c:		GMT->current.map.frame.plotted_header = true;
gmt_plot.c:	struct PSL_CTRL *PSL= GMT->PSL;
gmt_plot.c:	PSL_comment (GMT->PSL, "Deactivate Map clip path\n");
gmt_plot.c:	PSL_endclipping (GMT->PSL, 1);		/* Reduce polygon clipping by one level */
gmt_plot.c:	struct PSL_CTRL *PSL= GMT->PSL;
gmt_plot.c:	work_x[0] = work_x[3] = work_x[4] = GMT->current.proj.rect[XLO];
gmt_plot.c:	work_x[1] = work_x[2] = GMT->current.proj.rect[XHI];
gmt_plot.c:	work_y[0] = work_y[1] = work_y[4] = GMT->current.proj.rect[YLO];
gmt_plot.c:	work_y[2] = work_y[3] = GMT->current.proj.rect[YHI];
gmt_plot.c:	struct PSL_CTRL *PSL= GMT->PSL;
gmt_plot.c:		PSL_setfill (PSL, GMT->session.no_rgb, outline);
gmt_plot.c:	PSL_setfont (GMT->PSL, F->id);	/* Set the current font ID */
gmt_plot.c:		PSL_setcolor (GMT->PSL, F->fill.rgb, PSL_IS_FONT);
gmt_plot.c:					dim[k] /= GMT->current.map.dist[GMT_MAP_DIST].scale;	/* Convert units to meters */
gmt_plot.c:					dim[k] *= GMT->current.proj.scale[k];		/* Turns meters into inches on map */
gmt_plot.c:			for (k = 0; k < 4; k++) rect[k] /= GMT->current.map.dist[GMT_MAP_DIST].scale;	/* Turns units to meters */
gmt_plot.c:			rect[XLO] = rect[XLO] * GMT->current.proj.scale[GMT_X] + GMT->current.proj.origin[GMT_X];
gmt_plot.c:			rect[XHI] = rect[XHI] * GMT->current.proj.scale[GMT_X] + GMT->current.proj.origin[GMT_X];
gmt_plot.c:			rect[YLO] = rect[YLO] * GMT->current.proj.scale[GMT_Y] + GMT->current.proj.origin[GMT_Y];
gmt_plot.c:			rect[YHI] = rect[YHI] * GMT->current.proj.scale[GMT_Y] + GMT->current.proj.origin[GMT_Y];
gmt_plot.c:			struct GMT_DATASEGMENT *S = GMT_Alloc_Segment (GMT->parent, GMT_NO_STRINGS, 0, 2, NULL, NULL);	/* Just get empty array pointers */
gmt_plot.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Unable to parse arg %s\n", fake);
gmt_plot.c:	s = GMT->session.u2u[GMT_INCH][GMT->current.setting.proj_length_unit];
gmt_plot.c:	GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Map inset lower left corner and dimensions (in %s): %g %g %g %g\n",
gmt_plot.c:		GMT->session.unit_name[GMT->current.setting.proj_length_unit], rect[XLO]*s, rect[YLO]*s, dim[GMT_X]*s, dim[GMT_Y]*s);
gmt_plot.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Unable to create file %s\n", B->file);
gmt_plot.c:		PSL_comment (GMT->PSL, "Start of inset clip path\n");
gmt_plot.c:		PSL_command (GMT->PSL, "clipsave\n");
gmt_plot.c:		PSL_plotline (GMT->PSL, xc, yc, 4, PSL_MOVE | PSL_CLOSE);	/* Must not close path since first point not given ! */
gmt_plot.c:		PSL_command (GMT->PSL, "clip N\n");
gmt_plot.c:		PSL_command (GMT->PSL, "/PSL_inset_clip 1 def\n");	/* Remember that inset clipping is on */
gmt_plot.c:		PSL_command (GMT->PSL, "/PSL_inset_clip 0 def\n");
gmt_plot.c:		PSL_setorigin (GMT->PSL, rect[XLO], rect[YLO], 0.0, PSL_FWD);
gmt_plot.c:	struct PSL_CTRL *PSL= GMT->PSL;
gmt_plot.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Bad distance unit %c\n", measure);
gmt_plot.c:		bar_length_km = 0.001 * GMT->current.proj.m_per_unit[unit] * ms->length;	/* Now in km */
gmt_plot.c:	if (gmt_M_is_dnan (ms->origin[GMT_X])) ms->origin[GMT_X] = GMT->current.proj.central_meridian;
gmt_plot.c:	dx = 0.05 * GMT->current.map.width;
gmt_plot.c:	dim[GMT_Y] = scale_height = fabs (GMT->current.setting.map_scale_height);	/* Nominal scale bar height */
gmt_plot.c:	dist_to_annot = scale_height + 0.75 * GMT->current.setting.map_annot_offset[GMT_PRIMARY];	/* Dist from top of scalebar to top of annotations */
gmt_plot.c:		bar_height = 0.5 * fabs (GMT->current.setting.map_scale_height);	/* Height of the black/white checkered fancy bar */
gmt_plot.c:		bar_tick_len = 0.75 * fabs (GMT->current.setting.map_scale_height);	/* Length of tickmarks */
gmt_plot.c:			dim[XLO] = dim[XHI] = 0.5 * (js+1) * GMT_DEC_WIDTH * GMT->current.setting.font_annot[GMT_PRIMARY].size / PSL_POINTS_PER_INCH;
gmt_plot.c:				dim[XLO] += unit_width[unit] * GMT_LET_WIDTH * GMT->current.setting.font_annot[GMT_PRIMARY].size / PSL_POINTS_PER_INCH;
gmt_plot.c:				dim[XHI] += unit_width[unit] * GMT_LET_WIDTH * GMT->current.setting.font_annot[GMT_PRIMARY].size / PSL_POINTS_PER_INCH;
gmt_plot.c:				l_width = bar_tick_len + (ms->label[0] ? strlen (ms->label) : name_width[unit]) * GMT_LET_WIDTH * GMT->current.setting.font_label.size * GMT->session.u2u[GMT_PT][GMT_INCH];
gmt_plot.c:				l_height = GMT_LET_HEIGHT * GMT->current.setting.font_label.size / PSL_POINTS_PER_INCH;	/* Approximate height of label */
gmt_plot.c:			dim[YLO] = dist_to_annot + GMT_LET_HEIGHT * GMT->current.setting.font_annot[GMT_PRIMARY].size / PSL_POINTS_PER_INCH;
gmt_plot.c:			if (ms->do_label && ms->alignment == 'b') dim[YLO] += fabs (GMT->current.setting.map_label_offset) + l_height;
gmt_plot.c:			else if (ms->do_label && ms->alignment == 't') dim[YHI] += fabs (GMT->current.setting.map_label_offset) + l_height;
gmt_plot.c:		gmt_setpen (GMT, &GMT->current.setting.map_tick_pen[GMT_PRIMARY]);
gmt_plot.c:			PSL_setfill (PSL, (j%2) ? GMT->PSL->init.page_rgb : GMT->current.setting.map_default_pen.rgb, true);
gmt_plot.c:		form = gmt_setfont (GMT, &GMT->current.setting.font_annot[GMT_PRIMARY]);
gmt_plot.c:			gmt_sprintf_float (GMT, format, GMT->current.setting.format_float_map, j * d_base);
gmt_plot.c:			PSL_plottext (PSL, tx, ty, GMT->current.setting.font_annot[GMT_PRIMARY].size, txt, 0.0, PSL_TC, form);	/* Place annotation */
gmt_plot.c:					ty = ms->refpoint->y + fabs (GMT->current.setting.map_label_offset);
gmt_plot.c:					ty = ms->refpoint->y - dist_to_annot - GMT_LET_HEIGHT * GMT->current.setting.font_annot[GMT_PRIMARY].size / PSL_POINTS_PER_INCH - fabs (GMT->current.setting.map_label_offset);
gmt_plot.c:			form = gmt_setfont (GMT, &GMT->current.setting.font_label);
gmt_plot.c:			PSL_plottext (PSL, tx, ty, GMT->current.setting.font_label.size, this_label, 0.0, justify, form);
gmt_plot.c:			dim[XLO] = dim[XHI] = fabs (GMT->current.setting.map_annot_offset[GMT_PRIMARY]);
gmt_plot.c:			dim[YLO] = dist_to_annot + GMT_LET_HEIGHT * GMT->current.setting.font_annot[GMT_PRIMARY].size / PSL_POINTS_PER_INCH;
gmt_plot.c:		gmt_setpen (GMT, &GMT->current.setting.map_tick_pen[GMT_PRIMARY]);
gmt_plot.c:		gmt_sprintf_float (GMT, format, GMT->current.setting.format_float_map, ms->length);
gmt_plot.c:		form = gmt_setfont (GMT, &GMT->current.setting.font_annot[GMT_PRIMARY]);
gmt_plot.c:		PSL_plottext (PSL, ms->refpoint->x, ms->refpoint->y - dist_to_annot, GMT->current.setting.font_annot[GMT_PRIMARY].size, txt, 0.0, PSL_TC, form);
gmt_plot.c:		scale = GMT->current.proj.scale[GMT_Y];
gmt_plot.c:	off = ((GMT->current.setting.map_scale_height > 0.0) ? GMT->current.setting.map_tick_length[0] : 0.0) + GMT->current.setting.map_annot_offset[GMT_PRIMARY];
gmt_plot.c:	dim[GMT_X] = strlen (txt) * GMT_DEC_WIDTH * GMT->current.setting.font_annot[GMT_PRIMARY].size / PSL_POINTS_PER_INCH + off;
gmt_plot.c:	gmt_xyz_to_xy (GMT, x0 + sign * GMT->current.setting.map_scale_height, y0 - half_scale_length, 0.0, &xx[0], &yy[0]);
gmt_plot.c:	gmt_xyz_to_xy (GMT, x0 + sign * GMT->current.setting.map_scale_height, y0 + half_scale_length, 0.0, &xx[3], &yy[3]);
gmt_plot.c:	gmt_setpen (GMT, &GMT->current.setting.map_tick_pen[GMT_PRIMARY]);
gmt_plot.c:	PSL_plotline (GMT->PSL, xx, yy, 4, PSL_MOVE|PSL_STROKE);
gmt_plot.c:	form = gmt_setfont (GMT, &GMT->current.setting.font_annot[GMT_PRIMARY]);
gmt_plot.c:	PSL_plottext (GMT->PSL, x0 + sign * off, y0, GMT->current.setting.font_annot[GMT_PRIMARY].size, txt, 0.0, just, form);
gmt_plot.c:	gmt_setpen (GMT, &GMT->current.setting.map_tick_pen[GMT_PRIMARY]);
gmt_plot.c:	gmt_xyz_to_xy (GMT, x0 + GMT->current.setting.map_scale_height, y0 - dy, 0.0, &xx[0], &yy[0]);
gmt_plot.c:	gmt_xyz_to_xy (GMT, x0 + GMT->current.setting.map_scale_height, y0 + dy, 0.0, &xx[3], &yy[3]);
gmt_plot.c:	off = ((GMT->current.setting.map_scale_height > 0.0) ? GMT->current.setting.map_tick_length[0] : 0.0) + GMT->current.setting.map_annot_offset[GMT_PRIMARY];
gmt_plot.c:	form = gmt_setfont (GMT, &GMT->current.setting.font_annot[GMT_PRIMARY]);
gmt_plot.c:	PSL_plottext (PSL, x0 + off, y0, GMT->current.setting.font_annot[GMT_PRIMARY].size, txt, 0.0, PSL_ML, form);
gmt_plot.c:	struct PSL_CTRL *PSL= GMT->PSL;
gmt_plot.c:	GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Place rectangular back panel\n");
gmt_plot.c:	GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Clearance: %g/%g/%g/%g\n", P->padding[XLO], P->padding[XLO], P->padding[YLO], P->padding[YHI]);
gmt_plot.c:		PSL_plotsymbol (GMT->PSL, x + P->off[GMT_X], y + P->off[GMT_Y], dim, (P->mode & GMT_PANEL_ROUNDED) ? PSL_RNDRECT : PSL_RECT);
gmt_plot.c:	if ((mode&1 && (P->mode & GMT_PANEL_FILL)) || (mode&2 && (P->mode & GMT_PANEL_OUTLINE))) PSL_plotsymbol (GMT->PSL, x, y, dim, (P->mode & GMT_PANEL_ROUNDED) ? PSL_RNDRECT : PSL_RECT);
gmt_plot.c:		PSL_plotsymbol (GMT->PSL, x, y, dim, (P->mode & GMT_PANEL_ROUNDED) ? PSL_RNDRECT : PSL_RECT);
gmt_plot.c:	PSL_setcolor (GMT->PSL, GMT->current.setting.map_frame_pen.rgb, PSL_IS_STROKE);
gmt_plot.c:	GMT->current.setting.ps_penwidth = pen->width;	/* Remember current pen width */
gmt_plot.c:	PSL_setlinewidth (GMT->PSL, pen->width);
gmt_plot.c:	PSL_setdash (GMT->PSL, pen->style, pen->offset);
gmt_plot.c:	PSL_setcolor (GMT->PSL, pen->rgb, PSL_IS_STROKE);
gmt_plot.c:	struct GMT_FONT font = GMT->current.setting.font_annot[GMT_PRIMARY];
gmt_plot.c:	struct PSL_CTRL *PSL= GMT->PSL;
gmt_plot.c:			if ((symbol->PS & 4) == 0)	/* non-GMT-produced EPS macro - scale points to GMT's unit */
gmt_plot.c:					GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Symbol macro (%s) logical nesting too deep [> %d]\n", symbol->name, GMT_N_COND_LEVELS);
gmt_plot.c:					GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Symbol macro (%s) logical nesting error\n", symbol->name);
gmt_plot.c:				s->pen->width = fabs (s->pen->width * size[0] * GMT->session.u2u[GMT_INCH][GMT_PT]);
gmt_plot.c:				s->pen->width = size[s->var_pen] * GMT->session.u2u[GMT_INCH][GMT_PT];
gmt_plot.c:			action = GMT->current.io.curr_trailing_text[strlen(GMT->current.io.curr_trailing_text)-1];
gmt_plot.c:					GMT_Report (GMT->parent, GMT_MSG_COMPAT, "Circle macro symbol C is deprecated; use c instead\n");
gmt_plot.c:					GMT_Report (GMT->parent, GMT_MSG_NORMAL,
gmt_plot.c:				dim[5] = p.width * GMT->session.u2u[GMT_PT][GMT_INCH];
gmt_plot.c:					PSL_setfill (PSL, GMT->session.no_rgb, this_outline);
gmt_plot.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL,
gmt_plot.c:	if ((G->Out = GMT_Create_Data (GMT->parent, GMT_IS_DATASET, GMT_IS_POINT, GMT_WITH_STRINGS, dim, NULL, NULL, 0, 0, NULL)) == NULL) {
gmt_plot.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Unable to create a dataset\n");
gmt_plot.c:	snprintf (record, GMT_BUFSIZ, "# %s%s%s%sangle%slabel", xname[kind], GMT->current.setting.io_col_separator, yname[kind],
gmt_plot.c:		GMT->current.setting.io_col_separator, GMT->current.setting.io_col_separator);
gmt_plot.c:	GMT_Set_Comment (GMT->parent, GMT_IS_DATASET, GMT_COMMENT_IS_TEXT | GMT_COMMENT_IS_COMMAND, record, G->Out);
gmt_plot.c:	if (GMT_Write_Data (GMT->parent, GMT_IS_DATASET, GMT_IS_FILE, GMT_IS_POINT, GMT_WRITE_SET, NULL, G->label_file, G->Out) != GMT_NOERROR) {
gmt_plot.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Unable to create/write to file %s\n", G->label_file);
gmt_plot.c:	GMT_Destroy_Data (GMT->parent, &(G->Out));
gmt_plot.c:	PSL_comment (GMT->PSL, "Pen and fill for text boxes (if enabled):\n");
gmt_plot.c:	PSL_defpen (GMT->PSL, "PSL_setboxpen", BP->width, BP->style, BP->offset, BP->rgb);
gmt_plot.c:	PSL_defcolor (GMT->PSL, "PSL_setboxrgb", Brgb);
gmt_plot.c:	struct PSL_CTRL *PSL= GMT->PSL;
gmt_plot.c:	PSL_command (GMT->PSL, "[] 0 B\n");	/* Ensure no pen textures remain in effect */
gmt_plot.c:		GMT->current.ps.active ? sprintf(scale_c, "14c") : sprintf(scale_c, "1:1");
gmt_plot.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Did not get the SRS from input EPSG  %d\n", EPSGID);
gmt_plot.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Failed to convert the SRS to proj4 syntax\n");
gmt_plot.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Cannot open %s file\n", buffer);
gmt_plot.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Could not find the EPGS code %d in database\n", EPSGID);
gmt_plot.c:		GMT->current.proj.projection_GMT = GMT_LINEAR;
gmt_plot.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "In projection %s proj parameters\n", prjcode);
gmt_plot.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "UTM proj selected but no info about utm zone.\n");	
gmt_plot.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "UTM proj The lon_0 argument was not correctly parsed.\n");	
gmt_plot.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Projection %s needs the lat_1 & lat_2 proj parameters\n", prjcode);
gmt_plot.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Sorry, mapping this projection '%s' is not supported in GMT\n", prjcode);
gmt_plot.c:		GMT->current.setting.ref_ellipsoid[GMT->current.setting.proj_ellipsoid].eq_radius = atof(&token[2]);
gmt_plot.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "+b= in proj4 string without the companion +a\n");
gmt_plot.c:		f =  1 - atof(&token[2]) / GMT->current.setting.ref_ellipsoid[GMT->current.setting.proj_ellipsoid].eq_radius;
gmt_plot.c:		GMT->current.setting.ref_ellipsoid[GMT->current.setting.proj_ellipsoid].flattening = f;
gmt_plot.c:		GMT->current.setting.proj_scale_factor = atof (&token[4]);
gmt_plot.c:		GMT->current.setting.proj_scale_factor = atof (&token[2]);
gmt_plot.c:			;//sprintf(GMT->current.setting.ref_ellipsoid[GMT->current.setting.proj_ellipsoid].name, "%s", ename);
gmt_plot.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "could not translate the ellipsoid name %s\n", &token[6]);
gmt_plot.c:			GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "this datum %s is not yet ported to GMT\n", &token[6]);
gmt_plot.c:			sprintf(GMT->current.setting.ref_ellipsoid[GMT->current.setting.proj_ellipsoid].name, "%s", ename);
gmt_plot.c:			GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "could not translate the ellipsoid name %s\n", &token[6]);
gmt_plot.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, 
gmt_plot.c:			        GMT->current.setting.ref_ellipsoid[GMT->current.setting.proj_ellipsoid].eq_radius,
gmt_plot.c:					1 / GMT->current.setting.ref_ellipsoid[GMT->current.setting.proj_ellipsoid].flattening,
gmt_plot.c:			GMT->current.proj.datum.bursa[k] = GMT->current.proj.datum.to.xyz[k];
gmt_plot.c:		GMT->current.proj.proj4_x0 = atof(&token[4]);
gmt_plot.c:		GMT->current.proj.proj4_y0 = atof(&token[4]);
gmt_plot.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "using units other than meters is not yet implemented\n");
gmt_plot.c:		GMT->current.proj.gave_map_width = 0;
gmt_plot.c:		GMT->current.proj.proj4_scl = gmt_M_to_inch (GMT, scale_c);
gmt_plot.c:		GMT->current.proj.gave_map_width = 1;
gmt_plot.c:		GMT->current.proj.proj4_scl = gmt_M_to_inch (GMT, &token[6]);
gmt_plot.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Original proj4 string was not all consumend. Remaining options:\n\t%s\n", szProj4);
gmt_plot.c:	GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Converted to -J syntax = -J%s\n", opt_J);
gmt_plot.c:	GMT->current.proj.is_proj4 = true;		/* Used so far in map|grdproject to set local -C */ 
gmt_plot.c:	if (GMT->common.J.proj4string[0] == '+') {
gmt_plot.c:		pStrOut = strdup (GMT->common.J.proj4string);
gmt_plot.c:	scale_factor = GMT->current.setting.proj_scale_factor;
gmt_plot.c:	switch (GMT->current.proj.projection_GMT) {
gmt_plot.c:		snprintf (szProj4, GMT_LEN512, "+proj=utm +zone=%d +units=m", (int)GMT->current.proj.pars[0]);
gmt_plot.c:		if (GMT->current.proj.utm_hemisphere < 0) strcat (szProj4, " +south");
gmt_plot.c:			GMT->current.proj.pars[0] >= -360 ? GMT->current.proj.pars[0] : 0, scale_factor, false_easting, false_northing);
gmt_plot.c:			GMT->current.proj.pars[1], GMT->current.proj.pars[0], false_easting, false_northing);
gmt_plot.c:			GMT->current.proj.pars[1], 0.0, GMT->current.proj.pars[0], false_easting, false_northing);
gmt_plot.c:			GMT->current.proj.pars[1], GMT->current.proj.pars[0], false_easting, false_northing);
gmt_plot.c:			GMT->current.proj.pars[1], GMT->current.proj.pars[0], scale_factor, false_easting, false_northing);
gmt_plot.c:			GMT->current.proj.pars[1], GMT->current.proj.pars[0], false_easting, false_northing);
gmt_plot.c:			GMT->current.proj.pars[2], GMT->current.proj.pars[3], GMT->current.proj.pars[1], GMT->current.proj.pars[0], false_easting, false_northing);
gmt_plot.c:			GMT->current.proj.pars[2], GMT->current.proj.pars[3], GMT->current.proj.pars[1], GMT->current.proj.pars[0], false_easting, false_northing);
gmt_plot.c:			GMT->current.proj.pars[2], GMT->current.proj.pars[3], GMT->current.proj.pars[1], GMT->current.proj.pars[0], false_easting, false_northing);
gmt_plot.c:			GMT->current.proj.pars[1], GMT->current.proj.pars[0], false_easting, false_northing);
gmt_plot.c:			GMT->current.proj.pars[1], GMT->current.proj.pars[0], scale_factor, false_easting, false_northing);
gmt_plot.c:			GMT->current.proj.pars[1], GMT->current.proj.pars[0], false_easting, false_northing);
gmt_plot.c:			GMT->current.proj.pars[1], GMT->current.proj.pars[0], false_easting, false_northing);
gmt_plot.c:			GMT->current.proj.pars[1], GMT->current.proj.pars[0], false_easting, false_northing);
gmt_plot.c:			GMT->current.proj.pars[0], false_easting, false_northing);
gmt_plot.c:			GMT->current.proj.pars[0], false_easting, false_northing);
gmt_plot.c:			GMT->current.proj.pars[0], false_easting, false_northing);
gmt_plot.c:			GMT->current.proj.pars[0], false_easting, false_northing);
gmt_plot.c:			GMT->current.proj.pars[0], false_easting, false_northing);
gmt_plot.c:			GMT->current.proj.pars[0], false_easting, false_northing);
gmt_plot.c:		a = GMT->current.setting.ref_ellipsoid[GMT->current.setting.proj_ellipsoid].eq_radius;
gmt_plot.c:		f = GMT->current.setting.ref_ellipsoid[GMT->current.setting.proj_ellipsoid].flattening;
gmt_plot.c:			plot_ellipsoid_name_convert(GMT->current.setting.ref_ellipsoid[GMT->current.setting.proj_ellipsoid].name, proj4_ename);
gmt_plot.c:	bool O_active = GMT->common.O.active, auto_media = false;
gmt_plot.c:	struct GMT_INSET *I = &(GMT->current.plot.inset);	/* I->active == 1 if an inset */
gmt_plot.c:	PSL = GMT->PSL;	/* Shorthand */
gmt_plot.c:	PSL->internal.verbose = GMT->current.setting.verbose;		/* Inherit verbosity level from GMT */
gmt_plot.c:	if (gmt_M_compat_check (GMT, 4) && GMT->current.setting.ps_copies > 1) PSL->init.copies = GMT->current.setting.ps_copies;
gmt_plot.c:	PSL_setdefaults (PSL, GMT->current.setting.ps_magnify, GMT->current.setting.ps_page_rgb, GMT->current.setting.ps_encoding.name);
gmt_plot.c:	GMT->current.ps.memory = false;
gmt_plot.c:	if (doubleAlmostEqual (GMT->current.setting.ps_page_size[GMT_X], GMT_PAPER_DIM) && doubleAlmostEqual (GMT->current.setting.ps_page_size[GMT_Y], GMT_PAPER_DIM))
gmt_plot.c:	gmt_M_memcpy (media_size, GMT->current.setting.ps_page_size, 2, double);
gmt_plot.c:	GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Running in PS mode %s\n", ps_mode[GMT->current.setting.run_mode]);
gmt_plot.c:	if (GMT->current.setting.run_mode == GMT_MODERN) {	/* Write PS to hidden gmt_#.ps- file.  No -O -K allowed */
gmt_plot.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "No workflow directory\n");
gmt_plot.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "%s hidden PS file %s\n", verb[k], GMT->current.ps.filename);
gmt_plot.c:		if ((fp = PSL_fopen (PSL, GMT->current.ps.filename, mode[k])) == NULL) {	/* Must open inside PSL DLL */
gmt_plot.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Cannot open %s with mode %s\n", GMT->current.ps.filename, mode[k]);
gmt_plot.c:				GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Must specify a paper size when requesting a PostScript file\n");
gmt_plot.c:				if (GMT->current.setting.proj_length_unit == GMT_INCH) {	/* Use US settings */
gmt_plot.c:					GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Changing paper size to US Letter, but we cannot know if this is adequate for your plot; use PS_MEDIA.\n");
gmt_plot.c:					GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Changing paper size to A4, but we cannot know if this is adequate for your plot.\n");
gmt_plot.c:			if ((GMT->current.map.width > GMT->current.map.height) && (((GMT->current.map.width + GMT->current.setting.map_origin[GMT_X]) * 72) > media_size[GMT_X]) && GMT->current.setting.ps_orientation == PSL_PORTRAIT) {
gmt_plot.c:				GMT->current.setting.ps_orientation = PSL_LANDSCAPE;
gmt_plot.c:				GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Changing to PostScript landscape orientation based on plot and paper dimensions but cannot not sure.  Use PS_PAGE_ORIENTATION to correct any error\n");
gmt_plot.c:			if (!(GMT->common.X.active || GMT->common.Y.active) && auto_media)
gmt_plot.c:				GMT->current.setting.map_origin[GMT_X] = GMT->current.setting.map_origin[GMT_Y] = GMT_PAPER_MARGIN;
gmt_plot.c:			snprintf (file, PATH_MAX, "%s/gmt.movie", GMT->parent->gwf_dir);
gmt_plot.c:						GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Number of movie labels exceed capacity [%d] - skipped.\n", n_movie_labels);
gmt_plot.c:					GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Found MOVIE_LABEL_ARG%d = %s.\n", n_movie_labels, record);
gmt_plot.c:					GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Cannot delete file %s\n", file);
gmt_plot.c:	else if ((Out = GMT_Find_Option (GMT->parent, '>', options))) {	/* Want to use a specific output file */
gmt_plot.c:			GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "-O given but append-mode not selected for file %s\n", &(Out->arg[k]));
gmt_plot.c:			GMT->current.ps.memory = true;
gmt_plot.c:			strncpy (GMT->current.ps.memname, &(Out->arg[k]), GMT_STR16-1);
gmt_plot.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Cannot open %s with mode %s\n", &(Out->arg[k]), mode[k]);
gmt_plot.c:			GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Opened PS file %s\n", &(Out->arg[k]));
gmt_plot.c:	if (GMT->common.P.active) GMT->current.setting.ps_orientation = true;
gmt_plot.c:	if (!GMT->common.X.active && O_active) GMT->current.setting.map_origin[GMT_X] = 0.0;
gmt_plot.c:	if (!GMT->common.Y.active && O_active) GMT->current.setting.map_origin[GMT_Y] = 0.0;
gmt_plot.c:	if (GMT->current.ps.origin[GMT_X] == 'c') GMT->current.setting.map_origin[GMT_X] -= 0.5 * GMT->current.map.width;
gmt_plot.c:	if (GMT->current.ps.origin[GMT_Y] == 'c') GMT->current.setting.map_origin[GMT_Y] -= 0.5 * GMT->current.map.height;
gmt_plot.c:	if (GMT->common.U.active) fno[id++] = GMT->current.setting.font_logo.id;	/* Add GMT logo font */
gmt_plot.c:	if (GMT->current.map.frame.header[0]) fno[id++] = GMT->current.setting.font_title.id;
gmt_plot.c:	if (GMT->current.map.frame.axis[GMT_X].label[0] || GMT->current.map.frame.axis[GMT_Y].label[0] || GMT->current.map.frame.axis[GMT_Z].label[0])
gmt_plot.c:		fno[id++] = GMT->current.setting.font_label.id;
gmt_plot.c:	fno[id++] = GMT->current.setting.font_annot[GMT_PRIMARY].id;
gmt_plot.c:	fno[id++] = GMT->current.setting.font_annot[GMT_SECONDARY].id;
gmt_plot.c:	P = &(GMT->current.plot.panel);
gmt_plot.c:		GMT->current.setting.map_origin[GMT_X] += (P->dx + P->gap[XLO]);
gmt_plot.c:		GMT->current.setting.map_origin[GMT_Y] += (P->dy + P->gap[YLO]);
gmt_plot.c:		GMT->current.setting.map_origin[GMT_X] += (I->dx);
gmt_plot.c:		GMT->current.setting.map_origin[GMT_Y] += (I->dy);
gmt_plot.c:	if (O_active && GMT->current.ps.switch_set) {	/* User used --PS_CHAR_ENCODING=<encoding> to change it */
gmt_plot.c:		GMT->current.ps.switch_set = false;
gmt_plot.c:	snprintf (GMT->current.ps.title, GMT_LEN256, "GMT v%s Document from %s", GMT_VERSION, GMT->init.module_name);
gmt_plot.c:	PSL_beginplot (PSL, fp, GMT->current.setting.ps_orientation|write_to_mem|switch_charset, O_active, GMT->current.setting.ps_color_mode,
gmt_plot.c:		GMT->current.ps.origin, GMT->current.setting.map_origin, media_size, GMT->current.ps.title, fno);
gmt_plot.c:	if (GMT->common.p.do_z_rotation) {	/* Need a rotation about z of the whole page */
gmt_plot.c:		if (GMT->current.proj.z_project.view_given) {	/* Rotation is about another z-axis than through the origin */
gmt_plot.c:			x0 = GMT->current.proj.z_project.view_x;
gmt_plot.c:			y0 = GMT->current.proj.z_project.view_y;
gmt_plot.c:		else if (GMT->current.proj.z_project.world_given)	/* Rotation is about another lon/lat pole than the origin */
gmt_plot.c:			gmt_geo_to_xy (GMT, GMT->current.proj.z_project.world_x, GMT->current.proj.z_project.world_y, &x0, &y0);
gmt_plot.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Transrot: Rotating plot by %g degrees about (%g, %g)\n", GMT->common.p.z_rotation, x0, y0);
gmt_plot.c:		PSL_comment (GMT->PSL, "Possibly translate then rotate whole page\n");
gmt_plot.c:		PSL_setorigin (PSL, x0, y0, GMT->common.p.z_rotation, PSL_FWD);
gmt_plot.c:	this_proj = GMT->current.proj.projection_GMT;
gmt_plot.c:		if (GMT->current.proj.proj4[k].id == this_proj) id = k;
gmt_plot.c:		Cartesian_m[0] = (GMT->current.proj.rect[YLO] - GMT->current.proj.origin[GMT_Y]) * GMT->current.proj.i_scale[GMT_Y];
gmt_plot.c:		Cartesian_m[1] = (GMT->current.proj.rect[XHI] - GMT->current.proj.origin[GMT_X]) * GMT->current.proj.i_scale[GMT_X];
gmt_plot.c:		Cartesian_m[2] = (GMT->current.proj.rect[YHI] - GMT->current.proj.origin[GMT_Y]) * GMT->current.proj.i_scale[GMT_Y];
gmt_plot.c:		Cartesian_m[3] = (GMT->current.proj.rect[XLO] - GMT->current.proj.origin[GMT_X]) * GMT->current.proj.i_scale[GMT_X];
gmt_plot.c:		if (GMT->current.proj.projection_GMT == GMT_LINEAR && gmt_M_is_geographic (GMT, GMT_IN))
gmt_plot.c:			strncpy (proj4name, GMT->current.proj.proj4[id].name, 15U);
gmt_plot.c:			GMT->common.R.wesn[XLO], GMT->common.R.wesn[XHI], GMT->common.R.wesn[YLO], GMT->common.R.wesn[YHI],
gmt_plot.c:			GMT->current.setting.map_origin[GMT_X] * 72.0, GMT->current.setting.map_origin[GMT_Y] * 72.0,
gmt_plot.c:			GMT->current.map.width * 72.0, GMT->current.map.height * 72.0);
gmt_plot.c:		GMT->current.ps.layer = 0;
gmt_plot.c:	PSL_beginlayer (GMT->PSL, ++GMT->current.ps.layer);
gmt_plot.c:	if (GMT->common.t.active) {
gmt_plot.c:		if (GMT->common.t.value == 0.0) {
gmt_plot.c:			GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "A transparency of 0 is the same as opaque. Skipped\n");
gmt_plot.c:			GMT->common.t.active = false;
gmt_plot.c:			PSL_command (PSL, "%g /%s PSL_transp\n", 1.0 - 0.01 * GMT->common.t.value, GMT->current.setting.ps_transpmode);
gmt_plot.c:	if (GMT->current.ps.logo_cmd) {
gmt_plot.c:		size_t len = strlen (GMT->init.module_name);
gmt_plot.c:		strncpy (GMT->current.ps.map_logo_label, GMT->init.module_name, GMT_LEN256-1);
gmt_plot.c:			strncat (GMT->current.ps.map_logo_label, txt, GMT_LEN256-len);
gmt_plot.c:			strncat (GMT->current.ps.map_logo_label, opt->arg, GMT_LEN256-len);
gmt_plot.c:		GMT->current.ps.logo_cmd = false;	/* Mission accomplished */
gmt_plot.c:	if (GMT->current.setting.map_logo)
gmt_plot.c:		plot_timestamp (GMT, PSL, GMT->current.setting.map_logo_pos[GMT_X], GMT->current.setting.map_logo_pos[GMT_Y], GMT->current.setting.map_logo_justify, GMT->current.ps.map_logo_label);
gmt_plot.c:	PSL_settransparencymode (PSL, GMT->current.setting.ps_transpmode);	/* Set PDF transparency mode, if used */
gmt_plot.c:	k = GMT->PSL->internal.line_cap;	GMT->PSL->internal.line_cap = -1; PSL_setlinecap (PSL, k);
gmt_plot.c:	k = GMT->PSL->internal.line_join;	GMT->PSL->internal.line_join = -1; PSL_setlinejoin (PSL, k);
gmt_plot.c:	k = GMT->PSL->internal.miter_limit;	GMT->PSL->internal.miter_limit = -1; PSL_setmiterlimit (PSL, k);
gmt_plot.c:			PSL_setorigin (PSL, GMT->current.setting.map_origin[GMT_X] - P->gap[XLO], GMT->current.setting.map_origin[GMT_Y] - P->gap[YLO], 0.0, PSL_FWD);
gmt_plot.c:			form = gmt_setfont (GMT, &GMT->current.setting.font_tag);	/* Set the tag font */
gmt_plot.c:			PSL_command (PSL, PSL_makecolor (PSL, GMT->current.setting.font_tag.fill.rgb));
gmt_plot.c:			PSL_setfont (PSL, GMT->current.setting.font_tag.id);
gmt_plot.c:				PSL_plottextbox (PSL, plot_x, plot_y, GMT->current.setting.font_tag.size, P->tag, 0.0, justify, P->clearance, 0);
gmt_plot.c:				form = gmt_setfont (GMT, &GMT->current.setting.font_tag);	/* Set the tag font */
gmt_plot.c:				PSL_plottext (PSL, plot_x, plot_y, GMT->current.setting.font_tag.size, NULL, 0.0, justify, form);
gmt_plot.c:				PSL_plottext (PSL, plot_x, plot_y, GMT->current.setting.font_tag.size, P->tag, 0.0, justify, form);
gmt_plot.c:			gmt_M_memcpy (PSL->current.rgb[PSL_IS_FONT], GMT->session.no_rgb, 3, double);	/* Reset to -1,-1,-1 since text setting must set the color desired */
gmt_plot.c:		if (gmt_set_current_panel (GMT->parent, GMT->current.ps.figure, P->row, P->col, P->gap, P->tag, 0))
gmt_plot.c:				GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Unable to parse MOVIE_LABEL_ARG %s for 8 required items\n", movie_label_arg[T]);
gmt_plot.c:			gmt_M_memcpy (PSL->current.rgb[PSL_IS_FONT], GMT->session.no_rgb, 3, double);	/* Reset to -1,-1,-1 since text setting must set the color desired */
gmt_plot.c:	if (GMT->current.map.frame.paint) {	/* Paint the inside of the map with specified fill */
gmt_plot.c:		PSL_comment (GMT->PSL, "Fill the canvas %s\n", gmtlib_putfill (GMT, &GMT->current.map.frame.fill));
gmt_plot.c:		gmt_setfill (GMT, &GMT->current.map.frame.fill, false);
gmt_plot.c:		PSL_plotpolygon (GMT->PSL, x, y, (int)((1 + donut) * np));
gmt_plot.c:	bool K_active = (GMT->current.setting.run_mode == GMT_MODERN) ? true : GMT->common.K.active;
gmt_plot.c:	struct PSL_CTRL *PSL= GMT->PSL;
gmt_plot.c:	PSL_endlayer (GMT->PSL);
gmt_plot.c:	if (GMT->common.t.active) PSL_command (PSL, "1 /Normal PSL_transp\n"); /* Reset transparency to fully opaque, if required */
gmt_plot.c:	if (GMT->common.p.do_z_rotation) {	/* Need a undo the rotation about z of the whole page */
gmt_plot.c:		if (GMT->current.proj.z_project.view_given) {	/* Rotation is about another z-axis than through the origin */
gmt_plot.c:			x0 = GMT->current.proj.z_project.view_x;
gmt_plot.c:			y0 = GMT->current.proj.z_project.view_y;
gmt_plot.c:		else if (GMT->current.proj.z_project.world_given)	/* Rotation is about another lon/lat pole than the origin */
gmt_plot.c:			gmt_geo_to_xy (GMT, GMT->current.proj.z_project.world_x, GMT->current.proj.z_project.world_y, &x0, &y0);
gmt_plot.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Transrot: Unrotating plot by %g degrees about (%g, %g)\n", -GMT->common.p.z_rotation, x0, y0);
gmt_plot.c:		PSL_comment (GMT->PSL, "Possibly translate then unrotate rotate whole page\n");
gmt_plot.c:		PSL_setorigin (PSL, x0, y0, -GMT->common.p.z_rotation, PSL_FWD);
gmt_plot.c:	if (abs (GMT->current.ps.nclip) == PSL_ALL_CLIP)	/* Special case where we reset all polygon clip levels */
gmt_plot.c:		GMT->current.ps.clip_level = GMT->current.ps.nclip = PSL->current.nclip = 0;
gmt_plot.c:		GMT->current.ps.clip_level += GMT->current.ps.nclip;
gmt_plot.c:	if (GMT->current.ps.nclip != PSL->current.nclip)
gmt_plot.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE,
gmt_plot.c:		            "Module was expected to change clip level by %d, but clip level changed by %d\n", GMT->current.ps.nclip, PSL->current.nclip);
gmt_plot.c:		if (GMT->current.ps.clip_level > 0)
gmt_plot.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "%d external clip operations were not terminated!\n", GMT->current.ps.clip_level);
gmt_plot.c:		if (GMT->current.ps.clip_level < 0)
gmt_plot.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "%d extra terminations of external clip operations!\n", -GMT->current.ps.clip_level);
gmt_plot.c:		GMT->current.ps.clip_level = 0;	/* Reset to zero, so it will no longer show up in gmt.history */
gmt_plot.c:	for (i = 0; i < 3; i++) gmt_M_str_free (GMT->current.map.frame.axis[i].file_custom);
gmt_plot.c:	if (GMT->current.setting.run_mode == GMT_MODERN) {	/* Reset file pointer and name */
gmt_plot.c:		if (stat (GMT->current.ps.filename, &buf))
gmt_plot.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Could not determine size of file %s\n", GMT->current.ps.filename);
gmt_plot.c:			GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Current size of half-baked PS file %s = %" PRIuS ".\n", GMT->current.ps.filename, buf.st_size);
gmt_plot.c:		GMT->current.ps.fp = NULL;
gmt_plot.c:		GMT->current.ps.filename[0] = '\0';
gmt_plot.c:		snprintf (file, PATH_MAX, "%s/gmt.layers.%d", GMT->parent->gwf_dir, GMT->current.ps.figure);
gmt_plot.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Could not open/create file %s\n", file);
gmt_plot.c:		fprintf (fp, "%d\t%" PRIuS "\n", GMT->current.ps.layer, (size_t)buf.st_size);
gmt_plot.c:		if (GMT->current.ps.title[0]) {
gmt_plot.c:			P->header[0] = strdup (GMT->current.ps.title);
gmt_plot.c:		if (GMT_Write_Data (GMT->parent, GMT_IS_POSTSCRIPT, GMT_IS_REFERENCE, GMT_IS_TEXT, 0, NULL, GMT->current.ps.memname, P) != GMT_OK) {
gmt_plot.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Unable to write PS structure to file %s!\n", GMT->current.ps.memname);
gmt_plot.c:	GMT->current.ps.title[0] = '\0';	/* Reset title */
gmt_plot.c:	if (GMT->current.ps.oneliner) GMT->current.ps.active = true;	/* Since we are plotting we reset this here in case other modules have turned it off */
gmt_plot.c:	if ((GMT->current.plot.n = gmt_geo_to_xy_line (GMT, lon, lat, n)) == 0) return;	/* Nothing further to do */
gmt_plot.c:	gmt_plot_line (GMT, GMT->current.plot.x, GMT->current.plot.y, GMT->current.plot.pen, GMT->current.plot.n, PSL_LINEAR);	/* Separately plot the outline */
gmt_plot.c:	if (GMT->common.R.oblique) return n;	/* Algorithm assumes meridian boundaries */
gmt_plot.c:	if (!(gmt_M_is_misc(GMT) || (GMT->current.map.is_world  && (gmt_M_is_cylindrical(GMT) || (gmt_M_is_linear(GMT) && gmt_M_is_geographic(GMT,GMT_IN)))))) return 0;	/* We are only concerned with the global misc projections here */
gmt_plot.c:	GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Try to include %c pole in polar cap path\n", pole[SH->pole+1]);
gmt_plot.c:	GMT_Report (GMT->parent, GMT_MSG_DEBUG, "West longitude = %g.  East longitude = %g\n", GMT->common.R.wesn[XLO], GMT->common.R.wesn[XHI]);
gmt_plot.c:	start_lon = GMT->common.R.wesn[XHI];
gmt_plot.c:	stop_lon  = GMT->common.R.wesn[XLO];
gmt_plot.c:	GMT_Report (GMT->parent, GMT_MSG_DEBUG, "First longitude = %g.  Last longitude = %g\n", S->data[GMT_X][0], S->data[GMT_X][n-1]);
gmt_plot.c:		//R0 = GMT->common.R.wesn[XLO]-S->data[GMT_X][k];
gmt_plot.c:		//L0 = GMT->common.R.wesn[XLO]-S->data[GMT_X][k-1];
gmt_plot.c:		gmt_M_set_delta_lon (S->data[GMT_X][k],   GMT->common.R.wesn[XLO], R);	/* Handles the 360 jump cases */
gmt_plot.c:		gmt_M_set_delta_lon (S->data[GMT_X][k-1], GMT->common.R.wesn[XLO], L);	/* Handles the 360 jump cases */
gmt_plot.c:		//double x_dist = S->data[GMT_X][k0-1] - GMT->common.R.wesn[XLO];
gmt_plot.c:		gmt_M_set_delta_lon (S->data[GMT_X][k0-1], GMT->common.R.wesn[XLO], x_dist);	/* Handles the 360 jump cases */
gmt_plot.c:	GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Crossing at %g,%g\n", GMT->common.R.wesn[XLO], yc);
gmt_plot.c:	GMT_Report (GMT->parent, GMT_MSG_DEBUG, "k at point closest to lon %g is = %d [n = %d]\n", GMT->common.R.wesn[XLO], (int)k0, (int)n);
gmt_plot.c:	if (pole_lat < GMT->common.R.wesn[YLO]) pole_lat = GMT->common.R.wesn[YLO];
gmt_plot.c:	if (pole_lat >GMT->common.R.wesn[YHI])  pole_lat = GMT->common.R.wesn[YHI];
gmt_plot.c:	GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Created path from %g/%g to %g/%g [%d points]\n", start_lon, pole_lat, start_lon, yc, perim_n);
gmt_plot.c:	GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Add perimeter data from k0->n [%d->%d], then 0->k0 [%d]\n", k0, n, k0);
gmt_plot.c:	GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Add path from %g/%g to %g/%g [%d points]\n", stop_lon, yc, stop_lon, pole_lat, perim_n);
gmt_plot.c:	GMT_Report (GMT->parent, GMT_MSG_DEBUG, "New path has %d points, we allocated %d points\n", m, n_new);
gmt_plot.c:	struct PSL_CTRL *PSL= GMT->PSL;
gmt_plot.c:		if ((GMT->current.plot.n = gmt_geo_to_xy_line (GMT, S->data[GMT_X], S->data[GMT_Y], S->n_rows)) == 0) return;	/* Nothing further to do */
gmt_plot.c:		gmt_plot_line (GMT, GMT->current.plot.x, GMT->current.plot.y, GMT->current.plot.pen, GMT->current.plot.n, PSL_LINEAR);	/* Separately plot the outline */
gmt_plot.c:			if ((GMT->current.plot.n = gmt_geo_to_xy_line (GMT, S2->data[GMT_X], S2->data[GMT_Y], S2->n_rows)) == 0) continue;	/* Nothing for this hole */
gmt_plot.c:			gmt_plot_line (GMT, GMT->current.plot.x, GMT->current.plot.y, GMT->current.plot.pen, GMT->current.plot.n, PSL_LINEAR);	/* Separately plot the outline */
gmt_plot.c:		if ((GMT->current.plot.n = gmt_geo_to_xy_line (GMT, S->data[GMT_X], S->data[GMT_Y], S->n_rows)) == 0) return;	/* Nothing further to do */
gmt_plot.c:		gmt_plot_line (GMT, GMT->current.plot.x, GMT->current.plot.y, GMT->current.plot.pen, GMT->current.plot.n, PSL_LINEAR);	/* Separately plot the outline */
gmt_plot.c:			if ((GMT->current.plot.n = gmt_geo_to_xy_line (GMT, S2->data[GMT_X], S2->data[GMT_Y], S2->n_rows)) == 0) continue;	/* Nothing for this hole */
gmt_plot.c:			gmt_plot_line (GMT, GMT->current.plot.x, GMT->current.plot.y, GMT->current.plot.pen, GMT->current.plot.n, PSL_LINEAR);	/* Separately plot the outline */
gmt_plot.c:	PSL_comment (GMT->PSL, "Placing Spider Web\n");
gmt_plot.c:	PSL_command (GMT->PSL, "V PSL_spiderpen\n");	/* Place spider under gsave/grestore and change to spiderpen */
gmt_plot.c:		PSL_comment (GMT->PSL, "Drawing Spider Radials\n");
gmt_plot.c:			S = GMT_Alloc_Segment (GMT->parent, GMT_NO_STRINGS, 2, 2, NULL, NULL);	/* Segment with two rows */
gmt_plot.c:			if ((GMT->current.plot.n = gmt_geo_to_xy_line (GMT, S->data[GMT_X], S->data[GMT_Y], S->n_rows)) == 0) continue;
gmt_plot.c:			gmt_plot_line (GMT, GMT->current.plot.x, GMT->current.plot.y, GMT->current.plot.pen, GMT->current.plot.n, PSL_LINEAR);
gmt_plot.c:		n_arc = MAX (2, irint (fabs (az_stop - az_start) * L /GMT->current.setting.map_line_step));
gmt_plot.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Arcs will be approximated by %d-point lines\n", n_arc);
gmt_plot.c:		PSL_comment (GMT->PSL, "Drawing Spider Arcs\n");
gmt_plot.c:			S = GMT_Alloc_Segment (GMT->parent, GMT_NO_STRINGS, n_arc, 2, NULL, NULL);
gmt_plot.c:			if ((GMT->current.plot.n = gmt_geo_to_xy_line (GMT, S->data[GMT_X], S->data[GMT_Y], S->n_rows)) == 0) continue;
gmt_plot.c:			gmt_plot_line (GMT, GMT->current.plot.x, GMT->current.plot.y, GMT->current.plot.pen, GMT->current.plot.n, PSL_LINEAR);
gmt_plot.c:	PSL_command (GMT->PSL, "U\n");	/* End block where spiderpen is active; this resets previous pen (for outline) */
gmt_plot.c:	n_arc = MAX (2, irint (fabs (az_stop - az_start) * L /GMT->current.setting.map_line_step));
gmt_plot.c:	GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Wedge will be approximated by %d-sided polygon\n", n_path);
gmt_plot.c:	S = GMT_Alloc_Segment (GMT->parent, GMT_NO_STRINGS, n_path, 2, NULL, NULL);	/* Polygon array */
gmt_plot.c:		PSL_comment (GMT->PSL, "Drawing Wedge fill and outline\n");
gmt_plot.c:		PSL_comment (GMT->PSL, "Drawing Wedge fill only\n");
gmt_plot.c:		PSL_command (GMT->PSL, "V O0\n");	/* Temporarily disable outlines */
gmt_plot.c:		PSL_command (GMT->PSL, "U\n");		/* Undo */
gmt_plot.c:		PSL_comment (GMT->PSL, "Drawing Wedge outline only\n");
gmt_plot.c:		if ((GMT->current.plot.n = gmt_geo_to_xy_line (GMT, S->data[GMT_X], S->data[GMT_Y], S->n_rows)))
gmt_plot.c:			gmt_plot_line (GMT, GMT->current.plot.x, GMT->current.plot.y, GMT->current.plot.pen, GMT->current.plot.n, PSL_LINEAR);
gmt_plot.c:			gmt_xy_to_geo (GMT, &clon, &clat, GMT->current.map.half_width, GMT->current.map.half_height);	/* Geographic coordinates of middle map point */
gmt_plot.c:			GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Vector stem scale is %g degrees/inch at (%g, %g) for az = %g\n", S->v.scale, clon, clat, azimuth);
gmt_plot.c:			GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Vector stem scale is %g degrees/inch at (%g, %g) for az = %g\n", S->v.scale, lon0, lat0, azimuth);
gmt_plot.c:	struct PSL_CTRL *PSL= GMT->PSL;
gmt_plot.c:	center = (GMT->current.proj.central_meridian < GMT->common.R.wesn[XLO] || GMT->current.proj.central_meridian > GMT->common.R.wesn[XHI]) ? 0.5 * (GMT->common.R.wesn[XLO] + GMT->common.R.wesn[XHI]) : GMT->current.proj.central_meridian;
gmt_plot.c:	c = rho / GMT->current.proj.EQ_RAD;
gmt_plot.c:	if ((jump = (*GMT->current.map.jump) (GMT, xp, yp, xw, yw)))	/* Adjust for map jumps */
gmt_plot.c:	c = rho / GMT->current.proj.EQ_RAD;
gmt_plot.c:	if ((jump = (*GMT->current.map.jump) (GMT, xp, yp, xh, yh)))	/* Adjust for map jumps */
gmt_plot.c:	struct PSL_CTRL *PSL= GMT->PSL;
gmt_plot.c:		if (GMT->current.map.is_world && fabs (dx) > w) dx = copysign (2.0 * w - fabs (dx), -dx);
gmt_plot.c:			GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Number of front ticks reset from 0 to 1 (check your arguments)\n");
gmt_plot.c:			skip = (GMT->current.map.is_world && fabs (dx) > gmt_half_map_width (GMT, y[i]));	/* Don't do ticks on jumps */
gmt_plot.c:					offx = GMT->current.setting.map_annot_offset[GMT_PRIMARY] * sina; /* get offsets from front line */
gmt_plot.c:					offy = GMT->current.setting.map_annot_offset[GMT_PRIMARY] * cosa;
gmt_plot.c:					offy = GMT->current.setting.map_annot_offset[GMT_PRIMARY]; /* get offset from front line */
gmt_plot.c:	 * of the paper into a perspective view of that plane based on the GMT->current.proj.z_project
gmt_plot.c:	struct PSL_CTRL *PSL= GMT->PSL;
gmt_plot.c:	if (!GMT->current.proj.three_D) return;
gmt_plot.c:	if (GMT->hidden.func_level > GMT_TOP_MODULE) return;
gmt_plot.c:	if (plane == GMT->current.proj.z_project.plane && gmt_M_eq(level,GMT->current.proj.z_project.level)) return;
gmt_plot.c:	GMT->current.proj.z_project.level = level;
gmt_plot.c:	x_out = - x * GMT->current.proj.z_project.cos_az + y * GMT->current.proj.z_project.sin_az + GMT->current.proj.z_project.x_off;
gmt_plot.c:	y_out = - (x * GMT->current.proj.z_project.sin_az + y * GMT->current.proj.z_project.cos_az) *
gmt_plot.c:		GMT->current.proj.z_project.sin_el + z * GMT->current.proj.z_project.cos_el + GMT->current.proj.z_project.y_off;
gmt_plot.c:				a = GMT->current.proj.z_project.sin_az;
gmt_plot.c:				b = -GMT->current.proj.z_project.cos_az * GMT->current.proj.z_project.sin_el;
gmt_plot.c:				d = GMT->current.proj.z_project.cos_el;
gmt_plot.c:				e = GMT->current.proj.z_project.x_off - level * GMT->current.proj.z_project.cos_az;
gmt_plot.c:				f = GMT->current.proj.z_project.y_off - level * GMT->current.proj.z_project.sin_az * GMT->current.proj.z_project.sin_el;
gmt_plot.c:				a = -GMT->current.proj.z_project.cos_az;
gmt_plot.c:				b = -GMT->current.proj.z_project.sin_az * GMT->current.proj.z_project.sin_el;
gmt_plot.c:				d = GMT->current.proj.z_project.cos_el;
gmt_plot.c:				e = GMT->current.proj.z_project.x_off + level * GMT->current.proj.z_project.sin_az;
gmt_plot.c:				f = GMT->current.proj.z_project.y_off - level * GMT->current.proj.z_project.cos_az * GMT->current.proj.z_project.sin_el;
gmt_plot.c:				a = -GMT->current.proj.z_project.cos_az;
gmt_plot.c:				b = -GMT->current.proj.z_project.sin_az * GMT->current.proj.z_project.sin_el;
gmt_plot.c:				c = GMT->current.proj.z_project.sin_az;
gmt_plot.c:				d = -GMT->current.proj.z_project.cos_az * GMT->current.proj.z_project.sin_el;
gmt_plot.c:				e = GMT->current.proj.z_project.x_off;
gmt_plot.c:				f = GMT->current.proj.z_project.y_off + level * GMT->current.proj.z_project.cos_el;
gmt_plot.c:			(GMT->current.proj.z_project.plane >= 0) ? "PSL_GPP setmatrix" : "/PSL_GPP matrix currentmatrix def",
gmt_plot.c:	GMT->current.proj.z_project.plane = plane;
gmt_plot.c:	GMT->current.ps.figure = gmt_get_current_figure (GMT->parent);
gmt_plot.c:	if (GMT->parent->gwf_dir == NULL) {	/* Use the established temp directory */
gmt_plot.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "GMT WorkFlow directory not set!\n");
gmt_plot.c:		snprintf (GMT->current.ps.filename, GMT_LEN256, "%s/gmt_%d.ps-", GMT->parent->gwf_dir, GMT->current.ps.figure);
gmt_plot.c:	GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Use PS filename %s\n", GMT->current.ps.filename);
gmt_plot.c:	k = 1 + access (GMT->current.ps.filename, W_OK);	/* 1 = File exists (must append) or 0 (must create) */
gmt_plot.c:	GMT->current.ps.initialize = (k == 0);	/* False means it is an overlay and -R -J may come from history */
gmt_plot.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Could not open PostScript file %s\n", source);
gmt_plot.c:	PH->alloc_level = GMT->hidden.func_level;	/* Must be freed at this level. */
gmt_plot.c:	PH->id = GMT->parent->unique_var_ID++;		/* Give unique identifier */
gmt_plot.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Cannot find PostScript file %s\n", ps_file);
gmt_plot.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Cannot determine size of PostScript file %s\n", ps_file);
gmt_plot.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Cannot open PostScript file %s\n", ps_file);
gmt_plot.c:		if (fp == NULL) fp = GMT->session.std[GMT_IN];	/* Default input */
gmt_plot.c:		if (fp == GMT->session.std[GMT_IN])
gmt_plot.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Cannot determine size of PostScript file give by file descriptor %d\n", *fd);
gmt_plot.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Cannot convert PostScript file descriptor %d to stream in gmtlib_read_ps\n", *fd);
gmt_plot.c:		if (fp == GMT->session.std[GMT_IN])
gmt_plot.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Unrecognized source type %d in gmtlib_read_ps\n", source_type);
gmt_plot.c:	GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Reading PostScript from %s\n", ps_file);
gmt_plot.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Cannot %s PostScript file %s\n", msg2[append], &ps_file[append]);
gmt_plot.c:		if (fp == NULL) fp = GMT->session.std[GMT_OUT];	/* Default destination */
gmt_plot.c:		if (fp == GMT->session.std[GMT_OUT])
gmt_plot.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Cannot convert PostScript file descriptor %d to stream in gmtlib_write_ps\n", *fd);
gmt_plot.c:		if (fd == NULL) fp = GMT->session.std[GMT_OUT];	/* Default destination */
gmt_plot.c:		if (fp == GMT->session.std[GMT_OUT])
gmt_plot.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Unrecognized source type %d in gmtlib_write_ps\n", dest_type);
gmt_plot.c:	GMT_Report (GMT->parent, GMT_MSG_DEBUG, "%s PostScript to %s\n", msg1[append], &ps_file[append]);
gmt_plot.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error %s PostScript to %s\n", msg1[append], &ps_file[append]);
gmt_proj.c:		return (GMT->session.d_NaN);
gmt_proj.c:	switch (GMT->current.setting.interpolant) {	/* gmt_vrobinson would not allow case 0 so only GMT_SPLINE_AKIMA | GMT_SPLINE_CUBIC is possible */
gmt_proj.c:	double lon0 = 0.5 * (GMT->common.R.wesn[XLO] + GMT->common.R.wesn[XHI]);
gmt_proj.c:	if (GMT->current.map.is_world && lon0 != *clon) {
gmt_proj.c:		GMT->common.R.wesn[XLO] = *clon - 180.0;
gmt_proj.c:		GMT->common.R.wesn[XHI] = *clon + 180.0;
gmt_proj.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Central meridian set with -J (%g) implies -R%g/%g/%g/%g\n",
gmt_proj.c:			*clon, GMT->common.R.wesn[XLO], GMT->common.R.wesn[XHI], GMT->common.R.wesn[YLO], GMT->common.R.wesn[YHI]);
gmt_proj.c:	else if (!GMT->current.map.is_world) {
gmt_proj.c:		while (lon0 < GMT->common.R.wesn[XLO]) lon0 += 360.0;
gmt_proj.c:		if (lon0 > GMT->common.R.wesn[XHI]) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Central meridian outside region\n");
gmt_proj.c:	c = 2.0 * y * GMT->current.proj.i_EQ_RAD;
gmt_proj.c:	*phi = y * GMT->current.proj.i_EQ_RAD;
gmt_proj.c:	y *= GMT->current.proj.i_EQ_RAD;
gmt_proj.c:	y += GMT->current.proj.pole * D2R;
gmt_proj.c:		*x *= GMT->current.proj.EQ_RAD * D2R;
gmt_proj.c:		*x = GMT->current.proj.EQ_RAD * cp * sin(E);
gmt_proj.c:	N1 = GMT->current.proj.EQ_RAD/sqrt(1.0 - (GMT->current.proj.ECC2*sphi*sphi));
gmt_proj.c:	phig = phi - asind(N1*GMT->current.proj.ECC2*sphi*cphi/((h/GMT->current.proj.EQ_RAD+1.0)*GMT->current.proj.EQ_RAD));
gmt_proj.c:	theta = GMT->current.proj.g_azimuth - angle;
gmt_proj.c:	A = (y * GMT->current.proj.g_cos_azimuth + x * GMT->current.proj.g_sin_azimuth) * GMT->current.proj.g_sin_tilt / GMT->current.proj.g_H + GMT->current.proj.g_cos_tilt;
gmt_proj.c:		xp = (x * GMT->current.proj.g_cos_azimuth - y * GMT->current.proj.g_sin_azimuth) * GMT->current.proj.g_cos_tilt / A;
gmt_proj.c:		yp = (y * GMT->current.proj.g_cos_azimuth + x * GMT->current.proj.g_sin_azimuth) / A;
gmt_proj.c:		if (fabs(yp) > fabs(GMT->current.proj.g_max_yt)) {
gmt_proj.c:			yp = -GMT->current.proj.g_max_yt;
gmt_proj.c:		yp = -GMT->current.proj.g_max_yt;
gmt_proj.c:	*xt = xp * GMT->current.proj.g_cos_twist - yp * GMT->current.proj.g_sin_twist;
gmt_proj.c:	*yt = yp * GMT->current.proj.g_cos_twist + xp * GMT->current.proj.g_sin_twist;
gmt_proj.c:	H = GMT->current.proj.g_H;
gmt_proj.c:	P = GMT->current.proj.g_P;
gmt_proj.c:	R = GMT->current.proj.g_R;
gmt_proj.c:	one_m_e2 = GMT->current.proj.one_m_ECC2;
gmt_proj.c:	e2 = GMT->current.proj.ECC2;
gmt_proj.c:	cphig = GMT->current.proj.g_cphig;
gmt_proj.c:	cphi1 = GMT->current.proj.g_cphi1;
gmt_proj.c:	sphi1 = GMT->current.proj.g_sphi1;
gmt_proj.c:	B = GMT->current.proj.g_B;
gmt_proj.c:	D = GMT->current.proj.g_D;
gmt_proj.c:	u = GMT->current.proj.g_BLH - GMT->current.proj.g_DG*y + GMT->current.proj.g_BJ*y + GMT->current.proj.g_DHJ;
gmt_proj.c:	v = GMT->current.proj.g_LH2 + GMT->current.proj.g_G*y*y - GMT->current.proj.g_HJ*y + one_m_e2*x*x;
gmt_proj.c:	if (GMT->current.proj.g_debug > 1) {
gmt_proj.c:		gmt_message (GMT, "phig %12.7f\n", GMT->current.proj.g_phig);
gmt_proj.c:		gmt_message (GMT, "phig %12.7f\n", GMT->current.proj.g_phig);
gmt_proj.c:	if (set_exit || GMT->current.proj.g_debug > 1) {
gmt_proj.c:		if (GMT->current.proj.g_debug > 1 || set_exit) {
gmt_proj.c:			if (set_exit || GMT->current.proj.g_debug > 1) {
gmt_proj.c:	if (set_exit || GMT->current.proj.g_debug > 1) {
gmt_proj.c:	*lon = atan2d (Y, X) + GMT->current.proj.g_lon0;
gmt_proj.c:	a = GMT->current.proj.EQ_RAD;
gmt_proj.c:	e2 = GMT->current.proj.ECC2;
gmt_proj.c:	if (GMT->current.proj.g_radius || altitude < -10.0) {
gmt_proj.c:	GMT->current.proj.g_H = H;
gmt_proj.c:	GMT->current.proj.g_P = P;
gmt_proj.c:	GMT->current.proj.g_R = R;
gmt_proj.c:	GMT->current.proj.g_lon0 = lon0;
gmt_proj.c:	GMT->current.proj.g_sphi1 = sphi1;
gmt_proj.c:	GMT->current.proj.g_cphi1 = cphi1;
gmt_proj.c:	GMT->current.proj.g_phig = phig;
gmt_proj.c:	GMT->current.proj.g_sphig = sphig;
gmt_proj.c:	GMT->current.proj.g_cphig = cphig;
gmt_proj.c:	sincosd (lat-phig, &(GMT->current.proj.g_sdphi), &(GMT->current.proj.g_cdphi));
gmt_proj.c:	GMT->current.proj.g_L = 1.0 - e2*cphi1*cphi1;
gmt_proj.c:	GMT->current.proj.g_G = 1.0 - e2*sphi1*sphi1;
gmt_proj.c:	GMT->current.proj.g_J = 2.0*e2*sphi1*cphi1;
gmt_proj.c:	GMT->current.proj.g_B = P*GMT->current.proj.g_cdphi;
gmt_proj.c:	GMT->current.proj.g_D = P*GMT->current.proj.g_sdphi;
gmt_proj.c:	GMT->current.proj.g_BLH = -2.0*GMT->current.proj.g_B*GMT->current.proj.g_L*H;
gmt_proj.c:	GMT->current.proj.g_DG = 2.0*GMT->current.proj.g_D*GMT->current.proj.g_G;
gmt_proj.c:	GMT->current.proj.g_BJ = GMT->current.proj.g_B*GMT->current.proj.g_J;
gmt_proj.c:	GMT->current.proj.g_HJ = H*GMT->current.proj.g_J;
gmt_proj.c:	GMT->current.proj.g_DHJ = GMT->current.proj.g_D*GMT->current.proj.g_HJ;
gmt_proj.c:	GMT->current.proj.g_LH2 = GMT->current.proj.g_L*H*H;
gmt_proj.c:	if (GMT->current.proj.g_debug > 0) {
gmt_proj.c:	*forw = inv + GMT->current.proj.central_meridian;
gmt_proj.c:	*x_in = pow (x, GMT->current.proj.xyz_pow[GMT_X]);
gmt_proj.c:	*x = pow (x_in, GMT->current.proj.xyz_ipow[GMT_X]);
gmt_proj.c:	*y_in = pow (y, GMT->current.proj.xyz_pow[GMT_Y]);
gmt_proj.c:	*y = pow (y_in, GMT->current.proj.xyz_ipow[GMT_Y]);
gmt_proj.c:	*z_in = pow (z, GMT->current.proj.xyz_pow[GMT_Z]);
gmt_proj.c:	*z = pow (z_in, GMT->current.proj.xyz_ipow[GMT_Z]);
gmt_proj.c:	GMT->current.proj.p_base_angle = lon0;
gmt_proj.c:	GMT->current.proj.central_meridian = 0.5 * (GMT->common.R.wesn[XHI] + GMT->common.R.wesn[XLO]);
gmt_proj.c:	GMT->current.proj.north_pole = GMT->current.proj.got_elevations;
gmt_proj.c:	GMT->current.proj.pole = (GMT->current.proj.got_elevations) ? 90.0 : 0.0;
gmt_proj.c:	if (GMT->current.proj.got_azimuths) x = 90.0 - x;		/* azimuths, not directions */
gmt_proj.c:	if (GMT->current.proj.got_elevations) y = 90.0 - y;		/* elevations */
gmt_proj.c:	sincosd (x - GMT->current.proj.p_base_angle, y_i, x_i);	/* Change base line angle */
gmt_proj.c:	*x = d_atan2d (y_i, x_i) + GMT->current.proj.p_base_angle;
gmt_proj.c:	if (GMT->current.proj.got_azimuths) *x = 90.0 - (*x);		/* azimuths, not directions */
gmt_proj.c:	if (GMT->current.proj.got_elevations) *y = 90.0 - (*y);    /* elevations, presumably */
gmt_proj.c:	GMT->current.proj.central_meridian = lon0;
gmt_proj.c:	GMT->current.proj.j_x = cosd (slat) / d_sqrt (1.0 - GMT->current.proj.ECC2 * sind (slat) * sind (slat)) * GMT->current.proj.EQ_RAD;
gmt_proj.c:	GMT->current.proj.j_ix = 1.0 / GMT->current.proj.j_x;
gmt_proj.c:	/* Convert lon/lat to Mercator x/y (GMT->current.proj.EQ_RAD in GMT->current.proj.j_x) */
gmt_proj.c:	if (GMT->current.proj.GMT_convert_latitudes) lat = gmt_M_latg_to_latc (GMT, lat);
gmt_proj.c:	*x = GMT->current.proj.j_x * D2R * lon;
gmt_proj.c:	*y = (fabs (lat) < 90.0) ? GMT->current.proj.j_x * d_log (GMT, tand (45.0 + 0.5 * lat)) : copysign (DBL_MAX, lat);
gmt_proj.c:	/* Convert Mercator x/y to lon/lat  (GMT->current.proj.EQ_RAD in GMT->current.proj.j_ix) */
gmt_proj.c:	*lon = x * GMT->current.proj.j_ix * R2D + GMT->current.proj.central_meridian;
gmt_proj.c:	*lat = atand (sinh (y * GMT->current.proj.j_ix));
gmt_proj.c:	if (GMT->current.proj.GMT_convert_latitudes) *lat = gmt_M_latc_to_latg (GMT, *lat);
gmt_proj.c:	GMT->current.proj.central_meridian = lon0;
gmt_proj.c:	GMT->current.proj.j_x = GMT->current.proj.EQ_RAD * D2R * cosd (slat);
gmt_proj.c:	GMT->current.proj.j_y = GMT->current.proj.EQ_RAD / cosd (slat);
gmt_proj.c:	GMT->current.proj.j_ix = 1.0 / GMT->current.proj.j_x;
gmt_proj.c:	GMT->current.proj.j_iy = 1.0 / GMT->current.proj.j_y;
gmt_proj.c:	if (GMT->current.proj.GMT_convert_latitudes) lat = gmt_M_latg_to_lata (GMT, lat);
gmt_proj.c:	*x = lon * GMT->current.proj.j_x;
gmt_proj.c:	*y = GMT->current.proj.j_y * sind (lat);
gmt_proj.c:	if (GMT->current.proj.GMT_convert_latitudes) {	/* Gotta fudge abit */
gmt_proj.c:		(*x) *= GMT->current.proj.Dx;
gmt_proj.c:		(*y) *= GMT->current.proj.Dy;
gmt_proj.c:	if (GMT->current.proj.GMT_convert_latitudes) {	/* Gotta fudge abit */
gmt_proj.c:		x *= GMT->current.proj.iDx;
gmt_proj.c:		y *= GMT->current.proj.iDy;
gmt_proj.c:	*lon = x * GMT->current.proj.j_ix + GMT->current.proj.central_meridian;
gmt_proj.c:	*lat = d_asind (y * GMT->current.proj.j_iy);
gmt_proj.c:	if (GMT->current.proj.GMT_convert_latitudes) *lat = gmt_M_lata_to_latg (GMT, *lat);
gmt_proj.c:	GMT->current.proj.central_meridian = lon0;
gmt_proj.c:	GMT->current.proj.j_x = D2R * GMT->current.proj.EQ_RAD * cosd (slat);
gmt_proj.c:	GMT->current.proj.j_y = D2R * GMT->current.proj.EQ_RAD;
gmt_proj.c:	GMT->current.proj.j_ix = 1.0 / GMT->current.proj.j_x;
gmt_proj.c:	GMT->current.proj.j_iy = 1.0 / GMT->current.proj.j_y;
gmt_proj.c:	*x = lon * GMT->current.proj.j_x;
gmt_proj.c:	*y = lat * GMT->current.proj.j_y;
gmt_proj.c:	*lon = x * GMT->current.proj.j_ix + GMT->current.proj.central_meridian;
gmt_proj.c:	*lat = y * GMT->current.proj.j_iy;
gmt_proj.c:	GMT->current.proj.north_pole = (slat > 0.0);
gmt_proj.c:	GMT->current.proj.central_meridian = lon0;
gmt_proj.c:	GMT->current.proj.j_x = 0.25 * D2R * GMT->current.proj.EQ_RAD;
gmt_proj.c:	GMT->current.proj.j_y = 0.25 * D2R * GMT->current.proj.EQ_RAD;
gmt_proj.c:	GMT->current.proj.j_ix = 1.0 / GMT->current.proj.j_x;
gmt_proj.c:	GMT->current.proj.j_iy = 1.0 / GMT->current.proj.j_y;
gmt_proj.c:		*x = (0.5 + lon * (90.0 - lat) / 4050.0) * GMT->current.proj.j_x;
gmt_proj.c:		*y = ((lat-45.0) / 90.0) * GMT->current.proj.j_y;
gmt_proj.c:		*x = (0.5 - lon * (90.0 + lat) / 4050.0) * GMT->current.proj.j_x;
gmt_proj.c:		*y = -((lat+45) / 90.0) * GMT->current.proj.j_y;
gmt_proj.c:	if (GMT->current.proj.north_pole) {
gmt_proj.c:		*lat = 45.0 + 90.0 * y * GMT->current.proj.j_iy;
gmt_proj.c:		*lon = (4050.0 * (x * GMT->current.proj.j_ix - 0.5)) / (90.0 - *lat) + GMT->current.proj.central_meridian;
gmt_proj.c:		*lat = -(45.0 + 90.0 * y * GMT->current.proj.j_iy);
gmt_proj.c:		*lon = -(4050.0 * (x * GMT->current.proj.j_ix - 0.5)) / (90.0 + *lat) + GMT->current.proj.central_meridian;
gmt_proj.c:	GMT->current.proj.central_meridian = lon0;
gmt_proj.c:	GMT->current.proj.j_x = D2R * GMT->current.proj.EQ_RAD;
gmt_proj.c:	GMT->current.proj.j_y = 1.25 * GMT->current.proj.EQ_RAD;
gmt_proj.c:	GMT->current.proj.j_ix = 1.0 / GMT->current.proj.j_x;
gmt_proj.c:	GMT->current.proj.j_iy = 1.0 / GMT->current.proj.j_y;
gmt_proj.c:	*x = lon * GMT->current.proj.j_x;
gmt_proj.c:	*y = GMT->current.proj.j_y * d_log (GMT, tand (45.0 + 0.4 * lat));
gmt_proj.c:	*lon = x * GMT->current.proj.j_ix + GMT->current.proj.central_meridian;
gmt_proj.c:	*lat = 2.5 * atand (exp (y * GMT->current.proj.j_iy)) - 112.5;
gmt_proj.c:	GMT->current.proj.central_meridian = lon0;
gmt_proj.c:	GMT->current.proj.j_x = GMT->current.proj.EQ_RAD * D2R * cosd (slat);
gmt_proj.c:	GMT->current.proj.j_y = GMT->current.proj.EQ_RAD * (1.0 + cosd (slat));
gmt_proj.c:	GMT->current.proj.j_ix = 1.0 / GMT->current.proj.j_x;
gmt_proj.c:	GMT->current.proj.j_iy = 1.0 / GMT->current.proj.j_y;
gmt_proj.c:	*x = lon * GMT->current.proj.j_x;
gmt_proj.c:	*y = GMT->current.proj.j_y * tand (0.5 * lat);
gmt_proj.c:	*lon = x * GMT->current.proj.j_ix + GMT->current.proj.central_meridian;
gmt_proj.c:	*lat = 2.0 * atand (y * GMT->current.proj.j_iy);
gmt_proj.c:	if (GMT->current.proj.GMT_convert_latitudes) {	/* Set Conformal radius and pole latitude */
gmt_proj.c:	GMT->current.proj.central_meridian = lon0;
gmt_proj.c:	GMT->current.proj.pole = lat0;		/* This is always geodetic */
gmt_proj.c:	sincosd (clat, &(GMT->current.proj.sinp), &(GMT->current.proj.cosp));	/* These may be conformal */
gmt_proj.c:	GMT->current.proj.north_pole = (lat0 > 0.0);
gmt_proj.c:	GMT->current.proj.s_c = 2.0 * GMT->current.proj.EQ_RAD * GMT->current.setting.proj_scale_factor;
gmt_proj.c:	GMT->current.proj.s_ic = 1.0 / GMT->current.proj.s_c;
gmt_proj.c:	GMT->current.proj.f_horizon = horizon;
gmt_proj.c:	GMT->current.proj.rho_max = tand (0.5 * horizon) * GMT->current.proj.s_c;
gmt_proj.c:	if (GMT->current.proj.GMT_convert_latitudes) lat = gmt_M_latg_to_latc (GMT, lat);
gmt_proj.c:	if (GMT->current.proj.north_pole) {
gmt_proj.c:		rho = GMT->current.proj.s_c * tand (45.0 - 0.5 * lat);
gmt_proj.c:		rho = GMT->current.proj.s_c * tand (45.0 + 0.5 * lat);
gmt_proj.c:	if (GMT->current.proj.GMT_convert_latitudes) {	/* Gotta fudge abit */
gmt_proj.c:		(*x) *= GMT->current.proj.Dx;
gmt_proj.c:		(*y) *= GMT->current.proj.Dy;
gmt_proj.c:		*lon = GMT->current.proj.central_meridian;
gmt_proj.c:		*lat = GMT->current.proj.pole;
gmt_proj.c:	if (GMT->current.proj.GMT_convert_latitudes) {	/* Undo effect of fudge factors */
gmt_proj.c:		x *= GMT->current.proj.iDx;
gmt_proj.c:		y *= GMT->current.proj.iDy;
gmt_proj.c:	c = 2.0 * atan (hypot (x, y) * GMT->current.proj.s_ic);
gmt_proj.c:	if (GMT->current.proj.north_pole) {
gmt_proj.c:		*lon = GMT->current.proj.central_meridian + d_atan2d (x, -y);
gmt_proj.c:		*lon = GMT->current.proj.central_meridian + d_atan2d (x, y);
gmt_proj.c:	if (GMT->current.proj.GMT_convert_latitudes) *lat = gmt_M_latc_to_latg (GMT, *lat);
gmt_proj.c:	if (GMT->current.proj.GMT_convert_latitudes) lat = gmt_M_latg_to_latc (GMT, lat);
gmt_proj.c:	sincosd (lon - GMT->current.proj.central_meridian, &sin_dlon, &cos_dlon);
gmt_proj.c:	A = GMT->current.proj.s_c / (1.0 + GMT->current.proj.sinp * s + GMT->current.proj.cosp * cc);
gmt_proj.c:	*y = A * (GMT->current.proj.cosp * s - GMT->current.proj.sinp * cc);
gmt_proj.c:	if (GMT->current.proj.GMT_convert_latitudes) {	/* Gotta fudge abit */
gmt_proj.c:		(*x) *= GMT->current.proj.Dx;
gmt_proj.c:		(*y) *= GMT->current.proj.Dy;
gmt_proj.c:	if (GMT->current.proj.GMT_convert_latitudes) {	/* Undo effect of fudge factors */
gmt_proj.c:		x *= GMT->current.proj.iDx;
gmt_proj.c:		y *= GMT->current.proj.iDy;
gmt_proj.c:	if (rho > GMT->current.proj.rho_max) {
gmt_proj.c:		*lat = *lon = GMT->session.d_NaN;
gmt_proj.c:	c = 2.0 * atan (rho * GMT->current.proj.s_ic);
gmt_proj.c:	*lat = asind (cos_c * GMT->current.proj.sinp + y * sin_c * GMT->current.proj.cosp);
gmt_proj.c:	*lon = d_atan2d (x * sin_c, cos_c * GMT->current.proj.cosp - y * sin_c * GMT->current.proj.sinp) + GMT->current.proj.central_meridian;
gmt_proj.c:	if (GMT->current.proj.GMT_convert_latitudes) *lat = gmt_M_latc_to_latg (GMT, *lat);
gmt_proj.c:	dlon = lon - GMT->current.proj.central_meridian;
gmt_proj.c:		if (GMT->current.proj.GMT_convert_latitudes) lat = gmt_M_latg_to_latc (GMT, lat);
gmt_proj.c:		A = GMT->current.proj.s_c / (1.0 + c * clon);
gmt_proj.c:		if (GMT->current.proj.GMT_convert_latitudes) {	/* Gotta fudge abit */
gmt_proj.c:			(*x) *= GMT->current.proj.Dx;
gmt_proj.c:			(*y) *= GMT->current.proj.Dy;
gmt_proj.c:	GMT->current.proj.north_pole = (GMT->common.R.wesn[YHI] > 0.0 && (GMT->common.R.wesn[YLO] >= 0.0 || (-GMT->common.R.wesn[YLO]) < GMT->common.R.wesn[YHI]));
gmt_proj.c:	GMT->current.proj.pole = (GMT->current.proj.north_pole) ? 90.0 : -90.0;
gmt_proj.c:	t_pha = tand (45.0 - 0.5 * pha) / pow ((1.0 - GMT->current.proj.ECC *
gmt_proj.c:		sin_pha) / (1.0 + GMT->current.proj.ECC * sin_pha), GMT->current.proj.half_ECC);
gmt_proj.c:	m_pha = cos_pha / d_sqrt (1.0 - GMT->current.proj.ECC2 * sin_pha * sin_pha);
gmt_proj.c:	t_phb = tand (45.0 - 0.5 * phb) / pow ((1.0 - GMT->current.proj.ECC *
gmt_proj.c:		sin_phb) / (1.0 + GMT->current.proj.ECC * sin_phb), GMT->current.proj.half_ECC);
gmt_proj.c:	m_phb = cos_phb / d_sqrt (1.0 - GMT->current.proj.ECC2 * sin_phb * sin_phb);
gmt_proj.c:		pow ((1.0 - GMT->current.proj.ECC * sind (rlat0)) /
gmt_proj.c:		(1.0 + GMT->current.proj.ECC * sind (rlat0)), GMT->current.proj.half_ECC);
gmt_proj.c:		GMT->current.proj.l_N = sind (pha);
gmt_proj.c:		GMT->current.proj.l_N = (d_log (GMT, m_pha) - d_log (GMT, m_phb))/(d_log (GMT, t_pha) - d_log (GMT, t_phb));
gmt_proj.c:	GMT->current.proj.l_i_N = 1.0 / GMT->current.proj.l_N;
gmt_proj.c:	GMT->current.proj.l_F = m_pha / (GMT->current.proj.l_N * pow (t_pha, GMT->current.proj.l_N));
gmt_proj.c:	GMT->current.proj.central_meridian = rlong0;
gmt_proj.c:	GMT->current.proj.l_rF = GMT->current.proj.EQ_RAD * GMT->current.proj.l_F;
gmt_proj.c:	GMT->current.proj.l_i_rF = 1.0 / GMT->current.proj.l_rF;
gmt_proj.c:	GMT->current.proj.l_rho0 = GMT->current.proj.l_rF * pow (t_rlat0, GMT->current.proj.l_N);
gmt_proj.c:	GMT->current.proj.l_Nr = GMT->current.proj.l_N * D2R;
gmt_proj.c:	GMT->current.proj.l_i_Nr = 1.0 / GMT->current.proj.l_Nr;
gmt_proj.c:	es = GMT->current.proj.ECC * sind (lat);
gmt_proj.c:	hold2 = pow ((1.0 - es) / (1.0 + es), GMT->current.proj.half_ECC);
gmt_proj.c:	hold1 = pow (hold3 / hold2, GMT->current.proj.l_N);
gmt_proj.c:	rho = GMT->current.proj.l_rF * hold1;
gmt_proj.c:	theta = GMT->current.proj.l_Nr * lon;
gmt_proj.c:	*y = GMT->current.proj.l_rho0 - rho * c;
gmt_proj.c:	dy = GMT->current.proj.l_rho0 - y;
gmt_proj.c:	theta = (GMT->current.proj.l_N < 0.0) ? d_atan2 (-x, -dy) : d_atan2 (x, dy);
gmt_proj.c:	*lon = theta * GMT->current.proj.l_i_Nr + GMT->current.proj.central_meridian;
gmt_proj.c:	rho = copysign (hypot (x, dy), GMT->current.proj.l_N);
gmt_proj.c:	t = pow (rho * GMT->current.proj.l_i_rF, GMT->current.proj.l_i_N);
gmt_proj.c:		r = GMT->current.proj.ECC * sin (phi);
gmt_proj.c:		phi = M_PI_2 - 2.0 * atan (t * pow ((1.0 - r) / (1.0 + r), GMT->current.proj.half_ECC));
gmt_proj.c:	if (GMT->current.proj.GMT_convert_latitudes) lat = gmt_M_latg_to_latc (GMT, lat);
gmt_proj.c:	rho = GMT->current.proj.l_rF * pow (t, GMT->current.proj.l_N);
gmt_proj.c:	theta = GMT->current.proj.l_Nr * lon;
gmt_proj.c:	*y = GMT->current.proj.l_rho0 - rho * c;
gmt_proj.c:	dy = GMT->current.proj.l_rho0 - y;
gmt_proj.c:	theta = (GMT->current.proj.l_N < 0.0) ? d_atan2 (-x, -dy) : d_atan2 (x, dy);
gmt_proj.c:	*lon = theta * GMT->current.proj.l_i_Nr + GMT->current.proj.central_meridian;
gmt_proj.c:	rho = copysign (hypot (x, dy), GMT->current.proj.l_N);
gmt_proj.c:	t = pow (rho * GMT->current.proj.l_i_rF, GMT->current.proj.l_i_N);
gmt_proj.c:	if (GMT->current.proj.GMT_convert_latitudes) *lat = gmt_M_latc_to_latg (GMT, *lat);
gmt_proj.c:	*olat = d_asin (gmt_dot3v (GMT, X, GMT->current.proj.o_FP));
gmt_proj.c:	gmt_cross3v (GMT, GMT->current.proj.o_FP, X, p_cross_x);
gmt_proj.c:	*olon = copysign (d_acos (gmt_dot3v (GMT, p_cross_x, GMT->current.proj.o_FC)), gmt_dot3v (GMT, X, GMT->current.proj.o_FC));
gmt_proj.c:	*lat = d_asin (gmt_dot3v (GMT, X, GMT->current.proj.o_IP));
gmt_proj.c:	gmt_cross3v (GMT, GMT->current.proj.o_IP, X, p_cross_x);
gmt_proj.c:	*lon = copysign (d_acos (gmt_dot3v (GMT, p_cross_x, GMT->current.proj.o_IC)), gmt_dot3v (GMT, X, GMT->current.proj.o_IC));
gmt_proj.c:	*x = GMT->current.proj.j_x * tlon;
gmt_proj.c:	*y = (fabs (tlat) < M_PI_2) ? GMT->current.proj.j_x * d_log (GMT, tan (M_PI_4 + 0.5 * tlat)) - GMT->current.proj.o_shift : copysign (DBL_MAX, tlat);
gmt_proj.c:	if (GMT->current.proj.o_spole) {
gmt_proj.c:	if (GMT->current.proj.o_spole) {
gmt_proj.c:	tlon = x * GMT->current.proj.j_ix;
gmt_proj.c:	y += GMT->current.proj.o_shift;
gmt_proj.c:	tlat = atan (sinh (y * GMT->current.proj.j_ix));
gmt_proj.c:	e1 = (1.0 - d_sqrt (GMT->current.proj.one_m_ECC2)) / (1.0 + d_sqrt (GMT->current.proj.one_m_ECC2));
gmt_proj.c:	GMT->current.proj.t_e2 = GMT->current.proj.ECC2 * GMT->current.proj.i_one_m_ECC2;
gmt_proj.c:	GMT->current.proj.t_c1 = 1.0 - (1.0/4.0) * GMT->current.proj.ECC2 - (3.0/64.0) * GMT->current.proj.ECC4 - (5.0/256.0) * GMT->current.proj.ECC6;
gmt_proj.c:	GMT->current.proj.t_c2 = -((3.0/8.0) * GMT->current.proj.ECC2 + (3.0/32.0) * GMT->current.proj.ECC4 + (25.0/768.0) * GMT->current.proj.ECC6);
gmt_proj.c:	GMT->current.proj.t_c3 = (15.0/128.0) * GMT->current.proj.ECC4 + (45.0/512.0) * GMT->current.proj.ECC6;
gmt_proj.c:	GMT->current.proj.t_c4 = -(35.0/768.0) * GMT->current.proj.ECC6;
gmt_proj.c:	GMT->current.proj.t_i1 = 1.0 / (GMT->current.proj.EQ_RAD * GMT->current.proj.t_c1);
gmt_proj.c:	GMT->current.proj.t_i2 = (3.0/2.0) * e1 - (29.0/12.0) * pow (e1, 3.0);
gmt_proj.c:	GMT->current.proj.t_i3 = (21.0/8.0) * e1 * e1 - (1537.0/128.0) * pow (e1, 4.0);
gmt_proj.c:	GMT->current.proj.t_i4 = (151.0/24.0) * pow (e1, 3.0);
gmt_proj.c:	GMT->current.proj.t_i5 = (1097.0/64.0) * pow (e1, 4.0);
gmt_proj.c:	GMT->current.proj.central_meridian = lon0;
gmt_proj.c:	GMT->current.proj.t_lat0 = lat0 * D2R;	/* In radians */
gmt_proj.c:	sincos (2.0 * GMT->current.proj.t_lat0, &s2, &c2);
gmt_proj.c:	GMT->current.proj.t_M0 = GMT->current.proj.EQ_RAD * (GMT->current.proj.t_c1 * GMT->current.proj.t_lat0 + s2 * (GMT->current.proj.t_c2 + c2 * (GMT->current.proj.t_c3 + c2 * GMT->current.proj.t_c4)));
gmt_proj.c:	GMT->current.proj.t_r = GMT->current.proj.EQ_RAD * GMT->current.setting.proj_scale_factor;
gmt_proj.c:	GMT->current.proj.t_ir = 1.0 / GMT->current.proj.t_r;
gmt_proj.c:	M = y / GMT->current.setting.proj_scale_factor + GMT->current.proj.t_M0;
gmt_proj.c:	mu = M * GMT->current.proj.t_i1;
gmt_proj.c:	phi1 = mu + s * (GMT->current.proj.t_i2 + c * (GMT->current.proj.t_i3 + c * (GMT->current.proj.t_i4 + c * GMT->current.proj.t_i5)));
gmt_proj.c:	C1 = GMT->current.proj.t_e2 * cp2;
gmt_proj.c:	tmp = 1.0 - GMT->current.proj.ECC2 * (1.0 - cp2);
gmt_proj.c:	N1 = GMT->current.proj.EQ_RAD / tmp2;
gmt_proj.c:	R_1 = GMT->current.proj.EQ_RAD * GMT->current.proj.one_m_ECC2 / (tmp * tmp2);
gmt_proj.c:	D = x / (N1 * GMT->current.setting.proj_scale_factor);
gmt_proj.c:	*lon = GMT->current.proj.central_meridian + R2D * (D - (1.0 + 2.0 * T1 + C1) * (D3 * 0.16666666666666666667)
gmt_proj.c:		+ (5.0 - 2.0 * C1 + 28.0 * T1 - 3.0 * C12 + 8.0 * GMT->current.proj.t_e2 + 24.0 * T12)
gmt_proj.c:		(5.0 + 3.0 * T1 + 10.0 * C1 - 4.0 * C12 - 9.0 * GMT->current.proj.t_e2) * (D3 * 0.04166666666666666667)
gmt_proj.c:		+ (61.0 + 90.0 * T1 + 298 * C1 + 45.0 * T12 - 252.0 * GMT->current.proj.t_e2 - 3.0 * C12) * (D5 * 0.00138888888888888889));
gmt_proj.c:	gmt_M_set_delta_lon (GMT->current.proj.central_meridian, lon, dlon);
gmt_proj.c:	if (GMT->current.proj.GMT_convert_latitudes) lat = gmt_M_latg_to_latc (GMT, lat);
gmt_proj.c:		*y = -GMT->current.proj.t_r * GMT->current.proj.t_lat0;
gmt_proj.c:	yy = atan2 (slat, (clat * clon)) - GMT->current.proj.t_lat0;
gmt_proj.c:	*x = GMT->current.proj.t_r * xx;
gmt_proj.c:	*y = GMT->current.proj.t_r * yy;
gmt_proj.c:	xx = x * GMT->current.proj.t_ir;
gmt_proj.c:	yy = y * GMT->current.proj.t_ir + GMT->current.proj.t_lat0;
gmt_proj.c:	*lon = lambda + GMT->current.proj.central_meridian;
gmt_proj.c:	if (GMT->current.proj.GMT_convert_latitudes) *lat = gmt_M_latc_to_latg (GMT, *lat);
gmt_proj.c:	if (!GMT->current.proj.north_pole) (*y) += GMT_FALSE_NORTHING;	/* For S hemisphere, add 10^7 m */
gmt_proj.c:	if (!GMT->current.proj.north_pole) y -= GMT_FALSE_NORTHING;
gmt_proj.c:	if (!GMT->current.proj.north_pole) (*y) += GMT_FALSE_NORTHING;	/* For S hemisphere, add 10^7 m */
gmt_proj.c:	if (!GMT->current.proj.north_pole) y -= GMT_FALSE_NORTHING;
gmt_proj.c:	GMT->current.proj.central_meridian = lon0;
gmt_proj.c:	GMT->current.proj.pole = lat0;
gmt_proj.c:	if (GMT->current.proj.GMT_convert_latitudes) lat0 = gmt_M_latg_to_lata (GMT, lat0);
gmt_proj.c:	sincosd (lat0, &(GMT->current.proj.sinp), &(GMT->current.proj.cosp));
gmt_proj.c:	GMT->current.proj.f_horizon = horizon;
gmt_proj.c:	GMT->current.proj.rho_max = 2.0 * sind (0.5 * horizon) * GMT->current.proj.EQ_RAD;
gmt_proj.c:	if (GMT->current.proj.GMT_convert_latitudes) lat = gmt_M_latg_to_lata (GMT, lat);
gmt_proj.c:	tmp = 1.0 + GMT->current.proj.sinp * sin_lat + GMT->current.proj.cosp * c;
gmt_proj.c:		k = GMT->current.proj.EQ_RAD * d_sqrt (2.0 / tmp);
gmt_proj.c:		*y = k * (GMT->current.proj.cosp * sin_lat - GMT->current.proj.sinp * c);
gmt_proj.c:		if (GMT->current.proj.GMT_convert_latitudes) {	/* Gotta fudge abit */
gmt_proj.c:			(*x) *= GMT->current.proj.Dx;
gmt_proj.c:			(*y) *= GMT->current.proj.Dy;
gmt_proj.c:	if (GMT->current.proj.GMT_convert_latitudes) {	/* Undo effect of fudge factors */
gmt_proj.c:		x *= GMT->current.proj.iDx;
gmt_proj.c:		y *= GMT->current.proj.iDy;
gmt_proj.c:	if (rho > GMT->current.proj.rho_max) {			/* Horizon		*/
gmt_proj.c:		*lat = *lon = GMT->session.d_NaN;
gmt_proj.c:	a = 0.5 * rho * GMT->current.proj.i_EQ_RAD;			/* a = sin(c/2)		*/
gmt_proj.c:	sin_c = sqrt (1.0 - a) * GMT->current.proj.i_EQ_RAD;		/* sin_c = sin(c)/rho	*/
gmt_proj.c:	*lat = d_asind (cos_c * GMT->current.proj.sinp + y * sin_c * GMT->current.proj.cosp);
gmt_proj.c:	*lon = d_atan2d (x * sin_c, GMT->current.proj.cosp * cos_c - y * GMT->current.proj.sinp * sin_c) + GMT->current.proj.central_meridian;
gmt_proj.c:	if (GMT->current.proj.GMT_convert_latitudes) *lat = gmt_M_lata_to_latg (GMT, *lat);
gmt_proj.c:	dlon = lon - GMT->current.proj.central_meridian;
gmt_proj.c:	cosc = GMT->current.proj.sinp * sin_lat + GMT->current.proj.cosp * cos_lat * cos_dlon;
gmt_proj.c:	GMT->current.proj.g_outside = false;
gmt_proj.c:	if (cosc < GMT->current.proj.g_P_inverse) { /* over the horizon */
gmt_proj.c:		GMT->current.proj.g_outside = true;
gmt_proj.c:		if (GMT->current.proj.polar)
gmt_proj.c:		else if (GMT->current.proj.cosp*sinc != 0.0) {
gmt_proj.c:			angle = d_acos((sin_lat - GMT->current.proj.sinp*cosc)/(GMT->current.proj.cosp*sinc));
gmt_proj.c:		x *= GMT->current.proj.g_rmax;
gmt_proj.c:		y *= GMT->current.proj.g_rmax;
gmt_proj.c:	else if (GMT->current.proj.ECC2 != 0.0) { /* within field of view, ellipsoidal earth */
gmt_proj.c:		/* angle = GMT->current.proj.g_azimuth; */
gmt_proj.c:		kp = GMT->current.proj.g_R * (GMT->current.proj.g_P - 1.0) / (GMT->current.proj.g_P - cosc);
gmt_proj.c:		y = kp * (GMT->current.proj.cosp * sin_lat - GMT->current.proj.sinp * cos_lat * cos_dlon);
gmt_proj.c:		/* angle = GMT->current.proj.g_azimuth; */
gmt_proj.c:	proj_genper_to_xtyt (GMT, angle, x, y, GMT->current.proj.g_yoffset, xt, yt);
gmt_proj.c:	GMT->current.proj.central_meridian = lon0;
gmt_proj.c:	Req = R = GMT->current.proj.EQ_RAD;
gmt_proj.c:	Rpolar = Req * sqrt(GMT->current.proj.one_m_ECC2);
gmt_proj.c:	sincosd (lat0, &(GMT->current.proj.sinp), &(GMT->current.proj.cosp));
gmt_proj.c:	if (!GMT_PROJ_IS_ZERO (GMT->current.proj.ECC2)) {
gmt_proj.c:		GMT->current.proj.central_meridian = lon0;
gmt_proj.c:		GMT->current.proj.pole = GMT->current.proj.g_phig;
gmt_proj.c:		GMT->current.proj.pole = lat0;
gmt_proj.c:		if (GMT->current.proj.g_radius || (altitude < -10.0)) {
gmt_proj.c:		GMT->current.proj.g_R = R;
gmt_proj.c:		GMT->current.proj.g_H = H;
gmt_proj.c:		GMT->current.proj.g_P = P;
gmt_proj.c:	H = GMT->current.proj.g_H;
gmt_proj.c:	P = GMT->current.proj.g_P;
gmt_proj.c:	R = GMT->current.proj.g_R;
gmt_proj.c:	GMT->current.proj.g_P_inverse = P > 0.0 ? 1.0/P : 1.0;
gmt_proj.c:	if (GMT->current.proj.g_longlat_set) {
gmt_proj.c:			if (GMT->current.proj.g_debug > 0) {
gmt_proj.c:		if (GMT->current.proj.g_debug > 0) gmt_message (GMT, "vgenper: pointing at longitude %10.4f latitude %10.4f\n           with computed tilt %5.2f azimuth %6.2f\n", vp_long, vp_lat, tilt, azimuth);
gmt_proj.c:	else if (GMT->current.proj.g_debug > 1) {
gmt_proj.c:	if (tilt < 0.0) tilt = d_asind (GMT->current.proj.g_P_inverse);
gmt_proj.c:	sincosd (tilt, &(GMT->current.proj.g_sin_tilt), &(GMT->current.proj.g_cos_tilt));
gmt_proj.c:	sincosd (twist, &(GMT->current.proj.g_sin_twist), &(GMT->current.proj.g_cos_twist));
gmt_proj.c:	GMT->current.proj.g_box = !(fabs (width) < GMT_CONV4_LIMIT);
gmt_proj.c:	GMT->current.proj.g_width = width/2.0;
gmt_proj.c:	GMT->current.proj.g_azimuth = azimuth;
gmt_proj.c:	sincosd (azimuth, &(GMT->current.proj.g_sin_azimuth), &(GMT->current.proj.g_cos_azimuth));
gmt_proj.c:	if (GMT->current.proj.ECC2 != 0.0) rmax = rmax_at_lat0;
gmt_proj.c:	kp = R*(P - 1.0) / (P - GMT->current.proj.g_P_inverse);
gmt_proj.c:	omega_max = d_acosd(GMT->current.proj.g_P_inverse);
gmt_proj.c:	GMT->current.proj.g_rmax = rmax;
gmt_proj.c:	/* GMT->current.proj.f_horizon = GMT->current.proj.g_P_inverse; */
gmt_proj.c:	GMT->current.proj.f_horizon = omega_max;
gmt_proj.c:	gamma = 180.0 - d_asind (GMT->current.proj.g_sin_tilt * P);
gmt_proj.c:	if (GMT->current.proj.g_debug > 0)
gmt_proj.c:		             tilt, GMT->current.proj.g_sin_tilt, P, gamma, Omega, eccen);
gmt_proj.c:		if (GMT->current.proj.g_debug > 1)
gmt_proj.c:			if (GMT->current.proj.g_debug > 1)
gmt_proj.c:			if (GMT->current.proj.g_debug > 1)
gmt_proj.c:			if (GMT->current.proj.g_debug > 1)
gmt_proj.c:			if (GMT->current.proj.g_debug > 1)
gmt_proj.c:	GMT->current.proj.g_max_yt = max_yt;
gmt_proj.c:	sinlatvp = GMT->current.proj.sinp*cosOmega + GMT->current.proj.cosp*sinOmega*GMT->current.proj.g_cos_azimuth;
gmt_proj.c:	lonvp = acosd ((cosOmega - sinlatvp*GMT->current.proj.sinp)/(GMT->current.proj.cosp*coslatvp));
gmt_proj.c:	if (GMT->current.proj.g_debug > 1)
gmt_proj.c:	GMT->current.proj.g_yoffset = 0.0;
gmt_proj.c:		GMT->current.proj.g_yoffset = GMT->current.proj.g_sin_tilt * H ;
gmt_proj.c:		if (GMT->current.proj.g_debug > 2) {
gmt_proj.c:				             tilt, GMT->current.proj.g_sin_tilt, GMT->current.proj.g_cos_tilt);
gmt_proj.c:				             azimuth, GMT->current.proj.g_sin_azimuth, GMT->current.proj.g_cos_azimuth);
gmt_proj.c:			proj_genper_to_xtyt (GMT, (double)az, x, y, GMT->current.proj.g_yoffset, &xt, &yt);
gmt_proj.c:			if (fp && GMT->current.proj.g_debug > 2)
gmt_proj.c:		if (GMT->current.proj.g_debug > 2 && fp) fclose(fp);
gmt_proj.c:			GMT->current.proj.g_width = atand (2.0*rmax/H);
gmt_proj.c:			height = width = 2.0 * GMT->current.proj.g_width;
gmt_proj.c:			xt_max = yt_max = R * rho * sind (GMT->current.proj.g_width);
gmt_proj.c:	if (GMT->current.proj.g_debug > 1) {
gmt_proj.c:	GMT->current.proj.g_xmin = xt_min;
gmt_proj.c:	GMT->current.proj.g_xmax = xt_max;
gmt_proj.c:	GMT->current.proj.g_ymin = yt_min;
gmt_proj.c:	GMT->current.proj.g_ymax = yt_max;
gmt_proj.c:	if (width != 0.0) GMT->current.proj.scale[GMT_Y] = GMT->current.proj.scale[GMT_X]/width*height;
gmt_proj.c:	if (GMT->current.proj.g_debug > 0) {
gmt_proj.c:		gmt_message (GMT, "\nvgenper: polar %d north %d\n", GMT->current.proj.polar, GMT->current.proj.north_pole);
gmt_proj.c:		gmt_message (GMT, "vgenper: radius max %7.1f km\n", GMT->current.proj.g_rmax/1000.0);
gmt_proj.c:		gmt_message (GMT, "vgenper: y offset %7.1f km\n", GMT->current.proj.g_yoffset/1000.0);
gmt_proj.c:		gmt_message (GMT, "vgenper: y max %7.1f km\n", GMT->current.proj.g_ymax/1000.0);
gmt_proj.c:		gmt_message (GMT, "vgenper: y min %7.1f km\n", GMT->current.proj.g_ymin/1000.0);
gmt_proj.c:		gmt_message (GMT, "vgenper: x max %7.1f km\n", GMT->current.proj.g_xmax/1000.0);
gmt_proj.c:		gmt_message (GMT, "vgenper: x min %7.1f km\n", GMT->current.proj.g_xmin/1000.0);
gmt_proj.c:		gmt_message (GMT, "vgenper: user viewpoint %d\n", GMT->current.proj.g_box);
gmt_proj.c:	H = GMT->current.proj.g_H;
gmt_proj.c:	R = GMT->current.proj.g_R;
gmt_proj.c:	P = GMT->current.proj.g_P;
gmt_proj.c:	xt = (x * GMT->current.proj.g_cos_twist + y * GMT->current.proj.g_sin_twist);
gmt_proj.c:	yt = (y * GMT->current.proj.g_cos_twist - x * GMT->current.proj.g_sin_twist);
gmt_proj.c:	yt += GMT->current.proj.g_yoffset;
gmt_proj.c:	M = H * xt / (H - yt * GMT->current.proj.g_sin_tilt);
gmt_proj.c:	Q = H * yt * GMT->current.proj.g_cos_tilt /(H - yt * GMT->current.proj.g_sin_tilt);
gmt_proj.c:	x = M * GMT->current.proj.g_cos_azimuth + Q * GMT->current.proj.g_sin_azimuth;
gmt_proj.c:	y = Q * GMT->current.proj.g_cos_azimuth - M * GMT->current.proj.g_sin_azimuth;
gmt_proj.c:	GMT->current.proj.g_outside = false;
gmt_proj.c:		*lat = GMT->current.proj.pole;
gmt_proj.c:		*lon = GMT->current.proj.central_meridian;
gmt_proj.c:	if (rho > GMT->current.proj.g_rmax) {
gmt_proj.c:		x *= GMT->current.proj.g_rmax/rho;
gmt_proj.c:		y *= GMT->current.proj.g_rmax/rho;
gmt_proj.c:		rho = GMT->current.proj.g_rmax;
gmt_proj.c:		GMT->current.proj.g_outside = true;
gmt_proj.c:	if (GMT->current.proj.ECC2 != 0.0)
gmt_proj.c:		*lat = d_asind (cos_c * GMT->current.proj.sinp + y * sin_c * GMT->current.proj.cosp);
gmt_proj.c:		*lon = d_atan2d (x * sin_c, cos_c * GMT->current.proj.cosp - y * sin_c * GMT->current.proj.sinp) + GMT->current.proj.central_meridian;
gmt_proj.c:	if (GMT->current.proj.g_debug > 0) {
gmt_proj.c:		gmt_message (GMT, " x_scale %e y_scale %e, x0 %e y0 %e\n", GMT->current.proj.scale[GMT_X], GMT->current.proj.scale[GMT_Y], GMT->current.proj.origin[GMT_X], GMT->current.proj.origin[GMT_Y]);
gmt_proj.c:		x *= GMT->current.proj.g_rmax;
gmt_proj.c:		y *= GMT->current.proj.g_rmax;
gmt_proj.c:		proj_genper_to_xtyt (GMT, angle*R2D, x, y, GMT->current.proj.g_yoffset, &xt, &yt);
gmt_proj.c:		if (GMT->current.proj.g_width != 0.0) {
gmt_proj.c:			xt = MAX (GMT->current.proj.g_xmin, MIN (xt, GMT->current.proj.g_xmax));
gmt_proj.c:			yt = MAX (GMT->current.proj.g_ymin, MIN (yt, GMT->current.proj.g_ymax));
gmt_proj.c:		work_x[i] = xt * GMT->current.proj.scale[GMT_X] + GMT->current.proj.origin[GMT_X];
gmt_proj.c:		work_y[i] = yt * GMT->current.proj.scale[GMT_Y] + GMT->current.proj.origin[GMT_Y];
gmt_proj.c:	GMT->current.proj.central_meridian = lon0;
gmt_proj.c:	GMT->current.proj.pole = lat0;
gmt_proj.c:	sincosd (lat0, &(GMT->current.proj.sinp), &(GMT->current.proj.cosp));
gmt_proj.c:	GMT->current.proj.f_horizon = horizon;
gmt_proj.c:	GMT->current.proj.rho_max = sind (horizon);
gmt_proj.c:	*x = GMT->current.proj.EQ_RAD * cos_lat * sin_lon;
gmt_proj.c:	*y = GMT->current.proj.EQ_RAD * (GMT->current.proj.cosp * sin_lat - GMT->current.proj.sinp * cos_lat * cos_lon);
gmt_proj.c:	x *= GMT->current.proj.i_EQ_RAD;
gmt_proj.c:	y *= GMT->current.proj.i_EQ_RAD;
gmt_proj.c:	if (rho > GMT->current.proj.rho_max) {
gmt_proj.c:		*lat = *lon = GMT->session.d_NaN;
gmt_proj.c:	*lat = d_asind (cos_c * GMT->current.proj.sinp + y * GMT->current.proj.cosp);
gmt_proj.c:	*lon = d_atan2d (x, cos_c * GMT->current.proj.cosp - y * GMT->current.proj.sinp) + GMT->current.proj.central_meridian;
gmt_proj.c:	GMT->current.proj.central_meridian = lon0;
gmt_proj.c:	GMT->current.proj.f_horizon = horizon;
gmt_proj.c:	GMT->current.proj.rho_max = tand (GMT->current.proj.f_horizon);
gmt_proj.c:	GMT->current.proj.pole = lat0;
gmt_proj.c:	GMT->current.proj.north_pole = (lat0 > 0.0);
gmt_proj.c:	sincosd (lat0, &(GMT->current.proj.sinp), &(GMT->current.proj.cosp));
gmt_proj.c:	k =  GMT->current.proj.EQ_RAD / (GMT->current.proj.sinp * sin_lat + GMT->current.proj.cosp * cc);
gmt_proj.c:	*y = k * (GMT->current.proj.cosp * sin_lat - GMT->current.proj.sinp * cc);
gmt_proj.c:	x *= GMT->current.proj.i_EQ_RAD;
gmt_proj.c:	y *= GMT->current.proj.i_EQ_RAD;
gmt_proj.c:	if (rho > GMT->current.proj.rho_max) {
gmt_proj.c:		*lat = *lon = GMT->session.d_NaN;
gmt_proj.c:	*lat = d_asind (cos(c) * (GMT->current.proj.sinp + y * GMT->current.proj.cosp));
gmt_proj.c:	*lon = d_atan2d (x, GMT->current.proj.cosp - y * GMT->current.proj.sinp) + GMT->current.proj.central_meridian;
gmt_proj.c:	GMT->current.proj.central_meridian = lon0;
gmt_proj.c:	GMT->current.proj.pole = lat0;
gmt_proj.c:	sincosd (lat0, &(GMT->current.proj.sinp), &(GMT->current.proj.cosp));
gmt_proj.c:	GMT->current.proj.f_horizon = horizon;
gmt_proj.c:	GMT->current.proj.rho_max = horizon * D2R;
gmt_proj.c:	if (GMT_PROJ_IS_ZERO (lat-GMT->current.proj.pole) && GMT_PROJ_IS_ZERO (lon)) {	/* Center of projection */
gmt_proj.c:	cc = GMT->current.proj.sinp * slat + GMT->current.proj.cosp * t;
gmt_proj.c:		*x = *y = GMT->session.d_NaN;
gmt_proj.c:		GMT->current.proj.n_antipoles++;
gmt_proj.c:		k = (GMT_PROJ_IS_ZERO (c)) ? GMT->current.proj.EQ_RAD : GMT->current.proj.EQ_RAD * c / sin (c);
gmt_proj.c:		*y = k * (GMT->current.proj.cosp * slat - GMT->current.proj.sinp * t);
gmt_proj.c:	x *= GMT->current.proj.i_EQ_RAD;
gmt_proj.c:	y *= GMT->current.proj.i_EQ_RAD;
gmt_proj.c:	if (rho > GMT->current.proj.rho_max) {	/* Horizon */
gmt_proj.c:		*lat = *lon = GMT->session.d_NaN;
gmt_proj.c:	*lat = d_asind (cos_c * GMT->current.proj.sinp + y * sin_c * GMT->current.proj.cosp);
gmt_proj.c:	*lon = d_atan2d (x * sin_c, cos_c * GMT->current.proj.cosp - y * sin_c * GMT->current.proj.sinp) + GMT->current.proj.central_meridian;
gmt_proj.c:	GMT->current.proj.central_meridian = lon0;
gmt_proj.c:	GMT->current.proj.w_x = GMT->current.proj.EQ_RAD * D2R * d_sqrt (8.0) / M_PI;
gmt_proj.c:	GMT->current.proj.w_y = GMT->current.proj.EQ_RAD * M_SQRT2;
gmt_proj.c:	GMT->current.proj.w_iy = 1.0 / GMT->current.proj.w_y;
gmt_proj.c:	GMT->current.proj.w_r = 0.25 * (scale * GMT->current.proj.M_PR_DEG * 360.0);	/* = Half the minor axis */
gmt_proj.c:		*y = copysign (GMT->current.proj.w_y, lat);
gmt_proj.c:	if (GMT->current.proj.GMT_convert_latitudes) lat = gmt_M_latg_to_lata (GMT, lat);
gmt_proj.c:	*x = GMT->current.proj.w_x * lon * c;
gmt_proj.c:	*y = GMT->current.proj.w_y * s;
gmt_proj.c:	phi = asin (y * GMT->current.proj.w_iy);
gmt_proj.c:	*lon = x / (GMT->current.proj.w_x * cos(phi));
gmt_proj.c:		*lat = *lon = GMT->session.d_NaN;
gmt_proj.c:	*lon += GMT->current.proj.central_meridian;
gmt_proj.c:	if (GMT->current.proj.GMT_convert_latitudes) *lat = gmt_M_lata_to_latg (GMT, *lat);
gmt_proj.c:	GMT->current.proj.central_meridian = lon0;
gmt_proj.c:	GMT->current.proj.w_r = 0.25 * (scale * GMT->current.proj.M_PR_DEG * 360.0);	/* = Half the minor axis */
gmt_proj.c:		*y = M_SQRT2 * copysign (GMT->current.proj.EQ_RAD, lat);
gmt_proj.c:	if (GMT->current.proj.GMT_convert_latitudes) lat = gmt_M_latg_to_lata (GMT, lat);
gmt_proj.c:	D = GMT->current.proj.EQ_RAD * sqrt (2.0 / (1.0 + clat * clon));
gmt_proj.c:	a = 0.5 * rho * GMT->current.proj.i_EQ_RAD;			/* a = sin(c/2)		*/
gmt_proj.c:		*lat = *lon = GMT->session.d_NaN;
gmt_proj.c:	sin_c = sqrt (1.0 - a) * GMT->current.proj.i_EQ_RAD;		/* sin_c = sin(c)/rho	*/
gmt_proj.c:	*lon = 2.0 * d_atan2d (x * sin_c, cos_c) + GMT->current.proj.central_meridian;
gmt_proj.c:	if (GMT->current.proj.GMT_convert_latitudes) *lat = gmt_M_lata_to_latg (GMT, *lat);
gmt_proj.c:	GMT->current.proj.central_meridian = lon0;
gmt_proj.c:	GMT->current.proj.v_r = M_PI * GMT->current.proj.EQ_RAD;
gmt_proj.c:	GMT->current.proj.v_ir = 1.0 / GMT->current.proj.v_r;
gmt_proj.c:		*y = M_PI * copysign (GMT->current.proj.EQ_RAD, lat);
gmt_proj.c:	if (doubleAlmostEqualZero (lon, GMT->current.proj.central_meridian)) {	/* Save time */
gmt_proj.c:		*y = M_PI * copysign (GMT->current.proj.EQ_RAD, lat) * tan (0.5 * theta);
gmt_proj.c:		*x = GMT->current.proj.EQ_RAD * D2R * lon;
gmt_proj.c:	*x = copysign (GMT->current.proj.v_r, lon) * (A * GP2 + sqrt (A2 * GP2 * GP2 - P2A2 * (G*G - P2))) * i_P2A2;
gmt_proj.c:	*y = copysign (GMT->current.proj.v_r, lat) * (P * Q - A * sqrt ((A2 + 1.0) * P2A2 - Q * Q)) * i_P2A2;
gmt_proj.c:	x *= GMT->current.proj.v_ir;
gmt_proj.c:	y *= GMT->current.proj.v_ir;
gmt_proj.c:		*lat = *lon = GMT->session.d_NaN;
gmt_proj.c:	*lon = GMT->current.proj.central_meridian;
gmt_proj.c:	GMT->current.proj.r_cosphi1 = cosd (50.0+(28.0/60.0));
gmt_proj.c:	GMT->current.proj.central_meridian = lon0;
gmt_proj.c:	GMT->current.proj.w_r = 0.25 * (scale * GMT->current.proj.M_PR_DEG * 360.0);	/* = Half the minor axis */
gmt_proj.c:	x2 = lon * GMT->current.proj.r_cosphi1;
gmt_proj.c:	*x = GMT->current.proj.EQ_RAD * (x1 + x2);
gmt_proj.c:	*y = 0.5 * GMT->current.proj.EQ_RAD * (y1 + lat);
gmt_proj.c:	y -= GMT->current.proj.origin[GMT_Y];
gmt_proj.c:	y *= GMT->current.proj.i_scale[GMT_Y];
gmt_proj.c:	gmt_geo_to_xy (GMT, GMT->current.proj.central_meridian - 180.0, phi, &x, &c);
gmt_proj.c:	y -= GMT->current.proj.origin[GMT_Y];
gmt_proj.c:	y *= GMT->current.proj.i_scale[GMT_Y];
gmt_proj.c:	gmt_geo_to_xy (GMT, GMT->current.proj.central_meridian + 180.0, phi, &x, &c);
gmt_proj.c:	GMT->current.proj.k4_x = 2.0 * GMT->current.proj.EQ_RAD / d_sqrt (M_PI * (4.0 + M_PI));
gmt_proj.c:	GMT->current.proj.k4_y = 2.0 * GMT->current.proj.EQ_RAD * d_sqrt (M_PI / (4.0 + M_PI));
gmt_proj.c:	GMT->current.proj.k4_ix = 1.0 / GMT->current.proj.k4_x;
gmt_proj.c:	GMT->current.proj.k4_iy = 1.0 / GMT->current.proj.k4_y;
gmt_proj.c:	GMT->current.proj.central_meridian = lon0;
gmt_proj.c:	*x = GMT->current.proj.k4_x * lon * D2R * (1.0 + c);
gmt_proj.c:	*y = GMT->current.proj.k4_y * s;
gmt_proj.c:	s = y * GMT->current.proj.k4_iy;
gmt_proj.c:	*lon = R2D * x * GMT->current.proj.k4_ix / (1.0 + c);
gmt_proj.c:		*lat = *lon = GMT->session.d_NaN;
gmt_proj.c:	*lon += GMT->current.proj.central_meridian;
gmt_proj.c:	y -= GMT->current.proj.origin[GMT_Y];
gmt_proj.c:	y *= GMT->current.proj.i_scale[GMT_Y];
gmt_proj.c:	phi = d_asin (y * GMT->current.proj.k4_iy);
gmt_proj.c:	x = GMT->current.proj.k4_x * D2R * (GMT->common.R.wesn[XLO] - GMT->current.proj.central_meridian) * (1.0 + cos (phi));
gmt_proj.c:	return (x * GMT->current.proj.scale[GMT_X] + GMT->current.proj.origin[GMT_X]);
gmt_proj.c:	y -= GMT->current.proj.origin[GMT_Y];
gmt_proj.c:	y *= GMT->current.proj.i_scale[GMT_Y];
gmt_proj.c:	phi = d_asin (y * GMT->current.proj.k4_iy);
gmt_proj.c:	x = GMT->current.proj.k4_x * D2R * (GMT->common.R.wesn[XHI] - GMT->current.proj.central_meridian) * (1.0 + cos (phi));
gmt_proj.c:	return (x * GMT->current.proj.scale[GMT_X] + GMT->current.proj.origin[GMT_X]);
gmt_proj.c:	GMT->current.proj.k6_r = GMT->current.proj.EQ_RAD / sqrt (2.0 + M_PI);
gmt_proj.c:	GMT->current.proj.k6_ir = 1.0 / GMT->current.proj.k6_r;
gmt_proj.c:	GMT->current.proj.central_meridian = lon0;
gmt_proj.c:	if (GMT->current.proj.GMT_convert_latitudes) lat = gmt_M_latg_to_lata (GMT, lat);
gmt_proj.c:	*x = GMT->current.proj.k6_r * lon * D2R * (1.0 + cos (phi));
gmt_proj.c:	*y = 2.0 * GMT->current.proj.k6_r * phi;
gmt_proj.c:	phi = 0.5 * y * GMT->current.proj.k6_ir;
gmt_proj.c:	*lon = R2D * x * GMT->current.proj.k6_ir / (1.0 + c);
gmt_proj.c:		*lat = *lon = GMT->session.d_NaN;
gmt_proj.c:	*lon += GMT->current.proj.central_meridian;
gmt_proj.c:	if (GMT->current.proj.GMT_convert_latitudes) *lat = gmt_M_lata_to_latg (GMT, *lat);
gmt_proj.c:	y -= GMT->current.proj.origin[GMT_Y];
gmt_proj.c:	y *= GMT->current.proj.i_scale[GMT_Y];
gmt_proj.c:	phi = 0.5 * y * GMT->current.proj.k6_ir;
gmt_proj.c:	x = GMT->current.proj.k6_r * D2R * (GMT->common.R.wesn[XLO] - GMT->current.proj.central_meridian) * (1.0 + cos (phi));
gmt_proj.c:	return (x * GMT->current.proj.scale[GMT_X] + GMT->current.proj.origin[GMT_X]);
gmt_proj.c:	y -= GMT->current.proj.origin[GMT_Y];
gmt_proj.c:	y *= GMT->current.proj.i_scale[GMT_Y];
gmt_proj.c:	phi = 0.5 * y * GMT->current.proj.k6_ir;
gmt_proj.c:	x = GMT->current.proj.k6_r * D2R * (GMT->common.R.wesn[XHI] - GMT->current.proj.central_meridian) * (1.0 + cos (phi));
gmt_proj.c:	return (x * GMT->current.proj.scale[GMT_X] + GMT->current.proj.origin[GMT_X]);
gmt_proj.c:	if (GMT->current.setting.interpolant == GMT_SPLINE_LINEAR) {	/* Must reset and warn */
gmt_proj.c:		GMT->current.setting.interpolant = GMT_SPLINE_AKIMA;
gmt_proj.c:	GMT->current.proj.n_cx = 0.8487 * GMT->current.proj.EQ_RAD * D2R;
gmt_proj.c:	GMT->current.proj.n_cy = 1.3523 * GMT->current.proj.EQ_RAD;
gmt_proj.c:	GMT->current.proj.n_i_cy = 1.0 / GMT->current.proj.n_cy;
gmt_proj.c:	GMT->current.proj.central_meridian = lon0;
gmt_proj.c:	GMT->current.proj.n_phi[0] = 0;	GMT->current.proj.n_X[0] = 1.0000;	GMT->current.proj.n_Y[0] = 0.0000;
gmt_proj.c:	GMT->current.proj.n_phi[1] = 5;	GMT->current.proj.n_X[1] = 0.9986;	GMT->current.proj.n_Y[1] = 0.0620;
gmt_proj.c:	GMT->current.proj.n_phi[2] = 10;	GMT->current.proj.n_X[2] = 0.9954;	GMT->current.proj.n_Y[2] = 0.1240;
gmt_proj.c:	GMT->current.proj.n_phi[3] = 15;	GMT->current.proj.n_X[3] = 0.9900;	GMT->current.proj.n_Y[3] = 0.1860;
gmt_proj.c:	GMT->current.proj.n_phi[4] = 20;	GMT->current.proj.n_X[4] = 0.9822;	GMT->current.proj.n_Y[4] = 0.2480;
gmt_proj.c:	GMT->current.proj.n_phi[5] = 25;	GMT->current.proj.n_X[5] = 0.9730;	GMT->current.proj.n_Y[5] = 0.3100;
gmt_proj.c:	GMT->current.proj.n_phi[6] = 30;	GMT->current.proj.n_X[6] = 0.9600;	GMT->current.proj.n_Y[6] = 0.3720;
gmt_proj.c:	GMT->current.proj.n_phi[7] = 35;	GMT->current.proj.n_X[7] = 0.9427;	GMT->current.proj.n_Y[7] = 0.4340;
gmt_proj.c:	GMT->current.proj.n_phi[8] = 40;	GMT->current.proj.n_X[8] = 0.9216;	GMT->current.proj.n_Y[8] = 0.4958;
gmt_proj.c:	GMT->current.proj.n_phi[9] = 45;	GMT->current.proj.n_X[9] = 0.8962;	GMT->current.proj.n_Y[9] = 0.5571;
gmt_proj.c:	GMT->current.proj.n_phi[10] = 50;	GMT->current.proj.n_X[10] = 0.8679;	GMT->current.proj.n_Y[10] = 0.6176;
gmt_proj.c:	GMT->current.proj.n_phi[11] = 55;	GMT->current.proj.n_X[11] = 0.8350;	GMT->current.proj.n_Y[11] = 0.6769;
gmt_proj.c:	GMT->current.proj.n_phi[12] = 60;	GMT->current.proj.n_X[12] = 0.7986;	GMT->current.proj.n_Y[12] = 0.7346;
gmt_proj.c:	GMT->current.proj.n_phi[13] = 65;	GMT->current.proj.n_X[13] = 0.7597;	GMT->current.proj.n_Y[13] = 0.7903;
gmt_proj.c:	GMT->current.proj.n_phi[14] = 70;	GMT->current.proj.n_X[14] = 0.7186;	GMT->current.proj.n_Y[14] = 0.8435;
gmt_proj.c:	GMT->current.proj.n_phi[15] = 75;	GMT->current.proj.n_X[15] = 0.6732;	GMT->current.proj.n_Y[15] = 0.8936;
gmt_proj.c:	GMT->current.proj.n_phi[16] = 80;	GMT->current.proj.n_X[16] = 0.6213;	GMT->current.proj.n_Y[16] = 0.9394;
gmt_proj.c:	GMT->current.proj.n_phi[17] = 85;	GMT->current.proj.n_X[17] = 0.5722;	GMT->current.proj.n_Y[17] = 0.9761;
gmt_proj.c:	GMT->current.proj.n_phi[18] = 90;	GMT->current.proj.n_X[18] = 0.5322;	GMT->current.proj.n_Y[18] = 1.0000;
gmt_proj.c:	if (GMT->current.setting.interpolant == GMT_SPLINE_CUBIC) {	/* Natural cubic spline */
gmt_proj.c:		err_flag  = gmtlib_cspline (GMT, GMT->current.proj.n_phi, GMT->current.proj.n_X,   GMT_N_ROBINSON, GMT->current.proj.n_x_coeff);
gmt_proj.c:		err_flag += gmtlib_cspline (GMT, GMT->current.proj.n_phi, GMT->current.proj.n_Y,   GMT_N_ROBINSON, GMT->current.proj.n_y_coeff);
gmt_proj.c:		err_flag += gmtlib_cspline (GMT, GMT->current.proj.n_Y,   GMT->current.proj.n_X,   GMT_N_ROBINSON, GMT->current.proj.n_yx_coeff);
gmt_proj.c:		err_flag += gmtlib_cspline (GMT, GMT->current.proj.n_Y,   GMT->current.proj.n_phi, GMT_N_ROBINSON, GMT->current.proj.n_iy_coeff);
gmt_proj.c:		err_flag  = gmtlib_akima (GMT, GMT->current.proj.n_phi, GMT->current.proj.n_X,   GMT_N_ROBINSON, GMT->current.proj.n_x_coeff);
gmt_proj.c:		err_flag += gmtlib_akima (GMT, GMT->current.proj.n_phi, GMT->current.proj.n_Y,   GMT_N_ROBINSON, GMT->current.proj.n_y_coeff);
gmt_proj.c:		err_flag += gmtlib_akima (GMT, GMT->current.proj.n_Y,   GMT->current.proj.n_X,   GMT_N_ROBINSON, GMT->current.proj.n_yx_coeff);
gmt_proj.c:		err_flag += gmtlib_akima (GMT, GMT->current.proj.n_Y,   GMT->current.proj.n_phi, GMT_N_ROBINSON, GMT->current.proj.n_iy_coeff);
gmt_proj.c:	if (err_flag) GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Interpolation failed in gmt_vrobinson?\n");
gmt_proj.c:	X = proj_robinson_spline (GMT, phi, GMT->current.proj.n_phi, GMT->current.proj.n_X, GMT->current.proj.n_x_coeff);
gmt_proj.c:	Y = proj_robinson_spline (GMT, phi, GMT->current.proj.n_phi, GMT->current.proj.n_Y, GMT->current.proj.n_y_coeff);
gmt_proj.c:	*x = GMT->current.proj.n_cx * X * lon;	/* D2R is in n_cx already */
gmt_proj.c:	*y = GMT->current.proj.n_cy * copysign (Y, lat);
gmt_proj.c:	Y = fabs (y * GMT->current.proj.n_i_cy);
gmt_proj.c:	*lat = proj_robinson_spline (GMT, Y, GMT->current.proj.n_Y, GMT->current.proj.n_phi, GMT->current.proj.n_iy_coeff);
gmt_proj.c:	X = proj_robinson_spline (GMT, *lat, GMT->current.proj.n_phi, GMT->current.proj.n_X, GMT->current.proj.n_x_coeff);
gmt_proj.c:	*lon = x / (GMT->current.proj.n_cx * X);
gmt_proj.c:		*lat = *lon = GMT->session.d_NaN;
gmt_proj.c:	*lon += GMT->current.proj.central_meridian;
gmt_proj.c:	y -= GMT->current.proj.origin[GMT_Y];
gmt_proj.c:	y *= GMT->current.proj.i_scale[GMT_Y];
gmt_proj.c:	Y = fabs (y * GMT->current.proj.n_i_cy);
gmt_proj.c:	X = proj_robinson_spline (GMT, Y, GMT->current.proj.n_Y, GMT->current.proj.n_X, GMT->current.proj.n_yx_coeff);
gmt_proj.c:	x = GMT->current.proj.n_cx * X * (GMT->common.R.wesn[XLO] - GMT->current.proj.central_meridian);
gmt_proj.c:	return (x * GMT->current.proj.scale[GMT_X] + GMT->current.proj.origin[GMT_X]);
gmt_proj.c:	y -= GMT->current.proj.origin[GMT_Y];
gmt_proj.c:	y *= GMT->current.proj.i_scale[GMT_Y];
gmt_proj.c:	Y = fabs (y * GMT->current.proj.n_i_cy);
gmt_proj.c:	X = proj_robinson_spline (GMT, Y, GMT->current.proj.n_Y, GMT->current.proj.n_X, GMT->current.proj.n_yx_coeff);
gmt_proj.c:	x = GMT->current.proj.n_cx * X * (GMT->common.R.wesn[XHI] - GMT->current.proj.central_meridian);
gmt_proj.c:	return (x * GMT->current.proj.scale[GMT_X] + GMT->current.proj.origin[GMT_X]);
gmt_proj.c:	y -= GMT->current.proj.origin[GMT_Y];
gmt_proj.c:	y *= GMT->current.proj.i_scale[GMT_Y];
gmt_proj.c:	Y = fabs (y * GMT->current.proj.n_i_cy);
gmt_proj.c:	if (gmt_intpol (GMT, GMT->current.proj.n_Y, GMT->current.proj.n_X, GMT_N_ROBINSON, 1, &Y, &X, GMT->current.setting.interpolant)) {
gmt_proj.c:		GMT_exit (GMT, GMT_PROJECTION_ERROR); return GMT->session.d_NaN;
gmt_proj.c:	x = GMT->current.proj.n_cx * X * (GMT->common.R.wesn[XLO] - GMT->current.proj.central_meridian);
gmt_proj.c:	return (x * GMT->current.proj.scale[GMT_X] + GMT->current.proj.origin[GMT_X]);
gmt_proj.c:	y -= GMT->current.proj.origin[GMT_Y];
gmt_proj.c:	y *= GMT->current.proj.i_scale[GMT_Y];
gmt_proj.c:	Y = fabs (y * GMT->current.proj.n_i_cy);
gmt_proj.c:	if (gmt_intpol (GMT, GMT->current.proj.n_Y, GMT->current.proj.n_X, GMT_N_ROBINSON, 1, &Y, &X, GMT->current.setting.interpolant)) {
gmt_proj.c:		GMT_exit (GMT, GMT_PROJECTION_ERROR); return GMT->session.d_NaN;
gmt_proj.c:	x = GMT->current.proj.n_cx * X * (GMT->common.R.wesn[XHI] - GMT->current.proj.central_meridian);
gmt_proj.c:	return (x * GMT->current.proj.scale[GMT_X] + GMT->current.proj.origin[GMT_X]);
gmt_proj.c:	GMT->current.proj.central_meridian = lon0;
gmt_proj.c:	if (GMT->current.proj.GMT_convert_latitudes) lat = gmt_M_latg_to_lata (GMT, lat);
gmt_proj.c:	*x = GMT->current.proj.EQ_RAD * lon * D2R * cos (lat);
gmt_proj.c:	*y = GMT->current.proj.EQ_RAD * lat;
gmt_proj.c:	*lat = y * GMT->current.proj.i_EQ_RAD;
gmt_proj.c:	*lon = (doubleAlmostEqual (fabs (*lat), M_PI)) ? 0.0 : R2D * x / (GMT->current.proj.EQ_RAD * cos (*lat));
gmt_proj.c:		*lat = *lon = GMT->session.d_NaN;
gmt_proj.c:	*lon += GMT->current.proj.central_meridian;
gmt_proj.c:	if (GMT->current.proj.GMT_convert_latitudes) *lat = gmt_M_lata_to_latg (GMT, *lat);
gmt_proj.c:	y -= GMT->current.proj.origin[GMT_Y];
gmt_proj.c:	y *= GMT->current.proj.i_scale[GMT_Y];
gmt_proj.c:	lat = y * GMT->current.proj.i_EQ_RAD;
gmt_proj.c:	x = GMT->current.proj.EQ_RAD * (GMT->common.R.wesn[XLO] - GMT->current.proj.central_meridian) * D2R * cos (lat);
gmt_proj.c:	return (x * GMT->current.proj.scale[GMT_X] + GMT->current.proj.origin[GMT_X]);
gmt_proj.c:	y -= GMT->current.proj.origin[GMT_Y];
gmt_proj.c:	y *= GMT->current.proj.i_scale[GMT_Y];
gmt_proj.c:	lat = y * GMT->current.proj.i_EQ_RAD;
gmt_proj.c:	x = GMT->current.proj.EQ_RAD * (GMT->common.R.wesn[XHI] - GMT->current.proj.central_meridian) * D2R * cos (lat);
gmt_proj.c:	return (x * GMT->current.proj.scale[GMT_X] + GMT->current.proj.origin[GMT_X]);
gmt_proj.c:	GMT->current.proj.central_meridian = lon0;
gmt_proj.c:	GMT->current.proj.pole = lat0;
gmt_proj.c:	GMT->current.proj.c_p = lat0 * D2R;
gmt_proj.c:	sincos (2.0 * GMT->current.proj.c_p, &s2, &c2);
gmt_proj.c:	e1 = (1.0 - d_sqrt (GMT->current.proj.one_m_ECC2)) / (1.0 + d_sqrt (GMT->current.proj.one_m_ECC2));
gmt_proj.c:	GMT->current.proj.c_c1 = 1.0 - (1.0/4.0) * GMT->current.proj.ECC2 - (3.0/64.0) * GMT->current.proj.ECC4 - (5.0/256.0) * GMT->current.proj.ECC6;
gmt_proj.c:	GMT->current.proj.c_c2 = -((3.0/8.0) * GMT->current.proj.ECC2 + (3.0/32.0) * GMT->current.proj.ECC4 + (25.0/768.0) * GMT->current.proj.ECC6);
gmt_proj.c:	GMT->current.proj.c_c3 = (15.0/128.0) * GMT->current.proj.ECC4 + (45.0/512.0) * GMT->current.proj.ECC6;
gmt_proj.c:	GMT->current.proj.c_c4 = -(35.0/768.0) * GMT->current.proj.ECC6;
gmt_proj.c:	GMT->current.proj.c_M0 = GMT->current.proj.EQ_RAD * (GMT->current.proj.c_c1 * GMT->current.proj.c_p + s2 * (GMT->current.proj.c_c2 + c2 * (GMT->current.proj.c_c3 + c2 * GMT->current.proj.c_c4)));
gmt_proj.c:	GMT->current.proj.c_i1 = 1.0 / (GMT->current.proj.EQ_RAD * GMT->current.proj.c_c1);
gmt_proj.c:	GMT->current.proj.c_i2 = (3.0/2.0) * e1 - (29.0/12.0) * pow (e1, 3.0);
gmt_proj.c:	GMT->current.proj.c_i3 = (21.0/8.0) * e1 * e1 - (1537.0/128.0) * pow (e1, 4.0);
gmt_proj.c:	GMT->current.proj.c_i4 = (151.0/24.0) * pow (e1, 3.0);
gmt_proj.c:	GMT->current.proj.c_i5 = (1097.0/64.0) * pow (e1, 4.0);
gmt_proj.c:	M1 = GMT->current.proj.c_M0 + y;
gmt_proj.c:	u1 = M1 * GMT->current.proj.c_i1;
gmt_proj.c:	phi1 = u1 + s * (GMT->current.proj.c_i2 + c * (GMT->current.proj.c_i3 + c * (GMT->current.proj.c_i4 + c * GMT->current.proj.c_i5)));
gmt_proj.c:		*lon = GMT->current.proj.central_meridian;
gmt_proj.c:		S2 = 1.0 - GMT->current.proj.ECC2 * s * s;
gmt_proj.c:		N1 = GMT->current.proj.EQ_RAD / sqrt (S2);
gmt_proj.c:		R_1 = GMT->current.proj.EQ_RAD * GMT->current.proj.one_m_ECC2 / pow (S2, 1.5);
gmt_proj.c:		*lon = GMT->current.proj.central_meridian + R2D * (D - T1 * D3 / 3.0 + (1.0 + 3.0 * T1) * T1 * D3 * D2 / 15.0) / c;
gmt_proj.c:		*x = GMT->current.proj.EQ_RAD * lon * D2R;
gmt_proj.c:		*y = -GMT->current.proj.EQ_RAD * GMT->current.proj.c_p;
gmt_proj.c:	*x = GMT->current.proj.EQ_RAD * d_asin (clat * slon);
gmt_proj.c:	*y = GMT->current.proj.EQ_RAD * (atan (tlat / clon) - GMT->current.proj.c_p);
gmt_proj.c:	x *= GMT->current.proj.i_EQ_RAD;
gmt_proj.c:	D = y * GMT->current.proj.i_EQ_RAD + GMT->current.proj.c_p;
gmt_proj.c:	*lon = GMT->current.proj.central_meridian + atand (tx / cD);
gmt_proj.c:	GMT->current.proj.central_meridian = lon0;
gmt_proj.c:	GMT->current.proj.north_pole = (GMT->common.R.wesn[YHI] > 0.0 && (GMT->common.R.wesn[YLO] >= 0.0 || (-GMT->common.R.wesn[YLO]) < GMT->common.R.wesn[YHI]));
gmt_proj.c:	GMT->current.proj.pole = (GMT->current.proj.north_pole) ? 90.0 : -90.0;
gmt_proj.c:	m1 = c1 * c1 / (1.0 - GMT->current.proj.ECC2 * s1 * s1);	/* Actually m1 and m2 squared */
gmt_proj.c:	m2 = c2 * c2 / (1.0 - GMT->current.proj.ECC2 * s2 * s2);
gmt_proj.c:	q0 = (GMT_PROJ_IS_ZERO (GMT->current.proj.ECC)) ? 2.0 * s0 : GMT->current.proj.one_m_ECC2 * (s0 / (1.0 - GMT->current.proj.ECC2 * s0 * s0) - GMT->current.proj.i_half_ECC * log ((1.0 - GMT->current.proj.ECC * s0) / (1.0 + GMT->current.proj.ECC * s0)));
gmt_proj.c:	q1 = (GMT_PROJ_IS_ZERO (GMT->current.proj.ECC)) ? 2.0 * s1 : GMT->current.proj.one_m_ECC2 * (s1 / (1.0 - GMT->current.proj.ECC2 * s1 * s1) - GMT->current.proj.i_half_ECC * log ((1.0 - GMT->current.proj.ECC * s1) / (1.0 + GMT->current.proj.ECC * s1)));
gmt_proj.c:	q2 = (GMT_PROJ_IS_ZERO (GMT->current.proj.ECC)) ? 2.0 * s2 : GMT->current.proj.one_m_ECC2 * (s2 / (1.0 - GMT->current.proj.ECC2 * s2 * s2) - GMT->current.proj.i_half_ECC * log ((1.0 - GMT->current.proj.ECC * s2) / (1.0 + GMT->current.proj.ECC * s2)));
gmt_proj.c:	GMT->current.proj.a_n = (doubleAlmostEqualZero (ph1, ph2)) ? s1 : (m1 - m2) / (q2 - q1);
gmt_proj.c:	GMT->current.proj.a_i_n = 1.0 / GMT->current.proj.a_n;
gmt_proj.c:	GMT->current.proj.a_C = m1 + GMT->current.proj.a_n * q1;
gmt_proj.c:	GMT->current.proj.a_rho0 = GMT->current.proj.EQ_RAD * sqrt (GMT->current.proj.a_C - GMT->current.proj.a_n * q0) * GMT->current.proj.a_i_n;
gmt_proj.c:	GMT->current.proj.a_n2ir2 = (GMT->current.proj.a_n * GMT->current.proj.a_n) / (GMT->current.proj.EQ_RAD * GMT->current.proj.EQ_RAD);
gmt_proj.c:	GMT->current.proj.a_test = 1.0 - (GMT->current.proj.i_half_ECC * GMT->current.proj.one_m_ECC2) * log ((1.0 - GMT->current.proj.ECC) / (1.0 + GMT->current.proj.ECC));
gmt_proj.c:	GMT->current.proj.central_meridian = lon0;
gmt_proj.c:	GMT->current.proj.north_pole = (GMT->common.R.wesn[YHI] > 0.0 && (GMT->common.R.wesn[YLO] >= 0.0 || (-GMT->common.R.wesn[YLO]) < GMT->common.R.wesn[YHI]));
gmt_proj.c:	GMT->current.proj.pole = (GMT->current.proj.north_pole) ? 90.0 : -90.0;
gmt_proj.c:	GMT->current.proj.a_n = 0.5 * (s1 + sind (ph2));
gmt_proj.c:	GMT->current.proj.a_i_n = 1.0 / GMT->current.proj.a_n;
gmt_proj.c:	GMT->current.proj.a_C = c1 * c1 + 2.0 * GMT->current.proj.a_n * s1;
gmt_proj.c:	GMT->current.proj.a_rho0 = GMT->current.proj.EQ_RAD * sqrt (GMT->current.proj.a_C - 2.0 * GMT->current.proj.a_n * sind (lat0)) * GMT->current.proj.a_i_n;
gmt_proj.c:	GMT->current.proj.a_n2ir2 = 0.5 * GMT->current.proj.a_n / (GMT->current.proj.EQ_RAD * GMT->current.proj.EQ_RAD);
gmt_proj.c:	GMT->current.proj.a_Cin = 0.5 * GMT->current.proj.a_C / GMT->current.proj.a_n;
gmt_proj.c:	if (GMT_PROJ_IS_ZERO (GMT->current.proj.ECC))
gmt_proj.c:		r = GMT->current.proj.ECC * s;
gmt_proj.c:		q = GMT->current.proj.one_m_ECC2 * (s / (1.0 - GMT->current.proj.ECC2 * s * s) - GMT->current.proj.i_half_ECC * log ((1.0 - r) / (1.0 + r)));
gmt_proj.c:	theta = GMT->current.proj.a_n * lon * D2R;
gmt_proj.c:	rho = GMT->current.proj.EQ_RAD * sqrt (GMT->current.proj.a_C - GMT->current.proj.a_n * q) * GMT->current.proj.a_i_n;
gmt_proj.c:	*y = GMT->current.proj.a_rho0 - rho * c;
gmt_proj.c:	theta = (GMT->current.proj.a_n < 0.0) ? d_atan2 (-x, y - GMT->current.proj.a_rho0) : d_atan2 (x, GMT->current.proj.a_rho0 - y);
gmt_proj.c:	rho = hypot (x, GMT->current.proj.a_rho0 - y);
gmt_proj.c:	q = (GMT->current.proj.a_C - rho * rho * GMT->current.proj.a_n2ir2) * GMT->current.proj.a_i_n;
gmt_proj.c:	if (doubleAlmostEqualZero (fabs (q), GMT->current.proj.a_test))
gmt_proj.c:			r = GMT->current.proj.ECC * s;
gmt_proj.c:			ex_1 = 1.0 - GMT->current.proj.ECC2 * s2;
gmt_proj.c:			phi = phi0 + 0.5 * ex_1 * ex_1 * ((q * GMT->current.proj.i_one_m_ECC2) - s / ex_1
gmt_proj.c:				+ GMT->current.proj.i_half_ECC * log ((1 - r) / (1.0 + r))) / c;
gmt_proj.c:	*lon = GMT->current.proj.central_meridian + R2D * theta * GMT->current.proj.a_i_n;
gmt_proj.c:	if (GMT->current.proj.GMT_convert_latitudes) lat = gmt_M_latg_to_lata (GMT, lat);
gmt_proj.c:	theta = GMT->current.proj.a_n * lon * D2R;
gmt_proj.c:	rho = GMT->current.proj.EQ_RAD * sqrt (GMT->current.proj.a_C - 2.0 * GMT->current.proj.a_n * sind (lat)) * GMT->current.proj.a_i_n;
gmt_proj.c:	*y = GMT->current.proj.a_rho0 - rho * c;
gmt_proj.c:	theta = (GMT->current.proj.a_n < 0.0) ? d_atan2 (-x, y - GMT->current.proj.a_rho0) : d_atan2 (x, GMT->current.proj.a_rho0 - y);
gmt_proj.c:	dy = GMT->current.proj.a_rho0 - y;
gmt_proj.c:	A = (x * x + dy * dy) * GMT->current.proj.a_n2ir2;
gmt_proj.c:	*lat = d_asind (GMT->current.proj.a_Cin - A);
gmt_proj.c:	*lon = GMT->current.proj.central_meridian + R2D * theta * GMT->current.proj.a_i_n;
gmt_proj.c:	if (GMT->current.proj.GMT_convert_latitudes) *lat = gmt_M_lata_to_latg (GMT, *lat);
gmt_proj.c:	GMT->current.proj.north_pole = (GMT->common.R.wesn[YHI] > 0.0 && (GMT->common.R.wesn[YLO] >= 0.0 || (-GMT->common.R.wesn[YLO]) < GMT->common.R.wesn[YHI]));
gmt_proj.c:	GMT->current.proj.d_n = (doubleAlmostEqualZero (lat1, lat2)) ? sind (lat1) : (c1 - cosd (lat2)) / (D2R * (lat2 - lat1));
gmt_proj.c:	GMT->current.proj.d_i_n = R2D / GMT->current.proj.d_n;	/* R2D put here instead of in lon for ieconic */
gmt_proj.c:	GMT->current.proj.d_G = (c1 / GMT->current.proj.d_n) + lat1 * D2R;
gmt_proj.c:	GMT->current.proj.d_rho0 = GMT->current.proj.EQ_RAD * (GMT->current.proj.d_G - lat0 * D2R);
gmt_proj.c:	GMT->current.proj.central_meridian = lon0;
gmt_proj.c:	rho = GMT->current.proj.EQ_RAD * (GMT->current.proj.d_G - lat * D2R);
gmt_proj.c:	theta = GMT->current.proj.d_n * lon * D2R;
gmt_proj.c:	*y = GMT->current.proj.d_rho0 - rho * c;
gmt_proj.c:	rho = hypot (x, GMT->current.proj.d_rho0 - y);
gmt_proj.c:	if (GMT->current.proj.d_n < 0.0) rho = -rho;
gmt_proj.c:	theta = (GMT->current.proj.d_n < 0.0) ? d_atan2 (-x, y - GMT->current.proj.d_rho0) : d_atan2 (x, GMT->current.proj.d_rho0 - y);
gmt_proj.c:	*lat = (GMT->current.proj.d_G - rho * GMT->current.proj.i_EQ_RAD) * R2D;
gmt_proj.c:	*lon = GMT->current.proj.central_meridian + theta * GMT->current.proj.d_i_n;
gmt_proj.c:	GMT->current.proj.central_meridian = lon0;
gmt_proj.c:	GMT->current.proj.pole = lat0;
gmt_proj.c:		*x = GMT->current.proj.EQ_RAD * lon * D2R;
gmt_proj.c:		*y = GMT->current.proj.EQ_RAD * (lat - GMT->current.proj.pole) * D2R;
gmt_proj.c:		*x = GMT->current.proj.EQ_RAD * cp * sE;
gmt_proj.c:		*y = GMT->current.proj.EQ_RAD * ((lat - GMT->current.proj.pole) * D2R + cp * (1.0 - cE));
gmt_proj.c:	x *= GMT->current.proj.i_EQ_RAD;
gmt_proj.c:	y *= GMT->current.proj.i_EQ_RAD;
gmt_proj.c:	y += GMT->current.proj.pole * D2R;
gmt_proj.c:		*lat = y * R2D + GMT->current.proj.pole;
gmt_proj.c:		*lon = x * R2D + GMT->current.proj.central_meridian;
gmt_proj.c:		*lon = GMT->current.proj.central_meridian + asind(x * tanp) / sin(phi);
gmt_proj.c:	y -= GMT->current.proj.origin[GMT_Y];
gmt_proj.c:	y *= GMT->current.proj.i_scale[GMT_Y];
gmt_proj.c:	proj_ipolyconic_sub (GMT, y, GMT->common.R.wesn[XLO], &x);
gmt_proj.c:	return (x * GMT->current.proj.scale[GMT_X] + GMT->current.proj.origin[GMT_X]);
gmt_proj.c:	y -= GMT->current.proj.origin[GMT_Y];
gmt_proj.c:	y *= GMT->current.proj.i_scale[GMT_Y];
gmt_proj.c:	proj_ipolyconic_sub (GMT, y, GMT->common.R.wesn[XHI], &x);
gmt_proj.c:	return (x * GMT->current.proj.scale[GMT_X] + GMT->current.proj.origin[GMT_X]);
gmt_regexp.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "gmtlib_regexp_match: PCRE compilation failed at offset %d: %s.\n", erroffset, error);
gmt_regexp.c:				 GMT_Report (GMT->parent, GMT_MSG_NORMAL, "gmtlib_regexp_match: PCRE matching error %d.\n", rc);
gmt_regexp.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "gmtlib_regexp_match: PCRE2 compilation failed at offset %d: %s.\n", erroffset, error);
gmt_regexp.c:				 GMT_Report (GMT->parent, GMT_MSG_NORMAL, "gmtlib_regexp_match: PCRE2 matching error %d.\n", rc);
gmt_regexp.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "gmtlib_regexp_match: POSIX ERE compilation failed: %s\n", err_msg);
gmt_regexp.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "gmtlib_regexp_match: POSIX ERE matching error: %s\n", err_msg); /* Report error. */
gmt_regexp.c:	GMT_Report (GMT->parent, GMT_MSG_NORMAL, "gmtlib_regexp_match: this GMT version was compiled without regular expression support.\n");
gmt_remote.c:			if (len > 3) GMT_Message (GMT->parent, GMT_TIME_NONE, "%s: Download file from the GMT data server [data set size is %s].\n", name, gmt_data_info[k].size);
gmt_remote.c:			GMT_Message (GMT->parent, GMT_TIME_NONE, "%s: %s.\n\n", name, gmt_data_info[k].remark);
gmt_remote.c:				GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Remote file %s: Size is %0.0f bytes\n", URL, filesize);
gmt_remote.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Remote file %s: Curl returned error %d\n", URL, res);
gmt_remote.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Failed to initiate curl - cannot obtain %s\n", url);
gmt_remote.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Failed to set curl option to not verify the peer\n");
gmt_remote.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Failed to set curl option to follow redirects\n");
gmt_remote.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Failed to set curl option to fail for 4xx responses\n");
gmt_remote.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Failed to set curl option to read from %s\n", url);
gmt_remote.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Failed to set curl option to time out after %ld seconds\n", GMT_HASH_TIME_OUT);
gmt_remote.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Failed to set curl output callback function\n");
gmt_remote.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Failed to set curl option to write to %s\n", file);
gmt_remote.c:	GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Downloading file %s ...\n", url);
gmt_remote.c:		GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Unable to download file %s\n", url);
gmt_remote.c:		GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Libcurl Error: %s\n", curl_easy_strerror (curl_err));
gmt_remote.c:			GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "GMT data server may be down - delay checking hash file for 24 hours\n");
gmt_remote.c:			GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "You can turn remote file download off by setting GMT_DATA_SERVER_LIMIT = 0.\n");
gmt_remote.c:				GMT->current.io.hash_refreshed = GMT->current.io.internet_error = true;
gmt_remote.c:	GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Load contents from %s\n", file);
gmt_remote.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "File %s said it has %d records but only found %d - download error???\n", file, *n, k);
gmt_remote.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "File %s will be deleted.  Please try again\n", file);
gmt_remote.c:	if (GMT->current.io.hash_refreshed) return 0;	/* Already been here */
gmt_remote.c:	snprintf (hashpath, PATH_MAX, "%s/server/gmt_hash_server.txt", GMT->session.USERDIR);
gmt_remote.c:		snprintf (serverdir, PATH_MAX, "%s/server", GMT->session.USERDIR);
gmt_remote.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Unable to create GMT server directory : %s\n", serverdir);
gmt_remote.c:		snprintf (url, PATH_MAX, "%s/gmt_hash_server.txt", GMT->session.DATASERVER);
gmt_remote.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Download remote file %s for the first time\n", url);
gmt_remote.c:			GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Failed to get remote file %s\n", url);
gmt_remote.c:			GMT->current.setting.auto_download = GMT_NO_DOWNLOAD;		/* Temporarily turn off auto download in this session only */
gmt_remote.c:			GMT->current.io.internet_error = true;				/* No point trying again */
gmt_remote.c:		GMT->current.io.hash_refreshed = true;	/* Done our job */
gmt_remote.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Local file %s found\n", hashpath);
gmt_remote.c:	GMT->current.io.hash_refreshed = true;	/* Done our job */
gmt_remote.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Unable to get information about %s - abort\n", hashpath);
gmt_remote.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "File %s older than 24 hours, get latest from server.\n", hashpath);
gmt_remote.c:		snprintf (url, PATH_MAX, "%s/gmt_hash_server.txt", GMT->session.DATASERVER);	/* Set remote path to new hash file */
gmt_remote.c:			GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Failed to download %s - Internet troubles?\n", url);
gmt_remote.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Rename %s to %s\n", hashpath, old_hashpath);
gmt_remote.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Failed to rename %s to %s.\n", hashpath, old_hashpath);
gmt_remote.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Rename %s to %s\n", new_hashpath, hashpath);
gmt_remote.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Failed to rename %s to %s.\n", new_hashpath, hashpath);
gmt_remote.c:						GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Server and cache versions of %s have different hash codes - must download new copy.\n", N[n].name);
gmt_remote.c:							GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Could not determine size of file %s.\n", url);
gmt_remote.c:							GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Server and cache versions of %s have different byte sizes (%" PRIuS " versus %" PRIuS ") - must download new copy.\n", N[n].name, N[n].size, (size_t)buf.st_size);
gmt_remote.c:							GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Server and cache versions of %s are identical - no need to download new file.\n", N[n].name);
gmt_remote.c:				GMT_Report (GMT->parent, GMT_MSG_DEBUG, "File %s no longer supported on server - deleting local copy.\n", O[o].name);
gmt_remote.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "File %s less than 24 hours old, refresh is premature.\n", hashpath);
gmt_remote.c:	char *user_dir[3] = {GMT->session.CACHEDIR, GMT->session.USERDIR, NULL};
gmt_remote.c:	if (GMT->current.setting.auto_download == GMT_NO_DOWNLOAD) return 0;   /* Not allowed to use remote copying */
gmt_remote.c:	if (GMT->current.io.internet_error) return 0;   			/* Not able to use remote copying in this session */
gmt_remote.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Grid file %s is not a recognized remote grid\n", file);
gmt_remote.c:		GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Unable to obtain remote file %s\n", file);
gmt_remote.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Unable to create GMT data directory : %s\n", serverdir);
gmt_remote.c:	if (gmt_file_is_srtmtile (GMT->parent, file, &res)) {	/* Select the right sub-dir on the server and cache locally */
gmt_remote.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Unable to create GMT data directory : %s\n", srtmdir);
gmt_remote.c:			GMT_Report (GMT->parent, GMT_MSG_VERBOSE,
gmt_remote.c:		snprintf (url, PATH_MAX, "%s%s/%s", GMT->session.DATASERVER, cache_dir[from], &file[pos]);
gmt_remote.c:	if ((fsize = skip_large_files (GMT, url, GMT->current.setting.url_size_limit))) {
gmt_remote.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "File %s skipped as size [%s] exceeds limit set by GMT_DATA_SERVER_LIMIT [%s]\n", &file[pos], S, gmt_memory_use (GMT->current.setting.url_size_limit, 0));
gmt_remote.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Failed to initiate curl - cannot obtain %s\n", &file[pos]);
gmt_remote.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Failed to set curl option to not verify the peer\n");
gmt_remote.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Failed to set curl option to follow redirects\n");
gmt_remote.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Failed to set curl option to fail for 4xx responses\n");
gmt_remote.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Unable to create GMT data directory : %s\n", local_path);
gmt_remote.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Unable to create GMT data directory : %s\n", user_dir[to]);
gmt_remote.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Failed to set curl option to read from %s\n", url);
gmt_remote.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Failed to set curl output callback function\n");
gmt_remote.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Failed to set curl option to write to %s\n", local_path);
gmt_remote.c:	GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Downloading file %s ...\n", url);
gmt_remote.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Libcurl Error: %s\n", curl_easy_strerror (curl_err));
gmt_remote.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "You can turn remote file download off by setting GMT_DATA_SERVER_LIMIT = 0.\n");
gmt_remote.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Could not even remove file %s\n", local_path);
gmt_remote.c:			GMT->current.io.internet_error = true;	/* Prevent GMT from trying again in this session */
gmt_remote.c:		GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Convert SRTM tile from JPEG2000 to netCDF grid [%s]\n", file);
gmt_remote.c:		if (GMT_Call_Module (GMT->parent, "grdconvert", GMT_MODULE_CMD, cmd) != GMT_NOERROR) {
gmt_remote.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "ERROR - Unable to convert SRTM file %s to compressed netCDF format\n", local_path);
gmt_remote.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Could not even remove file %s\n", local_path);
gmt_remote.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Could not determine size of downloaded file %s\n", &file_name[pos]);
gmt_remote.c:			GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Download complete [Got %s].\n", gmt_memory_use (buf.st_size, 3));
gmt_remote.c:	if (API->GMT->current.setting.run_mode == GMT_MODERN) {	/* Isolation mode is baked in */
gmt_remote.c:		snprintf (srtmlist, PATH_MAX, "%s/=srtm%d.000000", API->GMT->parent->gwf_dir, res);
gmt_remote.c:	double *wesn = (region) ? region : API->GMT->common.R.wesn;	/* Default to -R */
gmt_shore.c:	 * 1. Check in GMT->session.GSHHGDIR
gmt_shore.c:	 *    GMT->session.USERDIR or GMT->session.SHAREDIR[/coast]?
gmt_shore.c:	 * 3. Look in current directory, GMT->session.USERDIR or
gmt_shore.c:	 *    GMT->session.SHAREDIR[/coast] for file "name".
gmt_shore.c:	/* 1. Check in GMT->session.GSHHGDIR */
gmt_shore.c:	if (GMT->session.GSHHGDIR) {
gmt_shore.c:		sprintf (path, "%s/%s%s", GMT->session.GSHHGDIR, stem, ".nc");
gmt_shore.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "1. GSHHG: GSHHGDIR set, trying %s\n", path);
gmt_shore.c:				GMT_Report (GMT->parent, GMT_MSG_DEBUG, "1. GSHHG: OK, could access %s\n", path);
gmt_shore.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "1. GSHHG: Found %s but cannot read it due to wrong permissions\n", path);
gmt_shore.c:			/* remove reference to invalid GMT->session.GSHHGDIR but don't free
gmt_shore.c:			if (reset) GMT->session.GSHHGDIR = NULL;
gmt_shore.c:			GMT_Report (GMT->parent, GMT_MSG_DEBUG, "1. GSHHG: Failure, could not access %s\n", path);
gmt_shore.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "2. GSHHG: coastline.conf found at %s\n", path);
gmt_shore.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "2. GSHHG: Failed to open %s\n", path);
gmt_shore.c:				GMT_Report (GMT->parent, GMT_MSG_DEBUG, "2. GSHHG: Trying %s\n", path);
gmt_shore.c:						/* update invalid GMT->session.GSHHGDIR */
gmt_shore.c:						gmt_M_str_free (GMT->session.GSHHGDIR);
gmt_shore.c:						GMT->session.GSHHGDIR = strdup (dir);
gmt_shore.c:						GMT_Report (GMT->parent, GMT_MSG_DEBUG, "2. GSHHG: OK, could access %s\n", path);
gmt_shore.c:						GMT_Report (GMT->parent, GMT_MSG_NORMAL, "2. GSHHG: Failure, could not access %s\n", path);
gmt_shore.c:						GMT_Report(GMT->parent, GMT_MSG_DEBUG, "2. GSHHG: Found %s but cannot read it due to wrong permissions\n", path);
gmt_shore.c:						GMT_Report (GMT->parent, GMT_MSG_NORMAL, "2. GSHHG: Did not find %s nor ithe older *.cdf version\n", path);
gmt_shore.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "2. GSHHG: Found %s but cannot read it due to wrong permissions\n", path);
gmt_shore.c:	GMT_Report (GMT->parent, GMT_MSG_DEBUG, "3. GSHHG: Trying via sharepath\n");
gmt_shore.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "3. GSHHG: Trying %s\n", path);
gmt_shore.c:				/* update invalid GMT->session.GSHHGDIR */
gmt_shore.c:				snprintf (dir, PATH_MAX, "%s/%s", GMT->session.SHAREDIR, "coast");
gmt_shore.c:				gmt_M_str_free (GMT->session.GSHHGDIR);
gmt_shore.c:				GMT->session.GSHHGDIR = strdup (dir);
gmt_shore.c:				GMT_Report (GMT->parent, GMT_MSG_DEBUG, "3. GSHHG: OK, could access %s\n", path);
gmt_shore.c:				GMT_Report (GMT->parent, GMT_MSG_DEBUG, "3. GSHHG: Failure, could not access %s\n", path);
gmt_shore.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "3. GSHHG: Found %s but cannot read it due to wrong permissions\n", path);
gmt_shore.c:	GMT_Report (GMT->parent, GMT_MSG_DEBUG, "4. GSHHG: Failure, could not access any GSHHG files\n");
gmt_shore.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "GSHHG version %d.%d.%d or newer is "
gmt_shore.c:					GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -A modifier +a: Invalid code %c\n", p[0]);
gmt_shore.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -A modifier +a: Cannot select both g and i\n");
gmt_shore.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -A modifier +a: Cannot select both s and S\n");
gmt_shore.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -A option: No area given\n");
gmt_shore.c:			if (GMT->common.J.active) {	/* Use map scale xxxx as in 1:xxxx */
gmt_shore.c:				double i_scale = 1.0 / (0.0254 * GMT->current.proj.scale[GMT_X]);
gmt_shore.c:			else if (GMT->common.R.active[RSET]) {	/* No scale, based on region only */
gmt_shore.c:				area = (GMT->common.R.wesn[GMT_XHI] - GMT->common.R.wesn[GMT_XLO]) * (GMT->common.R.wesn[GMT_YHI] - GMT->common.R.wesn[GMT_YLO]); /* Squared degrees */
gmt_shore.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "-%c option: Cannot select automatic resolution without -R or -J [Default to low]\n");
gmt_shore.c:			GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "-%c option: Selected resolution -%c%c\n", opt, opt, *res);
gmt_shore.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -%c option: Unknown modifier %c [Defaults to -%cl]\n", opt, *res, opt);
gmt_shore.c:	if (k >= 0 && k != orig) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Resolution %c not available, substituting resolution %c\n", res, type[k]);
gmt_shore.c:	GMT_Report (GMT->parent, GMT_MSG_DEBUG, "NetCDF Library Version: %s\n", nc_inq_libvers());
gmt_shore.c:		GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "GSHHS: Areas not accurate for small lakes and islands.  Consider updating GSHHG.\n");
gmt_shore.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "GSHHS: Unable to determine how polygon areas were stored.\n");
gmt_shore.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "GSHHG with two Antarcticas, read in extra ANT flgs.\n");
gmt_shore.c:			GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Selected ice grounding line as Antarctica coastline\n");
gmt_shore.c:			GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Selected ice front line as Antarctica coastline\n");
gmt_shore.c:			GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Skipping Antarctica coastline entirely\n");
gmt_shore.c:			GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Skipping all coastlines except Antarctica\n");
gmt_shore.c:	while (w > GMT->common.R.wesn[XLO] && GMT->current.map.is_world) w -= 360.0;
gmt_shore.c:	c->leftmost_bin = ((w <= GMT->common.R.wesn[XLO]) && (e > GMT->common.R.wesn[XLO]));
gmt_shore.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "%s resolution shoreline data base not installed\n", shore_resolution[base]);
gmt_shore.c:	GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Extract data from GSHHG version %s\n%s\n%s\n", c.version, c.title, c.source);
gmt_shore.c:		GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Reading GSHHS segments from bin # %5ld\r", c.bins[ind]);
gmt_shore.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "%s [%s resolution shoreline]\n", GMT_strerror(err), shore_resolution[base]);
gmt_shore.c:				S = GMT_Alloc_Segment (GMT->parent, GMT_NO_STRINGS, p[k].n, 2U, NULL, NULL);
gmt_shore.c:	GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Reading GSHHS segments from bin # %5ld\n", c.bins[c.nb-1]);
gmt_shore.c:		if ((*GMT->current.map.will_it_wrap) (GMT, xtmp, ytmp, n, &start)) {	/* Polygon does indeed wrap */
gmt_shore.c:			GMT->current.plot.n = gmt_map_truncate (GMT, xtmp, ytmp, n, start, -1);
gmt_shore.c:			n_use = (unsigned int)gmt_compact_line (GMT, GMT->current.plot.x, GMT->current.plot.y, GMT->current.plot.n, false, 0);
gmt_shore.c:			close = gmt_polygon_is_open (GMT, GMT->current.plot.x, GMT->current.plot.y, n_use);
gmt_shore.c:			gmt_M_memcpy (p[k].lon, GMT->current.plot.x, n_use, double);
gmt_shore.c:			gmt_M_memcpy (p[k].lat, GMT->current.plot.y, n_use, double);
gmt_shore.c:			GMT->current.plot.n = gmt_map_truncate (GMT, xtmp, ytmp, n, start, +1);
gmt_shore.c:			n_use = (unsigned int)gmt_compact_line (GMT, GMT->current.plot.x, GMT->current.plot.y, GMT->current.plot.n, false, 0);
gmt_shore.c:			close = gmt_polygon_is_open (GMT, GMT->current.plot.x, GMT->current.plot.y, n_use);
gmt_shore.c:			gmt_M_memcpy (p[np_new].lon, GMT->current.plot.x, n_use, double);
gmt_shore.c:			gmt_M_memcpy (p[np_new].lat, GMT->current.plot.y, n_use, double);
gmt_shore.c:				GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Antipodal bin # %d not filled!\n", anti_bin);
gmt_shore.c:	 * We assume gmt_init_shore (GMT, Ctrl->D.set, &c, GMT->common.R.wesn, &Ctrl->A.info) has been
gmt_shore.c:	west_border = floor (GMT->common.R.wesn[XLO] / c->bsize) * c->bsize;
gmt_shore.c:	east_border = ceil (GMT->common.R.wesn[XHI]  / c->bsize) * c->bsize;
gmt_shore.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "%s [gmt_shore_level_at_point]\n", GMT_strerror(err));
gmt_sph.c:	GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Call STRIPACK TRMESH subroutine...");
gmt_sph.c:	GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "OK\n");
gmt_sph.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "STRIPACK: Error in TRMESH. The first 3 nodes are collinear.\n");
gmt_sph.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "STRIPACK: Error in TRMESH.  Duplicate nodes encountered.\n");
gmt_sph.c:	GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Call STRIPACK TRLIST subroutine...");
gmt_sph.c:	GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "OK\n");
gmt_sph.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "STRIPACK: Error in TRLIST.\n");
gmt_sph.c:		GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Call STRIPACK CRLIST subroutine...");
gmt_sph.c:		GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "OK\n");
gmt_sph.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "STRIPACK: Error in CRLIST.  IERROR = %" PRId64 ".\n", ierror);
gmt_sph.c:					GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error in INTRC0: I = %d, J = %d, IER = %" PRId64 "\n", row, col, ierror);
gmt_sph.c:		GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "INTRC0: Number of evaluations = %" PRId64 ", number of extrapolations = %" PRId64 "\n", nm, nxp);
gmt_sph.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error in GRADL: K = %" PRId64 " IER = %" PRId64 "\n", k1, ierror);
gmt_sph.c:		GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "GRADL: Average number of nodes used in the least squares fits = %g\n", sum);
gmt_sph.c:					GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error in GETSIG: IER = %" PRId64 "\n", ierror);
gmt_sph.c:				GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "GETSIG: %" PRId64 " tension factors altered;  Max change = %g\n", ierror, dsm);
gmt_sph.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error in UNIF: IER = %" PRId64 "\n", ierror);
gmt_sph.c:		GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE,
gmt_sph.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error in GRADG (iteration %" PRId64 "): IER = %" PRId64 "\n", iter, ierror);
gmt_sph.c:			GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE,
gmt_sph.c:					GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error in GETSIG (iteration %" PRId64 "): ier = %" PRId64 "\n", iter, ierror);
gmt_sph.c:				GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE,
gmt_sph.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error in UNIF: IER = %" PRId64 "\n", ierror);
gmt_sph.c:		GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE,
gmt_sph.c:		GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE,
gmt_sph.c:		GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE,
gmt_sph.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error in SMSURF (iteration %" PRId64 "): IER = %" PRId64 "\n", iter, ierror);
gmt_sph.c:				GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE,
gmt_sph.c:					GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error in GETSIG (iteration %" PRId64 "): IER = %" PRId64 "\n", iter, ierror);
gmt_sph.c:				GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE,
gmt_sph.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error in UNIF: ier = %" PRId64 "\n", ierror);
gmt_sph.c:		GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE,
gmt_stat.c:	GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Ln Gamma:  Bad x (x <= 0).\n");
gmt_stat.c:		*gamser = GMT->session.d_NaN;
gmt_stat.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "x < 0 in gmtstat_gamma_ser(x)\n");
gmt_stat.c:		*gamser = GMT->session.d_NaN;
gmt_stat.c:	GMT_Report (GMT->parent, GMT_MSG_NORMAL, "a too large, ITMAX too small in gmtstat_gamma_ser(x)\n");
gmt_stat.c:		*gln = GMT->session.d_NaN;
gmt_stat.c:	GMT_Report (GMT->parent, GMT_MSG_NORMAL, "a too large, ITMAX too small in gmtstat_gamma_cf(x)\n");
gmt_stat.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Invalid arguments to GMT_gammaq\n");
gmt_stat.c:		return (GMT->session.d_NaN);
gmt_stat.c:	if (m == ITMAX) GMT_Report (GMT->parent, GMT_MSG_NORMAL, "gmtstat_cf_beta:  A or B too big, or ITMAX too small.\n");
gmt_stat.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "gmtstat_inc_beta:  Bad a (a <= 0).\n");
gmt_stat.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "gmtstat_inc_beta:  Bad b (b <= 0).\n");
gmt_stat.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "gmtstat_inc_beta:  Bad x (x < 0).\n");
gmt_stat.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "gmtstat_inc_beta:  Bad x (x > 1).\n");
gmt_stat.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "gmtstat_f_q:  Bad argument(s).\n");
gmt_stat.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "gmtstat_f_q:  Trouble in gmtstat_inc_beta call.\n");
gmt_stat.c:		*prob = GMT->session.d_NaN;
gmt_stat.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "gmtstat_f_test_new: Bad argument(s).\n");
gmt_stat.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "n < 0 in gmtstat_factln(n)\n");
gmt_stat.c:		return (GMT->session.d_NaN);
gmt_stat.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "gmtstat_f_test:  Chi-Square One <= 0.0\n");
gmt_stat.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "gmtstat_f_test:  Chi-Square Two <= 0.0\n");
gmt_stat.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "gmtstat_f_test:  Trouble on 1st gmtstat_inc_beta call.\n");
gmt_stat.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "gmtstat_f_test:  Trouble on 2nd gmtstat_inc_beta call.\n");
gmt_stat.c:	This function sets *prob = GMT->session.d_NaN and returns (-1)
gmt_stat.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "gmtstat_student_t_a:  Bad argument(s).\n");
gmt_stat.c:		*prob = GMT->session.d_NaN;
gmt_stat.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "x <= 0 in gmt_ker(x)\n");
gmt_stat.c:		return (GMT->session.d_NaN);
gmt_stat.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "x < 0 in gmt_kei(x)\n");
gmt_stat.c:		return (GMT->session.d_NaN);
gmt_stat.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "|x| > 1.0 in gmt_plm\n");
gmt_stat.c:		return (GMT->session.d_NaN);
gmt_stat.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "gmt_plm requires 0 <= m <= l.\n");
gmt_stat.c:		return (GMT->session.d_NaN);
gmt_stat.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "|x| > 1.0 in gmt_plm_bar\n");
gmt_stat.c:		return (GMT->session.d_NaN);
gmt_stat.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "gmt_plm_bar requires 0 <= m <= l.\n");
gmt_stat.c:		return (GMT->session.d_NaN);
gmt_stat.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "|x| > 1.0 in gmt_plm_bar_all\n");
gmt_stat.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "n < 0 in gmt_factorial(n)\n");
gmt_stat.c:		return (GMT->session.d_NaN);
gmt_stat.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "n < 0 or r < 0 or r > n in gmt_permutation(n,r)\n");
gmt_stat.c:		return (GMT->session.d_NaN);
gmt_stat.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "n < 0 or r < 0 or r > n in gmt_combination(n,r)\n");
gmt_stat.c:		return (GMT->session.d_NaN);
gmt_stat.c:	if (x < -GMT_CONV8_LIMIT) return (GMT->session.d_NaN);	/* Tolerate minor slop before we are outside domain */
gmt_stat.c:	if (fy > 1.0) return (GMT->session.d_NaN);	/* Outside domain */
gmt_stat.c:	*std = (m > 1) ? sqrt (sum2 / (m-1.0)) : GMT->session.d_NaN;
gmt_stat.c:	return ((m) ? mean : GMT->session.d_NaN);
gmt_stat.c:	return (m > 1) ? sqrt (sum2 / (((m-1.0) * sumw) / m)) : GMT->session.d_NaN;
gmt_stat.c:		*med = GMT->session.d_NaN;
gmt_stat.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Internal goof in gmt_median; please report to developers!\n");
gmt_stat.c:	if (n == 0) return (GMT->session.d_NaN);	/* No data, so no defined mean */
gmt_stat.c:	if (sum_w == 0.0) return (GMT->session.d_NaN);	/* No weights, so no defined mean */
gmt_stat.c:	if (n == 0) return (GMT->session.d_NaN);	/* No data, so no defined mode */
gmt_stat.c:	if (n == 0) return (GMT->session.d_NaN);	/* No data, so no defined mode */
gmt_stat.c:		*mode_est = GMT->session.d_NaN;
gmt_stat.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "gmt_mode: Array not sorted in non-decreasing order.\n");
gmt_stat.c:		*mode_est = GMT->session.d_NaN;
gmt_stat.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "gmt_mode_f: Array not sorted in non-decreasing order.\n");
gmt_stat.c:		*scale = GMT->session.d_NaN;
gmt_stat.c:		med = GMT->session.d_NaN;
gmt_stat.c:		*scale = GMT->session.d_NaN;
gmt_stat.c:		med = GMT->session.d_NaN;
gmt_stat.c:	double x_select = GMT->session.d_NaN;
gmt_stat.c:	if (n == 0) return (GMT->session.d_NaN);	/* No data, so no defined correlation */
gmt_stat.c:		if (n_use == 0) return (GMT->session.d_NaN);
gmt_stat.c:	if (n == 0) return (GMT->session.d_NaN);	/* No data, so no defined correlation */
gmt_stat.c:		if (n_use == 0) return (GMT->session.d_NaN);
gmt_stat.c:	if (n == 0) return (GMT->session.d_NaN);	/* No data, so no defined quantile */
gmt_stat.c:	if (n == 0) return (GMT->session.d_NaN);	/* No data, so no defined quantile */
gmt_stat.c:			pq[PV_RE] = GMT->session.d_NaN; p_set = true;	/* -inf */
gmt_stat.c:			pq[PV_RE] = GMT->session.d_NaN; p_set = true;	/* -inf */
gmt_stat.c:			pq[PV_RE] = GMT->session.d_NaN; p_set = true;	/* +inf */
gmt_stat.c:			pq[PV_RE] = GMT->session.d_NaN; p_set = true;	/* +inf */
gmt_stat.c:			pq[QV_RE] = GMT->session.d_NaN; q_set = true;
gmt_stat.c:		pq[QV_RE] = GMT->session.d_NaN; q_set = true;
gmt_stat.c:		a[0] = GMT->session.d_NaN;
gmt_stat.c:	return (n == 0 || sum_w == 0.0) ? GMT->session.d_NaN : sum_zw / sum_w;
gmt_stat.c:		std = (n <= 1 || sumw == 0.0) ? GMT->session.d_NaN : sqrt ((n * M2) / (sumw * (n - 1.0)));
gmt_stat.c:		std = (n > 1) ? sqrt (sumw / (n - 1.0)) : GMT->session.d_NaN;
gmt_stat.c:	rms = (sum_w > 0) ? sqrt (sum_z2w / sum_w) : GMT->session.d_NaN;
gmt_stat.c:			wmed = GMT->session.f_NaN;
gmt_stat.c:				wmed = GMT->session.d_NaN;
gmt_stat.c:			wmode = GMT->session.d_NaN;
gmt_stat.c:		if (GMT_n_multiples > 0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "%d Multiple modes found in the grid\n", GMT_n_multiples);
gmt_stat.c:				wmode = GMT->session.d_NaN;
gmt_stat.c:		if (GMT_n_multiples > 0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "%d Multiple modes found in the grid\n", GMT_n_multiples);
gmt_stat.c:	double lat, area, f, row_weight, col_weight = 1.0, R2 = pow (0.001 * GMT->current.proj.mean_radius, 2.0);	/* squared mean radius in km */
gmt_stat.c:	GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Compute spherical gridnode areas using %s radius [R = %.12g km] and %s latitudes\n",
gmt_stat.c:		rad[GMT->current.setting.proj_mean_radius], GMT->current.proj.mean_radius, aux[1+GMT->current.setting.proj_aux_latitude/2]);
gmt_stat.c:		lat = gmt_lat_swap (GMT, lat, GMT->current.setting.proj_aux_latitude);	/* Convert to selected auxiliary latitude */
gmt_support.c:						GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Background pixels set to transparent!\n");
gmt_support.c:							GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Background colorizing value %s not recognized!\n", &p[1]);
gmt_support.c:						GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Background pixels set to colors %s\n", gmt_putrgb (GMT, fill->b_rgb));
gmt_support.c:						GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Foreground pixels set to transparent!\n");
gmt_support.c:							GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Foreground colorizing value %s not recognized!\n", &p[1]);
gmt_support.c:						GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Foreground pixels set to colors %s\n", gmt_putrgb (GMT, fill->f_rgb));
gmt_support.c:						GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Pattern dpi %s is negative!\n", &p[1]);
gmt_support.c:					GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Pattern dpi set to %d\n", fill->dpi);
gmt_support.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Pattern image is in file %s\n", fill->pattern);
gmt_support.c:		if ((fill->I = GMT_Read_Data (GMT->parent, GMT_IS_IMAGE, GMT_IS_FILE, GMT_IS_SURFACE, GMT_CONTAINER_AND_DATA, NULL, fill->pattern, NULL)) == NULL) {
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Unable to read image %s, no pattern set\n", fill->pattern);
gmt_support.c:		gmt_set_pad (GMT, GMT->parent->pad); /* Restore to GMT Defaults */
gmt_support.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Pattern number %d selected\n", fill->pattern_no);
gmt_support.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Pattern will be inverted\n");
gmt_support.c:					GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Colorizing value %s not recognized!\n", word);
gmt_support.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Colorizing argument %c not recognized!\n", f);
gmt_support.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Not enough information to determine location of user pattern %s\n", fill.pattern);
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Not enough information to determine location of user pattern %s\n", fill.pattern);
gmt_support.c:	if (!line) { GMT_Report (GMT->parent, GMT_MSG_NORMAL, "No argument given to support_gethsv\n"); GMT_exit (GMT, GMT_PARSE_ERROR); return false; }
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Representation of transparency (%s) not recognized. Using default [0 or opaque].\n", t);
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Colorname %s not recognized!\n", buffer);
gmt_support.c:		for (i = 0; i < GMT->session.n_fonts && strcmp (name, GMT->session.font[i].name); i++);
gmt_support.c:		if (i < GMT->session.n_fonts) ret = i;
gmt_support.c:	for (i = 0; i < GMT->session.n_fonts && strcmp (word, GMT->session.font[i].name); i++);
gmt_support.c:	if (i == GMT->session.n_fonts) return (false);
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Pen name %s not recognized!\n", line);
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_COMPAT, "Pen-style \"a\" is deprecated, use \"dashed\" or \"-\" instead\n");
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Bad pen-style %s\n", line);
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_COMPAT, "Pen-style \"o\" is deprecated, use \"dotted\" or \".\" instead\n");
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Bad pen-style %s\n", line);
gmt_support.c:		unit = gmtlib_unit_lookup (GMT, line[n], GMT->current.setting.proj_length_unit);
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Pen style %s does not contain :<phase>. <phase> set to 0\n", line);
gmt_support.c:			snprintf (tmp, GMT_PEN_LEN, "%g ", (atof (ptr) * GMT->session.u2u[unit][GMT_PT]));
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Pen attributes too long!\n");
gmt_support.c:		P->offset *= GMT->session.u2u[unit][GMT_PT];
gmt_support.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Pen attributes not using just - and . for dashes and dots. Offending character --> %c\n", line[i]);
gmt_support.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Pen attributes contain more than 11 items (limit for PostScript setdash operator)!\n");
gmt_support.c:					GMT_Report (GMT->parent, GMT_MSG_NORMAL, "CPT z unit specification %s was unrecognized (part of file name?) and is ignored.\n", c);
gmt_support.c:				Z->z_unit_to_meter = GMT->current.proj.m_per_unit[Z->z_unit];	/* Converts unit to meters */
gmt_support.c:					GMT_Report (GMT->parent, GMT_MSG_NORMAL, "support_cpt_parse: Modifier +w ignored for output.\n");
gmt_support.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "CPT z unit specification %s was unrecognized (part of file name?) and is ignored.\n", c);
gmt_support.c:	Z->z_unit_to_meter = GMT->current.proj.m_per_unit[u_number];	/* Converts unit to meters */
gmt_support.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Found CPT hinge = %g for slice k = %u!\n", P->hinge, k);
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Input CPT z unit was converted from meters to %s after reading.\n", GMT->current.proj.unit_name[PH->z_unit[GMT_IN]]);
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Input CPT z unit was converted from %s to meters after reading.\n", GMT->current.proj.unit_name[PH->z_unit[GMT_IN]]);
gmt_support.c:				GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Output CPT z unit was converted from %s to meters before writing.\n", GMT->current.proj.unit_name[PH->z_unit[GMT_OUT]]);
gmt_support.c:				GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Output CPT z unit was converted from meters to %s before writing.\n", GMT->current.proj.unit_name[PH->z_unit[GMT_OUT]]);
gmt_support.c:				GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Output CPT z unit was reverted back to %s from meters before writing.\n", GMT->current.proj.unit_name[PH->z_unit[GMT_IN]]);
gmt_support.c:				GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Output CPT z unit was reverted back from meters to %s before writing.\n", GMT->current.proj.unit_name[PH->z_unit[GMT_IN]]);
gmt_support.c:	if (API->GMT->current.setting.run_mode == GMT_CLASSIC) return false;	/* No such thing in classic mode */
gmt_support.c:			if (GMT->current.setting.extrapolate_val[0] == GMT_EXTRAPOLATE_NONE) {
gmt_support.c:				v[i] = GMT->session.d_NaN;
gmt_support.c:			else if (GMT->current.setting.extrapolate_val[0] == GMT_EXTRAPOLATE_CONSTANT) {
gmt_support.c:				v[i] = GMT->current.setting.extrapolate_val[1];
gmt_support.c:	GMT_Destroy_Data (GMT->parent, &(G->X));
gmt_support.c:				*lon = GMT->common.R.wesn[XLO];
gmt_support.c:				*lon = 0.5 * (GMT->common.R.wesn[XLO] + GMT->common.R.wesn[XHI]);
gmt_support.c:				*lon = GMT->common.R.wesn[XHI];
gmt_support.c:				*lat = GMT->common.R.wesn[YLO];
gmt_support.c:				*lat = 0.5 * (GMT->common.R.wesn[YLO] + GMT->common.R.wesn[YHI]);
gmt_support.c:				*lat = GMT->common.R.wesn[YHI];
gmt_support.c:	if (error) GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Unrecognized location code %s\n", code);
gmt_support.c:		double d = (length / GMT->current.map.dist[GMT_MAP_DIST].scale);	/* Convert from chosen unit to meter or degree */
gmt_support.c:		if (!GMT->current.map.dist[GMT_MAP_DIST].arc) d /= GMT->current.proj.DIST_M_PR_DEG;	/* Convert meter to spherical degrees */
gmt_support.c:		double d = (length / GMT->current.map.dist[GMT_MAP_DIST].scale);	/* Convert from chosen unit to meter or degree */
gmt_support.c:		if (!GMT->current.map.dist[GMT_MAP_DIST].arc) d /= GMT->current.proj.DIST_M_PR_DEG;	/* Convert meter to spherical degrees */
gmt_support.c:		double colat = (r / GMT->current.map.dist[GMT_MAP_DIST].scale);	/* Convert from chosen unit to meter or degree */
gmt_support.c:		if (!GMT->current.map.dist[GMT_MAP_DIST].arc) colat /= GMT->current.proj.DIST_M_PR_DEG;	/* Convert meter to spherical degrees */
gmt_support.c:	GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Ave: Label Line angle = %g start/stop = %d/%d atan2d (%g, %g) Label angle = %g\n", L->line_angle, (int)start, (int)stop, sum_xy, sum_x2, L->angle);
gmt_support.c:	GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Vec: Label Line angle = %g start/stop = %d/%d atan2d (%g, %g) Label angle = %g\n", L->line_angle, (int)start, (int)stop, dy, dx, L->angle);
gmt_support.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Automatic label-averaging half_width = %d [n = %d]\n", G->half_width, (int)n);
gmt_support.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Automatic label-averaging half_width = %d [n = %d]\n", G->half_width, (int)n);
gmt_support.c:	if (GMT->current.map.z_periodic) support_setcontjump (z, 2);
gmt_support.c:		if (GMT->current.map.z_periodic) support_setcontjump (z, 5);
gmt_support.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "GMT internal error\n");
gmt_support.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "GMT internal error\n");
gmt_support.c:				gmt_get_format (GMT, this_dist * GMT->session.u2u[GMT_INCH][G->dist_unit], G->unit, NULL, format);
gmt_support.c:				gmt_sprintf_float (GMT, this_label, format, this_dist * GMT->session.u2u[GMT_INCH][G->dist_unit]);
gmt_support.c:				gmt_sprintf_float (GMT, this_label, GMT->current.setting.format_float_map, this_dist * GMT->session.u2u[GMT_INCH][G->dist_unit]);
gmt_support.c:			gmt_sprintf_float (GMT, this_label, GMT->current.setting.format_float_map, this_value_dist);
gmt_support.c:			sprintf (this_label, "%" PRIu64, (GMT->current.io.status & GMT_IO_SEGMENT_HEADER) ? GMT->current.io.seg_no - 1 : GMT->current.io.seg_no);
gmt_support.c:			sprintf (this_label, "%d/%" PRIu64, GMT->current.io.tbl_no, (GMT->current.io.status & GMT_IO_SEGMENT_HEADER) ? GMT->current.io.seg_no - 1 : GMT->current.io.seg_no);
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "GMT internal error\n");
gmt_support.c:			if (gmt_M_is_geographic (GMT, GMT_IN) && GMT->current.map.is_world && fabs (dx) > (width = gmt_half_map_width (GMT, yy[i-1]))) {
gmt_support.c:			if (G->n_label == 0) GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Your -Gd|D option produced no contour labels for z = %g\n", zval);
gmt_support.c:			if (G->n_label == 0) GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Your -Gn|N option produced no contour labels for z = %g\n", zval);
gmt_support.c:			if (G->n_label == 0) GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Your -Gx|X|l|L option produced no contour labels for z = %g\n", zval);
gmt_support.c:			if (G->n_label == 0) GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Your -Gf option produced no contour labels for z = %g\n", zval);
gmt_support.c:		if (gmt_M_is_geographic (GMT, GMT_IN) && GMT->current.map.is_world && fabs (dx) > (width = gmt_half_map_width (GMT, yy[i-1]))) {
gmt_support.c: * spherical polygon S read by GMT_import_table.  Note GMT->current.io.skip_duplicates must be true when the polygon
gmt_support.c:	if (GMT->current.proj.sph_inside) {	/* Assumes these are input polygons */
gmt_support.c:	GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Delaunay triangulation calculated by Jonathan Shewchuk's Triangle [http://www.cs.cmu.edu/~quake/triangle.html]\n");
gmt_support.c:	GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Voronoi partitioning calculated by Jonathan Shewchuk's Triangle [http://www.cs.cmu.edu/~quake/triangle.html]\n");
gmt_support.c:	GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Output from triangulate:\n");
gmt_support.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Edge %8" PRIu64 " Point %8d to %8d normlist = %8g\t%8g\n", i, vorOut.edgelist[k], vorOut.edgelist[k+1], vorOut.normlist[k], vorOut.normlist[k+1]);
gmt_support.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Point %8" PRIu64 " at %g\t%g\n", i, vorOut.pointlist[k], vorOut.pointlist[k+1]);
gmt_support.c:	GMT_Report (GMT->parent, GMT_MSG_DEBUG, "n_vertex = %d n_edge = %d n_inf_rays = %d n_outside = %d\n", n_int_vertex, n_int_edges, n_extra, n_to_clip);
gmt_support.c:	if ((P = GMT_Create_Data (GMT->parent, GMT_IS_DATASET, geometry, 0, dim, NULL, NULL, 0, 0, NULL)) == NULL) {
gmt_support.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Unable to create a data set for support_voronoi_shewchuk\n");
gmt_support.c:				GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Voronoi infinite ray truncated from %g %g to %g %g\n", xe, ye, new_x, wesn[YLO]);
gmt_support.c:				GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Voronoi infinite ray truncated from %g %g to %g %g\n", xe, ye, new_x, wesn[YHI]);
gmt_support.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "After infinite ray and exterior vertex crossing replacements:\n");
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Edge %8" PRIu64 " Point %8d to %8d normlist = %8g\t%8g\n", i, vorOut.edgelist[k], vorOut.edgelist[k+1], vorOut.normlist[k], vorOut.normlist[k+1]);
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Point %8" PRIu64 " at %g\t%g\n", i, vorOut.pointlist[k], vorOut.pointlist[k+1]);
gmt_support.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Before border edges are added:\n");
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Edge %8" PRIu64 " Point %8d to %8d normlist = %8g\t%8g\n", i, vorOut.edgelist[k], vorOut.edgelist[k+1], vorOut.normlist[k], vorOut.normlist[k+1]);
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Point %8" PRIu64 " [%d] at %g\t%g\n", i, point_type[i], vorOut.pointlist[k], vorOut.pointlist[k+1]);
gmt_support.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "\nAfter border edges are added:\n");
gmt_support.c:				GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Edge %8" PRIu64 " Point %8d to %8d normlist = %8g\t%8g\n", i, vorOut.edgelist[k], vorOut.edgelist[k+1], vorOut.normlist[k], vorOut.normlist[k+1]);
gmt_support.c:				GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Edge %8" PRIu64 " Point %8d to %8d\n", i, vorOut.edgelist[k], vorOut.edgelist[k+1]);
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Point %8" PRIu64 " [%d] at %g\t%g\n", i, point_type[i], vorOut.pointlist[k], vorOut.pointlist[k+1]);
gmt_support.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "\nAfter removing unused edges:\n");
gmt_support.c:				GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Edge %8" PRIu64 " Point %8d to %8d normlist = %8g\t%8g\n", i, vorOut.edgelist[k], vorOut.edgelist[k+1], vorOut.normlist[k], vorOut.normlist[k+1]);
gmt_support.c:				GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Edge %8" PRIu64 " Point %8d to %8d\n", i, vorOut.edgelist[k], vorOut.edgelist[k+1]);
gmt_support.c:				S = P->table[0]->segment[seg] = GMT_Alloc_Segment (GMT->parent, GMT_NO_STRINGS, np, 2U, header, P->table[0]->segment[seg]);
gmt_support.c:	GMT_Report (GMT->parent, GMT_MSG_NORMAL, "unavailable: Shewchuk's triangle option was not selected during GMT installation\n");
gmt_support.c:	GMT_Report (GMT->parent, GMT_MSG_NORMAL, "unavailable: Shewchuk's triangle option was not selected during GMT installation\n");
gmt_support.c:	GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Delaunay triangulation calculated by Dave Watson's ACORD [Computers & Geosciences, 8, 97-101, 1982]\n");
gmt_support.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Records %" PRIu64 " and %" PRIu64 " are duplicates!\n", P[i-1].rec, P[i].rec);
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "WARNING: Bug Report Advice for Watson ACORD External Code:\n");
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "The Watson algorithm can fail if there are duplicate (x,y) records.\n");
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "We found %" PRIu64 " duplicate records in your data set.\n", n_duplicates);
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Please remove duplicates and redo your analysis if the results are corrupted.\n");
gmt_support.c:	GMT_Report (GMT->parent, GMT_MSG_NORMAL, "No Voronoi unless you select Shewchuk's triangle option during GMT installation\n");
gmt_support.c:						GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -%c option:  Must specify +c<lon>/<lat> for center [Also note this is obsolete syntax]\n", option);
gmt_support.c:					GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Warning -%c option:  Insert fill attributes now given with panel setting (-F)\n", option);
gmt_support.c:					GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Warning -%c option:  Insert pen attributes now given with panel setting (-F)\n", option);
gmt_support.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Converted %s to %s and %s\n", in_text, text, panel_txt);
gmt_support.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error %c: No argument given\n", option);
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_COMPAT, "Distance unit m is deprecated; use M for statute miles\n");
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -%c option:  Valid distance units are %s\n", option, GMT_LEN_UNITS2_DISPLAY);
gmt_support.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error:  Scale reference point was not accepted\n");
gmt_support.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -%c option:  Latitude where scale should apply is out of range\n", option);
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -%c option:  Scale longitude is out of range\n", option);
gmt_support.c:		ms->origin[GMT_X] = GMT->session.d_NaN;
gmt_support.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -%c option:  Length must be positive\n", option);
gmt_support.c:						GMT_Report (GMT->parent, GMT_MSG_COMPAT, "+f<fill> in map scale is deprecated, use -F panel settings instead\n");
gmt_support.c:						GMT_Report (GMT->parent, GMT_MSG_COMPAT, "+g<fill> in map scale is deprecated, use -F panel settings instead\n");
gmt_support.c:						GMT_Report (GMT->parent, GMT_MSG_COMPAT, "+p<pen> in map scale is deprecated, use -F panel settings instead\n");
gmt_support.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error %c: No argument given\n", option);
gmt_support.c:	strcpy (ms->label[0], GMT->current.language.cardinal_name[2][2]);
gmt_support.c:	strcpy (ms->label[1], GMT->current.language.cardinal_name[2][1]);
gmt_support.c:	strcpy (ms->label[2], GMT->current.language.cardinal_name[2][3]);
gmt_support.c:	strcpy (ms->label[3], GMT->current.language.cardinal_name[2][0]);
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -%c option:  Give annotation interval(s)\n", option);
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -%c option: Labels must be given in format :w,e,s,n:\n", option);
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -%c option: Labels must be given in format :w,e,s,n:\n", option);
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -%c option:  Correct syntax\n", option);
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "\t-%c[f|m][x]<x0>/<y0>/<size>[/<info>][:wesnlabels:][+<gint>[/<mint>]]\n", option);
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -%c option:  Correct syntax\n", option);
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "\t-%c[f|m][x]<x0>/<y0>/<size>[/<info>][:wesnlabels:][+<gint>[/<mint>]]\n", option);
gmt_support.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error:  Map rose reference point was not accepted\n");
gmt_support.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -%c option:  Size must be positive\n", option);
gmt_support.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -%c option:  <kind> must be 1, 2, or 3\n", option);
gmt_support.c:	/* gmt_geo_to_xy (GMT->current.proj.central_meridian, GMT->current.proj.pole, &x0, &y0); */
gmt_support.c:	x0 = GMT->current.proj.c_x0;
gmt_support.c:	y0 = GMT->current.proj.c_y0;
gmt_support.c:	if (GMT->current.proj.north_pole) {
gmt_support.c:	if (GMT->current.proj.projection_GMT == GMT_POLAR && GMT->current.proj.got_azimuths) gmt_M_int_swap (left, right);	/* Because with azimuths we get confused... */
gmt_support.c:	if (GMT->current.proj.projection_GMT == GMT_POLAR && GMT->current.proj.got_elevations) {
gmt_support.c:		if (GMT->current.map.frame.horizontal) {
gmt_support.c:			if (GMT->current.proj.got_elevations && (doubleAlmostEqual (angle, 180.0) || gmt_M_is_zero (angle)))
gmt_support.c:	if (GMT->current.map.frame.horizontal && !(side%2)) *text_angle += 90.0;
gmt_support.c:	if (GMT->current.map.frame.horizontal && !(side%2)) *text_angle += 90.0;
gmt_support.c:	if (type == 0 && GMT->current.setting.map_annot_oblique & GMT_OBL_ANNOT_LON_HORIZONTAL) *text_angle = 0.0;	/* Force horizontal lon annotation */
gmt_support.c:	if (type == 1 && GMT->current.setting.map_annot_oblique & GMT_OBL_ANNOT_LAT_HORIZONTAL) *text_angle = 0.0;	/* Force horizontal lat annotation */
gmt_support.c:			if (GMT->current.map.frame.horizontal)
gmt_support.c:				*justify = (GMT->current.proj.got_elevations) ? 2 : 10;
gmt_support.c:			if (type == 1 && GMT->current.setting.map_annot_oblique & GMT_OBL_ANNOT_LAT_PARALLEL) {
gmt_support.c:			if (GMT->current.map.frame.horizontal)
gmt_support.c:				*justify = (GMT->current.proj.got_elevations) ? 10 : 2;
gmt_support.c:			if (type == 1 && GMT->current.setting.map_annot_oblique & GMT_OBL_ANNOT_LAT_PARALLEL) {
gmt_support.c:	if (GMT->current.map.frame.horizontal) return (true);
gmt_support.c:			ok = (fabs ((*text_angle)) >= GMT->current.setting.map_annot_min_angle);
gmt_support.c:			ok = (fabs ((*text_angle)) <= (90.0 - GMT->current.setting.map_annot_min_angle));
gmt_support.c:	xp = xp * GMT->current.setting.map_line_step + x;
gmt_support.c:	yp = yp * GMT->current.setting.map_line_step + y;
gmt_support.c:	r = hypot (xp - GMT->current.proj.r, yp - GMT->current.proj.r);
gmt_support.c:	inside = (r < GMT->current.proj.r);
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Found EPS macro %s\n", path);
gmt_support.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Could not determine size of EPS macro %s\n", path);
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Could not find either custom symbol or EPS macro %s\n", name);
gmt_support.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Found custom symbol %s\n", path);
gmt_support.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Could not find custom symbol %s\n", &name[pos]);
gmt_support.c:					GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Custom EPS symbol %s has width %g and height %g inches [%s]\n",
gmt_support.c:					GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Custom symbol %s has inconsistent N: <npar> [<types>] declaration\n", &name[pos]);
gmt_support.c:							GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Custom symbol %s has unrecognized <types> declaration in %s\n", &name[pos], flags);
gmt_support.c:					if (OP[k+1] != '=') GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Please use == to indicate equality operator\n");
gmt_support.c:				s->font = GMT->current.setting.font_annot[GMT_PRIMARY];	/* Default font for symbols */
gmt_support.c:									GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Macro code l contains bad +<font> modifier (set to %s)\n", gmt_putfont (GMT, &s->font));
gmt_support.c:								GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Macro code l contains bad modifier +%c\n", p[0]);
gmt_support.c:					GMT_Report (GMT->parent, GMT_MSG_COMPAT, "Warning in macro l: <string>[%%<font>] is deprecated syntax, use +f<font> instead\n");
gmt_support.c:					if (gmt_getfont (GMT, c, &s->font)) GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Custom symbol subcommand l contains bad GMT4-style font information (set to %s)\n", gmt_putfont (GMT, &GMT->current.setting.font_annot[GMT_PRIMARY]));
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Failed to parse symbol commands in file %s\n", file);
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Offending line: %s\n", buffer);
gmt_support.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Code %c Conditional = %d OP = %c negate = %d var = %d/%d/%d do_pen = %d do_fill = %d\n", \
gmt_support.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "EPS symbol %s is a GMT-produced macro\n", head->name);
gmt_support.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error: Dataset does not have at least 2 columns with coordinates\n");
gmt_support.c:	cross_half_width = cross_length / GMT->current.map.dist[GMT_MAP_DIST].scale;	/* Now in meters */
gmt_support.c:	across_ds_radians = D2R * (cross_half_width / GMT->current.proj.DIST_M_PR_DEG) / n_half_cross;	/* Angular change from point to point */
gmt_support.c:	if ((Xout = GMT_Create_Data (GMT->parent, GMT_IS_DATASET, GMT_IS_LINE, 0, dim, NULL, NULL, 0, 0, NULL)) == NULL) return (NULL);	/* An empty dataset of n_tot_cols columns and np_cross rows */
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Process Segment %s [segment %" PRIu64 "] which has %" PRIu64 " crossing profiles\n", Tin->segment[seg]->label, seg, Tin->segment[seg]->n_rows);
gmt_support.c:				GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Working on cross profile %" PRIu64 " [local line orientation = %06.1f]\n", row, orientation);
gmt_support.c:				S = GMT_Alloc_Segment (GMT->parent, GMT_NO_STRINGS, np_cross, n_tot_cols, NULL, NULL);
gmt_support.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error: Dataset does not have at least 2 columns with coordinates\n");
gmt_support.c:	if ((Xout = GMT_Create_Data (GMT->parent, GMT_IS_DATASET, GMT_IS_LINE, 0, dim, NULL, NULL, 0, 0, NULL)) == NULL) return (NULL);	/* An empty dataset of n_tot_cols columns and np_cross rows */
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Process Segment %s [segment %" PRIu64 "] which has %" PRIu64 " crossing profiles\n", Tin->segment[seg]->label, seg, Tin->segment[seg]->n_rows);
gmt_support.c:				GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Working on cross profile %" PRIu64 " [local line orientation = %06.1f]\n", row, orientation);
gmt_support.c:				S = GMT_Alloc_Segment (GMT->parent, GMT_NO_STRINGS, np_cross, n_tot_cols, NULL, NULL);
gmt_support.c:  		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Cannot find/open list file %s\n", file);
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "gmtlib_glob_list: problem with wildcard expansion of (%s), stopping early [%s]\n",
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "called with less than 2 points, return NaNs\n");
gmt_support.c:			*intercept = (m) ? sum_y : GMT->session.d_NaN;	/* Value of single y-point or NaN */
gmt_support.c:			*slope = GMT->session.d_NaN;
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "called with slope = NaN - skipped\n");
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "called with intercept = NaN - skipped\n");
gmt_support.c:	if (GMT->current.proj.projection_GMT != GMT_LINEAR) return;	/* This only applies to Cartesian scaling */
gmt_support.c:	if (!GMT->current.proj.xyz_pos[GMT_X]) {	/* Negative x scale */
gmt_support.c:		if (!GMT->current.proj.xyz_pos[GMT_Y])	/* Negative y-scale too */
gmt_support.c:	else if (!GMT->current.proj.xyz_pos[GMT_Y])	/* Negative y-scale only */
gmt_support.c:	if (GMT->current.proj.projection_GMT != GMT_LINEAR) return;	/* This only applies to Cartesian scaling */
gmt_support.c:	if (!GMT->current.proj.xyz_pos[GMT_X]) {	/* Negative x scale */
gmt_support.c:		if (!GMT->current.proj.xyz_pos[GMT_Y])	/* Negative y-scale too */
gmt_support.c:	else if (!GMT->current.proj.xyz_pos[GMT_Y])	/* Negative y-scale only */
gmt_support.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "gmt_sort_order: Given illegal direction %d\n", dir);
gmt_support.c:	if (!line) { GMT_Report (GMT->parent, GMT_MSG_NORMAL, "No argument given to gmt_getfill\n"); GMT_exit (GMT, GMT_PARSE_ERROR); return false; }
gmt_support.c:	k = gmt_hash_lookup (GMT, Lname, GMT->session.rgb_hashnode, GMT_N_COLOR_NAMES, GMT_N_COLOR_NAMES);
gmt_support.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "No argument given to gmt_getrgb\n");
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Representation of transparency (%s) not recognized. Using default [0 or opaque].\n", line);
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Colorname %s not recognized!\n", buffer);
gmt_support.c:					GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Failed to convert %s to r/g/b\n", &text[i]);
gmt_support.c:	if (k > size) GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Replacement string too long - truncated\n");
gmt_support.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "No argument given to gmt_getfont\n");
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Representation of font outline pen not recognized - ignored.\n");
gmt_support.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Representation of font size not recognised. Using default.\n");
gmt_support.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Representation of font type not recognized. Using default.\n");
gmt_support.c:		gmt_M_rgb_copy (F->fill.rgb, GMT->session.no_rgb);
gmt_support.c:		if (gmt_getfill (GMT, fill, &F->fill)) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Representation of font fill not recognized. Using default.\n");
gmt_support.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Cannot turn off both font fill and font outline.  Reset to font fill.\n");
gmt_support.c:		snprintf (text, GMT_BUFSIZ, "%gp,%s,%s=%s", F->size, GMT->session.font[F->id].name, gmtlib_putfill (GMT, &F->fill), gmt_putpen (GMT, &F->pen));
gmt_support.c:		snprintf (text, GMT_BUFSIZ, "%gp,%s,%s", F->size, GMT->session.font[F->id].name, gmtlib_putfill (GMT, &F->fill));
gmt_support.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Pen modifier found: %s\n", mods);
gmt_support.c:							GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error parsing pen modification +%s\n", p);
gmt_support.c:							GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error parsing vector specifications %s\n", T[END]);
gmt_support.c:					GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Pen modifier (%s) not recognized.\n", p);
gmt_support.c:					GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Pen modifier (%s) not recognized.\n", p);
gmt_support.c:	if (support_getpenwidth (GMT, width, P)) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Representation of pen width (%s) not recognized. Using default.\n", width);
gmt_support.c:	if (gmt_getrgb (GMT, color, P->rgb)) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Representation of pen color (%s) not recognized. Using default.\n", color);
gmt_support.c:	if (support_getpenstyle (GMT, style, P)) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Representation of pen style (%s) not recognized. Using default.\n", style);
gmt_support.c:	if (!line) { GMT_Report (GMT->parent, GMT_MSG_NORMAL, "No argument given to gmt_getinc\n"); return (true); }
gmt_support.c:		GMT->current.io.inc_code[GMT_Y] = GMT->current.io.inc_code[GMT_X];	/* Use exact inc codes for both x and y */
gmt_support.c:	if (GMT->current.io.inc_code[GMT_X] & GMT_INC_IS_NNODES && GMT->current.io.inc_code[GMT_X] & GMT_INC_UNITS) {
gmt_support.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "number of x nodes cannot have units\n");
gmt_support.c:	if (GMT->current.io.inc_code[GMT_Y] & GMT_INC_IS_NNODES && GMT->current.io.inc_code[GMT_Y] & GMT_INC_UNITS) {
gmt_support.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "number of y nodes cannot have units\n");
gmt_support.c:	if (!line) { GMT_Report (GMT->parent, GMT_MSG_NORMAL, "No argument given to gmt_getincn\n"); GMT_exit (GMT, GMT_PARSE_ERROR); return GMT_PARSE_ERROR; }
gmt_support.c:	i = pos = GMT->current.io.inc_code[GMT_X] = GMT->current.io.inc_code[GMT_Y] = 0;
gmt_support.c:			if (i < 2) GMT->current.io.inc_code[i] |= GMT_INC_IS_EXACT;
gmt_support.c:			if (i < 2) GMT->current.io.inc_code[i] |= GMT_INC_IS_EXACT;
gmt_support.c:			if (i < 2) GMT->current.io.inc_code[i] |= GMT_INC_IS_NNODES;
gmt_support.c:			if (i < 2) GMT->current.io.inc_code[i] |= GMT_INC_IS_NNODES;
gmt_support.c:					GMT_Report (GMT->parent, GMT_MSG_COMPAT, "Second interval unit c is deprecated; use s instead\n");
gmt_support.c:				if (i < 2) GMT->current.io.inc_code[i] |= GMT_INC_IS_M;
gmt_support.c:				if (i < 2) GMT->current.io.inc_code[i] |= GMT_INC_IS_FEET;
gmt_support.c:				if (i < 2) GMT->current.io.inc_code[i] |= GMT_INC_IS_KM;
gmt_support.c:				if (i < 2) GMT->current.io.inc_code[i] |= GMT_INC_IS_MILES;
gmt_support.c:				if (i < 2) GMT->current.io.inc_code[i] |= GMT_INC_IS_NMILES;
gmt_support.c:				if (i < 2) GMT->current.io.inc_code[i] |= GMT_INC_IS_SURVEY_FEET;
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Unable to decode %s as a floating point number\n", p);
gmt_support.c:			case 'd': scale[k] = GMT->current.proj.DIST_M_PR_DEG; break;			/* arc degree */
gmt_support.c:			case 'm': scale[k] = GMT->current.proj.DIST_M_PR_DEG * GMT_MIN2DEG; break;	/* arc minutes */
gmt_support.c:			case 's': scale[k] = GMT->current.proj.DIST_M_PR_DEG * GMT_SEC2DEG; break;	/* arc seconds */
gmt_support.c:	if (!line) { GMT_Report (GMT->parent, GMT_MSG_NORMAL, "No argument given to gmt_get_distance\n"); return (-1); }
gmt_support.c:	*dist = GMT->session.d_NaN;
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_COMPAT, "Leading +|- to set distance mode is deprecated; use common option -j instead\n");
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Negative distance given\n");
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_COMPAT, "Unit c is deprecated; use s instead\n");
gmt_support.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Invalid distance unit (%c). Choose among %s\n", (int)copy[last], GMT_LEN_UNITS_DISPLAY);
gmt_support.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Unable to decode %s as a floating point number.\n", &copy[start]);
gmt_support.c:	if (GMT->current.io.inc_code[GMT_X] & GMT_INC_IS_NNODES) {	/* Got n_columns */
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Your number of x-nodes %g is not a valid integer\n", h->inc[GMT_X]);
gmt_support.c:		GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Given n_columns implies x_inc = %g\n", h->inc[GMT_X]);
gmt_support.c:	else if (GMT->current.io.inc_code[GMT_X] & GMT_INC_UNITS) {	/* Got funny units */
gmt_support.c:			switch (GMT->current.io.inc_code[GMT_X] & GMT_INC_UNITS) {
gmt_support.c:			h->inc[GMT_X] *= s / (GMT->current.proj.DIST_M_PR_DEG * cosd (0.5 * (h->wesn[YLO] + h->wesn[YHI])));	/* Latitude scaling of E-W distances */
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Distance to degree conversion implies x_inc = %g\n", h->inc[GMT_X]);
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Cartesian x-increments are unit-less! - unit ignored\n");
gmt_support.c:			GMT->current.io.inc_code[GMT_X] -= (GMT->current.io.inc_code[GMT_X] & GMT_INC_UNITS);
gmt_support.c:	if (!(GMT->current.io.inc_code[GMT_X] & (GMT_INC_IS_NNODES | GMT_INC_IS_EXACT))) {	/* Adjust x_inc to exactly fit west/east */
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Given domain implies x_inc = %g\n", h->inc[GMT_X]);
gmt_support.c:	if (GMT->current.io.inc_code[GMT_X] & GMT_INC_IS_EXACT) {	/* Want to keep x_inc exactly as given; adjust x_max accordingly */
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "x_max adjusted to %g\n", h->wesn[XHI]);
gmt_support.c:	if (GMT->current.io.inc_code[GMT_Y] & GMT_INC_IS_NNODES) {	/* Got n_rows */
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Your number of y-nodes %g is not a valid integer\n", h->inc[GMT_Y]);
gmt_support.c:		GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Given n_rows implies y_inc = %g\n", h->inc[GMT_Y]);
gmt_support.c:	else if (GMT->current.io.inc_code[GMT_Y] & GMT_INC_UNITS) {	/* Got funny units */
gmt_support.c:			switch (GMT->current.io.inc_code[GMT_Y] & GMT_INC_UNITS) {
gmt_support.c:			h->inc[GMT_Y] = (h->inc[GMT_Y] == 0.0) ? h->inc[GMT_X] : h->inc[GMT_Y] * s / GMT->current.proj.DIST_M_PR_DEG;
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Distance to degree conversion implies y_inc = %g\n", h->inc[GMT_Y]);
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Cartesian y-increments are unit-less! - unit ignored\n");
gmt_support.c:			GMT->current.io.inc_code[GMT_Y] -= (GMT->current.io.inc_code[GMT_Y] & GMT_INC_UNITS);
gmt_support.c:	if (!(GMT->current.io.inc_code[GMT_Y] & (GMT_INC_IS_NNODES | GMT_INC_IS_EXACT))) {	/* Adjust y_inc to exactly fit south/north */
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Given domain implies y_inc = %g\n", h->inc[GMT_Y]);
gmt_support.c:	if (GMT->current.io.inc_code[GMT_Y] & GMT_INC_IS_EXACT) {	/* Want to keep y_inc exactly as given; adjust y_max accordingly */
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "y_max adjusted to %g\n", h->wesn[YHI]);
gmt_support.c:	PH->alloc_level = GMT->hidden.func_level;	/* Must be freed at this level. */
gmt_support.c:	PH->id = GMT->parent->unique_var_ID++;		/* Give unique identifier */
gmt_support.c:	GMT->current.setting.color_model = P_to->model = P_from->model;
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Cannot open color palette table %s\n", cpt_file);
gmt_support.c:		if (fp == NULL) fp = GMT->session.std[GMT_IN];	/* Default input */
gmt_support.c:		if (fp == GMT->session.std[GMT_IN])
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Cannot convert file descriptor %d to stream in gmtlib_read_cpt\n", *fd);
gmt_support.c:		if (fd == NULL) fp = GMT->session.std[GMT_IN];	/* Default input */
gmt_support.c:		if (fp == GMT->session.std[GMT_IN])
gmt_support.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Unrecognized source type %d in gmtlib_read_cpt\n", source_type);
gmt_support.c:	GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Reading CPT from %s\n", cpt_file);
gmt_support.c:	color_model = GMT->current.setting.color_model;		/* Save the original setting since it may be modified by settings in the CPT */
gmt_support.c:	/* Also: GMT->current.setting.color_model is used in some rgb_to_xxx functions so it must be set if changed by cpt */
gmt_support.c:		gmt_M_rgb_copy (X->bfn[id].rgb, GMT->current.setting.color_patch[id]);
gmt_support.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Unrecognized COLOR_MODEL in color palette table %s\n", cpt_file);
gmt_support.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Could not parse RANGE [%s] in %s\n", &h[7], cpt_file);
gmt_support.c:		GMT->current.setting.color_model = X->model;
gmt_support.c:			if (GMT->common.h.mode == GMT_COMMENT_IS_RESET) continue;	/* Simplest way to replace headers on output is to ignore them on input */
gmt_support.c:					GMT_Report (GMT->parent, GMT_MSG_NORMAL, "CPT Pattern fill (%s) not understood!\n", T1);
gmt_support.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "z-slice to skip not in [z0 - z1 -] format!\n");
gmt_support.c:			gmt_M_rgb_copy (X->data[n].rgb_low,  GMT->current.setting.ps_page_rgb);	/* If we must paint, use page color */
gmt_support.c:			gmt_M_rgb_copy (X->data[n].rgb_high, GMT->current.setting.ps_page_rgb);
gmt_support.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "CPT Pattern fill (%s) not understood!\n", T1);
gmt_support.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "z-slice with pattern fill not in [z0 pattern z1 -] format!\n");
gmt_support.c:					GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Z-slice with dz = 0\n");
gmt_support.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Cannot decode %s as categorical CPT\n", cpt_file);
gmt_support.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Failed to decode %s\n", cpt_file);
gmt_support.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "CPT %s has no z-slices!\n", cpt_file);
gmt_support.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Z-slice with dz = 0\n");
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Color palette table %s has a gap of size %g between slices %d and %d!\n", cpt_file, -dz, i, i+1);
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Color palette table %s has an overlap of size %g between slices %d and %d\n", cpt_file, dz, i, i+1);
gmt_support.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Must abort due to above errors in %s\n", cpt_file);
gmt_support.c:	if (color_model & GMT_COLORINT) GMT->current.setting.color_model = color_model;
gmt_support.c:	GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Given grid header, select default CPT to be %s\n", GMT->init.cpt[zmode]);
gmt_support.c:	if (GMT->current.setting.run_mode == GMT_CLASSIC) return;
gmt_support.c:	gmtlib_get_cpt_level (GMT->parent, &fig, &subplot, panel, &inset);	/* Determine the cpt level */
gmt_support.c:		snprintf (file, PATH_MAX, "%s/gmt.inset.cpt", GMT->parent->gwf_dir);
gmt_support.c:			snprintf (file, PATH_MAX, "%s/gmt.%d.subplot.cpt", GMT->parent->gwf_dir, fig);
gmt_support.c:			snprintf (file, PATH_MAX, "%s/gmt.%d.panel.%s.cpt", GMT->parent->gwf_dir, fig, panel);
gmt_support.c:		snprintf (file, PATH_MAX, "%s/gmt.%d.cpt", GMT->parent->gwf_dir, fig);
gmt_support.c:		snprintf (file, PATH_MAX, "%s/gmt.cpt", GMT->parent->gwf_dir);
gmt_support.c:	if (GMT_Write_Data (GMT->parent, GMT_IS_PALETTE, GMT_IS_FILE, GMT_IS_NONE, cpt_flags, NULL, file, P) != GMT_NOERROR)
gmt_support.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Unable to save current CPT file to %s !\n", file);
gmt_support.c:		GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Save current CPT file to %s !\n", file);
gmt_support.c:	if (GMT->current.setting.run_mode == GMT_CLASSIC) return NULL;		/* Not available in classic mode */
gmt_support.c:	gmtlib_get_cpt_level (GMT->parent, &fig, &subplot, panel, &inset);	/* Determine the cpt level */
gmt_support.c:		snprintf (path, PATH_MAX, "%s/gmt.inset.cpt", GMT->parent->gwf_dir);
gmt_support.c:			snprintf (path, PATH_MAX, "%s/gmt.%d.panel.%s.cpt", GMT->parent->gwf_dir, fig, panel);
gmt_support.c:			snprintf (path, PATH_MAX, "%s/gmt.%d.subplot.cpt", GMT->parent->gwf_dir, fig);
gmt_support.c:		snprintf (path, PATH_MAX, "%s/gmt.%d.cpt", GMT->parent->gwf_dir, fig);
gmt_support.c:		snprintf (path, PATH_MAX, "%s/gmt.cpt", GMT->parent->gwf_dir);
gmt_support.c:		GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Selected current CPT file %s\n", file);
gmt_support.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "No current CPT file found\n");
gmt_support.c:		P = GMT_Read_Data (GMT->parent, GMT_IS_PALETTE, GMT_IS_FILE, GMT_IS_NONE, GMT_READ_NORMAL|continuous, NULL, file, NULL);
gmt_support.c:	   2. file is NULL and runmode is classic and hence we default to master CPT name GMT->init.cpt[GMT_DEFAULT_CPT] (or a type-specific CPT).
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Passing zmax or zmin == NaN prevents automatic CPT generation!\n");
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Passing max <= zmin prevents automatic CPT generation!\n");
gmt_support.c:			P = GMT_Read_Data (GMT->parent, GMT_IS_PALETTE, GMT_IS_FILE, GMT_IS_NONE, GMT_READ_NORMAL, NULL, current_cpt, NULL);
gmt_support.c:		master = (file && file[0]) ? file : GMT->init.cpt[zmode];	/* Set master CPT prefix */
gmt_support.c:		P = GMT_Read_Data (GMT->parent, GMT_IS_PALETTE, GMT_IS_FILE, GMT_IS_NONE, GMT_READ_NORMAL|GMT_CPT_CONTINUOUS, NULL, master, NULL);
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Auto-stretching CPT file %s to fit data range %g to %g\n", master, zmin, zmax);
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Auto-stretching CPT file %s to fit rounded data range %g to %g\n", master, zmin, zmax);
gmt_support.c:		P = GMT_Read_Data (GMT->parent, GMT_IS_PALETTE, GMT_IS_FILE, GMT_IS_NONE, GMT_READ_NORMAL, NULL, &file[first], NULL);
gmt_support.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "No CPT file or master given?\n");
gmt_support.c:					GMT_Report (GMT->parent, GMT_MSG_NORMAL, "gmt_parse_inv_cpt: Unrecognized mode %c passed!\n", arg[k]);
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_DEBUG, "gmt_stretch_cpt: Passed z_low == z_high but CPT has no explicit range.  No changes made\n");
gmt_support.c:	if ((P = GMT_Create_Data (GMT->parent, GMT_IS_PALETTE, GMT_IS_NONE, 0, dim_nz, NULL, NULL, 0, 0, NULL)) == NULL) return NULL;
gmt_support.c:				GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "CPT resampling caused aliasing - corrected by averaging at boundaries\n");
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Z-slice with dz = 0\n");
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Cannot %s file %s\n", msg2[append], &cpt_file[append]);
gmt_support.c:		if (fp == NULL) fp = GMT->session.std[GMT_OUT];	/* Default destination */
gmt_support.c:		if (fp == GMT->session.std[GMT_OUT])
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Cannot convert file descriptor %d to stream in gmtlib_write_cpt\n", *fd);
gmt_support.c:		if (fd == NULL) fp = GMT->session.std[GMT_OUT];	/* Default destination */
gmt_support.c:		if (fp == GMT->session.std[GMT_OUT])
gmt_support.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Unrecognized source type %d in gmtlib_write_cpt\n", dest_type);
gmt_support.c:	GMT_Report (GMT->parent, GMT_MSG_DEBUG, "%s CPT to %s\n", msg1[append], &cpt_file[append]);
gmt_support.c:		fprintf (fp, GMT->current.setting.format_float_out, P->hinge);
gmt_support.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "gmt_truncate_cpt error: z_low/z_high [%g/%g] is completely outside range of this CPT [%g/%g]!\n",
gmt_support.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "gmt_truncate_cpt error: z_low = %g less than lowest z (%g)\n",
gmt_support.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "gmt_truncate_cpt: z_high = %g larger than highest z (%g)\n",
gmt_support.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "%d: %g to %g. R/G/B %s to %s. idz = %g diff R/G/B = %g/%g/%g\n", n,
gmt_support.c:	GMT->current.setting.color_model = (P->model | GMT_COLORINT);	/* So color interpolation will happen in the color system */
gmt_support.c:		gmt_M_rgb_copy (rgb, GMT->current.setting.ps_page_rgb);
gmt_support.c:		if (GMT->current.setting.color_model == (GMT_HSV | GMT_COLORINT)) {	/* Interpolation in HSV space */
gmt_support.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Requested color lookup via z=<value> but no CPT was given via -A<cpt>\n");
gmt_support.c:	GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Gave z=%g and returned %s\n", z, text);
gmt_support.c:		if (hsv[1] != 0.0) hsv[1] = di * hsv[1] + intensity * GMT->current.setting.color_hsv_max_s;
gmt_support.c:		hsv[2] = di * hsv[2] + intensity * GMT->current.setting.color_hsv_max_v;
gmt_support.c:		if (hsv[1] != 0.0) hsv[1] = di * hsv[1] - intensity * GMT->current.setting.color_hsv_min_s;
gmt_support.c:		hsv[2] = di * hsv[2] - intensity * GMT->current.setting.color_hsv_min_v;
gmt_support.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Need at least 2 x-values\n");
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "x-values are not monotonically increasing/decreasing (at zero-based record %d)!\n", err_flag);
gmt_support.c:	for (i = 0; i < m; i++) v[i] = GMT->session.d_NaN;	/* Initialize all output to NaN */
gmt_support.c:	if (GMT->current.setting.proj_length_unit == GMT_CM) G->label_dist_spacing = 10.0 / 2.54;
gmt_support.c:	G->font_label = GMT->current.setting.font_annot[GMT_PRIMARY];	/* FONT_ANNOT_PRIMARY */
gmt_support.c:	G->dist_unit = GMT->current.setting.proj_length_unit;
gmt_support.c:	G->pen = GMT->current.setting.map_default_pen;
gmt_support.c:	G->line_pen = GMT->current.setting.map_default_pen;
gmt_support.c:	gmt_M_rgb_copy (G->rgb, GMT->current.setting.ps_page_rgb);		/* Default box color is page color [nominally white] */
gmt_support.c:					GMT_Report (GMT->parent, GMT_MSG_COMPAT,
gmt_support.c:						G->dist_unit = gmtlib_unit_lookup (GMT, p[2], GMT->current.setting.proj_length_unit);
gmt_support.c:					GMT_Report (GMT->parent, GMT_MSG_COMPAT, "+s<fontsize> in contour label spec is obsolete, now part of +f<font>\n");
gmt_support.c:					GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -Sq option: The +x modifier is only valid with -SqN2\n");
gmt_support.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Cannot combine +v and +n\n");
gmt_support.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -%c option: Number of labels must exceed zero\n", L->flag);
gmt_support.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -%c option: Minimum label separation cannot be negative\n", L->flag);
gmt_support.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -%c option: Cannot find/read fixed point file %s\n", L->flag, L->file);
gmt_support.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -%c option: Cannot find/read crossing line file %s\n", L->flag, L->file);
gmt_support.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -%c option: Spacing between labels must exceed 0.0\n", L->flag);
gmt_support.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -%c option: Initial label distance fraction must be in 0-1 range\n", L->flag);
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -%c option: Unrecognized modifier %c\n", L->flag, txt[0]);
gmt_support.c:	if (GMT->current.setting.proj_length_unit == GMT_CM) G->symbol_dist_spacing = 10.0 / 2.54;
gmt_support.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "No symbol specified!\n");
gmt_support.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "No symbol size specified!\n");
gmt_support.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -%c option: Number of symbols must exceed zero\n", L->flag);
gmt_support.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -%c option: Minimum symbols separation cannot be negative\n", L->flag);
gmt_support.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -%c option: Cannot find/read fixed point file %s\n", L->file);
gmt_support.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -%c option: Cannot find/read crossing line file %s\n", L->file);
gmt_support.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -%c option: Spacing between symbols must exceed 0.0\n", L->flag);
gmt_support.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -%c option: Initial symbols distance fraction must be in 0-1 range\n", L->flag);
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -%c option: Unrecognized modifier %c\n", L->flag, txt[0]);
gmt_support.c:	if (get_distances) GMT_Report (GMT->parent, GMT_MSG_DEBUG, "gmt_make_profiles: Return distances along track\n");
gmt_support.c:	if ((D = GMT_Create_Data (GMT->parent, GMT_IS_DATASET, GMT_IS_LINE, 0, dim, NULL, NULL, 0, 0, NULL)) == NULL)
gmt_support.c:		S = GMT_Alloc_Segment (GMT->parent, GMT_NO_STRINGS, 2, n_cols, NULL, T->segment[T->n_segments]);	/* n_cols with 2 rows each */
gmt_support.c:									GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Output sampling interval in d exceeds grid interval and may lead to aliasing.\n");
gmt_support.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -%c:  Modifiers +a and +o requires +l<length>\n", option);
gmt_support.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -%c:  Modifies +r requires +i<inc> or +n<np>\n", option);
gmt_support.c:					GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -%c:  z+ option not applicable here\n", option);
gmt_support.c:					GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -%c:  z- option not applicable here\n", option);
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -%c:  Valid coordinate codes are [lcr][bmt] and z[+-]\n", option);
gmt_support.c:				double colat = (r / GMT->current.map.dist[GMT_MAP_DIST].scale);	/* Convert from chosen radius unit to meter or degree */
gmt_support.c:				if (!GMT->current.map.dist[GMT_MAP_DIST].arc) colat /= GMT->current.proj.DIST_M_PR_DEG;	/* Convert meter to spherical degrees */
gmt_support.c:				step = (step / GMT->current.map.dist[GMT_MAP_DIST].scale);	/* Convert from chosen unit to meter or degree */
gmt_support.c:				if (!GMT->current.map.dist[GMT_MAP_DIST].arc) step /= GMT->current.proj.DIST_M_PR_DEG;	/* Convert meter to spherical degrees */
gmt_support.c:		GMT->current.map.dist[GMT_LABEL_DIST].func = GMT->current.map.dist[GMT_CONT_DIST].func;
gmt_support.c:		GMT->current.map.dist[GMT_LABEL_DIST].scale = GMT->current.map.dist[GMT_CONT_DIST].scale;
gmt_support.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -%c:  Map distance options requires a map projection.\n", G->flag);
gmt_support.c:		if ((G->X = GMT_Read_Data (GMT->parent, GMT_IS_DATASET, GMT_IS_FILE, GMT_IS_LINE, GMT_READ_NORMAL, NULL, &G->file[first], NULL)) == NULL) {	/* Failure to read the file */
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -%c:  Crossing file %s does not exist or had no data records\n", G->flag, G->file);
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -%c:  Crossing file %s does not have enough columns or records\n", G->flag, G->file);
gmt_support.c:		if ((error = GMT_Set_Columns (GMT->parent, GMT_IN, 2, GMT_COL_FIX_NO_TEXT))) {
gmt_support.c:		if ((T = GMT_Read_Data (GMT->parent, GMT_IS_DATASET, GMT_IS_FILE, GMT_IS_POINT, GMT_READ_NORMAL, NULL, &G->file[first], NULL)) == NULL) {
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -%c:  Could not open file %s\n", G->flag, G->file);
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Data file %s has only %" PRIu64 " data columns!\n", G->file, T->n_columns);
gmt_support.c:				if (abs (GMT->current.map.this_x_status) > 1 || abs (GMT->current.map.this_y_status) > 1) continue;	/* Outside map region */
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -%c:  Fixed position file %s does not have any data records\n",
gmt_support.c:		if (GMT_Destroy_Data (GMT->parent, &T) != GMT_NOERROR)
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -%c:  Failed to free DATASET allocated to parse %s\n",
gmt_support.c:		G->clearance[GMT_X] = 0.01 * G->clearance[GMT_X] * G->font_label.size * GMT->session.u2u[GMT_PT][GMT_INCH];
gmt_support.c:		G->clearance[GMT_Y] = 0.01 * G->clearance[GMT_Y] * G->font_label.size * GMT->session.u2u[GMT_PT][GMT_INCH];
gmt_support.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -%c:  Labeling option +Lf requires the fixed label location setting\n", G->flag);
gmt_support.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -%c:  Labeling option +Lx requires the crossing lines setting\n", G->flag);
gmt_support.c:		GMT->current.map.dist[GMT_LABEL_DIST].func = GMT->current.map.dist[GMT_CONT_DIST].func;
gmt_support.c:		GMT->current.map.dist[GMT_LABEL_DIST].scale = GMT->current.map.dist[GMT_CONT_DIST].scale;
gmt_support.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -%c:  Map distance options requires a map projection.\n", G->flag);
gmt_support.c:		if ((G->X = GMT_Read_Data (GMT->parent, GMT_IS_DATASET, GMT_IS_FILE, GMT_IS_LINE, GMT_READ_NORMAL, NULL, &G->file[first], NULL)) == NULL) {	/* Failure to read the file */
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -%c:  Crossing file %s does not exist or had no data records\n", G->flag, G->file);
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -%c:  Crossing file %s does not have enough columns or records\n", G->flag, G->file);
gmt_support.c:		if ((error = GMT_Set_Columns (GMT->parent, GMT_IN, 2, GMT_COL_FIX))) {
gmt_support.c:		if ((T = GMT_Read_Data (GMT->parent, GMT_IS_DATASET, GMT_IS_FILE, GMT_IS_POINT, GMT_READ_NORMAL, NULL, &G->file[first], NULL)) == NULL) {
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -%c:  Could not open file %s\n", G->flag, G->file);
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Data file %s has only %" PRIu64 " data columns!\n", G->file, T->n_columns);
gmt_support.c:				if (abs (GMT->current.map.this_x_status) > 1 || abs (GMT->current.map.this_y_status) > 1) continue;	/* Outside map region */
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -%c:  Fixed position file %s does not have any data records\n",
gmt_support.c:		if (GMT_Destroy_Data (GMT->parent, &T) != GMT_NOERROR)
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -%c:  Failed to free DATASET allocated to parse %s\n",
gmt_support.c:	GMT_Destroy_Data (GMT->parent, &(G->X));
gmt_support.c:	S = GMT_Alloc_Segment (GMT->parent, GMT_NO_STRINGS, n, n_cols, NULL, NULL);
gmt_support.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Bad fraftion, error = %g\n", e);
gmt_support.c:	if (GMT->current.plot.substitute_pi) {	/* Want to use pi when close to known multiples of pi. This variable is set per axis in gmt_xy_axis */
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Expanded %s to %s\n", tmp, string);
gmt_support.c:	GMT->current.plot.n_alloc = (GMT->current.plot.n_alloc == 0) ? GMT_CHUNK : (GMT->current.plot.n_alloc << 1);
gmt_support.c:	GMT->current.plot.x = gmt_M_memory (GMT, GMT->current.plot.x, GMT->current.plot.n_alloc, double);
gmt_support.c:	GMT->current.plot.y = gmt_M_memory (GMT, GMT->current.plot.y, GMT->current.plot.n_alloc, double);
gmt_support.c:	GMT->current.plot.pen = gmt_M_memory (GMT, GMT->current.plot.pen, GMT->current.plot.n_alloc, unsigned int);
gmt_support.c:	if (!strcmp (GMT->current.setting.format_float_map, "%.12g")) {	/* Default map format given means auto-detect decimals */
gmt_support.c:		snprintf (text, GMT_BUFSIZ, GMT->current.setting.format_float_map, interval);
gmt_support.c:		strcpy (format, GMT->current.setting.format_float_map);
gmt_support.c:			sprintf (format, "%s%s", GMT->current.setting.format_float_map, text);
gmt_support.c:		for (i = 0, j = -1; j == -1 && i < ((int)strlen(GMT->current.setting.format_float_map) - 1)
gmt_support.c:		                            && GMT->current.setting.format_float_map[i]; i++)
gmt_support.c:			if (GMT->current.setting.format_float_map[i] == '.') j = i;
gmt_support.c:		if (j > -1) ndec = atoi (&GMT->current.setting.format_float_map[j+1]);
gmt_support.c:		strcpy (format, GMT->current.setting.format_float_map);
gmt_support.c:		GMT->current.proj.sph_inside = true;
gmt_support.c:		GMT->current.proj.sph_inside = false;
gmt_support.c:		GMT->current.proj.sph_inside = false;
gmt_support.c:	else if (GMT->current.map.is_world)	/* Here we are dealing with geographic data that has 360 degree range */
gmt_support.c:		GMT->current.proj.sph_inside = true;
gmt_support.c:			GMT->current.proj.sph_inside = true;
gmt_support.c:			GMT->current.proj.sph_inside = false;
gmt_support.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Not enough information given to gmt_set_inside_mode.\n");
gmt_support.c:	GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "A point's inside/outside status w.r.t. polygon(s) will be determined using a %s algorithm.\n", method[GMT->current.proj.sph_inside]);
gmt_support.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "given non-closed polygon\n");
gmt_support.c:	if (GMT->current.io.OGR && (H = SH->next)) {	/* Must check for and skip if inside a hole */
gmt_support.c:	if (GMT->current.setting.triangulate == GMT_TRIANGLE_SHEWCHUK) return (support_delaunay_shewchuk (GMT, x_in, y_in, n, link));
gmt_support.c:	if (GMT->current.setting.triangulate == GMT_TRIANGLE_WATSON)   return (support_delaunay_watson    (GMT, x_in, y_in, n, link));
gmt_support.c:	GMT_Report (GMT->parent, GMT_MSG_NORMAL, "GMT_TRIANGULATE outside possible range! %d\n", GMT->current.setting.triangulate);
gmt_support.c:	if (GMT->current.setting.triangulate == GMT_TRIANGLE_SHEWCHUK) return (support_voronoi_shewchuk (GMT, x_in, y_in, n, wesn, mode));
gmt_support.c:	if (GMT->current.setting.triangulate == GMT_TRIANGLE_WATSON)   return (support_voronoi_watson    (GMT, x_in, y_in, n, wesn, mode));
gmt_support.c:	GMT_Report (GMT->parent, GMT_MSG_NORMAL, "GMT_TRIANGULATE outside possible range! %d\n", GMT->current.setting.triangulate);
gmt_support.c:	if (GMT->current.setting.triangulate == GMT_TRIANGLE_SHEWCHUK) gmt_M_str_free (*link);
gmt_support.c:	if (GMT->current.setting.triangulate == GMT_TRIANGLE_WATSON) gmt_M_free (GMT, *link);
gmt_support.c:	if (GMT->common.n.bc_set) {	/* Override BCs via -n+<BC> */
gmt_support.c:		while (GMT->common.n.BC[i]) {
gmt_support.c:			switch (GMT->common.n.BC[i]) {
gmt_support.c:					if (GMT->common.n.BC[i+1] == 'x') { HH->BC[XLO] = HH->BC[XHI] = GMT_BC_IS_NATURAL; i++; }
gmt_support.c:					else if (GMT->common.n.BC[i+1] == 'y') { HH->BC[YLO] = HH->BC[YHI] = GMT_BC_IS_NATURAL; i++; }
gmt_support.c:					if (GMT->common.n.BC[i+1] == 'x') { HH->BC[XLO] = HH->BC[XHI] = GMT_BC_IS_PERIODIC; HH->nxp = 1; i++; }
gmt_support.c:					else if (GMT->common.n.BC[i+1] == 'y') { HH->BC[YLO] = HH->BC[YHI] = GMT_BC_IS_PERIODIC; HH->nyp = 1; i++; }
gmt_support.c:					GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Cannot parse boundary condition %s\n", GMT->common.n.BC);
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "GMT boundary condition g overrides n[x|y] or p[x|y]\n");
gmt_support.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Longitude range too small; geographic boundary condition changed to natural.\n");
gmt_support.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Grid is considered to have a 360-degree longitude range.\n");
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "x_inc does not divide 180; geographic boundary condition changed to natural.\n");
gmt_support.c:		GMT->common.n.periodic[GMT_X] = true;
gmt_support.c:		GMT->common.n.range[GMT_X] = h->wesn[XHI] - h->wesn[XLO];
gmt_support.c:		GMT->common.n.half_range[GMT_X] = 0.5 * GMT->common.n.range[GMT_X];
gmt_support.c:		GMT->common.n.periodic[GMT_Y] = true;
gmt_support.c:		GMT->common.n.range[GMT_Y] = h->wesn[YHI] - h->wesn[YLO];
gmt_support.c:		GMT->common.n.half_range[GMT_Y] = 0.5 * GMT->common.n.range[GMT_Y];
gmt_support.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Chosen boundary condition for all edges: %s\n", kind[HH->BC[XLO]]);
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Chosen boundary condition for left and right edges: %s\n", kind[HH->BC[XLO]]);
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Chosen boundary condition for left   edge: %s\n", kind[HH->BC[XLO]]);
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Chosen boundary condition for right  edge: %s\n", kind[HH->BC[XHI]]);
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Chosen boundary condition for bottom and top edges: %s\n", kind[HH->BC[YLO]]);
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Chosen boundary condition for bottom edge: %s\n", kind[HH->BC[YLO]]);
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Chosen boundary condition for top    edge: %s\n", kind[HH->BC[YHI]]);
gmt_support.c:	HH->bcr_interpolant = GMT->common.n.interpolant;
gmt_support.c:	HH->bcr_threshold = GMT->common.n.threshold;
gmt_support.c:		GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "All boundaries set via extended data.\n");
gmt_support.c:		GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "requires n_columns,n_rows at least 1.\n");
gmt_support.c:		if (direction == GMT_IN) GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "called with a pad < 2; skipped.\n");
gmt_support.c:			if (bok > 0) GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "%d (of %d) inconsistent grid values at North pole.\n", bok, G->header->n_columns);
gmt_support.c:			if (bok > 0) GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "%d (of %d) inconsistent grid values at South pole.\n", bok, G->header->n_columns);
gmt_support.c:			if (bok > 0) GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "%d (of %d) inconsistent grid values at South and North boundaries for repeated nodes.\n", bok, G->header->n_columns);
gmt_support.c:				GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Set boundary condition for bottom and top edges: %s\n", kind[HH->BC[YLO]]);
gmt_support.c:				GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Set boundary condition for %s edge: %s\n", edge[YLO], kind[HH->BC[YLO]]);
gmt_support.c:				GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Set boundary condition for %s edge: %s\n", edge[YHI], kind[HH->BC[YHI]]);
gmt_support.c:				GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Set boundary condition for all edges: %s\n", kind[HH->BC[XLO]]);
gmt_support.c:				GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Set boundary condition for %s edge: %s\n", edge[i], kind[HH->BC[i]]);
gmt_support.c:		if (bok > 0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "%d (of %d) inconsistent grid values at West and East boundaries for repeated nodes.\n", bok, G->header->n_rows);
gmt_support.c:			if (bok > 0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "%d (of %d) inconsistent grid values at South and North boundaries for repeated nodes.\n", bok, G->header->n_columns);
gmt_support.c:				GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Set boundary condition for bottom and top edges: %s\n", kind[HH->BC[YLO]]);
gmt_support.c:				GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Set boundary condition for %s edge: %s\n", edge[YLO], kind[HH->BC[YLO]]);
gmt_support.c:				GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Set boundary condition for %s edge: %s\n", edge[YHI], kind[HH->BC[YHI]]);
gmt_support.c:				GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Set boundary condition for %s edge: %s\n", edge[YHI], kind[HH->BC[YHI]]);
gmt_support.c:				GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Set boundary condition for %s edge: %s\n", edge[YHI], kind[HH->BC[YHI]]);
gmt_support.c:				GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Set boundary condition for %s edge: %s\n", edge[YLO], kind[HH->BC[YLO]]);
gmt_support.c:				GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Set boundary condition for %s edge: %s\n", edge[YLO], kind[HH->BC[YLO]]);
gmt_support.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "requires n_columns,n_rows at least 1.\n");
gmt_support.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Pad not large enough for BC assignments; no BCs applied\n");
gmt_support.c:			if (bok > 0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Inconsistent image values at North pole.\n");
gmt_support.c:			if (bok > 0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Inconsistent grid values at South pole.\n");
gmt_support.c:				GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Set boundary condition for bottom and top edge: %s\n", kind[HH->BC[YLO]]);
gmt_support.c:				GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Set boundary condition for %s edge: %s\n", edge[YLO], kind[HH->BC[YLO]]);
gmt_support.c:				GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Set boundary condition for %s edge: %s\n", edge[YHI], kind[HH->BC[YHI]]);
gmt_support.c:				GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Set boundary condition for all edges: %s\n", kind[HH->BC[XLO]]);
gmt_support.c:					GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Set boundary condition for %s edge: %s\n", edge[i], kind[HH->BC[i]]);
gmt_support.c:				GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Set boundary condition for bottom and top edge: %s\n", kind[HH->BC[YLO]]);
gmt_support.c:				GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Set boundary condition for %s edge: %s\n", edge[YLO], kind[HH->BC[YLO]]);
gmt_support.c:				GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Set boundary condition for %s edge: %s\n", edge[YHI], kind[HH->BC[YHI]]);
gmt_support.c:				GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Set boundary condition for %s edge: %s\n", edge[YHI], kind[HH->BC[YHI]]);
gmt_support.c:				GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Set boundary condition for %s edge: %s\n", edge[YHI], kind[HH->BC[YHI]]);
gmt_support.c:				GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Set boundary condition for %s edge: %s\n", edge[YLO], kind[HH->BC[YLO]]);
gmt_support.c:				GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Set boundary condition for %s edge: %s\n", edge[YLO], kind[HH->BC[YLO]]);
gmt_support.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error option %c: No argument given\n", option);
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error:  Map inset reference point was not accepted\n");
gmt_support.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -%c option:  No dimensions given to +w modifier\n", option);
gmt_support.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -%c option:  No justification argument given to +j modifier\n", option);
gmt_support.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -%c option:  Failed to parse offset arguments for +o modifier\n", option);
gmt_support.c:			if (GMT->current.setting.run_mode == GMT_MODERN) {	/* Not valid in modern node */
gmt_support.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -%c option:  +s modifier is valid in classic mode only\n", option);
gmt_support.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -%c option:  No filename given to +s modifier\n", option);
gmt_support.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Map inset attributes: justify = %d, dx = %g dy = %g\n", B->justify, B->off[GMT_X], B->off[GMT_Y]);
gmt_support.c:						if (GMT->current.setting.run_mode == GMT_MODERN) {	/* Not valid in modern node */
gmt_support.c:							GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -%c option:  +s modifier is valid in classic mode only\n", option);
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -%c option:  Must specify w/e/s/n or <unit>xmin/xmax/ymin/ymax\n", option);
gmt_support.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error %c: No argument given\n", option);
gmt_support.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error:  Scale reference point was not accepted\n");
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -%c option:  Not allowed for Cartesian projections\n", option);
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -%c option:  No scale [<longitude>/]<latitude> argument given to +c modifier\n", option);
gmt_support.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -%c option:  Failed to parse scale <longitude>/<latitude> for +c modifier\n", option);
gmt_support.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -%c option:  Scale longitude is out of range for +c modifier\n", option);
gmt_support.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -%c option:  Failed to parse scale latitude for +c modifier\n", option);
gmt_support.c:			ms->origin[GMT_X] = GMT->session.d_NaN;	/* Must be set after gmt_map_setup is called */
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -%c option:  Scale latitude is out of range for +c modifier\n", option);
gmt_support.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -%c option:  Scale origin modifier +c[<lon>/]/<lat> is required\n", option);
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -%c option:  No length argument given to +w modifier\n", option);
gmt_support.c:				GMT_Report (GMT->parent, GMT_MSG_COMPAT, "Distance unit m is deprecated; use M for statute miles\n");
gmt_support.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -%c option:  Valid distance units are %s\n", option, GMT_LEN_UNITS2_DISPLAY);
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -%c option:  Length must be positive\n", option);
gmt_support.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -%c option:  Scale length modifier +w<length>[unit] is required\n", option);
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -%c option:  No fancy map scale modifier allowed for Cartesian projections\n", option);
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -%c option:  No vertical scale modifier allowed for geographic projections\n", option);
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -%c option:  No justification argument given to +j modifier\n", option);
gmt_support.c:			double out_offset = GMT->current.setting.map_label_offset + GMT->current.setting.map_frame_width;
gmt_support.c:			double in_offset  = GMT->current.setting.map_label_offset;
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -%c option:  Valid label alignments (+a) are l|r|t|b\n", option);
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -%c option:  Failed to parse offset arguments for +o modifier\n", option);
gmt_support.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error %c: No argument given\n", option);
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -%c option:  Append d for directional and m for magnetic rose\n", option);
gmt_support.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error:  Map rose reference point was not accepted\n");
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -%c option:  No width argument given to +w modifier\n", option);
gmt_support.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -%c option:  Rose dimension modifier +w<length>[unit] is required\n", option);
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -%c option:  Cannot specify +d<info> when -Td is selected\n", option);
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -%c option:  Cannot give both +f and +m\n", option);
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -%c option:  Modifier +f<kind> must be 1, 2, or 3\n", option);
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -%c option:  No justification argument given to +j modifier\n", option);
gmt_support.c:			strcpy (ms->label[0], GMT->current.language.cardinal_name[2][2]);
gmt_support.c:			strcpy (ms->label[1], GMT->current.language.cardinal_name[2][1]);
gmt_support.c:			strcpy (ms->label[2], GMT->current.language.cardinal_name[2][3]);
gmt_support.c:			strcpy (ms->label[3], GMT->current.language.cardinal_name[2][0]);
gmt_support.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -%c option: 4 Labels must be given via modifier +lw,e,s,n\n", option);
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -%c option:  Failed to parse offset arguments for +o modifier\n", option);
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -%c option:  Modifier +t<intervals> expects 3 or 6 intervals\n", option);
gmt_support.c:	if ((n = GMT_Get_Values (GMT->parent, string, par, 2)) < 0) return n;	/* Parsing error */
gmt_support.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Parsing error: Expected two %s\n", kind[mode]);
gmt_support.c:			par[k] *= GMT->session.u2u[GMT->current.setting.proj_length_unit][GMT_INCH];
gmt_support.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "gmt_getpanel: Given a non-null panel pointer!\n");
gmt_support.c:	P->radius = GMT->session.u2u[GMT_PT][GMT_INCH] * GMT_FRAME_RADIUS;	/* 6 pt */
gmt_support.c:	P->pen1 = GMT->current.setting.map_frame_pen;			/* Heavier pen for main outline */
gmt_support.c:	P->pen2 = GMT->current.setting.map_default_pen;			/* Thinner pen for optional inner outline */
gmt_support.c:	P->gap = GMT->session.u2u[GMT_PT][GMT_INCH] * GMT_FRAME_GAP;	/* Default is 2p */
gmt_support.c:	P->padding[XLO] = GMT->session.u2u[GMT_PT][GMT_INCH] * GMT_FRAME_CLEARANCE;	/* Default is 4p */
gmt_support.c:				n = GMT_Get_Values (GMT->parent, &p[1], P->padding, 4);
gmt_support.c:					GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error -%c: Bad number of increment to modifier +%c.\n", option, p[0]);
gmt_support.c:				for (n = 0; n < 4; n++) P->padding[n] *= GMT->session.u2u[GMT->current.setting.proj_length_unit][GMT_INCH];
gmt_support.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Bad mode (%d)\n", mode);
gmt_support.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "gmt_first_modifier: No separation codes given\n");
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Modifier +%c found but not a valid modifier! - ignored\n", string[k]);
gmt_support.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error -%c: Unrecognized modifier +%c\n", option, string[*pos]);
gmt_support.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Unrecognized modifier +%c\n", string[*pos]);
gmt_support.c:				GMT_Report (GMT->parent, GMT_MSG_COMPAT, "Second interval unit c is deprecated; use s instead\n");
gmt_support.c:	GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Malformed justification/position code %s replaced by %s\n", key, def);
gmt_support.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Horizontal text justification not set, defaults to L(eft)\n");
gmt_support.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Vertical text justification not set, defaults to B(ottom)\n");
gmt_support.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "%s appears to be an Absolute Time String: ", item);
gmt_support.c:					GMT_Report (GMT->parent, GMT_MSG_NORMAL, "This is not allowed for a map projection\n");
gmt_support.c:					GMT_Report (GMT->parent, GMT_MSG_NORMAL, "You must specify time data type with option -f.\n");
gmt_support.c:				GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "%s appears to be a Geographical Location String: ", item);
gmt_support.c:				if (GMT->current.proj.projection_GMT == GMT_LINEAR)
gmt_support.c:					GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "You should append d to the -Jx or -JX projection for geographical data.\n");
gmt_support.c:					GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "You should specify geographical data type with option -f.\n");
gmt_support.c:				GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Will proceed assuming geographical input data.\n");
gmt_support.c:				GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "%s appears to be a Geographical Longitude String: ", item);
gmt_support.c:				if (GMT->current.proj.projection_GMT == GMT_LINEAR)
gmt_support.c:					GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "You should append d to the -Jx or -JX projection for geographical data.\n");
gmt_support.c:					GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "You should specify geographical data type with option -f.\n");
gmt_support.c:				GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Will proceed assuming geographical input data.\n");
gmt_support.c:				GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "%s appears to be a Geographical Latitude String: ", item);
gmt_support.c:				if (GMT->current.proj.projection_GMT == GMT_LINEAR)
gmt_support.c:					GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "You should append d to the -Jx or -JX projection for geographical data.\n");
gmt_support.c:					GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "You should specify geographical data type with option -f.\n");
gmt_support.c:				GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Will proceed assuming geographical input data.\n");
gmt_support.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Could not decode %s, return NaN.\n", item);
gmt_support.c:					GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Expected longitude, but %s is a latitude!\n", item);
gmt_support.c:					GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Expected latitude, but %s is a longitude!\n", item);
gmt_support.c:	/* Opens up GMT->init.custom_symbols.lis and displays the list of custom symbols */
gmt_support.c:	/* Open the list in $GMT->session.SHAREDIR */
gmt_support.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Cannot open file %s\n", list);
gmt_support.c:	n = urint (D2R * fabs (dir2 - dir1) * r / GMT->current.setting.map_line_step);
gmt_support.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "nl = 0 in gmt_init_track\n");
gmt_support.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "First line lon range: %g %g  Second line lon range: %g %g\n", amin, amax, bmin, bmax);
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "First geographic line has 360-degree range.  This may fool the Cartesian crossover algorithm\n");
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Second geographic line has 360-degree range.  This may fool the Cartesian crossover algorithm\n");
gmt_support.c:					GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Warning - Two consecutive crossovers appear to be identical, the 2nd one was skipped\n");
gmt_support.c:	if (GMT->current.map.frame.axis[x_or_y_or_z].type != GMT_POW) return (gmtlib_linear_array (GMT, min, max, delta, 0.0, array));
gmt_support.c:		GMT->current.proj.fwd_x (GMT, min, &v0);
gmt_support.c:		GMT->current.proj.fwd_x (GMT, max, &v1);
gmt_support.c:		for (i = 0; i < n; i++) GMT->current.proj.inv_x (GMT, &val[i], val[i]);
gmt_support.c:		GMT->current.proj.fwd_y (GMT, min, &v0);
gmt_support.c:		GMT->current.proj.fwd_y (GMT, max, &v1);
gmt_support.c:		for (i = 0; i < n; i++) GMT->current.proj.inv_y (GMT, &val[i], val[i]);
gmt_support.c:		GMT->current.proj.fwd_z (GMT, min, &v0);
gmt_support.c:		GMT->current.proj.fwd_z (GMT, max, &v1);
gmt_support.c:		for (i = 0; i < n; i++) GMT->current.proj.inv_z (GMT, &val[i], val[i]);
gmt_support.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Invalid side (%d) passed!\n", x_or_y_or_z);
gmt_support.c:	save_coltype = GMT->current.io.col_type[GMT_IN][GMT_X];
gmt_support.c:	save_trailing = GMT->current.io.trailing_text[GMT_IN];
gmt_support.c:	save_max_cols_to_read = GMT->current.io.max_cols_to_read;
gmt_support.c:	GMT->current.io.col_type[GMT_IN][GMT_X] = gmt_M_type (GMT, GMT_IN, A->id);
gmt_support.c:	GMT->current.io.trailing_text[GMT_IN] = true;	/* Since we definitively have that here */
gmt_support.c:	if (!GMT->common.R.oblique)	/* Eliminate items outside rectangular w/e/s/n/z0/z1 bounds */
gmt_support.c:		limit[0] = GMT->common.R.wesn[2*A->id], limit[1] = GMT->common.R.wesn[2*A->id+1];
gmt_support.c:	if ((error = GMT_Set_Columns (GMT->parent, GMT_IN, 1, GMT_COL_FIX)) != GMT_NOERROR) return (1);
gmt_support.c:	if ((D = GMT_Read_Data (GMT->parent, GMT_IS_DATASET, GMT_IS_FILE, GMT_IS_NONE, GMT_READ_NORMAL, NULL, A->file_custom, NULL)) == NULL) {
gmt_support.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Unable to open custom annotation file %s!\n", A->file_custom);
gmt_support.c:		GMT->current.io.col_type[GMT_IN][GMT_X] = save_coltype;
gmt_support.c:	GMT->current.io.col_type[GMT_IN][GMT_X] = save_coltype;
gmt_support.c:	GMT->current.io.trailing_text[GMT_IN] = save_trailing;
gmt_support.c:	GMT->current.io.max_cols_to_read = save_max_cols_to_read;
gmt_support.c:	GMT_Destroy_Data (GMT->parent, &D);
gmt_support.c:	if (GMT->current.map.frame.axis[T->parent].file_custom) {	/* Want custom intervals */
gmt_support.c:		n = gmt_load_custom_annot (GMT, &GMT->current.map.frame.axis[T->parent], (char)tolower((unsigned char) T->type), array, labels);
gmt_support.c:	switch (GMT->current.proj.xyz_projection[T->parent]) {
gmt_support.c:			n = gmtlib_linear_array (GMT, min, max, gmtlib_get_map_interval (GMT, T), GMT->current.map.frame.axis[T->parent].phase, array);
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Invalid projection type (%d) passed!\n", GMT->current.proj.xyz_projection[T->parent]);
gmt_support.c:		if ((stop - start) < (GMT->current.setting.time_interval_fraction * range)) return (true);		/* Sorry, fraction not large enough to annotate */
gmt_support.c:		if ((stop - start) < (GMT->current.setting.time_interval_fraction * range)) return (true);		/* Sorry, fraction not large enough to annotate */
gmt_support.c:	switch (GMT->current.map.frame.axis[T->parent].type) {
gmt_support.c:			if (GMT->current.proj.xyz_projection[T->parent] == GMT_POW)
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Wrong type (%d) passed!\n", GMT->current.map.frame.axis[T->parent].type);
gmt_support.c:	if (!GMT->current.proj.edge[side]) return -1;		/* Side doesn't exist */
gmt_support.c:	if (GMT->current.map.frame.side[side] < GMT_AXIS_ANNOT) return -1;	/* Don't want labels here */
gmt_support.c:	if (GMT->current.map.frame.check_side == true && type != side%2) return -1;
gmt_support.c:	if (GMT->current.setting.map_annot_oblique & GMT_OBL_ANNOT_NORMAL_TICKS && !(side%2)) angle = -90.0;	/* support_get_label_parameters will make this 0 */
gmt_support.c:	set_angle = ((!GMT->common.R.oblique && !(gmt_M_is_azimuthal(GMT) || gmt_M_is_conical(GMT))) || GMT->common.R.oblique);
gmt_support.c:	if (!GMT->common.R.oblique && (GMT->current.proj.projection_GMT == GMT_GENPER || GMT->current.proj.projection_GMT == GMT_GNOMONIC || GMT->current.proj.projection_GMT == GMT_POLYCONIC)) set_angle = true;
gmt_support.c:	if (GMT->current.setting.map_annot_oblique & GMT_OBL_ANNOT_NORMAL_TICKS) *line_angle = (side - 1) * 90.0;
gmt_support.c:	if (set_angle && !GMT->common.R.oblique && GMT->current.proj.projection_GMT == GMT_GNOMONIC) {
gmt_support.c:/* worldmap:	T/F, whatever GMT->current.map.is_world is */
gmt_support.c:	if (GMT->current.plot.calclock.geo.order[1] == -1) do_minutes = false;
gmt_support.c:	if (GMT->current.plot.calclock.geo.order[2] == -1) do_seconds = false;
gmt_support.c:	for (k = n_items = 0; k < 3; k++) if (GMT->current.plot.calclock.geo.order[k] >= 0) n_items++;	/* How many of d, m, and s are requested as integers */
gmt_support.c:		gmt_lon_range_adjust (GMT->current.plot.calclock.geo.range, &val);
gmt_support.c:		if (doubleAlmostEqual (val, 360.0) && worldmap && GMT->current.proj.projection_GMT == GMT_OBLIQUE_MERC)
gmt_support.c:	if (GMT->current.plot.calclock.geo.wesn) {
gmt_support.c:		if (GMT->current.plot.calclock.geo.wesn == 2) strcat (hemi, " ");
gmt_support.c:			switch (GMT->current.plot.calclock.geo.range) {
gmt_support.c:					strcat (hemi, GMT->current.language.cardinal_name[1][1]);
gmt_support.c:					strcat (hemi, GMT->current.language.cardinal_name[2][1]);
gmt_support.c:					if (!(doubleAlmostEqual (val, 180.0) || doubleAlmostEqual (val, -180.0))) strcat (hemi, (val < 0.0) ? GMT->current.language.cardinal_name[1][0] : GMT->current.language.cardinal_name[1][1]);
gmt_support.c:			strcat (hemi, (val < 0.0) ? GMT->current.language.cardinal_name[2][2] : GMT->current.language.cardinal_name[2][3]);
gmt_support.c:	if (GMT->current.plot.calclock.geo.no_sign) val = fabs (val);
gmt_support.c:	type = (GMT->current.plot.calclock.geo.n_sec_decimals > 0) ? 1 : 0;
gmt_support.c:	if (GMT->current.plot.r_theta_annot && lonlat)	/* Special check for the r in r-theta (set in )*/
gmt_support.c:		gmt_sprintf_float (GMT, label, GMT->current.setting.format_float_map, val);
gmt_support.c:	else if (GMT->current.plot.calclock.geo.decimal)
gmt_support.c:		sprintf (label, GMT->current.plot.calclock.geo.x_format, val, hemi);
gmt_support.c:		(void) gmtlib_geo_to_dms (val, n_items, GMT->current.plot.calclock.geo.f_sec_to_int, &d, &m, &s, &m_sec);	/* Break up into d, m, s, and remainder */
gmt_support.c:				sprintf (label, GMT->current.plot.format[level][type], d, hemi);
gmt_support.c:				sprintf (label, GMT->current.plot.format[level][type], d, m_sec, hemi);
gmt_support.c:				sprintf (label, GMT->current.plot.format[level][type], d, m, hemi);
gmt_support.c:				sprintf (label, GMT->current.plot.format[level][type], d, m, m_sec, hemi);
gmt_support.c:				sprintf (label, GMT->current.plot.format[level][type], d, m, s, hemi);
gmt_support.c:				sprintf (label, GMT->current.plot.format[level][type], d, m, s, m_sec, hemi);
gmt_support.c:		if (fabs (fmod (lon1 - GMT->common.R.wesn[XLO] + 360.0, 360.0)) > fabs (fmod (lon1 - GMT->common.R.wesn[XHI] + 360.0, 360.0))) {	/* East */
gmt_support.c:			gmt_geo_to_xy (GMT, GMT->common.R.wesn[XHI], GMT->common.R.wesn[YLO], &x1, &y1);
gmt_support.c:			gmt_geo_to_xy (GMT, GMT->common.R.wesn[XHI], GMT->common.R.wesn[YHI], &x2, &y2);
gmt_support.c:			GMT->current.map.corner = 1;
gmt_support.c:			gmt_geo_to_xy (GMT, GMT->common.R.wesn[XLO], GMT->common.R.wesn[YLO], &x1, &y1);
gmt_support.c:			gmt_geo_to_xy (GMT, GMT->common.R.wesn[XLO], GMT->common.R.wesn[YHI], &x2, &y2);
gmt_support.c:			GMT->current.map.corner = 3;
gmt_support.c:		if (GMT->current.proj.got_azimuths) angle += 180.0;
gmt_support.c:	if (abs (GMT->current.map.prev_x_status) == 2 && abs (GMT->current.map.prev_y_status) == 2)	/* Last point outside */
gmt_support.c:	else if (GMT->current.map.prev_x_status == 0 && GMT->current.map.prev_y_status == 0)		/* Last point inside */
gmt_support.c:		if (abs (GMT->current.map.this_x_status) == 2 && abs (GMT->current.map.this_y_status) == 2)	/* This point outside */
gmt_support.c:		else if (GMT->current.map.this_x_status == 0 && GMT->current.map.this_y_status == 0)		/* This point inside */
gmt_support.c:			if (GMT->current.map.prev_x_status == GMT->current.map.this_x_status)
gmt_support.c:				direction = (GMT->current.map.prev_y_status == 0) ? angle : angle + 180.0;
gmt_support.c:			else if (GMT->current.map.prev_y_status == GMT->current.map.this_y_status)
gmt_support.c:				direction = (GMT->current.map.prev_x_status == 0) ? angle : angle + 180.0;
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "gmt_flip_justify called with incorrect argument (%d)\n", j);
gmt_support.c:	for (i = 0; found == -1 && i < GMT->init.n_custom_symbols; i++) if (!strcmp (name, GMT->init.custom_symbol[i]->name)) found = i;
gmt_support.c:	if (found >= 0) return (GMT->init.custom_symbol[found]);	/* Return a previously loaded symbol */
gmt_support.c:	GMT->init.custom_symbol = gmt_M_memory (GMT, GMT->init.custom_symbol, GMT->init.n_custom_symbols+1, struct GMT_CUSTOM_SYMBOL *);
gmt_support.c:	support_init_custom_symbol (GMT, name, &(GMT->init.custom_symbol[GMT->init.n_custom_symbols]));
gmt_support.c:	return (GMT->init.custom_symbol[GMT->init.n_custom_symbols++]);
gmt_support.c:	if (GMT->init.n_custom_symbols == 0) return;
gmt_support.c:	for (i = 0; i < GMT->init.n_custom_symbols; i++)
gmt_support.c:		gmtlib_free_one_custom_symbol (GMT, GMT->init.custom_symbol[i]);
gmt_support.c:	gmt_M_free (GMT, GMT->init.custom_symbol);
gmt_support.c:	GMT->init.n_custom_symbols = 0;
gmt_support.c:	GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Max node-search half-widths are: half_x = %d, half_y = %d\n", *d_row, *actual_max_d_col);
gmt_support.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Unable to open %s macro file\n", line);
gmt_support.c:	struct GMTAPI_CTRL *API = GMT->parent;
gmt_support.c:		GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Segmentize input data into %" PRIu64 " variable-length segment lines\n", dim[GMT_SEG]);
gmt_support.c:		GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Segmentize input data into %" PRIu64 " 2-point segment lines\n", dim[GMT_SEG]);
gmt_support.c:	if ((D = GMT_Create_Data (GMT->parent, GMT_IS_DATASET, GMT_IS_LINE, 0, dim, NULL, NULL, 0, 0, NULL)) == NULL) {
gmt_support.c:		GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "No need to insert new points at 180\n");
gmt_support.c:		L[seg] = GMT_Alloc_Segment (GMT->parent, smode, length, S->n_columns, S->header, NULL);	/* Allocate array space for coordinates */
gmt_support.c:	 * GMT->session.std[GMT_ERR] the values which are an improvement over the
gmt_support.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Bad mode: %u Must select either 1 or 2\n", mode);
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Could not find/open file: %s\n", &item[k+2]);
gmt_support.c:	GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Number of integer selections returned: %" PRIu64 "\n", n);
gmt_support.c:	if (GMT->current.setting.verbose == GMT_MSG_DEBUG) {
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Selection # %" PRIu64 ": %" PRIu64 "\n", n, select->item[n]);
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Could not find/open file: %s\n", &item[k+2]);
gmt_support.c:	use_proj = (GMT->common.R.oblique || (j == 1 && gmt_M_is_nonlinear_graticule(GMT)));
gmt_support.c:	box = (use_proj) ? GMT->current.proj.rect : GMT->common.R.wesn;
gmt_support.c:		if (!GMT->current.proj.xyz_pos[GMT_X]) i = 4 - i;	/* Negative x-scale, flip left-to-right */
gmt_support.c:		if (!GMT->current.proj.xyz_pos[GMT_Y]) j = 2 - j;	/* Negative y-scale, flip top-to-bottom */
gmt_support.c:	GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Converted code %d to i = %d, j = %d and finally x = %g and y = %g\n", justify, i, j, *x, *y);
gmt_support.c:	//if (!GMT->current.proj.xyz_pos[GMT_X]) i = 4 - i;	/* Negative x-scale, flip left-to-right */
gmt_support.c:	//if (!GMT->current.proj.xyz_pos[GMT_Y]) j = 2 - j;	/* Negative y-scale, flip top-to-bottom */
gmt_support.c:		*x = GMT->current.proj.rect[XLO];
gmt_support.c:		*x = (GMT->current.proj.rect[XLO] + GMT->current.proj.rect[XHI]) / 2;
gmt_support.c:		*x = GMT->current.proj.rect[XHI];
gmt_support.c:		*y = GMT->current.proj.rect[YLO];
gmt_support.c:		*y = (GMT->current.proj.rect[YLO] + GMT->current.proj.rect[YHI]) / 2;
gmt_support.c:		*y = GMT->current.proj.rect[YHI];
gmt_support.c:	GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Converted code %d to i = %d, j = %d and finally x = %g and y = %g\n", justify, i, j, *x, *y);
gmt_support.c:				GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Your -%c option was interpreted to mean -%c%c\n", option, option, kind[mode]);
gmt_support.c:		else if (GMT->common.J.active == false && GMT->common.R.active[RSET] == false)	/* No -R, -J were given so can only mean plot coordinates */
gmt_support.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Your -%c option was interpreted to mean -%c%c\n", option, option, kind[mode]);
gmt_support.c:		if (GMT->common.J.active == false && GMT->common.R.active[RSET] == false) {
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Your -%c%c reference point coordinates require both -R -J to be specified\n", option, kind[mode]);
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Anchor point specified via normalized coordinates: %g, %g\n", A->x, A->y);
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Anchor point specified via plot coordinates (in inches): %g, %g\n", A->x, A->y);
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Anchor point specified via justification code: %s\n", txt_x);
gmt_support.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error -%c: Could not parse geographic coordinates %s and/or %s\n", option, txt_x, txt_y);
gmt_support.c:				GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Anchor point specified via map coordinates: %g, %g\n", A->x, A->y);
gmt_support.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Convert map reference point coordinates from %g, %g to %g, %g\n", A->x, A->y, x, y);
gmt_support.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Convert code inside reference point coordinates from justification %s to %g, %g\n", GMT_just_code[A->justify], A->x, A->y);
gmt_support.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Convert code outside reference point coordinates from justification %s to %g, %g\n", GMT_just_code[A->justify], A->x, A->y);
gmt_support.c:		x = A->x * (2.0 * GMT->current.map.half_width);
gmt_support.c:		y = A->y * GMT->current.map.height;
gmt_support.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Convert normalized reference point coordinates from %g, %g to %g, %g\n", A->x, A->y, x, y);
gmt_support.c:	if (GMT->common.x.active) {
gmt_support.c:		if (GMT->common.x.n_threads < gmtlib_get_num_processors()) {
gmt_support.c:			omp_set_num_threads (GMT->common.x.n_threads);	/* Use requested threads for all consecutive parallel regions */
gmt_support.c:		GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Enable %d threads of %d available\n", GMT->common.x.n_threads, gmtlib_get_num_processors());
gmt_support.c:		GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Enable all available threads (up to %d)\n", gmtlib_get_num_processors());
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error -%c option: Modifier +%c unrecognized\n", option, string[k+1]);
gmt_support.c:	GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Before justify = %d, Dim x = %g y = %g, Reference x = %g y = %g\n",
gmt_support.c:	GMT_Report (GMT->parent, GMT_MSG_DEBUG, "After justify = %d, Offset x = %g y = %g, Reference x = %g y = %g\n",
gmt_support.c:	GMT_Report (GMT->parent, GMT_MSG_DEBUG, "After shifts, Reference x = %g y = %g\n", ref->x, ref->y);
gmt_support.c:	gmt_M_memcpy (GMT->hidden.mem_coord[GMT_X], &x[new[BEG]], new_n, double);
gmt_support.c:	gmt_M_memcpy (GMT->hidden.mem_coord[GMT_Y], &y[new[BEG]], new_n, double);
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error: Unable to parse value %s from list %s\n", p, list);
gmt_support.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -%c: No arguments given\n", option);
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Cannot find/open file %s\n", &argument[first]);
gmt_support.c:			if (!GMT->common.f.active[GMT_OUT]) gmt_set_column (GMT, GMT_OUT, tcol, GMT_IS_ABSTIME);
gmt_support.c:					GMT_Report (GMT->parent, GMT_MSG_NORMAL, "-%cmin/max/inc+ modifier +%s not recognized.\n", option, p);
gmt_support.c:		GMT_Report (GMT->parent, GMT_MSG_COMPAT, "-%cmin/max/inc+ is deprecated; use -%c[<min>/<max>/]<int>[<unit>][+a|n] instead.\n", option, option);
gmt_support.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -%c: Must specify valid min[/max[/inc[<unit>|+n]]] option\n", option);
gmt_support.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -%c: Must specify valid min/max/inc[<unit>|+n] option\n", option);
gmt_support.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -%c: Must specify valid [min/max/]inc[<unit>|+n] option\n", option);
gmt_support.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -%c: Logarithmic array requires an increment argument\n", option);
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -%c: Calendar time not allowed for this module\n", option);
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -%c: Cannot use +n modifier with calendar time data\n", option);
gmt_support.c:		if (!GMT->common.f.active[GMT_OUT]) gmt_set_column (GMT, GMT_OUT, tcol, GMT_IS_ABSTIME);
gmt_support.c:				T->vartime = (strchr (GMT_TIME_VAR_UNITS, GMT->current.setting.time_system.unit) != NULL);
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -%c: Distance units not allowed for this module\n", option);
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -%c: Increment is zero\n", option);
gmt_support.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -%c: Logarithmic increment must be an integer\n", option);
gmt_support.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -%c: Logarithmic increment must be 1, 2, 3 (or a negative integer)\n", option);
gmt_support.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -%c: Unable to parse min temporal value from %s (ISO datetime format required)\n", option, txt[GMT_X]);
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -%c: Unable to parse min value from %s\n", option, txt[GMT_X]);
gmt_support.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -%c: Unable to parse max temporal value from %s\n", option, txt[GMT_Y]);
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -%c: Unable to parse max value from %s (ISO datetime format required)\n", option, txt[GMT_Y]);
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -%c: Cannot specify - as min or max value in this module\n", option);
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -%c: min >= max\n", option);
gmt_support.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -%c: Unable to parse min temporal value from %s (ISO datetime format required)\n", option, txt[GMT_X]);
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -%c: Unable to parse min value from %s\n", option, txt[GMT_X]);
gmt_support.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -%c: Modifier +e only applies when increment is given without any range\n", option);
gmt_support.c:	char unit = GMT->current.setting.time_system.unit;
gmt_support.c:	double scale = GMT->current.setting.time_system.scale, inc = T->inc, t0, t1;
gmt_support.c:		unsigned int save_coltype = GMT->current.io.col_type[GMT_IN][GMT_X];
gmt_support.c:		unsigned int save_trailing = GMT->current.io.trailing_text[GMT_IN];
gmt_support.c:		unsigned int save_max_cols_to_read = GMT->current.io.max_cols_to_read;
gmt_support.c:		if (T->temporal) GMT->current.io.col_type[GMT_IN][GMT_X] = GMT_IS_ABSTIME;
gmt_support.c:		GMT->current.io.record_type[GMT_IN] = GMT_READ_NORMAL;
gmt_support.c:		GMT->current.io.trailing_text[GMT_IN] = false;
gmt_support.c:		if ((error = GMT_Set_Columns (GMT->parent, GMT_IN, 1, GMT_COL_FIX_NO_TEXT)) != GMT_NOERROR) return (GMT_PARSE_ERROR);
gmt_support.c:		if ((D = GMT_Read_Data (GMT->parent, GMT_IS_DATASET, GMT_IS_FILE, GMT_IS_NONE, GMT_READ_NORMAL, NULL, T->file, NULL)) == NULL) {
gmt_support.c:		GMT->current.io.col_type[GMT_IN][GMT_X] = save_coltype;
gmt_support.c:		GMT->current.io.trailing_text[GMT_IN] = save_trailing;
gmt_support.c:		GMT->current.io.max_cols_to_read = save_max_cols_to_read;
gmt_support.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -%c: File %s has more than one segment\n", option, T->file);
gmt_support.c:			GMT_Destroy_Data (GMT->parent, &D);
gmt_support.c:		GMT_Destroy_Data (GMT->parent, &D);
gmt_support.c:	if (T->temporal && GMT->current.setting.time_system.unit != T->unit) {	/* Dealing with calendar time and must update time unit */
gmt_support.c:		GMT->current.setting.time_system.unit = T->unit;
gmt_support.c:		(void) gmt_init_time_system_structure (GMT, &GMT->current.setting.time_system);
gmt_support.c:		scale = GMT->current.setting.time_system.scale / scale;
gmt_support.c:		T->n = gmt_time_array (GMT, t0, t1, inc, GMT->current.setting.time_system.unit, false, &(T->array));
gmt_support.c:				GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Range (max - min) is not a whole multiple of inc. Adjusted max to %g\n", option, t1);
gmt_support.c:				GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Range (max - min) is not a whole multiple of inc. Adjusted inc to %g\n", option, inc);
gmt_support.c:				GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Information from -%c option: (max - min) is not a whole multiple of inc. Adjusted max to %g\n", option, t1);
gmt_support.c:					GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -%c option: (max - min) is <= 0\n", option);
gmt_support.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -%c option: inc is <= 0\n", option);
gmt_support.c:	if (T->vartime && GMT->current.setting.time_system.unit != unit) {
gmt_support.c:		//scale = GMT->current.setting.time_system.scale / scale;
gmt_support.c:		GMT->current.setting.time_system.unit = unit;
gmt_support.c:		(void) gmt_init_time_system_structure (GMT, &GMT->current.setting.time_system);
gmt_support.c:	GMT_Report (GMT->parent, GMT_MSG_DEBUG, "gmt_check_executable: Pass to popen: [%s]\n", cmd);
gmt_support.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "%s failed\n", cmd);
gmt_support.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "%s was successful\n", cmd);
gmt_support.c:			case 'a': strcat (opts, GMT->common.a.string); break;
gmt_support.c:			case 'b': strcat (opts, GMT->common.b.string); break;
gmt_support.c:			case 'd': strcat (opts, GMT->common.d.string); break;
gmt_support.c:			case 'f': strcat (opts, GMT->common.f.string); break;
gmt_support.c:			case 'g': strcat (opts, GMT->common.g.string); break;
gmt_support.c:			case 'h': strcat (opts, GMT->common.h.string); break;
gmt_support.c:			case 'i': strcat (opts, GMT->common.i.string); break;
gmt_support.c:			case 'n': strcat (opts, GMT->common.n.string); break;
gmt_support.c:			case 's': strcat (opts, GMT->common.s.string); break;
gmt_support.c:			case 'V': string[0] = gmt_set_V (GMT->current.setting.verbose);
gmt_support.c:				GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Unrecognized option %c\n", list[k]);
gmt_vector.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error in gmt_svdcmp: m < n augment A with additional rows\n");
gmt_vector.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error in gmt_svdcmp: No convergence in 30 iterations\n");
gmt_vector.c:	GMT->hidden.mem_coord[GMT_X][0] = x[0];	GMT->hidden.mem_coord[GMT_Y][0] = y[0];
gmt_vector.c:			GMT->hidden.mem_coord[GMT_X][k] = x[i];
gmt_vector.c:			GMT->hidden.mem_coord[GMT_Y][k] = y[i-1];
gmt_vector.c:			GMT->hidden.mem_coord[GMT_X][k] = x[i-1];
gmt_vector.c:			GMT->hidden.mem_coord[GMT_Y][k] = y[i];
gmt_vector.c:		GMT->hidden.mem_coord[GMT_X][k] = x[i];	GMT->hidden.mem_coord[GMT_Y][k] = y[i];
gmt_vector.c:	GMT->hidden.mem_coord[GMT_X][0] = x[0];	GMT->hidden.mem_coord[GMT_Y][0] = y[0];	n_new = 1;
gmt_vector.c:				GMT->hidden.mem_coord[GMT_X][n_new] = x[i-1] * (1 - c) + x[i] * c;
gmt_vector.c:				GMT->hidden.mem_coord[GMT_Y][n_new] = y[i-1];
gmt_vector.c:				GMT->hidden.mem_coord[GMT_X][n_new] = x[i];
gmt_vector.c:				GMT->hidden.mem_coord[GMT_Y][n_new] = y[i-1] * (1 - c) + y[i] * c;
gmt_vector.c:				GMT->hidden.mem_coord[GMT_X][n_new] = x[i-1];
gmt_vector.c:				GMT->hidden.mem_coord[GMT_Y][n_new] = y[i-1] * (1 - c) + y[i] * c;
gmt_vector.c:				GMT->hidden.mem_coord[GMT_X][n_new] = x[i-1] * (1 - c) + x[i] * c;
gmt_vector.c:				GMT->hidden.mem_coord[GMT_Y][n_new] = y[i];
gmt_vector.c:				GMT->hidden.mem_coord[GMT_X][n_new] = x[i-1] * (1 - c) + x[i] * c;
gmt_vector.c:				GMT->hidden.mem_coord[GMT_Y][n_new] = y[i-1] * (1 - c) + y[i] * c;
gmt_vector.c:		GMT->hidden.mem_coord[GMT_X][n_new] = x[i];	GMT->hidden.mem_coord[GMT_Y][n_new] = y[i];	n_new++;
gmt_vector.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Internal error: vector_resample_path_spherical given negative step-size\n");
gmt_vector.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Internal error: vector_resample_path_spherical given bad mode %d\n", mode);
gmt_vector.c:		if (GMT->current.map.dist[GMT_MAP_DIST].arc)	/* Gave an increment in arc length (degree, min, sec) */
gmt_vector.c:			step_out /= GMT->current.map.dist[GMT_MAP_DIST].scale;	/* Get degrees */
gmt_vector.c:			step_out = (step_out / GMT->current.map.dist[GMT_MAP_DIST].scale) / GMT->current.proj.DIST_M_PR_DEG;	/* Get degrees */
gmt_vector.c:			if (GMT->current.map.loxodrome) {	/* Linear resampling along Mercator straight line */
gmt_vector.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Internal error: vector_resample_path_cartesian given negative step-size\n");
gmt_vector.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Internal error: vector_resample_path_cartesian given bad mode %d\n", mode);
gmt_vector.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "gmt_jacobi failed to converge in %d sweeps\n", nsweeps);
gmt_vector.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "gmt_gaussjordan given a singular matrix\n");
gmt_vector.c:	GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "gmt_svdcmp: Using Lapack dsyev\n");
gmt_vector.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "gmt_svdcmp: Error - dsyev failed to compute eigenvalues.\n" );
gmt_vector.c:	GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "gmt_svdcmp: Using GMT's NR-based SVD\n");
gmt_vector.c:	GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "gmt_solve_svd: Evaluate solution\n");
gmt_vector.c:		GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "gmt_solve_svd: Given fraction %g corresponds to %d eigenvalues\n", was, irint(cutoff));
gmt_vector.c:		GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE,
gmt_vector.c:		GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE,
gmt_vector.c:	/* Sets the GMT->current.map.path_mode setting given -A and data type.
gmt_vector.c:		if (active && mode == GMT_STAIRS_OFF) GMT->current.map.path_mode = GMT_LEAVE_PATH;	/* Turn off resampling */
gmt_vector.c:		if (!active) GMT->current.map.path_mode = GMT_LEAVE_PATH;	/* Turn off resampling */
gmt_vector.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Your data array row 0 contains NaNs - no resampling taken place!\n");
gmt_vector.c:	GMT->hidden.mem_coord[GMT_X][0] = lon[0];
gmt_vector.c:	GMT->hidden.mem_coord[GMT_Y][0] = lat[0];
gmt_vector.c:	if (step <= 0.0) step = GMT->current.map.path_step;	/* Based on GMT->current.setting.map_line_step converted to degrees */
gmt_vector.c:			GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Your data array row %" PRIu64 " contains NaNs - no resampling taken place!\n", i);
gmt_vector.c:				GMT->hidden.mem_coord[GMT_X][n_new] = lon[i-1] * (1 - c) + lon_i * c;
gmt_vector.c:				GMT->hidden.mem_coord[GMT_Y][n_new] = lat[i-1];
gmt_vector.c:				GMT->hidden.mem_coord[GMT_X][n_new] = lon[i];
gmt_vector.c:				GMT->hidden.mem_coord[GMT_Y][n_new] = lat[i-1] * (1 - c) + lat[i] * c;
gmt_vector.c:				GMT->hidden.mem_coord[GMT_X][n_new] = lon[i-1];
gmt_vector.c:				GMT->hidden.mem_coord[GMT_Y][n_new] = lat[i-1] * (1 - c) + lat[i] * c;
gmt_vector.c:				GMT->hidden.mem_coord[GMT_X][n_new] = lon[i-1] * (1 - c) + lon_i * c;
gmt_vector.c:				GMT->hidden.mem_coord[GMT_Y][n_new] = lat[i];
gmt_vector.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Two points in input list are antipodal - great circle resampling is not unique!\n");
gmt_vector.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Fix input data or use project -A to generate the desired great circle by providing an azimuth.\n");
gmt_vector.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Two points in input list are antipodal - great circle resampling is not unique!\n");
gmt_vector.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "There are two possible geodesics but GMT does not currently calculate geodesics.\n");
gmt_vector.c:					GMT->hidden.mem_coord[GMT_X][n_new] = lon[i-1];	/* Keep longitude constant */
gmt_vector.c:					GMT->hidden.mem_coord[GMT_Y][n_new] = lat[i-1] + j * dy;	/* March towards N pole */
gmt_vector.c:					GMT->hidden.mem_coord[GMT_X][n_new] = lon[1];
gmt_vector.c:					GMT->hidden.mem_coord[GMT_Y][n_new] = 90.0 - j * dy;
gmt_vector.c:					GMT->hidden.mem_coord[GMT_X][n_new] = lon[i-1];
gmt_vector.c:					GMT->hidden.mem_coord[GMT_Y][n_new] = lat[i-1] - j * dy;
gmt_vector.c:					GMT->hidden.mem_coord[GMT_X][n_new] = lon[1];
gmt_vector.c:					GMT->hidden.mem_coord[GMT_Y][n_new] = j * dy - 90.0;
gmt_vector.c:				gmt_cart_to_geo (GMT, &GMT->hidden.mem_coord[GMT_Y][n_new], &GMT->hidden.mem_coord[GMT_X][n_new], x, true);
gmt_vector.c:					GMT->hidden.mem_coord[GMT_X][n_new] = minlon;
gmt_vector.c:				else if (GMT->hidden.mem_coord[GMT_X][n_new] < minlon)
gmt_vector.c:					GMT->hidden.mem_coord[GMT_X][n_new] += 360.0;
gmt_vector.c:				else if (GMT->hidden.mem_coord[GMT_X][n_new] > maxlon)
gmt_vector.c:					GMT->hidden.mem_coord[GMT_X][n_new] -= 360.0;
gmt_vector.c:		GMT->hidden.mem_coord[GMT_X][n_new] = lon[i];	GMT->hidden.mem_coord[GMT_Y][n_new] = lat[i];
gmt_vector.c:	gmt_eliminate_lon_jumps (GMT, GMT->hidden.mem_coord[GMT_X], n_new);	/* Ensure longitudes are in the same quadrants */
gmtconnect.c:	if (GMT->common.b.active[GMT_IN] && GMT->common.b.ncol[GMT_IN] == 0) GMT->common.b.ncol[GMT_IN] = 2;
gmtconnect.c:	n_errors += gmt_M_check_condition (GMT, GMT->common.b.active[GMT_IN] && GMT->common.b.ncol[GMT_IN] < 2, "Syntax error: Binary input data (-bi) must have at least 2 columns\n");
gmtconnect.c:			if ((Q = GMT_Create_Data (GMT->parent, GMT_IS_DATASET, GMT_IS_TEXT, GMT_WITH_STRINGS, dim_tscr, NULL, NULL, 0, 0, NULL)) == NULL) {
gmtconnect.c:				T[CLOSED][out_seg] = GMT_Alloc_Segment (GMT->parent, smode, n_rows, n_columns, S->header, NULL);
gmtconnect.c:				T[OPEN][n_open] = GMT_Alloc_Segment (GMT->parent, smode, np, n_columns, S->header, NULL);
gmtconnect.c:		char *pp = NULL, *s = GMT->current.setting.io_col_separator;
gmtconnect.c:		sprintf (fmt, "%%" PRIu64 "%s%%s%s%%s%s%%c%s%s%s%s%s%%s%s%%c%s%s%s%s", s, s, s, s, GMT->current.setting.format_float_out, s, GMT->current.setting.format_float_out, \
gmtconnect.c:			s, s, s, GMT->current.setting.format_float_out, s, GMT->current.setting.format_float_out);
gmtconnect.c:		GMT->current.setting.io_header[GMT_OUT] = true;	/* Turn on table headers on output */
gmtconnect.c:		T[CLOSED][out_seg] = GMT_Alloc_Segment (GMT->parent, smode, n_alloc_pts, n_columns, NULL, NULL);
gmtconnect.c:		gmt_M_memset (GMT->current.io.segment_header, GMT_BUFSIZ, char);	/* Blank the current segment header */
gmtconnect.c:		if (n_seg_length < n_alloc_pts) T[OPEN][out_seg] = GMT_Alloc_Segment (GMT->parent, smode, n_seg_length, n_columns, NULL, T[OPEN][out_seg]);	/* Trim memory allocation */
gmtconvert.c:	struct GMTAPI_CTRL *API = GMT->parent;
gmtconvert.c:			Ctrl->D.name = GMT->common.b.active[GMT_OUT] ?
gmtconvert.c:	n_errors += gmt_M_check_condition (GMT, GMT->common.b.active[GMT_IN] && GMT->common.b.ncol[GMT_IN] == 0,
gmtconvert.c:	n_errors += gmt_M_check_condition (GMT, GMT->common.b.active[GMT_IN] && (Ctrl->L.active || Ctrl->S.active),
gmtconvert.c:	if (GMT->common.a.active && D[GMT_IN]->n_tables > 1) {
gmtconvert.c:	if (GMT->common.a.active && THi->ogr) {
gmtconvert.c:		GMT->current.io.skip_headers_on_outout = true;
gmtconvert.c:		if (prevent_seg_headers) GMT->current.io.skip_headers_on_outout = false;	/* Restore to default if it was changed */
gmtconvert.c:	if (n_cols_out == 0 && !GMT->current.io.trailing_text[GMT_OUT]) {
gmtconvert.c:	if (Ctrl->S.active && GMT->current.io.ogr == GMT_OGR_TRUE && (p = strchr (Ctrl->S.select->pattern[0], '=')) != NULL) {	/* Want to search for an aspatial value */
gmtconvert.c:		if ((Ctrl->S.select->ogr_item = gmt_get_ogr_id (GMT->current.io.OGR, Ctrl->S.select->pattern[0])) != GMT_NOTSET) {
gmtconvert.c:						if (use_tbl) strcat (D[GMT_OUT]->table[tbl_ver]->segment[seg]->text[n_rows], GMT->current.setting.io_col_separator);
gmtconvert.c:		if (GMT->common.a.output)	/* Must notify the machinery of this output type */
gmtconvert.c:		GMT->current.io.record_type[GMT_OUT] = GMT->current.io.record_type[GMT_IN];
gmtconvert.c:						GMT->hidden.mem_coord[GMT_X][row] = S->data[col][Z[row].order];
gmtconvert.c:						if (S->text) GMT->hidden.mem_txt[row] = S->text[Z[row].order];
gmtconvert.c:					gmt_M_memcpy (S->data[col], GMT->hidden.mem_coord[GMT_X], S->n_rows, double);
gmtconvert.c:					if (S->text) gmt_M_memcpy (S->text, GMT->hidden.mem_txt, S->n_rows, char *);
gmtconvert.c:	if (prevent_seg_headers) GMT->current.io.skip_headers_on_outout = false;	/* Restore to default if it was changed for file output */
gmtdefaults.c:					GMT_Report (GMT->parent, GMT_MSG_COMPAT, "Option -L is deprecated; it is now the default behavior.\n");
gmtinfo.c:	struct GMTAPI_CTRL *API = GMT->parent;
gmtinfo.c:	if (Ctrl->n_files > 1 && GMT->common.a.active) {
gmtinfo.c:		for (col = 0; col < 5; col++) GMT->current.io.col_type[GMT_OUT][col] = GMT_IS_FLOAT;
gmtinfo.c:	off = (GMT->common.R.active[GSET]) ? 0.5 : 0.0;
gmtinfo.c:		if (!strcmp (GMT->current.setting.format_geo_out, "D")) {
gmtinfo.c:			strcpy (GMT->current.setting.format_geo_out, "+D");
gmtinfo.c:			            GMT->current.setting.format_geo_out);
gmtinfo.c:		else if (!strcmp (GMT->current.setting.format_geo_out, "ddd:mm:ss")) {
gmtinfo.c:			strcpy (GMT->current.setting.format_geo_out, "ddd:mm:ssF");
gmtinfo.c:			            GMT->current.setting.format_geo_out);
gmtinfo.c:	save_range = GMT->current.io.geo.range;
gmtinfo.c:	GMT->current.io.geo.range = GMT_IGNORE_RANGE;	/* Ensure no adjustment will happen since we control it here */
gmtinfo.c:	d_ptr = (Ctrl->C.active || Ctrl->E.active) ? GMT->current.io.curr_rec : ((Ctrl->I.mode == BOUNDBOX) ? out : NULL);
gmtinfo.c:			for (col = 0; col < ncol; col++) if (GMT->current.io.col_type[GMT_IN][col] == GMT_IS_LON) {	/* Must finalize longitudes first */
gmtinfo.c:			if (gmt_M_rec_is_segment_header (GMT) && GMT->current.io.seg_no == 0) continue;	/* Very first segment header means there is no prior segment to report on yet */
gmtinfo.c:				GMT->current.io.seg_no++;	/* Must manually increment since we are not reading any further */
gmtinfo.c: 			for (col = 0; col < ncol; col++) if (GMT->current.io.col_type[GMT_IN][col] == GMT_IS_LON) {	/* Must update longitudes separately */
gmtinfo.c:					if (GMT->common.R.active[GSET]) strcpy (buffer, " (-r is ignored).");
gmtinfo.c:					in_dim[GMT_X] = gmt_M_get_n (GMT, west, east, Ctrl->I.inc[GMT_X], GMT->common.R.active[GSET]);
gmtinfo.c:					in_dim[GMT_Y] = gmt_M_get_n (GMT, south, north, Ctrl->I.inc[GMT_Y], GMT->common.R.active[GSET]);
gmtinfo.c:					if (GMT->common.a.active) {	/* Write text record with name[type] of the aspatial fields */
gmtinfo.c:					if (Ctrl->A.mode == REPORT_PER_DATASET && GMT->current.io.tbl_no > 1)	/* More than one table given */
gmtinfo.c:						sprintf (record, "%s-%" PRIu64, file, GMT->current.io.seg_no);
gmtinfo.c:						low = high = GMT->session.d_NaN;
gmtinfo.c:						GMT->current.io.curr_rec[2*col] = low;
gmtinfo.c:						GMT->current.io.curr_rec[2*col+1] = high;
gmtinfo.c:				gmt_M_memcpy (col_type, GMT->current.io.col_type[GMT_OUT], GMT_MAX_COLUMNS, int);	/* Save previous output col types */
gmtinfo.c:					GMT->current.io.col_type[GMT_OUT][2*col] = GMT->current.io.col_type[GMT_OUT][2*col+1] = GMT->current.io.col_type[GMT_IN][col];
gmtinfo.c:				if (GMT->current.io.col_type[GMT_IN][col] == GMT_IS_LON)
gmtinfo.c:				if (GMT->current.io.col_type[GMT_IN][col] == GMT_IS_LON) {	/* Longitude requires more work */
gmtinfo.c:		if (file[0] == 0) strncpy (file, GMT->current.io.filename[GMT_IN], PATH_MAX-1);	/* Grab name of current file while we can */
gmtinfo.c:	if (GMT->common.a.active) {
gmtinfo.c:	GMT->current.io.geo.range = save_range;	/* Restore what we changed */
gmtinfo.c:		gmt_M_memcpy (GMT->current.io.col_type[GMT_OUT], col_type, GMT_MAX_COLUMNS, int);
gmtlogo.c:				GMT_Report (GMT->parent, GMT_MSG_COMPAT, "Option -W is deprecated; -D...+w%s was set instead, use this in the future.\n", opt->arg);
gmtlogo.c:		n_errors += gmt_M_check_condition (GMT, !GMT->common.R.active[RSET], "Syntax error: -D%c requires the -R option\n", kind[Ctrl->D.refpoint->mode]);
gmtlogo.c:		n_errors += gmt_M_check_condition (GMT, !GMT->common.J.active, "Syntax error: -D%c requires the -J option\n", kind[Ctrl->D.refpoint->mode]);
gmtlogo.c:	if (!(GMT->common.R.active[RSET] && GMT->common.J.active)) {	/* When no projection specified, use fake linear projection */
gmtlogo.c:		GMT->common.R.active[RSET] = true;
gmtlogo.c:		GMT->common.J.active = false;
gmtlogo.c:		gmt_plane_perspective (GMT, GMT->current.proj.z_project.view_plane, GMT->current.proj.z_level);
gmtlogo.c:		if (gmt_M_err_pass (GMT, gmt_map_setup (GMT, GMT->common.R.wesn), "")) Return (GMT_PROJECTION_ERROR);
gmtlogo.c:		gmt_plane_perspective (GMT, GMT->current.proj.z_project.view_plane, GMT->current.proj.z_level);
gmtlogo.c:		GMT->common.J.active = false;
gmtlogo.c:		GMT->common.R.active[RSET] = GMT->common.J.active = true;
gmtlogo.c:	/* Allocate a matrix container for holding the GMT-matrix coordinates */
gmtmath.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error, %sFIT requires at least 2 active columns!\n", pre[svd]);
gmtmath.c:		GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Solve LS system via SVD decomposition and exclude eigenvalues < %g.\n", eigen_min);
gmtmath.c:		GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Solve LS system via Cholesky decomposition\n");
gmtmath.c:			GMT_Report (GMT->parent, GMT_MSG_VERBOSE,
gmtmath.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Eigenvalue routine failed to converge in 50 sweeps.\n");
gmtmath.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "The solution might be inaccurate.\n");
gmtmath.c:		if (k) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "%d eigenvalues < %g set to zero to yield a stable solution\n", k, eigen_min);
gmtmath.c:		if ((D = GMT_Create_Data (GMT->parent, GMT_IS_DATASET, GMT_IS_NONE, 0, dim, NULL, NULL, 0, 0, NULL)) == NULL)
gmtmath.c:			return (GMT->parent->error);
gmtmath.c:		GMT_Set_Comment (GMT->parent, GMT_IS_DATASET, GMT_COMMENT_IS_OPTION | GMT_COMMENT_IS_COMMAND, options, D);
gmtmath.c:		if (GMT->common.h.add_colnames) {
gmtmath.c:			if (GMT_Set_Comment (GMT->parent, GMT_IS_DATASET, GMT_COMMENT_IS_COLNAMES, header, D)) return (GMT->parent->error);
gmtmath.c:		if (GMT_Write_Data (GMT->parent, GMT_IS_DATASET, (file ? GMT_IS_FILE : GMT_IS_STREAM), GMT_IS_NONE, 0, NULL, file, D) != GMT_NOERROR)
gmtmath.c:			return (GMT->parent->error);
gmtmath.c:		D = GMT_Duplicate_Data (GMT->parent, GMT_IS_DATASET, GMT_DUPLICATE_ALLOC, S->D);	/* Same table length as S->D, but with up to n_cols columns (lon, lat, dist, g1, g2, ...) */
gmtmath.c:		if (GMT->common.h.add_colnames) {
gmtmath.c:			if (GMT_Set_Comment (GMT->parent, GMT_IS_DATASET, GMT_COMMENT_IS_COLNAMES, header, D)) return (GMT->parent->error);
gmtmath.c:		if (GMT_Write_Data (GMT->parent, GMT_IS_DATASET, (file ? GMT_IS_FILE : GMT_IS_STREAM), GMT_IS_NONE, 0, NULL, file, D) != GMT_NOERROR) {
gmtmath.c:			return (GMT->parent->error);
gmtmath.c:	struct GMTAPI_CTRL *API = GMT->parent;
gmtmath.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Fatal error: Not enough items on the stack\n");
gmtmath.c:	if (S[last]->constant && S[last]->factor == 0.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, operand == 0!\n");
gmtmath.c:	if (S[last]->constant && fabs (S[last]->factor) > 1.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, |operand| > 1 for ACOS!\n");
gmtmath.c:	if (S[last]->constant && fabs (S[last]->factor) < 1.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, operand < 1 for ACOSH!\n");
gmtmath.c:	if (S[last]->constant && fabs (S[last]->factor) > 1.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, |operand| > 1 for ACOT!\n");
gmtmath.c:	if (S[last]->constant && fabs (S[last]->factor) <= 1.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, |operand| <= 1 for ACOTH!\n");
gmtmath.c:	if (S[last]->constant && fabs (S[last]->factor) > 1.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, |operand| > 1 for ACSC!\n");
gmtmath.c:	if (S[prev]->constant && S[prev]->factor == 0.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, operand one == 0!\n");
gmtmath.c:	if (S[last]->constant && S[last]->factor == 0.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, operand two == 0!\n");
gmtmath.c:	if (S[last]->constant && fabs (S[last]->factor) > 1.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, |operand| > 1 for ASEC!\n");
gmtmath.c:	if (S[last]->constant && fabs (S[last]->factor) > 1.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, operand > 1 for ASECH!\n");
gmtmath.c:	if (S[last]->constant && fabs (S[last]->factor) > 1.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, |operand| > 1 for ASIN!\n");
gmtmath.c:	if (S[prev]->constant && S[prev]->factor == 0.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, operand one == 0 for ATAN2!\n");
gmtmath.c:	if (S[last]->constant && S[last]->factor == 0.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, operand two == 0 for ATAN2!\n");
gmtmath.c:	if (S[last]->constant && fabs (S[last]->factor) >= 1.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, |operand| >= 1 for ATANH!\n");
gmtmath.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error. Argument p to BCDF must be a 0 <= p <= 1!\n");
gmtmath.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error. Argument n to BCDF must be a positive integer (n >= 0)!\n");
gmtmath.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error. Argument x to BCDF must be a positive integer (x >= 0)!\n");
gmtmath.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error. Argument p to BPDF must be a 0 <= p <= 1!\n");
gmtmath.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error. Argument n to BPDF must be a positive integer (n >= 0)!\n");
gmtmath.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error. Argument x to BPDF must be a positive integer (x >= 0)!\n");
gmtmath.c:			T_prev->segment[s]->data[col][row] = GMT->session.d_NaN;
gmtmath.c:	if (n_warn) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "BITAND resulted in %" PRIu64 " values truncated to fit in the 53 available bits\n");
gmtmath.c:			T_prev->segment[s]->data[col][row] = GMT->session.d_NaN;
gmtmath.c:				if (first) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Bit shift must be >= 0; other values yield NaN\n");
gmtmath.c:				T_prev->segment[s]->data[col][row] = GMT->session.d_NaN;
gmtmath.c:	if (n_warn) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "BITLEFT resulted in %" PRIu64 " values truncated to fit in the 53 available bits\n");
gmtmath.c:			T->segment[s]->data[col][row] = GMT->session.d_NaN;
gmtmath.c:	if (n_warn) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "BITNOT resulted in %" PRIu64 " values truncated to fit in the 53 available bits\n");
gmtmath.c:			T_prev->segment[s]->data[col][row] = GMT->session.d_NaN;
gmtmath.c:	if (n_warn) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "BITOR resulted in %" PRIu64 " values truncated to fit in the 53 available bits\n");
gmtmath.c:			T_prev->segment[s]->data[col][row] = GMT->session.d_NaN;
gmtmath.c:				if (first) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Bit shift must be >= 0; other values yield NaN\n");
gmtmath.c:				T_prev->segment[s]->data[col][row] = GMT->session.d_NaN;
gmtmath.c:	if (n_warn) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "BITRIGHT resulted in %" PRIu64 " values truncated to fit in the 53 available bits\n");
gmtmath.c:			T_prev->segment[s]->data[col][row] = GMT->session.d_NaN;
gmtmath.c:				if (first) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Bit position range for BITTEST is 0-63 (since we are using do); other values yield NaN\n");
gmtmath.c:				T_prev->segment[s]->data[col][row] = GMT->session.d_NaN;
gmtmath.c:	if (n_warn) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "BITTEST resulted in %" PRIu64 " values truncated to fit in the 53 available bits\n");
gmtmath.c:			T_prev->segment[s]->data[col][row] = GMT->session.d_NaN;
gmtmath.c:	if (n_warn) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "BITXOR resulted in %" PRIu64 " values truncated to fit in the 53 available bits\n");
gmtmath.c:	if (S[prev]->constant && S[prev]->factor == 0.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, operand one == 0 for CHI2CRIT!\n");
gmtmath.c:	if (S[last]->constant && S[last]->factor == 0.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, operand two == 0 for CHI2CRIT!\n");
gmtmath.c:	if (S[prev]->constant && S[prev]->factor == 0.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, operand one == 0 for CHI2CDF!\n");
gmtmath.c:	if (S[last]->constant && S[last]->factor == 0.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, operand two == 0 for CHI2CDF!\n");
gmtmath.c:	if (S[prev]->constant && S[prev]->factor == 0.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, operand one == 0 for CHI2PDF!\n");
gmtmath.c:	if (S[last]->constant && S[last]->factor == 0.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, operand two == 0 for CHI2PDF!\n");
gmtmath.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error, argument to COL must be a constant column number (0 <= k < n_col)!\n");
gmtmath.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error. Argument n to COMB must be a positive integer (n >= 0)!\n");
gmtmath.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error. Argument r to COMB must be a positive integer (r >= 0)!\n");
gmtmath.c:			for (row = 0; row < info->T->segment[s]->n_rows; row++) T_prev->segment[s]->data[col][row] = GMT->session.d_NaN;
gmtmath.c:	if (S[last]->constant && S[last]->factor == 0.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, operand two == 0 for PCDF!\n");
gmtmath.c:	if (info->irregular) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, DDT called on irregularly spaced data (not supported)!\n");
gmtmath.c:	if (S[last]->constant) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, operand to DDT is constant!\n");
gmtmath.c:	if (info->irregular) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, D2DT2 called on irregularly spaced data (not supported)!\n");
gmtmath.c:	if (S[last]->constant) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, operand to D2DT2 is constant!\n");
gmtmath.c:			T->segment[s]->data[col][row] = (gmt_M_is_dnan (T->segment[s]->data[col][row]) || gmt_M_is_dnan (T->segment[s]->data[col][row+1])) ? GMT->session.d_NaN : 0.0;
gmtmath.c:			T->segment[s]->data[col][row] = (gmt_M_is_dnan (T->segment[s]->data[col][row]) || gmt_M_is_dnan (T->segment[s]->data[col][row-1])) ? GMT->session.d_NaN : 0.0;
gmtmath.c:		T->segment[s]->data[col][info->T->segment[s]->n_rows - 1] = GMT->session.d_NaN;
gmtmath.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Divide by zero gives NaNs\n");
gmtmath.c:	if (S[prev2]->constant && S[prev2]->factor == 0.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, operand one == 0 for FCRIT!\n");
gmtmath.c:	if (S[prev1]->constant && S[prev1]->factor == 0.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, operand two == 0 for FCRIT!\n");
gmtmath.c:	if (S[last]->constant && S[last]->factor == 0.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, operand three == 0 for FCRIT!\n");
gmtmath.c:	if (S[prev1]->constant && S[prev1]->factor == 0.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, operand two == 0 for FCDF!\n");
gmtmath.c:	if (S[last]->constant && S[last]->factor == 0.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, operand three == 0 for FCDF!\n");
gmtmath.c:	if (S[last]->constant && S[last]->factor == 0.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, using FMOD 0!\n");
gmtmath.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error. Argument F to FPDF must be a >= 0!\n");
gmtmath.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error. Argument nu1 to FPDF must be a positive integer (nu1 > 0)!\n");
gmtmath.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error. Argument nu2 to FPDF must be a positive integer (nu2 > 0)!\n");
gmtmath.c:	if (S[prev]->constant && S[prev]->factor == 0.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, operand one == 0!\n");
gmtmath.c:	if (S[last]->constant && S[last]->factor == 0.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, operand two == 0!\n");
gmtmath.c:		if (S[last]->factor < 0.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, order < 0 for IN!\n");
gmtmath.c:		if (fabs (rint(S[last]->factor) - S[last]->factor) > GMT_CONV4_LIMIT) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, order not an integer for IN!\n");
gmtmath.c:			T_prev2->segment[s]->data[col][row] = GMT->session.d_NaN;
gmtmath.c:	if (S[last]->constant && S[last]->factor == 0.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Inverse of zero gives NaNs\n");
gmtmath.c:	if (S[last]->constant) a = (S[last]->factor == 0) ? GMT->session.d_NaN : 1.0 / S[last]->factor;
gmtmath.c:		if (S[last]->factor < 0.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, order < 0 for JN!\n");
gmtmath.c:		if (fabs (rint(S[last]->factor) - S[last]->factor) > GMT_CONV4_LIMIT) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, order not an integer for JN!\n");
gmtmath.c:		if (S[last]->factor < 0.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, order < 0 for KN!\n");
gmtmath.c:		if (fabs (rint(S[last]->factor) - S[last]->factor) > GMT_CONV4_LIMIT) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, order not an integer for KN!\n");
gmtmath.c:		for (s = 0; s < info->T->n_segments; s++) for (row = 0; row < info->T->segment[s]->n_rows; row++) T->segment[s]->data[col][row] = GMT->session.d_NaN;
gmtmath.c:				kurt = GMT->session.d_NaN;
gmtmath.c:		kurt = GMT->session.d_NaN;
gmtmath.c:				lmsscl = GMT->session.d_NaN;
gmtmath.c:			if (GMT_n_multiples > 0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "%d Multiple modes found for segment %" PRIu64 "\n", GMT_n_multiples, s);
gmtmath.c:		lmsscl = GMT->session.d_NaN;
gmtmath.c:	if (GMT_n_multiples > 0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "%d Multiple modes found\n", GMT_n_multiples);
gmtmath.c:	if (S[last]->constant && S[last]->factor == 0.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, argument to log = 0!\n");
gmtmath.c:	if (S[last]->constant && S[last]->factor == 0.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, argument to log10 = 0!\n");
gmtmath.c:	if (S[last]->constant && S[last]->factor < 0.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, argument to log1p < 0!\n");
gmtmath.c:	if (S[last]->constant && S[last]->factor == 0.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, argument to log2 = 0!\n");
gmtmath.c:		if (low == DBL_MAX) low = GMT->session.d_NaN;
gmtmath.c:				mad = GMT->session.d_NaN;
gmtmath.c:		mad = GMT->session.d_NaN;
gmtmath.c:		T_prev->segment[s]->data[col][row] = (gmt_M_is_dnan (a) || gmt_M_is_dnan (b)) ? GMT->session.d_NaN : MAX (a, b);
gmtmath.c:			sum_a = (n_a) ? sum_a / n_a : GMT->session.d_NaN;
gmtmath.c:	sum_a = (n_a) ? sum_a / n_a : GMT->session.d_NaN;
gmtmath.c:			zm = (n_a == 0 || sum_w == 0.0) ? GMT->session.d_NaN : (sum_zw / sum_w);
gmtmath.c:	zm = (n_a == 0 || sum_w == 0.0) ? GMT->session.d_NaN : (sum_zw / sum_w);
gmtmath.c:				med = GMT->session.d_NaN;
gmtmath.c:		med = GMT->session.d_NaN;
gmtmath.c:		T_prev->segment[s]->data[col][row] = (gmt_M_is_dnan (a) || gmt_M_is_dnan (b)) ? GMT->session.d_NaN : MIN (a, b);
gmtmath.c:	if (S[last]->constant && S[last]->factor == 0.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, using MOD 0!\n");
gmtmath.c:	if (S[prev]->constant && S[prev]->factor == 0.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, operand one == 0!\n");
gmtmath.c:	if (S[last]->constant && S[last]->factor == 0.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, operand two == 0!\n");
gmtmath.c:		T_prev->segment[s]->data[col][row] = ((a == b) ? GMT->session.d_NaN : a);
gmtmath.c:	if (S[last]->constant && S[last]->factor == 0.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, operand == 0!\n");
gmtmath.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, NORM of a constant gives NaN!\n");
gmtmath.c:		a = GMT->session.d_NaN;
gmtmath.c:		a = (n == 0 || zmax == zmin) ? GMT->session.d_NaN : 1.0 / (zmax - zmin);	/* Normalization scale */
gmtmath.c:	if (S[last]->constant && S[last]->factor == 0.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, operand == 0!\n");
gmtmath.c:		T_prev->segment[s]->data[col][row] = (gmt_M_is_dnan (a) || gmt_M_is_dnan (b)) ? GMT->session.d_NaN : a;
gmtmath.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error, argument n to PERM must be a positive integer (n >= 0)!\n");
gmtmath.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error, argument r to PERM must be a positive integer (r >= 0)!\n");
gmtmath.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "PLM: L and M must be constants!\n");
gmtmath.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "PLMg: L and M must be constants!\n");
gmtmath.c:	if (S[prev]->constant && S[prev]->factor == 0.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, operand one == 0!\n");
gmtmath.c:	if (S[last]->constant && S[last]->factor == 0.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, operand two == 0!\n");
gmtmath.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "PQUANT must be given a constant quantile!\n");
gmtmath.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "PQUANT must be given a constant quantile between 0-100%%!\n");
gmtmath.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "PQUANT of a constant is set to NaN\n");
gmtmath.c:		p = GMT->session.d_NaN;
gmtmath.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "PQUANTW must be given a constant quantile!\n");
gmtmath.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "PQUANTW must be given a constant quantile between 0-100%%!\n");
gmtmath.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "PQUANTW of a constant is set to NaN\n");
gmtmath.c:		p = GMT->session.d_NaN;
gmtmath.c:		if ((S[first]->factor < -1.0 || S[first]->factor > 1.0)) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, argument to %s outside domain!\n", name[kind]);
gmtmath.c:	if (S[prev]->constant && S[prev]->factor == 0.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, operand one == 0!\n");
gmtmath.c:	if (S[last]->constant && S[last]->factor == 0.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, operand two == 0!\n");
gmtmath.c:				sum2 = (n > 0) ? sqrt (sum2 / n) : GMT->session.d_NaN;
gmtmath.c:	if (!S[last]->constant) sum2 = (n > 0) ? sqrt (sum2 / n) : GMT->session.d_NaN;
gmtmath.c:				sum2 = (sumw > 0.0) ? sqrt (sum2 / sumw) : GMT->session.d_NaN;
gmtmath.c:	if (!S[prev]->constant) sum2 = (n > 0) ? sqrt (sum2 / sumw) : GMT->session.d_NaN;
gmtmath.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "length and shift must be constants in ROLL!\n");
gmtmath.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Items on stack is fewer than required by ROLL!\n");
gmtmath.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "T-shift must be a constant in ROTT!\n");
gmtmath.c:	if (S[last]->constant && S[last]->factor == 0.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, operand == 0!\n");
gmtmath.c:		for (s = 0; s < info->T->n_segments; s++) for (row = 0; row < info->T->segment[s]->n_rows; row++) T->segment[s]->data[col][row] = GMT->session.d_NaN;
gmtmath.c:				skew = GMT->session.d_NaN;
gmtmath.c:		skew = GMT->session.d_NaN;
gmtmath.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error SORT: Column must be a constant column number (0 <= k < n_col)!\n");
gmtmath.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error SORT: Direction must be -1 (decreasing) or +1 (increasing)!\n");
gmtmath.c:				GMT->hidden.mem_coord[GMT_X][row] = T_prev2->segment[s]->data[col][Z[k].order];
gmtmath.c:			gmt_M_memcpy (T_prev2->segment[s]->data[col], GMT->hidden.mem_coord[GMT_X], info->T->segment[s]->n_rows, double);
gmtmath.c:	if (S[last]->constant && S[last]->factor < 0.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, operand one < 0!\n");
gmtmath.c:		std = GMT->session.d_NaN;
gmtmath.c:				std = (n > 1) ? sqrt (sum2 / (n - 1)) : GMT->session.d_NaN;
gmtmath.c:		std = (n > 1) ? sqrt (sum2 / (n - 1)) : GMT->session.d_NaN;
gmtmath.c:		std = GMT->session.d_NaN;
gmtmath.c:				std = (n > 1) ? sqrt ((n * M2 / sumw) / (n - 1.0)) : GMT->session.d_NaN;
gmtmath.c:		std = (n > 1) ? sqrt ((n * M2 / sumw) / (n - 1.0)) : GMT->session.d_NaN;
gmtmath.c:	if (S[prev]->constant && S[prev]->factor == 0.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, operand one == 0!\n");
gmtmath.c:	if (S[last]->constant && S[last]->factor == 0.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, operand two == 0!\n");
gmtmath.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "TAPER: Argument A must be a constant!\n");
gmtmath.c:	if (S[prev]->constant && S[prev]->factor == 0.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, operand one == 0 for TCRIT!\n");
gmtmath.c:	if (S[last]->constant && S[last]->factor == 0.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, operand two == 0 for TCRIT!\n");
gmtmath.c:		if (high == -DBL_MAX) high = GMT->session.d_NaN;
gmtmath.c:		var = GMT->session.d_NaN;
gmtmath.c:				sum2 = (n > 1) ? sum2 / (n - 1) : GMT->session.d_NaN;
gmtmath.c:		var = (n > 1) ? sum2 / (n - 1) : GMT->session.d_NaN;
gmtmath.c:		var = GMT->session.d_NaN;
gmtmath.c:				var = (n > 1) ? (n * M2 / sumw) / (n - 1.0) : GMT->session.d_NaN;
gmtmath.c:		var = (n > 1) ? (n * M2 / sumw) / (n - 1.0) : GMT->session.d_NaN;
gmtmath.c:	if (S[prev1]->constant && S[prev1]->factor <= 0.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, operand two <=0 for WCDF!\n");
gmtmath.c:	if (S[last]->constant && S[last]->factor <= 0.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, operand three <= 0 for WCDF!\n");
gmtmath.c:	if (S[prev1]->constant && S[prev1]->factor <= 0.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, operand two <=0 for WCRIT!\n");
gmtmath.c:	if (S[last]->constant && S[last]->factor <= 0.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, operand three <= 0 for WCRIT!\n");
gmtmath.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error. Argument x to WPDF must be x >= 0!\n");
gmtmath.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error. Argument a to WPDF must be a positive (a > 0)!\n");
gmtmath.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error. Argument b to WPDF must be a positive (b > 0)!\n");
gmtmath.c:	if (S[last]->constant && S[last]->factor == 0.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, operand = 0 for Y0!\n");
gmtmath.c:	if (S[last]->constant && S[last]->factor == 0.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, operand = 0 for Y1!\n");
gmtmath.c:	if (S[last]->constant && S[last]->factor < 0.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, order < 0 for YN!\n");
gmtmath.c:	if (S[last]->constant && fabs (rint(S[last]->factor) - S[last]->factor) > GMT_CONV4_LIMIT) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, order not an integer for YN!\n");
gmtmath.c:	if (S[prev]->constant && S[prev]->factor == 0.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, argument = 0 for YN!\n");
gmtmath.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Argument to operator ROOTS must be a constant: the column number. Reset to 0\n");
gmtmath.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Argument to operator ROOTS must be a column number 0 < col < %d. Reset to 0\n", info->n_col);
gmtmath.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Argument to operator ROOTS must be a column number 0 < col < %d. Reset to 0\n", info->n_col);
gmtmath.c:	if (!strcmp (txt, "NaN")) {*value = GMT->session.d_NaN; return GMTMATH_ARG_IS_NUMBER;}
gmtmath.c:		if (check != GMT_IS_NAN && possible_number) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Your argument %s is both a file and a number.  File is selected\n", txt);
gmtmath.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Option %s not recognized\n", txt);
gmtmath.c:	GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error: %s is not a number, operator or file name\n", txt);
gmtmath.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "No label appended to STO|RCL|CLR operator!\n");
gmtmath.c:		GMT_Report (GMT->parent, GMT_MSG_COMPAT, "Operator %s is deprecated; use %s instead.\n", old, t);
gmtmath.c:	GMT->current.io.skip_if_NaN[GMT_X] = GMT->current.io.skip_if_NaN[GMT_Y] = false;	/* Turn off default GMT NaN-handling of x/y (e.g. lon/lat columns) */
gmtmath.c:	GMT->current.io.skip_if_NaN[Ctrl->N.tcol] = t_check_required;	/* Determines if the t-column may have NaNs */
gmtmath.c:		GMT->current.io.skip_if_NaN[GMT_X] = GMT->current.io.skip_if_NaN[GMT_Y] = false;
gmtmath.c:		GMT->current.io.skip_if_NaN[Ctrl->N.tcol] = true;
gmtmath.c:				Ctrl->T.T.inc = (row == info.T->segment[seg]->n_rows) ? GMT->session.d_NaN : info.T->segment[seg]->data[COL_T][row] - info.T->segment[seg]->data[COL_T][row-1];
gmtmath.c:			R->table[0]->segment[0]->data[0][0] *= GMT->session.u2u[GMT_INCH][GMT->current.setting.proj_length_unit];
gmtmath.c:			if ((N = GMT_Create_Data (GMT->parent, GMT_IS_DATASET, GMT_IS_NONE, 0, dim, NULL, NULL, 0, 0, NULL)) == NULL)
gmtmath.c:				return (GMT->parent->error);
gmtread.c:							GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Unrecognized data type %c.  Choose from c, d, g, i, and p\n", opt->arg[0]);
gmtread.c:						GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Unrecognized data type %c.  Choose from c, d, g, i, and p\n", opt->arg[0]);
gmtread.c:	n_errors += gmt_M_check_condition (GMT, GMT->common.b.active[GMT_IN] && GMT->common.b.ncol[GMT_IN] == 0,
gmtregress.c:						GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -E option: Unrecognized type %c\n", opt->arg[0]);
gmtregress.c:							GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -F option: Choose from -F%s\n", GMTREGRESS_FARGS);
gmtregress.c:						GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -F option: Too many output columns selected\n");
gmtregress.c:						GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -N option: Unrecognized norm %c\n", opt->arg[0]);
gmtregress.c:						GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -W option: Specify -W[w][x][y][r]\n");
gmtregress.c:					GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -W option: Gave more than 3 uncertainty types\n");
gmtregress.c:	if (GMT->common.b.active[GMT_IN] && GMT->common.b.ncol[GMT_IN] == 0) GMT->common.b.ncol[GMT_IN] = 2;
gmtregress.c:	n_errors += gmt_M_check_condition (GMT, GMT->common.b.active[GMT_IN] && GMT->common.b.ncol[GMT_IN] < 2,
gmtregress.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Computed single weights from separate x- and y-weights %s\n",
gmtregress.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Computed weights from given %c-weights\n", (w[GMT_X]) ? 'x' : 'y');
gmtregress.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Computed unit weights in the absence of actual weights\n");
gmtregress.c:			GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Internal error: misfit norm not specified? - set to L2\n");
gmtregress.c:		b = GMT->session.d_NaN;				/* Slope is undefined */
gmtregress.c:			GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Internal error: misfit norm not specified? - set to L2\n");
gmtregress.c:			GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "%s\n", buffer);
gmtregress.c:	GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Robust regression algorithm convergence required %d iterations\n", n_iter);
gmtregress.c:		GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "%s\n", buffer);
gmtregress.c:	GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "York orthogonal algorithm convergence required %d iterations\n", n_iter);
gmtregress.c:		Sa = GMT_Alloc_Segment (GMT->parent, GMT_NO_STRINGS, n_try, n_columns, NULL, NULL);
gmtselect.c:	             API->GMT->session.unit_name[API->GMT->current.setting.proj_length_unit]);
gmtselect.c:	             API->GMT->session.unit_name[API->GMT->current.setting.proj_length_unit]);
gmtselect.c:	struct GMTAPI_CTRL *API = GMT->parent;
gmtselect.c:	if (Ctrl->Z.max_col == 1 && (Ctrl->C.active || Ctrl->E.active || Ctrl->F.active || Ctrl->L.active || Ctrl->N.active || GMT->common.R.active[RSET])) Ctrl->Z.max_col = 2;
gmtselect.c:	if (!GMT->common.R.active[RSET] && Ctrl->N.active) {	/* If we use coastline data or used -fg but didn't give -R we implicitly set -Rg */
gmtselect.c:		GMT->common.R.active[RSET] = true;
gmtselect.c:		GMT->common.R.wesn[XLO] = 0.0;	GMT->common.R.wesn[XHI] = 360.0;	GMT->common.R.wesn[YLO] = -90.0;	GMT->common.R.wesn[YHI] = +90.0;
gmtselect.c:	if (GMT->common.R.active[RSET]) {	/* -R was set directly or indirectly; hence must set -J if not supplied */
gmtselect.c:		if (!GMT->common.J.active) {	/* -J not specified, set one implicitly */
gmtselect.c:			GMT->current.proj.projection = GMT->current.proj.projection_GMT = GMT->current.proj.xyz_projection[GMT_X] = GMT->current.proj.xyz_projection[GMT_Y] = GMT_LINEAR;
gmtselect.c:			GMT->current.proj.pars[0] = GMT->current.proj.pars[1] = 1.0;
gmtselect.c:			GMT->common.J.active = no_resample = true;
gmtselect.c:			while (GMT->common.R.wesn[XLO] < 0.0 && GMT->common.R.wesn[XHI] < 0.0) {	/* Make all-negative longitude range positive instead */
gmtselect.c:				GMT->common.R.wesn[XLO] += 360.0;
gmtselect.c:				GMT->common.R.wesn[XHI] += 360.0;
gmtselect.c:		if (gmt_M_err_pass (GMT, gmt_proj_setup (GMT, GMT->common.R.wesn), "")) Return (GMT_PROJECTION_ERROR);
gmtselect.c:		if (no_resample) GMT->current.map.parallel_straight = GMT->current.map.meridian_straight = 2;	/* No resampling along bin boundaries */
gmtselect.c:		if ((err = gmt_init_shore (GMT, Ctrl->D.set, &c, GMT->common.R.wesn, &Ctrl->A.info))) {
gmtselect.c:		west_border = floor (GMT->common.R.wesn[XLO] / c.bsize) * c.bsize;
gmtselect.c:		east_border = ceil (GMT->common.R.wesn[XHI] / c.bsize) * c.bsize;
gmtselect.c:	GMT->common.b.ncol[GMT_OUT] = UINT_MAX;	/* Flag to have it reset to GMT->common.b.ncol[GMT_IN] when writing */
gmtselect.c:				need_header = GMT->current.io.multi_segments[GMT_OUT];	/* Only need to break up segments */
gmtselect.c:		if (GMT->common.R.active[RSET]) {	/* Apply region test */
gmtsimplify.c:	if (GMT->common.b.active[GMT_IN] && GMT->common.b.ncol[GMT_IN] == 0) GMT->common.b.ncol[GMT_IN] = 2;
gmtsimplify.c:	n_errors += gmt_M_check_condition (GMT, GMT->common.b.active[GMT_IN] && GMT->common.b.ncol[GMT_IN] < 2, "Syntax error: Binary input data (-bi) must have at least 2 columns.\n");
gmtsimplify.c:			tolerance /= GMT->current.map.dist[GMT_MAP_DIST].scale; /* Get degrees */
gmtsimplify.c:			tolerance /= GMT->current.map.dist[GMT_MAP_DIST].scale;	/* Get meters... */
gmtsimplify.c:			tolerance /= GMT->current.proj.DIST_M_PR_DEG;		/* ...then convert to spherical degrees */
gmtsimplify.c:				S[GMT_OUT] = GMT_Alloc_Segment (GMT->parent, smode, np_out, S[GMT_IN]->n_columns, NULL, NULL);
gmtspatial.c:		GMT->current.proj.projection_GMT = GMT->current.proj.projection = GMT_LAMB_AZ_EQ;
gmtspatial.c:		GMT->current.proj.unit = 1.0;
gmtspatial.c:		GMT->current.proj.pars[3] = 39.3700787401574814;
gmtspatial.c:		GMT->common.R.oblique = false;
gmtspatial.c:		GMT->common.J.active = true;
gmtspatial.c:		GMT->current.setting.map_line_step = 1.0e7;	/* To avoid nlon/nlat being huge */
gmtspatial.c:		GMT->current.proj.pars[0] = out[GMT_X];
gmtspatial.c:		GMT->current.proj.pars[1] = out[GMT_Y];
gmtspatial.c:		ix = 1.0 / GMT->current.proj.scale[GMT_X];
gmtspatial.c:		iy = 1.0 / GMT->current.proj.scale[GMT_Y];
gmtspatial.c:			xp[i] = (xx - GMT->current.proj.origin[GMT_X]) * ix;
gmtspatial.c:			yp[i] = (yy - GMT->current.proj.origin[GMT_Y]) * iy;
gmtspatial.c:	if (geo) size *= (GMT->current.map.dist[GMT_MAP_DIST].scale * GMT->current.map.dist[GMT_MAP_DIST].scale);
gmtspatial.c:	GMT_Put_Record (GMT->parent, GMT_WRITE_DATA, &Out);
gmtspatial.c:	GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Determine the segments in D closest to our segment\n");
gmtspatial.c:		GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "No other segment found within dmax [probably due to +p requirement]\n");
gmtspatial.c:		GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Closest segment (Table %d, segment %" PRIu64 ") is %.3f km away; %d segments found within dmax\n", I->table, I->segment, I->distance, n_close);
gmtspatial.c:				GMT_Report (GMT->parent, GMT_MSG_DEBUG, "S to Sp of same length and gave d1 = %g and d2 = %g\n", d1, d2);
gmtspatial.c:			use_sep = (separation[0] == DBL_MAX) ? GMT->session.d_NaN : separation[0];
gmtspatial.c:			use_close = (close[0] == DBL_MAX) ? GMT->session.d_NaN : close[0];
gmtspatial.c:			GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE,
gmtspatial.c:				use_sep = (np == 0 || med_separation[0] == DBL_MAX) ? GMT->session.d_NaN : med_separation[0];
gmtspatial.c:				use_close = (np == 0 || med_close[0] == DBL_MAX) ? GMT->session.d_NaN : med_close[0];
gmtspatial.c:				GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "S  has median separation to Sp of %.3f km, and a robust closeness ratio of %g\n",
gmtspatial.c:			use_sep = (separation[1] == DBL_MAX) ? GMT->session.d_NaN : separation[1];
gmtspatial.c:			use_close = (close[1] == DBL_MAX) ? GMT->session.d_NaN : close[1];
gmtspatial.c:			GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Sp has length %.3f km, has mean separation to S of %.3f km, and a closeness ratio of %g [n = %" PRIu64 "/%" PRIu64 "]\n",
gmtspatial.c:				use_sep = (med_separation[1] == DBL_MAX) ? GMT->session.d_NaN : med_separation[1];
gmtspatial.c:				use_close = (med_close[1] == DBL_MAX) ? GMT->session.d_NaN : med_close[1];
gmtspatial.c:				GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Sp has median separation to S  of %.3f km, and a robust closeness ratio of %g\n",
gmtspatial.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "===> Iteration = %d\n", iteration);
gmtspatial.c:			GMT_Report (GMT->parent, GMT_MSG_DEBUG, "%6d\tID=%6d\tNeighbor=%6d\tDistance = %.12g\n", (int)k, (int)P[k].ID, P[k].neighbor, P[k].distance);
gmtspatial.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "===> Initialization\n");
gmtspatial.c:			GMT_Report (GMT->parent, GMT_MSG_DEBUG, "%6d\tID=%6d\tNeighbor=%6d\tDistance = %.12g\n", (int)k, (int)P[k].ID, P[k].neighbor, P[k].distance);
gmtspatial.c:	struct GMTAPI_CTRL *API = GMT->parent;
gmtspatial.c:	if (GMT->common.b.active[GMT_IN] && GMT->common.b.ncol[GMT_IN] == 0) GMT->common.b.ncol[GMT_IN] = 2;
gmtspatial.c:	n_errors += gmt_M_check_condition (GMT, GMT->common.b.active[GMT_IN] && GMT->common.b.ncol[GMT_IN] < 2, "Syntax error: Binary input data (-bi) must have at least %d columns\n", 2);
gmtspatial.c:	n_errors += gmt_M_check_condition (GMT, Ctrl->S.mode == POL_CLIP && !Ctrl->T.file && !GMT->common.R.active[RSET], "Syntax error: -T without a polygon requires -R\n");
gmtspatial.c:	n_errors += gmt_M_check_condition (GMT, Ctrl->C.active && !Ctrl->T.active && !GMT->common.R.active[RSET], "Syntax error: -C requires -R\n");
gmtspatial.c:	n_errors += gmt_M_check_condition (GMT, Ctrl->L.active && !GMT->common.R.active[RSET], "Syntax error: -L requires -R\n");
gmtspatial.c:					NN_dist[b].distance = GMT->session.d_NaN;	/* Flag this point as used.  NNA_update_dist will sort it and place all NaNs at the end */
gmtspatial.c:			if (GMT->common.h.add_colnames) {
gmtspatial.c:			if (GMT->common.h.add_colnames) {
gmtspatial.c:			if (GMT->common.R.active[RSET]) {
gmtspatial.c:				struct GMT_DATASEGMENT *S = GMT_Alloc_Segment (GMT->parent, GMT_NO_STRINGS, 5, 2, NULL, NULL);
gmtspatial.c:				S->data[GMT_X][0] = S->data[GMT_X][3] = S->data[GMT_X][4] = GMT->common.R.wesn[XLO];
gmtspatial.c:				S->data[GMT_X][1] = S->data[GMT_X][2] = GMT->common.R.wesn[XHI];
gmtspatial.c:				S->data[GMT_Y][0] = S->data[GMT_Y][1] = S->data[GMT_Y][4] = GMT->common.R.wesn[YLO];
gmtspatial.c:				S->data[GMT_Y][2] = S->data[GMT_Y][3] = GMT->common.R.wesn[YHI];
gmtspatial.c:					DX = MIN (fabs (S->data[GMT_X][row] - GMT->common.R.wesn[XLO]), fabs (S->data[GMT_X][row] - GMT->common.R.wesn[XHI]));
gmtspatial.c:					DY = MIN (fabs (S->data[GMT_Y][row] - GMT->common.R.wesn[YLO]), fabs (S->data[GMT_Y][row] - GMT->common.R.wesn[YHI]));
gmtspatial.c:							strncpy (GMT->current.io.segment_header, S->header, GMT_BUFSIZ-1);
gmtspatial.c:			GMT->current.io.multi_segments[GMT_OUT] = true;	/* To ensure we can write headers */
gmtspatial.c:				S1->data[GMT_X][0] = S1->data[GMT_X][3] = S1->data[GMT_X][4] = GMT->common.R.wesn[XLO];
gmtspatial.c:				S1->data[GMT_X][1] = S1->data[GMT_X][2] = GMT->common.R.wesn[XHI];
gmtspatial.c:				S1->data[GMT_Y][0] = S1->data[GMT_Y][1] = S1->data[GMT_Y][4] = GMT->common.R.wesn[YLO];
gmtspatial.c:				S1->data[GMT_Y][2] = S1->data[GMT_Y][3] = GMT->common.R.wesn[YHI];
gmtspatial.c:		sprintf (fmt, "%s%s%s%s%s%s%s%s%%s%s%%s\n", GMT->current.setting.format_float_out, GMT->current.setting.io_col_separator, GMT->current.setting.format_float_out, \
gmtspatial.c:			GMT->current.setting.io_col_separator, GMT->current.setting.format_float_out, GMT->current.setting.io_col_separator, GMT->current.setting.format_float_out, \
gmtspatial.c:			GMT->current.setting.io_col_separator, GMT->current.setting.io_col_separator);
gmtspatial.c:										if (first && GMT->current.io.multi_segments[GMT_OUT]) {	/* Must find unique edges to output only once */
gmtspatial.c:												strncpy (GMT->current.io.segment_header, S2->header, GMT_BUFSIZ-1);
gmtspatial.c:												sprintf (GMT->current.io.segment_header, "New segment");
gmtspatial.c:									if (first && GMT->current.io.multi_segments[GMT_OUT]) {	/* Must find unique edges to output only once */
gmtspatial.c:											strncpy (GMT->current.io.segment_header, S2->header, GMT_BUFSIZ-1);
gmtspatial.c:											sprintf (GMT->current.io.segment_header, "New segment");
gmtspatial.c:											if (first && GMT->current.io.multi_segments[GMT_OUT]) {	/* Must find unique edges to output only once */
gmtspatial.c:													strncpy (GMT->current.io.segment_header, S2->header, GMT_BUFSIZ-1);
gmtspatial.c:													sprintf (GMT->current.io.segment_header, "New segment");
gmtspatial.c:									sprintf (record, "%s-%" PRIu64 "%s%s-%" PRIu64, TH1->file[GMT_IN], seg1, GMT->current.setting.io_col_separator, TH2->file[GMT_IN], seg2);
gmtspatial.c:									sprintf (record, "%s%s%s", TH1->file[GMT_IN], GMT->current.setting.io_col_separator, TH2->file[GMT_IN]);
gmtspatial.c:								if (GMT->current.io.multi_segments[GMT_OUT]) {	/* Must find unique edges to output only once */
gmtspatial.c:										strncpy (GMT->current.io.segment_header, S2->header, GMT_BUFSIZ-1);
gmtspatial.c:										sprintf (GMT->current.io.segment_header, "New segment");
gmtspatial.c:			S2 = GMT_Alloc_Segment (GMT->parent, smode, 0, C->n_columns, NULL, NULL);
gmtspatial.c:		         GMT->current.setting.format_float_out);
gmtspatial.c:		if (!GMT->common.J.active) {	/* -J not specified, set one implicitly */
gmtspatial.c:		if (gmt_M_err_pass (GMT, gmt_proj_setup (GMT, GMT->common.R.wesn), "")) Return (GMT_RUNTIME_ERROR);
gmtspatial.c:				if ((np = (*GMT->current.map.clip) (GMT, S->data[GMT_X], S->data[GMT_Y], S->n_rows, &cp[GMT_X], &cp[GMT_Y], &nx)) == 0) {
gmtspatial.c:				if (np > S->n_rows) S = GMT_Alloc_Segment (GMT->parent, smode, np, S->n_columns, NULL, S);
gmtvector.c:	struct GMTAPI_CTRL *API = GMT->parent;
gmtvector.c:	if (GMT->common.b.active[GMT_IN] && GMT->common.b.ncol[GMT_IN] == 0) GMT->common.b.ncol[GMT_IN] = n_in;
gmtvector.c:	n_errors += gmt_M_check_condition (GMT, GMT->common.b.active[GMT_IN] && GMT->common.b.ncol[GMT_IN] < n_in, "Syntax error: Binary input data (-bi) must have at least %d columns\n", n_in);
gmtvector.c:	ix = (GMT->current.setting.io_lonlat_toggle[GMT_IN]);	iy = 1 - ix;
gmtvector.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Bad vector argument (%s)\n", arg);
gmtvector.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Failed to decode the geographic coordinates (%s)\n", arg);
gmtvector.c:		GMT_Message (GMT->parent, GMT_TIME_NONE, "Eigenvalue routine failed to converge in 50 sweeps.\n");
gmtvector.c:	scl = (n_components == 3) ? GMT->current.proj.DIST_KM_PR_DEG * R2D * sqrt (gmt_chi2crit (GMT, conf, 3)) : sqrt (gmt_chi2crit (GMT, conf, 2));
gmtvector.c:	GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "%g%% confidence ellipse on mean position: Major axis = %g Minor axis = %g Major axis azimuth = %g\n", 100.0 * conf, E[1], E[2], E[0]);
gmtwhich.c:						GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Download mode %s not recognized\n", opt->arg);
gmtwrite.c:							GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Unrecognized data type %c.  Choose from c, d, g, i, and p\n", opt->arg[0]);
gmtwrite.c:						GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Unrecognized data type %c.  Choose from c, d, g, i, and p\n", opt->arg[0]);
grd2cpt.c:	C->G.z_low = C->G.z_high = GMT->session.d_NaN;	/* No truncation */
grd2cpt.c:	const char *H_OPT = (API->GMT->current.setting.run_mode == GMT_MODERN) ? " [-H]" : "";
grd2cpt.c:	if (API->GMT->current.setting.run_mode == GMT_MODERN)
grd2cpt.c:	struct GMTAPI_CTRL *API = GMT->parent;
grd2cpt.c:	if (Ctrl->H.active && GMT->current.setting.run_mode == GMT_CLASSIC) {
grd2cpt.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Unrecognized option -H\n");
grd2cpt.c:		Ctrl->C.file = strdup (GMT->init.cpt[0]);
grd2cpt.c:	write = (GMT->current.setting.run_mode == GMT_CLASSIC || Ctrl->H.active);	/* Only output to stdout in classic mode and with -H in modern mode */
grd2cpt.c:	if (GMT->common.R.active[RSET]) gmt_M_memcpy (wesn, GMT->common.R.wesn, 4, double);	/* Subset */
grd2cpt.c:						G[k]->data[ij] = GMT->session.f_NaN;
grd2cpt.c:		         GMT->current.setting.format_float_out, GMT->current.setting.format_float_out);
grd2cpt.c:	if (gmt_M_is_verbose (GMT, GMT_MSG_LONG_VERBOSE)) sprintf (format, "z = %s and CDF(z) = %s\n", GMT->current.setting.format_float_out, GMT->current.setting.format_float_out);
grd2kml.c:					GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -A: Must be positive!\n");
grd2kml.c:					GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -F: Choose among b, c, g, m!\n");
grd2kml.c:					GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -I: Requires a valid grid file or a constant\n");
grd2kml.c:					GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -L: Must be radix 2!\n");
grd2kml.c:						GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -M: Must be positive!\n");
grd2kml.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Grid must be geographic (lon, lat)\n");
grd2kml.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Grid spacing must be the same in longitude and latitude!\n");
grd2kml.c:		strcpy (GMT->current.setting.format_geo_out, "ddd:mm");
grd2kml.c:		strcpy (GMT->current.setting.format_geo_out, "ddd:mm:ss");
grd2kml.c:		strcpy (GMT->current.setting.format_geo_out, "ddd:mm:ss.x");
grd2kml.c:		strcpy (GMT->current.setting.format_float_out, "%.16g");
grd2kml.c:		strcpy (GMT->current.setting.format_geo_out, "D");
grd2kml.c:	GMT->current.io.geo.range = (G->header->wesn[XLO] < 0.0 && G->header->wesn[XHI] > 0.0) ? ((G->header->wesn[XHI] > 180.0) ? GMT_IS_GIVEN_RANGE : GMT_IS_M180_TO_P180_RANGE) : GMT_IS_0_TO_P360_RANGE;
grd2kml.c:		GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Level %d: Factor = %g Dim = %d x %d -> %d x %d\n",
grd2kml.c:			GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Level %d: Filtering down the grid(s)\n", level);
grd2kml.c:				GMT->current.io.geo.range = (west < 0.0 && east > 0.0) ? ((east > 180.0) ? GMT_IS_GIVEN_RANGE : GMT_IS_M180_TO_P180_RANGE) : GMT_IS_0_TO_P360_RANGE;
grd2kml.c:						GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Level %d: Mapped tile %s\n", level, region);
grd2kml.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Summary Level %d: %d by %d = %d tiles, %d mapped, %d empty\n", level, row, col, row*col, row*col - n_skip, n_skip);
grd2kml.c:	GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Found %d tiles that passed the no-NaN test but gave a blank image (?)\n", n_bummer);
grd2kml.c:	GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Processes quadtree links for %d tiles.\n", n);
grd2kml.c:				GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Tile %s: Unable to link tile for row = %d, col = %d at level %d to a parent (!?).  Probably empty - skipped.\n", Q[k]->tag, row, col, level);
grd2kml.c:				GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Tile %s: Region was %g/%g/%g/%g.\n", Q[k]->tag, Q[k]->wesn[XLO], Q[k]->wesn[XHI], Q[k]->wesn[YLO], Q[k]->wesn[YHI]);
grd2kml.c:	fprintf (fp, "    <!-- cmd: gmt %s %s -->\n", GMT->init.module_name, cmd_args);
grd2xyz.c:	struct GMTAPI_CTRL *API = GMT->parent;
grd2xyz.c:					gmt_M_memset (GMT->current.io.io_nan_col, GMT_MAX_COLUMNS, int);
grd2xyz.c:					GMT->current.io.io_nan_col[0] = GMT_Z;	/* The default is to examine the z-column */
grd2xyz.c:					GMT->current.io.io_nan_ncols = GMT_IO_NAN_SKIP;		/* Default is that single z column */
grd2xyz.c:					GMT->current.setting.io_nan_mode = 1;	/* Plain -S */
grd2xyz.c:					if (opt->arg[0] == 'r') GMT->current.setting.io_nan_mode = GMT_IO_NAN_KEEP;	/* Old -Sr */
grd2xyz.c:					GMT->common.s.active = true;
grd2xyz.c:	gmt_M_memcpy (wesn, GMT->common.R.wesn, 4, double);	/* Current -R setting, if any */
grd2xyz.c:	if (GMT->common.b.active[GMT_OUT]) {
grd2xyz.c:			GMT->common.b.active[GMT_OUT] = false;
grd2xyz.c:			GMT->common.b.active[GMT_OUT] = false;
grd2xyz.c:	else if (io.binary) GMT->common.b.active[GMT_OUT] = true;
grd2xyz.c:			bool previous = GMT->common.b.active[GMT_OUT], rst = false;
grd2xyz.c:			save = GMT->current.io.output;
grd2xyz.c:			GMT->current.io.output = gmt_z_output;		/* Override and use chosen output mode */
grd2xyz.c:			GMT->common.b.active[GMT_OUT] = io.binary;	/* May have to set binary as well */
grd2xyz.c:			GMT->current.setting.io_lonlat_toggle[GMT_OUT] = false;	/* Since no x,y involved here */
grd2xyz.c:			if (GMT->current.setting.io_nan_mode && GMT->current.io.io_nan_col[0] == GMT_Z) 
grd2xyz.c:				{rst = true; GMT->current.io.io_nan_col[0] = GMT_X;}	/* Since we don't do xy here, only z */
grd2xyz.c:				if (GMT->common.d.active[GMT_OUT] && gmt_M_is_dnan (d_value))	/* Grid node is NaN and -d was set, so change to nan-proxy */
grd2xyz.c:					d_value = GMT->common.d.nan_proxy[GMT_OUT];
grd2xyz.c:					d_value = GMT->session.d_NaN;
grd2xyz.c:			GMT->current.io.output = save;			/* Reset pointer */
grd2xyz.c:			GMT->common.b.active[GMT_OUT] = previous;	/* Reset binary */
grd2xyz.c:			if (rst) GMT->current.io.io_nan_col[0] = GMT_Z;	/* Reset to what it was */
grd2xyz.c:				sprintf (item, GMT->current.setting.format_float_out, G->header->wesn[XLO]);
grd2xyz.c:				sprintf (item, GMT->current.setting.format_float_out, G->header->wesn[YLO]);
grd2xyz.c:				sprintf (item, GMT->current.setting.format_float_out, G->header->wesn[XLO]);
grd2xyz.c:				sprintf (item, GMT->current.setting.format_float_out, G->header->wesn[YLO]);
grd2xyz.c:			sprintf (item, GMT->current.setting.format_float_out, G->header->inc[GMT_X]);
grd2xyz.c:						sprintf (item, GMT->current.setting.format_float_out, G->data[ij]);
grd2xyz.c:					GMT->current.io.io_nan_col[0] = GMT_Y;	/* Since that is where z will go now */
grd2xyz.c:			if (GMT->current.setting.io_header[GMT_OUT] && first) {
grd2xyz.c:				if (GMT->current.setting.io_lonlat_toggle[GMT_IN])
grd2xyz.c:					sprintf (header, "%s%s%s%s%s", G->header->y_units, GMT->current.setting.io_col_separator, G->header->x_units, GMT->current.setting.io_col_separator, G->header->z_units);
grd2xyz.c:					sprintf (header, "%s%s%s%s%s", G->header->x_units, GMT->current.setting.io_col_separator, G->header->y_units, GMT->current.setting.io_col_separator, G->header->z_units);
grd2xyz.c:					strcat (header, GMT->current.setting.io_col_separator);
grd2xyz.c:					if (GMT->common.d.active[GMT_OUT] && gmt_M_is_dnan (out[GMT_Y]))	/* Input matched no-data setting, so change to NaN */
grd2xyz.c:						out[GMT_Y] = GMT->common.d.nan_proxy[GMT_OUT];
grd2xyz.c:						out[GMT_Y] = GMT->session.d_NaN;
grd2xyz.c:					if (GMT->common.d.active[GMT_OUT] && gmt_M_is_dnan (out[GMT_Z]))	/* Input matched no-data setting, so change to NaN */
grd2xyz.c:						out[GMT_Z] = GMT->common.d.nan_proxy[GMT_OUT];
grd2xyz.c:						out[GMT_Z] = GMT->session.d_NaN;
grd2xyz.c:		if (GMT->current.setting.io_nan_mode == GMT_IO_NAN_KEEP)
grdblend.c:			GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Very odd - should not happen [format = %s]. Post a note on the gmt user forum\n", not_supported[i]);
grdblend.c:			GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Grid format type %s for file %s is not supported for row-by-row i/o.\n", not_supported[i], file);
grdblend.c:			GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "We will create a temporary output file which will be converted (via grdconvert) to your chosen format.\n");
grdblend.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "File %s entirely outside longitude range of final grid region (skipped)\n", B->file);
grdblend.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "File %s %s region needed longitude adjustment to fit final grid region\n", B->file, type[mode]);
grdblend.c:			if ((In = GMT_Get_Record (GMT->parent, GMT_READ_TEXT, NULL)) == NULL) {	/* Read next record, get NULL if special case */
grdblend.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Read error for blending parameters near row %d\n", n);
grdblend.c:			if (gmt_file_is_srtmtile (GMT->parent, L[n].file, &res)) {
grdblend.c:			GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Downloading SRTM%d tile %d of %d [%s]\n", srtm_res, ++down, n_download, tile);
grdblend.c:		if ((B[n].G = GMT_Read_Data (GMT->parent, GMT_IS_GRID, GMT_IS_FILE, GMT_IS_SURFACE, GMT_CONTAINER_ONLY|GMT_GRID_ROW_BY_ROW, NULL, B[n].file, NULL)) == NULL) {
grdblend.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Internal snafu - please report the problem on the GMT issues page\n");
grdblend.c:			GMT_Report (GMT->parent, GMT_MSG_VERBOSE,
grdblend.c:		gmt_M_grd_setpad (GMT, h, GMT->current.io.pad); /* Assign default pad */
grdblend.c:			GMT_Report (GMT->parent, GMT_MSG_VERBOSE,
grdblend.c:			GMT_Report (GMT->parent, GMT_MSG_VERBOSE,
grdblend.c:			GMT_Report (GMT->parent, GMT_MSG_VERBOSE,
grdblend.c:			GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "File %s has different increments (%.12g/%.12g) than the output grid (%.12g/%.12g) - must resample\n",
grdblend.c:			GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "File %s coordinates are phase-shifted w.r.t. the output grid - must resample\n", B[n].file);
grdblend.c:			GMT_Report (GMT->parent, GMT_MSG_DEBUG, "File %s is sampled using region %s\n", B[n].file, Rargs);
grdblend.c:				if (GMT->parent->tmp_dir)	/* Use the established temp directory */
grdblend.c:					sprintf (buffer, "%s/grdblend_resampled_%d_%d.nc", GMT->parent->tmp_dir, (int)getpid(), n);
grdblend.c:				         Iargs, Rargs, buffer, V_level[GMT->current.setting.verbose]);
grdblend.c:				GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Resample %s via grdsample %s\n", B[n].file, cmd);
grdblend.c:				if ((status = GMT_Call_Module (GMT->parent, "grdsample", GMT_MODULE_CMD, cmd))) {	/* Resample the file */
grdblend.c:					GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Unable to resample file %s - exiting\n", B[n].file);
grdblend.c:					GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE,
grdblend.c:				if (GMT->parent->tmp_dir)	/* Use the established temp directory */
grdblend.c:					sprintf (buffer, "%s/grdblend_reformatted_%d_%d.nc", GMT->parent->tmp_dir, (int)getpid(), n);
grdblend.c:				snprintf (cmd, GMT_LEN256, "%s %s %s -V%c", B[n].file, Rargs, buffer, V_level[GMT->current.setting.verbose]);
grdblend.c:				GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Reformat %s via grdconvert %s\n", B[n].file, cmd);
grdblend.c:				if ((status = GMT_Call_Module (GMT->parent, "grdconvert", GMT_MODULE_CMD, cmd))) {	/* Resample the file */
grdblend.c:					GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Unable to resample file %s - exiting\n", B[n].file);
grdblend.c:			if (GMT_Destroy_Data (GMT->parent, &B[n].G))
grdblend.c:			if ((B[n].G = GMT_Read_Data (GMT->parent, GMT_IS_GRID, GMT_IS_FILE, GMT_IS_SURFACE, GMT_CONTAINER_ONLY|GMT_GRID_ROW_BY_ROW, NULL, B[n].file, NULL)) == NULL) {
grdblend.c:			type = GMT->session.grdformat[B[n].G->header->type][0];
grdblend.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Grid %s: out: %d/%d/%d/%d in: %d/%d/%d/%d skip: %d offset: %d\n",
grdblend.c:		GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Blend file %s in %g/%g/%g/%g with %s weight %g [%d-%d]\n",
grdblend.c:		if (!B[n].memory && GMT_Destroy_Data (GMT->parent, &B[n].G)) return (-1);	/* Free grid unless it is a memory grid */
grdblend.c:				if (GMT_Destroy_Data (GMT->parent, &B[k].G)) return GMT_NOERROR;
grdblend.c:						GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Failed to delete file %s\n", B[k].file); 
grdblend.c:				if ((B[k].G = GMT_Read_Data (GMT->parent, GMT_IS_GRID, GMT_IS_FILE, GMT_IS_SURFACE, GMT_CONTAINER_ONLY|GMT_GRID_ROW_BY_ROW, NULL, B[k].file, NULL)) == NULL) {
grdblend.c:			GMT_Get_Row (GMT->parent, 0, B[k].G, B[k].z);	/* Get one row from this file */
grdblend.c:	C->N.nodata = GMT->session.d_NaN;
grdblend.c:	struct GMTAPI_CTRL *API = GMT->parent;
grdblend.c:					Ctrl->N.nodata = (opt->arg[0] == 'N' || opt->arg[0] == 'n') ? GMT->session.d_NaN : atof (opt->arg);
grdblend.c:	n_errors += gmt_M_check_condition (GMT, !GMT->common.R.active[RSET], "Syntax error -R option: Must specify region\n");
grdblend.c:	n_errors += gmt_M_check_condition (GMT, GMT->common.R.inc[GMT_X] <= 0.0 || GMT->common.R.inc[GMT_Y] <= 0.0,
grdblend.c:	if (GMT->common.R.active[RSET] && GMT->common.R.active[ISET]) {	/* Set output grid via -R -I [-r] */
grdblend.c:	type = GMT->session.grdformat[Grid->header->type][0];
grdblend.c:		GMT_Report (API, GMT_MSG_NORMAL, "Syntax error -Q option: Not supported for grid format %s\n", GMT->session.grdformat[Grid->header->type]);
grdblend.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Failed to delete file %s\n", blend[k].file); 
grdblend.c:		sprintf (cmd, "%s %s -V%c --GMT_HISTORY=false", outfile, Ctrl->G.file, V_level[GMT->current.setting.verbose]);
grdblend.c:		if ((status = GMT_Call_Module (GMT->parent, "grdconvert", GMT_MODULE_CMD, cmd))) {	/* Resample the file */
grdblend.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Failed to delete file %s\n", outfile); 
grdclip.c:	struct GMTAPI_CTRL *API = GMT->parent;
grdclip.c:						Ctrl->S.above = (txt[0] == 'N' || txt[0] == 'n') ? GMT->session.f_NaN : (gmt_grdfloat)atof (txt);
grdclip.c:						Ctrl->S.below = (txt[0] == 'N' || txt[0] == 'n') ? GMT->session.f_NaN : (gmt_grdfloat)atof (txt);
grdclip.c:							Ctrl->S.class[n_class].between = (txt[0] == 'N' || txt[0] == 'n') ? GMT->session.f_NaN : (gmt_grdfloat)atof (txt);
grdclip.c:							Ctrl->S.class[n_class].between = (txt[0] == 'N' || txt[0] == 'n') ? GMT->session.f_NaN : (gmt_grdfloat)atof (txt);
grdclip.c:	gmt_M_memcpy (wesn, GMT->common.R.wesn, 4, double);	/* Current -R setting, if any */
grdclip.c:			sprintf (buffer, "< %s set to %s\n", GMT->current.setting.format_float_out, GMT->current.setting.format_float_out);
grdclip.c:			sprintf (buffer, "between %s and %s set to %s\n", GMT->current.setting.format_float_out, 
grdclip.c:				GMT->current.setting.format_float_out, GMT->current.setting.format_float_out);
grdclip.c:			sprintf (buffer, "equal to %s set to %s\n", GMT->current.setting.format_float_out, GMT->current.setting.format_float_out);
grdclip.c:			sprintf (buffer, "> %s set to %s\n", GMT->current.setting.format_float_out, GMT->current.setting.format_float_out);
grdcontour.c:	C->A.single_cont = GMT->session.d_NaN;
grdcontour.c:	C->C.single_cont = GMT->session.d_NaN;
grdcontour.c:	C->T.dim[GMT_X] = TICKED_SPACING * GMT->session.u2u[GMT_PT][GMT_INCH];	/* 14p */
grdcontour.c:	C->T.dim[GMT_Y] = TICKED_LENGTH  * GMT->session.u2u[GMT_PT][GMT_INCH];	/* 3p */
grdcontour.c:	C->W.pen[0] = C->W.pen[1] = GMT->current.setting.map_default_pen;
grdcontour.c:	P = API->GMT->current.setting.map_default_pen;
grdcontour.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL,
grdcontour.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL,
grdcontour.c:	struct GMTAPI_CTRL *API = GMT->parent;
grdcontour.c:				if (GMT->current.setting.run_mode == GMT_MODERN && gmt_M_no_cpt_given (opt->arg))
grdcontour.c:	n_errors += gmt_M_check_condition (GMT, !GMT->common.J.active && !Ctrl->D.active,
grdcontour.c:				PSL_plottext (PSL, x_lbl, y_lbl, GMT->current.setting.font_annot[GMT_PRIMARY].size, lbl[save[pol].high], 0.0, PSL_MC, form);
grdcontour.c:				PSL_plottext (PSL, save[pol].xlabel, save[pol].ylabel, GMT->current.setting.font_annot[GMT_PRIMARY].size, lbl[save[pol].high], 0.0, PSL_MC, form);
grdcontour.c:				GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Unable to adjust hill label contour orientation (node point on contour)\n");
grdcontour.c:				GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Unable to adjust hill label contour orientation (node value = contour value)\n");
grdcontour.c:		if (API->GMT->current.setting.run_mode == GMT_CLASSIC) strcat (cmd1, " -K");	/* If classic mode then we need to say we will append more PostScript later */
grdcontour.c:		if (API->GMT->current.setting.run_mode == GMT_CLASSIC) strcat (cmd2, " -O");	/* If classic mode then we need to say we this is an overlay */
grdcontour.c:	GMT->current.map.z_periodic = Ctrl->Z.periodic;	/* Phase data */
grdcontour.c:	if (!GMT->common.R.active[RSET])	/* -R was not set so we use the grid domain */
grdcontour.c:	if (need_proj && gmt_map_setup (GMT, GMT->common.R.wesn)) Return (GMT_PROJECTION_ERROR);
grdcontour.c:			gmt_plane_perspective (GMT, GMT->current.proj.z_project.view_plane, GMT->current.proj.z_level);
grdcontour.c:		gmt_M_memcpy (&Clock, &GMT->current.io.clock_output, 1, struct GMT_CLOCK_IO);
grdcontour.c:		gmt_M_memcpy (&Date, &GMT->current.io.date_output, 1, struct GMT_DATE_IO);
grdcontour.c:		gmt_M_memcpy (&GMT->current.io.clock_output, &GMT->current.plot.calclock.clock, 1, struct GMT_CLOCK_IO);
grdcontour.c:		gmt_M_memcpy (&GMT->current.io.date_output,  &GMT->current.plot.calclock.date, 1, struct GMT_DATE_IO);
grdcontour.c:		tmp = GMT->current.setting.time_system.epoch_t0; GMT->current.setting.time_system.epoch_t0 = 0.0;	/* Save */
grdcontour.c:		t_epoch_unit = gmt_rdc2dt (GMT, GMT->current.setting.time_system.rata_die, tmp * GMT_DAY2SEC_F);	/* Epoch in user units */
grdcontour.c:		GMT->current.setting.time_system.epoch_t0 = tmp;	/* Restore */
grdcontour.c:			gmt_plane_perspective (GMT, GMT->current.proj.z_project.view_plane, GMT->current.proj.z_level);
grdcontour.c:			cont[c].angle = (Ctrl->contour.angle_type == 2) ? Ctrl->contour.label_angle : GMT->session.d_NaN;
grdcontour.c:		cont[c].angle = (Ctrl->contour.angle_type == 2) ? Ctrl->contour.label_angle : GMT->session.d_NaN;
grdcontour.c:			cont[c].angle = (Ctrl->contour.angle_type == 2) ? Ctrl->contour.label_angle : GMT->session.d_NaN;
grdcontour.c:			cont[c+nc].angle = (Ctrl->contour.angle_type == 2) ? Ctrl->contour.label_angle : GMT->session.d_NaN;
grdcontour.c:			cont[n_contours].angle = (got == 3) ? tmp : GMT->session.d_NaN;
grdcontour.c:			cont[n_contours].angle = (Ctrl->contour.angle_type == 2) ? Ctrl->contour.label_angle : GMT->session.d_NaN;
grdcontour.c:		if (!GMT->current.map.z_periodic && min < G->header->z_min) min += Ctrl->C.interval;
grdcontour.c:			cont[n_contours].angle = (Ctrl->contour.angle_type == 2) ? Ctrl->contour.label_angle : GMT->session.d_NaN;
grdcontour.c:	if (GMT->current.map.z_periodic && n_contours > 1 && fabs (cont[n_contours-1].val - cont[0].val - 360.0) < GMT_CONV4_LIMIT) {	/* Get rid of redundant contour */
grdcontour.c:			gmt_plane_perspective (GMT, GMT->current.proj.z_project.view_plane, GMT->current.proj.z_level);
grdcontour.c:	for (i = 0; i < 3; i++) GMT->current.io.col_type[GMT_OUT][i] = gmt_M_type (GMT, GMT_IN, i);	/* Used if -D is set */
grdcontour.c:		if (Ctrl->contour.delay) GMT->current.ps.nclip = +2;	/* Signal that this program initiates clipping that will outlive this process */
grdcontour.c:		gmt_plane_perspective (GMT, GMT->current.proj.z_project.view_plane, GMT->current.proj.z_level);
grdcontour.c:		gmt_map_clip_on (GMT, GMT->session.no_rgb, 3);
grdcontour.c:		while ((n = (unsigned int)gmt_contours (GMT, G, Ctrl->S.value, GMT->current.setting.interpolant, Ctrl->F.value, edge, &begin, &x, &y)) > 0) {
grdcontour.c:		gmt_M_memcpy (&GMT->current.io.clock_output, &Clock, 1, struct GMT_CLOCK_IO);
grdcontour.c:		gmt_M_memcpy (&GMT->current.io.date_output, &Date, 1, struct GMT_DATE_IO);
grdcontour.c:	if (GMT_Destroy_Data (GMT->parent, &G_orig) != GMT_NOERROR) {
grdconvert.c:	struct GMTAPI_CTRL *API = GMT->parent;
grdconvert.c:		GMT_Report (API, GMT_MSG_NORMAL, "Writing unsupported: %s\n", GMT->session.grdformat[GMT_GRID_IS_SD]);
grdconvert.c:		            fname[GMT_IN], GMT->session.grdformat[type[GMT_IN]], fname[GMT_OUT], GMT->session.grdformat[type[GMT_OUT]]);
grdconvert.c:		if (hmode && GMT->session.grdformat[type[GMT_OUT]][0] != 'c' && GMT->session.grdformat[type[GMT_OUT]][0] != 'n')
grdconvert.c:	if (GMT->common.R.active[RSET]) {	/* Specified a subset */
grdconvert.c:		if (!global && (GMT->common.R.wesn[XLO] < (Grid->header->wesn[XLO]-noise[GMT_X]) || GMT->common.R.wesn[XHI] > (Grid->header->wesn[XHI]+noise[GMT_X]))) error++;
grdconvert.c:		if (GMT->common.R.wesn[YLO] < (Grid->header->wesn[YLO]-noise[GMT_Y]) || GMT->common.R.wesn[YHI] > (Grid->header->wesn[YHI]+noise[GMT_Y])) error++;
grdconvert.c:		if (GMT_Read_Data (API, GMT_IS_GRID, GMT_IS_FILE, GMT_IS_SURFACE, GMT_DATA_ONLY, GMT->common.R.wesn, Ctrl->In.file, Grid) == NULL) {
grdconvert.c:	if (!GMT->common.R.active[RSET] && ((type[GMT_IN]  >= GMT_GRID_IS_CB && type[GMT_IN]  <= GMT_GRID_IS_CD)  ||	/* That is, from netCDF to netCDF */
grdcut.c:	C->N.value = GMT->session.f_NaN;
grdcut.c:					Ctrl->N.value = (opt->arg[0] == 'N' || opt->arg[0] == 'n') ? GMT->session.f_NaN : (gmt_grdfloat)atof (opt->arg);
grdcut.c:	n_errors += gmt_M_check_condition (GMT, (GMT->common.R.active[RSET] + Ctrl->S.active + Ctrl->Z.active) != 1,
grdcut.c:	GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Nans found: W = %d E = %d S = %d N = %d\n",
grdcut.c:	gmt_M_memcpy (wesn, GMT->common.R.wesn, 4, double);	/* Default is to take the -R as given */
grdcut.c:	if (GMT->common.R.oblique == false || GMT->current.proj.projection == GMT_NO_PROJ) return GMT_NOERROR;	/* Nothing else to do */
grdcut.c:	gmt_wesn_search (GMT, GMT->current.proj.rect[XLO], GMT->current.proj.rect[XHI], GMT->current.proj.rect[YLO],
grdcut.c:	                 GMT->current.proj.rect[YHI], &GMT->common.R.wesn[XLO], &GMT->common.R.wesn[XHI],
grdcut.c:					 &GMT->common.R.wesn[YLO], &GMT->common.R.wesn[YHI]);
grdcut.c:	wesn[XLO] = floor (GMT->common.R.wesn[XLO] / inc[GMT_X]) * inc[GMT_X];
grdcut.c:	wesn[XHI] = ceil  (GMT->common.R.wesn[XHI] / inc[GMT_X]) * inc[GMT_X];
grdcut.c:	wesn[YLO] = floor (GMT->common.R.wesn[YLO] / inc[GMT_Y]) * inc[GMT_Y];
grdcut.c:	wesn[YHI] = ceil  (GMT->common.R.wesn[YHI] / inc[GMT_Y]) * inc[GMT_Y];
grdcut.c:		GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "%s -> -R%d:%02d/%d:%02d/%d:%02d/%d:%02d\n",
grdcut.c:		            GMT->common.R.string, w, wm, e, em, s, sm, n, nm);
grdcut.c:		GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "%s -> -R%d:%02d:%02d/%d:%02d:%02d/%d:%02d:%02d/%d:%02d:%02d\n",
grdcut.c:		            GMT->common.R.string, w, wm, ws, e, em, es, s, sm, ss, n, nm, ns);
grdcut.c:		GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "%s -> -R%g/%g/%g/%g\n",
grdcut.c:		            GMT->common.R.string, wesn[XLO], wesn[XHI], wesn[YLO], wesn[YHI]);
grdcut.c:		radius = R2D * (Ctrl->S.radius / GMT->current.map.dist[GMT_MAP_DIST].scale) / GMT->current.proj.mean_radius;	/* Approximate radius in degrees */
grdcut.c:		gmt_M_memcpy (def_pad, GMT->current.io.pad, 4, unsigned int);	/* Default pad */
grdcut.c:		gmt_M_memcpy (GMT->current.io.pad, pad, 4, unsigned int);	/* Change default pad */
grdcut.c:		gmt_M_memcpy (GMT->current.io.pad, def_pad, 4, unsigned int);	/* Reset default pad */
grdcut.c:		gmt_M_grd_setpad (GMT, G->header, GMT->current.io.pad);	/* Set the default pad */
grdcut.c:		sprintf (format, "\t%s\t%s\t%s\t%s\t%s\t%s\t%%d\t%%d\n", GMT->current.setting.format_float_out,
grdcut.c:		         GMT->current.setting.format_float_out, GMT->current.setting.format_float_out,
grdcut.c:		         GMT->current.setting.format_float_out, GMT->current.setting.format_float_out,
grdcut.c:		         GMT->current.setting.format_float_out);
grdcut.c:					G->data[node] = GMT->session.f_NaN;
grdedit.c:					GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax Error -E: Unrecognized modifier %c\n", opt->arg[0]);
grdedit.c:	n_errors += gmt_M_check_condition (GMT, Ctrl->S.active && !GMT->common.R.active[RSET],
grdedit.c:	n_errors += gmt_M_check_condition (GMT, Ctrl->S.active && !gmt_M_360_range (GMT->common.R.wesn[XLO], GMT->common.R.wesn[XHI]),
grdedit.c:	if ((do_J = GMT->common.J.active)) {	/* Only gave -J to set the proj4 flag, so grid is already projected (i.e., Cartesian) */
grdedit.c:			gmt_parse_R_option (GMT, GMT->common.R.string);	/* Since parsing under -J would have imposed checks. */
grdedit.c:		GMT->current.proj.projection = GMT->current.proj.projection_GMT = GMT_NO_PROJ;
grdedit.c:		GMT->common.J.active = false;	/* Leave no trace of this, except in the history... */
grdedit.c:		shift_amount = GMT->common.R.wesn[XLO] - G->header->wesn[XLO];
grdedit.c:		if (GMT->common.R.active[RSET]) {
grdedit.c:				out_file, GMT->common.R.wesn[XLO], GMT->common.R.wesn[XHI], GMT->common.R.wesn[YLO], GMT->common.R.wesn[YHI]);
grdedit.c:			gmt_M_memcpy (G->header->wesn, GMT->common.R.wesn, 4, double);
grdfft.c: *		have been generalized and made available GMT-wide via new functions
grdfft.c:	if ((D = GMT_Create_Data (GMT->parent, GMT_IS_DATASET, GMT_IS_NONE, 0, dim, NULL, NULL, 0, 0, NULL)) == NULL) {
grdfft.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Unable to create a data set for spectral estimates\n");
grdfft.c:		return (GMT->parent->error);
grdfft.c:	if (GMT->common.h.add_colnames) {
grdfft.c:		if (GMT_Set_Comment (GMT->parent, GMT_IS_DATASET, GMT_COMMENT_IS_COLNAMES, header, D)) return (GMT->parent->error);
grdfft.c:	if (GMT_Write_Data (GMT->parent, GMT_IS_DATASET, GMT_IS_FILE, GMT_IS_NONE, GMT_WRITE_SET, NULL, file, D) != GMT_NOERROR) {
grdfft.c:		return (GMT->parent->error);
grdfft.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Too many slashes in -F.\n");
grdfft.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, " Cannot read token %d.\n", n_tokens);
grdfft.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "-F Cannot find 2-4 tokens separated by slashes.\n");
grdfft.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "-F Wavelengths are not in descending order.\n");
grdfft.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "-F Pass/Cut specification error.\n");
grdfft.c:	struct GMTAPI_CTRL *API = GMT->parent;
grdfill.c:	struct GMTAPI_CTRL *API = GMT->parent;
grdfill.c:	GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Interpolating to nearest neighbor...\n");
grdfill.c: 		GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Working on row %" PRIi64 "\n", i);
grdfill.c:				GMT_Report (GMT->parent, GMT_MSG_DEBUG, "(%d %d %d %d)\n", j, rr, recx, recy);
grdfill.c:	GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "%" PRIi64 " number of searches used\n", cs);
grdfill.c:	if (GMT->common.R.active[RSET]) {	/* Specified a subset */
grdfill.c:		if (!global && (GMT->common.R.wesn[XLO] < Grid->header->wesn[XLO] || GMT->common.R.wesn[XHI] > Grid->header->wesn[XHI])) error++;
grdfill.c:		if (GMT->common.R.wesn[YLO] < Grid->header->wesn[YLO] || GMT->common.R.wesn[YHI] > Grid->header->wesn[YHI]) error++;
grdfill.c:		if (GMT_Read_Data (API, GMT_IS_GRID, GMT_IS_FILE, GMT_IS_SURFACE, GMT_DATA_ONLY, GMT->common.R.wesn, Ctrl->In.file, Grid) == NULL) {
grdfilter.c:	if ((A = GMT_Create_Data (GMT->parent, GMT_IS_GRID, GMT_IS_SURFACE, GMT_CONTAINER_AND_DATA, NULL, G->header->wesn, G->header->inc, \
grdfilter.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Write area weight grid to file %s\n", file);
grdfilter.c:		if (GMT_Set_Comment (GMT->parent, GMT_IS_GRID, GMT_COMMENT_IS_REMARK, "Area weight grid for debugging purposes", A)) return (NULL);
grdfilter.c:		if (GMT_Write_Data (GMT->parent, GMT_IS_GRID, GMT_IS_FILE, GMT_IS_SURFACE, GMT_CONTAINER_AND_DATA, NULL, file, A) != GMT_NOERROR) return (NULL);
grdfilter.c:	struct GMTAPI_CTRL *API = GMT->parent;
grdfilter.c:	n_errors += gmt_M_check_condition (GMT, GMT->common.R.active[ISET] && (GMT->common.R.inc[GMT_X] <= 0.0 || GMT->common.R.inc[GMT_Y] <= 0.0),
grdfilter.c:	n_errors += gmt_M_check_condition (GMT, GMT->common.R.active[RSET] && GMT->common.R.active[ISET] && Ctrl->F.highpass,
grdfilter.c:	n_errors += gmt_M_check_condition (GMT, GMT->common.R.active[GSET] && Ctrl->T.active,
grdfilter.c:	GMT->common.x.n_threads = 1;        /* Default to use only one core (we may change this to max cores) */
grdfilter.c:	if (GMT->common.R.active[GSET])	/* Explicitly set the output registration */
grdfilter.c:		one_or_zero = (GMT->common.R.registration == GMT_GRID_PIXEL_REG) ? 0 : 1;
grdfilter.c:	gmt_M_memcpy (wesn, (GMT->common.R.active[RSET] ? GMT->common.R.wesn : Gin->header->wesn), 4, double);
grdfilter.c:	gmt_M_memcpy (inc, (GMT->common.R.active[ISET] ? GMT->common.R.inc : Gin->header->inc), 2, double);
grdfilter.c:	if (Ctrl->F.custom && GMT->common.x.n_threads > 1)
grdfilter.c:	same_grid = !(GMT->common.R.active[RSET] || GMT->common.R.active[ISET] || Gin->header->registration == one_or_zero);
grdfilter.c:			x_scale = y_scale = GMT->current.proj.DIST_KM_PR_DEG;
grdfilter.c:			x_scale = GMT->current.proj.DIST_KM_PR_DEG * cosd (0.5 * (Gout->header->wesn[YHI] + Gout->header->wesn[YLO]));
grdfilter.c:			y_scale = GMT->current.proj.DIST_KM_PR_DEG;
grdfilter.c:			x_scale = GMT->current.proj.DIST_KM_PR_DEG * ((fabs (Gout->header->wesn[YLO]) > Gout->header->wesn[YHI]) ? cosd (Gout->header->wesn[YLO]) : cosd (Gout->header->wesn[YHI]));
grdfilter.c:			y_scale = GMT->current.proj.DIST_KM_PR_DEG;
grdfilter.c:			x_scale = GMT->current.proj.DIST_KM_PR_DEG * ((fabs (Gin->header->wesn[YLO]) > Gin->header->wesn[YHI]) ? cosd (Gin->header->wesn[YLO]) : cosd (Gin->header->wesn[YHI]));
grdfilter.c:			y_scale = GMT->current.proj.DIST_KM_PR_DEG;
grdfilter.c:			merc_range = LAT2IMG (max_lat + (0.5 * Ctrl->F.width / GMT->current.proj.DIST_KM_PR_DEG)) - LAT2IMG (max_lat);
grdfilter.c:	par[GRDFILTER_Y_SCALE] = (Ctrl->D.mode == GRDFILTER_GEO_MERCATOR) ? GMT->current.proj.DIST_KM_PR_DEG : y_scale;
grdfilter.c:		GMT_Report (API, GMT_MSG_LONG_VERBOSE, "Calculations will be distributed over %d threads.\n", GMT->common.x.n_threads);
grdfilter.c:	if (GMT->common.x.n_threads > 1)
grdfilter.c:		threads = gmt_M_memory (GMT, NULL, GMT->common.x.n_threads, GThread *);
grdfilter.c:	threadArg = gmt_M_memory (GMT, NULL, GMT->common.x.n_threads, struct THREAD_STRUCT);
grdfilter.c:	for (i = 0; i < GMT->common.x.n_threads; i++) {
grdfilter.c:   		threadArg[i].r_start    = i * irint((Gout->header->n_rows) / GMT->common.x.n_threads);
grdfilter.c:		if (GMT->common.x.n_threads == 1) {		/* Independently of WITH_THREADS, if only one don't call the threading machine */
grdfilter.c:   		threadArg[i].r_stop = (i + 1) * irint((Gout->header->n_rows) / GMT->common.x.n_threads);
grdfilter.c:   		if (i == GMT->common.x.n_threads - 1) threadArg[i].r_stop = Gout->header->n_rows;	/* Make sure last row is not left behind */
grdfilter.c:	if (GMT->common.x.n_threads > 1) {		/* Otherwise g_thread_new was never called aand so no need to "join" */
grdfilter.c:		for (i = 0; i < GMT->common.x.n_threads; i++)
grdfilter.c:	if (GMT->common.x.n_threads > 1)
grdfilter.c:		if (GMT->common.R.active[RSET] || GMT->common.R.active[ISET] || GMT->common.R.active[GSET]) {	/* Must resample result so grids are coregistered */
grdfilter.c:			sprintf (cmd, "%s -G%s -R%s -V%c", in_string, out_string, Ctrl->In.file, V_level[GMT->current.setting.verbose]);
grdfilter.c:			GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Calling grdsample with args %s\n", cmd);
grdfilter.c:		Return (GMT->parent->error);
grdfilter.c:		GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Processing output line %d\n", row_out);
grdfilter.c:			par[GRDFILTER_X_SCALE] = GMT->current.proj.DIST_KM_PR_DEG * cosd (lat_out);	/* Update flat-Earth longitude scale */
grdfilter.c:				Gout->data[ij_out] = GMT->session.f_NaN;
grdfilter.c:				Gout->data[ij_out] = GMT->session.f_NaN;
grdfilter.c:					Gout->data[ij_out] = GMT->session.f_NaN;
grdfilter.c:				if (wt_sum == 0.0) {	/* Nothing found inside circle or rectangle, assign value = GMT->session.f_NaN */
grdfilter.c:					Gout->data[ij_out] = GMT->session.f_NaN;
grdfilter.c:	GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Processing output line %d\n", row_out);
grdfilter_mt.c:	if ((A = GMT_Create_Data (GMT->parent, GMT_IS_GRID, GMT_IS_SURFACE, GMT_CONTAINER_AND_DATA, NULL, G->header->wesn, G->header->inc, \
grdfilter_mt.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Write area weight grid to file %s\n", file);
grdfilter_mt.c:		if (GMT_Set_Comment (GMT->parent, GMT_IS_GRID, GMT_COMMENT_IS_REMARK, "Area weight grid for debugging purposes", A)) return (NULL);
grdfilter_mt.c:		if (GMT_Write_Data (GMT->parent, GMT_IS_GRID, GMT_IS_FILE, GMT_IS_SURFACE, GMT_CONTAINER_AND_DATA, NULL, file, A) != GMT_NOERROR) return (NULL);
grdfilter_mt.c:	struct GMTAPI_CTRL *API = GMT->parent;
grdfilter_mt.c:	n_errors += gmt_M_check_condition (GMT, GMT->common.R.active[ISET] && (GMT->common.R.inc[GMT_X] <= 0.0 || GMT->common.R.inc[GMT_Y] <= 0.0),
grdfilter_mt.c:	n_errors += gmt_M_check_condition (GMT, GMT->common.R.active[RSET] && GMT->common.R.active[ISET] && Ctrl->F.highpass,
grdfilter_mt.c:	gmt_M_memcpy (wesn, (GMT->common.R.active[RSET] ? GMT->common.R.wesn : Gin->header->wesn), 4, double);
grdfilter_mt.c:	gmt_M_memcpy (inc, (GMT->common.R.active[ISET] ? GMT->common.R.inc : Gin->header->inc), 2, double);
grdfilter_mt.c:	same_grid = !(GMT->common.R.active[RSET] || GMT->common.R.active[ISET] || Gin->header->registration == one_or_zero);
grdfilter_mt.c:			x_scale = y_scale = GMT->current.proj.DIST_KM_PR_DEG;
grdfilter_mt.c:			x_scale = GMT->current.proj.DIST_KM_PR_DEG * cosd (0.5 * (Gout->header->wesn[YHI] + Gout->header->wesn[YLO]));
grdfilter_mt.c:			y_scale = GMT->current.proj.DIST_KM_PR_DEG;
grdfilter_mt.c:			x_scale = GMT->current.proj.DIST_KM_PR_DEG * ((fabs (Gout->header->wesn[YLO]) > Gout->header->wesn[YHI]) ? cosd (Gout->header->wesn[YLO]) : cosd (Gout->header->wesn[YHI]));
grdfilter_mt.c:			y_scale = GMT->current.proj.DIST_KM_PR_DEG;
grdfilter_mt.c:			x_scale = GMT->current.proj.DIST_KM_PR_DEG * ((fabs (Gin->header->wesn[YLO]) > Gin->header->wesn[YHI]) ? cosd (Gin->header->wesn[YLO]) : cosd (Gin->header->wesn[YHI]));
grdfilter_mt.c:			y_scale = GMT->current.proj.DIST_KM_PR_DEG;
grdfilter_mt.c:			merc_range = LAT2IMG (max_lat + (0.5 * Ctrl->F.width / GMT->current.proj.DIST_KM_PR_DEG)) - LAT2IMG (max_lat);
grdfilter_mt.c:	par[GRDFILTER_Y_SCALE] = (Ctrl->D.mode == GRDFILTER_GEO_MERCATOR) ? GMT->current.proj.DIST_KM_PR_DEG : y_scale;
grdfilter_mt.c:		if (GMT->common.R.active[RSET] || GMT->common.R.active[ISET] || GMT->common.R.active[GSET]) {	/* Must resample result so grids are coregistered */
grdfilter_mt.c:			sprintf (cmd, "%s -G%s -R%s -V%d", in_string, out_string, Ctrl->In.file, GMT->current.setting.verbose);
grdfilter_mt.c:			GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Calling grdsample with args %s\n", cmd);
grdfilter_mt.c:			if (GMT_Call_Module (GMT->parent, "grdsample", GMT_MODULE_CMD, cmd) != GMT_NOERROR) {	/* Resample the file */
grdfilter_mt.c:		Return (GMT->parent->error);
grdfilter_mt.c:		GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Processing output line %d\r", row_out);
grdfilter_mt.c:			par[GRDFILTER_X_SCALE] = GMT->current.proj.DIST_KM_PR_DEG * cosd (lat_out);	/* Update flat-Earth longitude scale */
grdfilter_mt.c:				Gout->data[ij_out] = GMT->session.f_NaN;
grdfilter_mt.c:				Gout->data[ij_out] = GMT->session.f_NaN;
grdfilter_mt.c:					Gout->data[ij_out] = GMT->session.f_NaN;
grdfilter_mt.c:				if (wt_sum == 0.0) {	/* Nothing found inside circle or rectangle, assign value = GMT->session.f_NaN */
grdfilter_mt.c:					Gout->data[ij_out] = GMT->session.f_NaN;
grdfilter_mt.c:	GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Processing output line %d\n", row_out);
grdgradient.c:	struct GMTAPI_CTRL *API = GMT->parent;
grdgradient.c:					gmt_strncpy (GMT->common.n.BC, opt->arg, 4U);
grdgradient.c:					if (!strcmp (GMT->common.n.BC, "g")) {
grdgradient.c:		if (GMT->session.TMPDIR)
grdgradient.c:			sprintf (sfile, "%s/grdgradient.stat", GMT->session.TMPDIR);
grdgradient.c:	if (GMT->common.R.active[RSET]) gmt_M_memcpy (wesn, GMT->common.R.wesn, 4, double);	/* Current -R setting, if any */
grdgradient.c:		dx_grid = GMT->current.proj.DIST_M_PR_DEG * Surf->header->inc[GMT_X] * cosd ((Surf->header->wesn[YHI] + Surf->header->wesn[YLO]) / 2.0);
grdgradient.c:		dy_grid = GMT->current.proj.DIST_M_PR_DEG * Surf->header->inc[GMT_Y];
grdgradient.c:			dx_grid = GMT->current.proj.DIST_M_PR_DEG * Surf->header->inc[GMT_X] * cosd (lat);
grdgradient.c:				Out->data[index] = GMT->session.f_NaN;
grdgradient.c:				if (Ctrl->S.active) Slope->data[ij] = GMT->session.f_NaN;
grdgradient.c:					azim = GMT->session.d_NaN;
grdgradient.c:		gmt_grd_pad_on (GMT, Out, GMT->current.io.pad);	/* Now reinstate the pad */
grdgradient.c:			sprintf (format, "\t%s\t%s\t%s\t%s\n", GMT->current.setting.format_float_out, GMT->current.setting.format_float_out, GMT->current.setting.format_float_out, GMT->current.setting.format_float_out);
grdgradient.c:		if (GMT->session.TMPDIR)
grdgradient.c:			sprintf (sfile, "%s/grdgradient.stat", GMT->session.TMPDIR);
grdhisteq.c:		if ((Orig = GMT_Duplicate_Data (GMT->parent, GMT_IS_GRID, GMT_DUPLICATE_DATA, Grid)) == NULL) {	/* Must keep original if readonly */
grdhisteq.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Grid duplication failed - memory error?\n");
grdhisteq.c:			return (GMT->parent->error);
grdhisteq.c:			GMT_Put_Record (GMT->parent, GMT_WRITE_DATA, Out);
grdhisteq.c:	if (dump_intervals && GMT_End_IO (GMT->parent, GMT_OUT, 0) != GMT_NOERROR) {	/* Disables further data ioutput */
grdhisteq.c:		return (GMT->parent->error);
grdhisteq.c:		for (i = 0; i < Grid->header->nm; i++) Grid->data[i] = (gmt_M_is_fnan (Orig->data[i])) ? GMT->session.f_NaN : get_cell (Orig->data[i], cell, n_cells_m1, last_cell);
grdhisteq.c:		if (GMT_Destroy_Data (GMT->parent, &Orig) != GMT_NOERROR) {
grdhisteq.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Failed to free Orig\n");
grdhisteq.c:			GMT_Put_Record (GMT->parent, GMT_WRITE_DATA, Out);
grdhisteq.c:	if (dump_intervals && GMT_End_IO (GMT->parent, GMT_OUT, 0) != GMT_NOERROR) {	/* Disables further data ioutput */
grdhisteq.c:		return (GMT->parent->error);
grdhisteq.c:			Grid->data[node] = (gmt_M_is_fnan (Grid->data[node])) ? GMT->session.f_NaN : get_cell (Grid->data[node], cell, n_cells_m1, last_cell);
grdhisteq.c:	gmt_M_memcpy (wesn, GMT->common.R.wesn, 4, double);	/* Current -R setting, if any */
grdimage.c:	struct GMTAPI_CTRL *API = GMT->parent;
grdimage.c:	if (!GMT->common.n.active && (!Ctrl->C.active || gmt_is_cpt_master (GMT, Ctrl->C.file)))
grdimage.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Detected geographic global gridline-registered grid with sloppy longitude bounds.\n");
grdimage.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Detected geographic global pixel-registered grid posing as gridline-registered with sloppy longitude bounds.\n");
grdimage.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Detected geographic global gridline-registered grid with gridline latitude bounds.\n");
grdimage.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Detected geographic global pixel-registered grid posing as gridline-registered with sloppy latitude bounds.\n");
grdimage.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Old region: %g/%g/%g/%g with incs %g/%g\n", wasR[XLO], wasR[XHI], wasR[YLO], wasR[YHI], wasI[GMT_X], wasI[GMT_Y]);
grdimage.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "New region: %g/%g/%g/%g with incs %g/%g\n", h->wesn[XLO], h->wesn[XHI], h->wesn[YLO], h->wesn[YHI], h->inc[GMT_X], h->inc[GMT_Y]);
grdimage.c:	gmt_M_memcpy (r->wesn, GMT->current.proj.rect, 4, double);
grdimage.c:	if (GMT->current.proj.projection_GMT == GMT_GENPER && GMT->current.proj.g_width != 0.0) return;
grdimage.c:	if (gmt_M_is_azimuthal (GMT) && !GMT->current.proj.polar) return;
grdimage.c:			r->wesn[XLO] = GMT->current.proj.rect[XLO];	r->wesn[XHI] = GMT->current.proj.rect[XHI];
grdimage.c:			r->wesn[YLO] = GMT->current.proj.rect[YLO];	r->wesn[YHI] = GMT->current.proj.rect[YHI];
grdimage.c:				if ((Grid_orig[0] = GMT_Read_Data (API, GMT_IS_GRID, GMT_IS_FILE, GMT_IS_SURFACE, GMT_CONTAINER_AND_DATA, GMT->common.R.wesn, Ctrl->In.file[0], NULL)) == NULL)	/* Get srtm grid data */
grdimage.c:		if (GMT->common.R.active[RSET]) Ctrl->D.mode = true;
grdimage.c:			if (Ctrl->D.active && GMT->common.R.active[RSET]) {	/* Should we add -Dr or is it just a valid subset specification? */
grdimage.c:		if (use_intensity_grid && GMT->common.R.active[RSET]) {
grdimage.c:			if (GMT->common.R.wesn[XLO] < (Intens_orig->header->wesn[XLO]-xnoise) || GMT->common.R.wesn[XHI] > (Intens_orig->header->wesn[XHI]+xnoise) ||
grdimage.c:			    GMT->common.R.wesn[YLO] < (Intens_orig->header->wesn[YLO]-ynoise) || GMT->common.R.wesn[YHI] > (Intens_orig->header->wesn[YHI]+ynoise)) {
grdimage.c:		if (!Ctrl->D.mode && use_intensity_grid && !GMT->common.R.active[RSET])	/* Apply illumination to an image but no -R provided; use intensity domain */
grdimage.c:			gmt_M_memcpy (GMT->common.R.wesn, Intens_orig->header->wesn, 4, double);
grdimage.c:		if (!Ctrl->D.mode && !Ctrl->I.active && !GMT->common.R.active[RSET])	/* No -R or -I. Use image dimensions as -R */
grdimage.c:			gmt_M_memcpy (GMT->common.R.wesn, I->header->wesn, 4, double);
grdimage.c:		if ( (Ctrl->D.mode && GMT->common.R.active[RSET]) || (!Ctrl->D.mode && use_intensity_grid) ) {
grdimage.c:			gmt_M_memcpy (I->header->wesn, GMT->common.R.wesn, 4, double);
grdimage.c:		if (!GMT->common.J.active) {
grdimage.c:				GMT->common.J.active = true;
grdimage.c:			else if (GMT->current.setting.run_mode == GMT_CLASSIC) {
grdimage.c:	if (!GMT->common.R.active[RSET] && n_grids)	/* -R was not set so we use the grid domain */
grdimage.c:	if (gmt_M_err_pass (GMT, gmt_map_setup (GMT, GMT->common.R.wesn), "")) Return (GMT_PROJECTION_ERROR);
grdimage.c:	if (!gmt_grd_setregion (GMT, header_work, wesn, need_to_project * GMT->common.n.interpolant))
grdimage.c:	else if (use_intensity_grid && !Ctrl->I.derive && !gmt_grd_setregion (GMT, Intens_orig->header, wesn, need_to_project * GMT->common.n.interpolant))
grdimage.c:			gmt_plane_perspective (GMT, GMT->current.proj.z_project.view_plane, GMT->current.proj.z_level);
grdimage.c:		gmt_plane_perspective (GMT, GMT->current.proj.z_project.view_plane, GMT->current.proj.z_level);
grdimage.c:		if (!Ctrl->N.active) gmt_map_clip_on (GMT, GMT->session.no_rgb, 3);
grdimage.c:			if (GMT_Call_Module (GMT->parent, "grdsample", GMT_MODULE_CMD, cmd) != GMT_NOERROR)	/* Do the resampling */
grdimage.c:				for (k = 0; k < 3; k++) GMT->current.setting.color_patch[GMT_NAN][k] = 1.0;	/* For img GDAL write use white as bg color */
grdimage.c:	NaN_rgb = (P) ? P->bfn[GMT_NAN].rgb : GMT->current.setting.color_patch[GMT_NAN];
grdimage.c:		unsigned int this_proj = GMT->current.proj.projection;
grdimage.c:			img_wesn[XLO] = GMT->common.R.wesn[XLO];		img_wesn[XHI] = GMT->common.R.wesn[XHI];
grdimage.c:			img_wesn[YHI] = GMT->common.R.wesn[YHI];		img_wesn[YLO] = GMT->common.R.wesn[YLO];
grdimage.c:			img_wesn[XLO] = GMT->current.proj.rect_m[XLO];	img_wesn[XHI] = GMT->current.proj.rect_m[XHI];
grdimage.c:			img_wesn[YHI] = GMT->current.proj.rect_m[YHI];	img_wesn[YLO] = GMT->current.proj.rect_m[YLO];
grdimage.c:		if (GMT->current.gdal_read_in.O.mem_layout[0])
grdimage.c:			strcpy (mem_layout, GMT->current.gdal_read_in.O.mem_layout);	/* Backup current layout */
grdimage.c:				if (GMT->current.proj.proj4[k].id == this_proj) id = k;
grdimage.c:	normal_x = !(GMT->current.proj.projection_GMT == GMT_LINEAR && !GMT->current.proj.xyz_pos[0] && !resampled);
grdimage.c:	normal_y = !(GMT->current.proj.projection_GMT == GMT_LINEAR && !GMT->current.proj.xyz_pos[1] && !resampled);
grdinfo.c:				if (GMT->parent->external && Ctrl->C.mode == GRDINFO_TRADITIONAL) Ctrl->C.mode = GRDINFO_NUMERICAL;
grdinfo.c:					GMT_Report (GMT->parent, GMT_MSG_COMPAT, "-Ts option is deprecated; please use -T[<dz>][+s][+a[<alpha>]] next time.\n");
grdinfo.c:					GMT_Report (GMT->parent, GMT_MSG_COMPAT, "Error -T: Syntax is -T[<dz>][+s][+a[<alpha>]] next time.\n");
grdinfo.c:	no_file_OK = (Ctrl->D.active && Ctrl->D.mode == 0 && GMT->common.R.active[RSET]);
grdinfo.c:	n_errors += gmt_M_check_condition (GMT, GMT->common.o.active && !num_report,
grdinfo.c:					GMT_Put_Record (GMT->parent, GMT_WRITE_DATA, Out);
grdinfo.c:					GMT_Put_Record (GMT->parent, GMT_WRITE_DATA, Out);
grdinfo.c:	sep = GMT->current.setting.io_col_separator;
grdinfo.c:	gmt_M_memcpy (wesn, GMT->common.R.wesn, 4, double);	/* Current -R setting, if any */
grdinfo.c:	if (Ctrl->D.active && Ctrl->D.mode == 0 && GMT->common.R.active[RSET]) {
grdinfo.c:		global_xmin = GMT->common.R.wesn[XLO]; global_ymin = GMT->common.R.wesn[YLO];
grdinfo.c:		global_xmax = GMT->common.R.wesn[XHI] ; global_ymax = GMT->common.R.wesn[YHI];
grdinfo.c:	GMT_Set_Columns (GMT->parent, GMT_OUT, n_cols, cmode);
grdinfo.c:			GMT->current.io.col_type[GMT_OUT][n] = gmt_M_type (GMT, GMT_IN, n);	/* Since grids may differ in types */
grdinfo.c:				GMT->current.io.col_type[GMT_OUT][10] = GMT->current.io.col_type[GMT_OUT][12] = GMT->current.io.col_type[GMT_OUT][GMT_X];
grdinfo.c:				GMT->current.io.col_type[GMT_OUT][11] = GMT->current.io.col_type[GMT_OUT][13] = GMT->current.io.col_type[GMT_OUT][GMT_Y];
grdinfo.c:			GMT->current.io.col_type[GMT_OUT][2] = GMT->current.io.col_type[GMT_OUT][3] = GMT->current.io.col_type[GMT_OUT][GMT_Y];
grdinfo.c:			GMT->current.io.col_type[GMT_OUT][1] = GMT->current.io.col_type[GMT_OUT][GMT_X];
grdinfo.c:				x_min = x_max = y_min = y_max = GMT->session.d_NaN;
grdinfo.c:				GMT->current.io.geo.range = GMT_IS_GIVEN_RANGE;
grdinfo.c:				GMT->current.io.geo.range = GMT_IS_GIVEN_RANGE;
grdinfo.c:				GMT->current.io.geo.range = GMT_IS_M180_TO_P180_RANGE;
grdinfo.c:				GMT->current.io.geo.range = GMT_IS_0_TO_P360_RANGE;
grdinfo.c:				sprintf (record, "%s: Grid file format: %s", HH->name, GMT->session.grdformat[G->header->type]);
grdinfo.c:				if (z_min == DBL_MAX) z_min = GMT->session.d_NaN;
grdinfo.c:				if (z_max == -DBL_MAX) z_max = GMT->session.d_NaN;
grdinfo.c:			         HH->name, GMT->current.setting.format_float_out, GMT->current.setting.format_float_out);
grdinfo.c:				         GMT->current.setting.format_float_out, GMT->current.setting.format_float_out);
grdinfo.c:			if (strspn(GMT->session.grdformat[G->header->type], "nc") != 0) {
grdinfo.c:	if (global_zmin == DBL_MAX) global_zmin = GMT->session.d_NaN;	/* Never got set */
grdinfo.c:	if (global_zmax == -DBL_MAX) global_zmax = GMT->session.d_NaN;
grdlandmask.c:	struct GMTAPI_CTRL *API = GMT->parent;
grdlandmask.c:						Ctrl->N.mask[2*j+1] = (ptr[0] == 'N' || ptr[0] == 'n') ? GMT->session.f_NaN : (gmt_grdfloat)atof (ptr);
grdlandmask.c:					Ctrl->N.mask[2*j] = (ptr[0] == 'N' || ptr[0] == 'n') ? GMT->session.f_NaN : (gmt_grdfloat)atof (ptr);
grdlandmask.c:	n_errors += gmt_M_check_condition (GMT, !GMT->common.R.active[RSET], "Syntax error: Must specify -R option\n");
grdlandmask.c:	n_errors += gmt_M_check_condition (GMT, GMT->common.R.inc[GMT_X] <= 0.0 || GMT->common.R.inc[GMT_Y] <= 0.0, "Syntax error -I option: Must specify positive increment(s)\n");
grdlandmask.c:		sprintf (line, "%s\n", GMT->current.setting.format_float_out);
grdlandmask.c:	GMT->current.map.parallel_straight = GMT->current.map.meridian_straight = 2;	/* No resampling along bin boundaries */
grdlandmask.c:	wrap = GMT->current.map.is_world = gmt_grd_is_global (GMT, Grid->header);
grdlandmask.c:	if ((Cart = GMT_Create_Data (API, GMT_IS_GRID, GMT_IS_SURFACE, GMT_CONTAINER_ONLY, NULL, GMT->current.proj.rect, inc_inch, \
grdlandmask.c:	west_border = floor (GMT->common.R.wesn[XLO] / c.bsize) * c.bsize;
grdlandmask.c:	east_border =  ceil (GMT->common.R.wesn[XHI] / c.bsize) * c.bsize;
grdlandmask.c:				row_min = MAX (0, irint (ceil ((GMT->current.proj.rect[YHI] - ymax) * i_dy_inch - Grid->header->xy_off - GMT_CONV8_LIMIT)));
grdlandmask.c:				row_max = MIN (ny1, irint (floor ((GMT->current.proj.rect[YHI] - ymin) * i_dy_inch - Grid->header->xy_off + GMT_CONV8_LIMIT)));
grdmask.c:	double value = (p[0] == 'N' || p[0] == 'n') ? GMT->session.d_NaN : atof (p);
grdmask.c:		sprintf(txt, "%.12g/%.12g", n_cells * GMT->common.R.inc[GMT_X], n_cells * GMT->common.R.inc[GMT_Y]);
grdmask.c:	n_errors += gmt_M_check_condition (GMT, !GMT->common.R.active[RSET], "Syntax error: Must specify -R option\n");
grdmask.c:	n_errors += gmt_M_check_condition (GMT, GMT->common.R.inc[GMT_X] <= 0.0 || GMT->common.R.inc[GMT_Y] <= 0.0,
grdmask.c:			sprintf (line, "%s\n", GMT->current.setting.format_float_out);
grdmask.c:	if (!Ctrl->S.active && GMT->current.map.path_mode == GMT_RESAMPLE_PATH) {	/* Resample all polygons to desired resolution, once and for all */
grdmath.c:	struct GMTAPI_CTRL *API = GMT->parent;
grdmath.c:	if (GMT->common.R.active[ISET] && (GMT->common.R.inc[GMT_X] <= 0.0 || GMT->common.R.inc[GMT_Y] <= 0.0)) {
grdmath.c:	struct GMT_GRID *New = GMT_Create_Data (GMT->parent, GMT_IS_GRID, GMT_IS_SURFACE, GMT_CONTAINER_AND_DATA, NULL, Template->header->wesn, Template->header->inc, \
grdmath.c:		lmsscl = GMT->session.d_NaN;
grdmath.c:		mad = GMT->session.d_NaN;
grdmath.c:		med = GMT->session.d_NaN;
grdmath.c:	 	x = (gmt_M_is_dnan (x) || gmt_M_is_dnan (array[k])) ? GMT->session.d_NaN : x;
grdmath.c:	 	x = (gmt_M_is_dnan (x) && gmt_M_is_dnan (array[k])) ? 0.0 : (gmt_M_is_dnan (array[k]) ? GMT->session.d_NaN : x);
grdmath.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Unrecognized stack reduction operator %s - ignored\n", OP);
grdmath.c:	if (stack[last]->constant && stack[last]->factor == 0.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, operand == 0!\n");
grdmath.c:	if (stack[last]->constant && fabs (stack[last]->factor) > 1.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, |operand| > 1 for ACOS!\n");
grdmath.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, operand < 1 for ACOSH!\n");
grdmath.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, |operand| > 1 for ACOT!\n");
grdmath.c:	if (stack[last]->constant && fabs (stack[last]->factor) <= 1.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, |operand| <= 1 for ACOTH!\n");
grdmath.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, |operand| > 1 for ACSC!\n");
grdmath.c:			stack[prev]->G->data[node] = GMT->session.f_NaN;  /* NaN output */
grdmath.c:	if (stack[last]->constant && fabs (stack[last]->factor) > 1.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, |operand| > 1 for ASEC!\n");
grdmath.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, operand > 1 for ASECH!\n");
grdmath.c:	if (stack[last]->constant && fabs (stack[last]->factor) > 1.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, |operand| > 1 for ASIN!\n");
grdmath.c:	if (stack[prev]->constant && stack[prev]->factor == 0.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, operand one == 0 for ATAN2!\n");
grdmath.c:	if (stack[last]->constant && stack[last]->factor == 0.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, operand two == 0 for ATAN2!\n");
grdmath.c:	if (stack[last]->constant && fabs (stack[last]->factor) >= 1.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, |operand| >= 1 for ATANH!\n");
grdmath.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error, argument p to BPDF must be in 0 <= p <= 1!\n");
grdmath.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error, argument n to BPDF must be a positive integer (n >= 0)!\n");
grdmath.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error, argument x to BPDF must be a positive integer (x >= 0)!\n");
grdmath.c:		value = (error) ? GMT->session.f_NaN : (float)gmt_binom_cdf (GMT, lrint(x), lrint(n), p);
grdmath.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error, argument p to BPDF must be in 0 <= p <= 1!\n");
grdmath.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error, argument n to BPDF must be a positive integer (n >= 0)!\n");
grdmath.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error, argument x to BPDF must be a positive integer (x >= 0)!\n");
grdmath.c:		value = (error) ? GMT->session.f_NaN : (float)(gmt_combination (GMT, irint (n), irint (x)) * pow (p, x) * pow (q, n-x));
grdmath.c:			stack[prev]->G->data[node] = GMT->session.f_NaN;
grdmath.c:	if (n_warn) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "BITAND resulted in %" PRIu64 " values truncated to fit in the 24 available bits\n");
grdmath.c:			stack[prev]->G->data[node] = GMT->session.f_NaN;
grdmath.c:				if (first) GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Bit shift must be >= 0; other values yield NaN\n");
grdmath.c:				stack[prev]->G->data[node] = GMT->session.f_NaN;
grdmath.c:	if (n_warn) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "BITLEFT resulted in %" PRIu64 " values truncated to fit in the 24 available bits\n");
grdmath.c:			stack[last]->G->data[node] = GMT->session.f_NaN;
grdmath.c:	if (n_warn) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "BITNOT resulted in %" PRIu64 " values truncated to fit in the 24 available bits\n");
grdmath.c:			stack[prev]->G->data[node] = GMT->session.f_NaN;
grdmath.c:	if (n_warn) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "BITOR resulted in %" PRIu64 " values truncated to fit in the 24 available bits\n");
grdmath.c:			stack[prev]->G->data[node] = GMT->session.f_NaN;
grdmath.c:				if (first) GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Bit shift must be >= 0; other values yield NaN\n");
grdmath.c:				stack[prev]->G->data[node] = GMT->session.f_NaN;
grdmath.c:	if (n_warn) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "BITRIGHT resulted in %" PRIu64 " values truncated to fit in the 24 available bits\n");
grdmath.c:			stack[prev]->G->data[node] = GMT->session.f_NaN;
grdmath.c:				if (first) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Bit position range for BITTEST is 0-31 ; other values yield NaN\n");
grdmath.c:				stack[prev]->G->data[node] = GMT->session.f_NaN;
grdmath.c:	if (n_warn) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "BITTEST resulted in %" PRIu64 " values truncated to fit in the 24 available bits\n");
grdmath.c:			stack[prev]->G->data[node] = GMT->session.f_NaN;
grdmath.c:	if (n_warn) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "BITXOR resulted in %" PRIu64 " values truncated to fit in the 24 available bits\n");
grdmath.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Grid must be Cartesian; see SDIST for geographic data.\n");
grdmath.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Grid must be Cartesian; see SDIST2 for geographic data.\n");
grdmath.c:			stack[prev]->G->data[node] = GMT->session.f_NaN;
grdmath.c:	if (stack[prev]->constant && stack[prev]->factor == 0.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, operand one == 0 for CHI2CRIT!\n");
grdmath.c:	if (stack[last]->constant && stack[last]->factor == 0.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, operand two == 0 for CHI2CRIT!\n");
grdmath.c:	if (stack[prev]->constant && stack[prev]->factor == 0.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, operand one == 0 for CHI2CDF!\n");
grdmath.c:	if (stack[last]->constant && stack[last]->factor == 0.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, operand two == 0 for CHI2CDF!\n");
grdmath.c:	if (stack[prev]->constant && stack[prev]->factor == 0.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, operand one == 0 for CHI2PDF!\n");
grdmath.c:	if (stack[last]->constant && stack[last]->factor == 0.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, operand two == 0 for CHI2PDF!\n");
grdmath.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error, argument n to COMB must be a positive integer (n >= 0)!\n");
grdmath.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error, argument r to COMB must be a positive integer (r >= 0)!\n");
grdmath.c:		float value = (error) ? GMT->session.f_NaN : (float)gmt_combination (GMT, irint(stack[prev]->factor), irint(stack[last]->factor));
grdmath.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Constant operands for CORRCOEFF yields NaNs\n");
grdmath.c:		for (node = 0; node < info->size; node++) stack[prev]->G->data[node] = GMT->session.f_NaN;
grdmath.c:	if (stack[last]->constant && stack[last]->factor == 0.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, operand two == 0 for PCDF!\n");
grdmath.c:	if (stack[last]->constant && stack[last]->factor == 0.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, operand two == 0 for PPDF!\n");
grdmath.c:	if (gmt_M_is_geographic (GMT, GMT_IN)) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, geographic grid given to a Cartesian operator [CURV]!\n");
grdmath.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, operand to CURV is constant!\n");
grdmath.c:	if (gmt_M_is_geographic (GMT, GMT_IN)) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, geographic grid given to a Cartesian operator [D2DX2]!\n");
grdmath.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, operand to D2DX2 is constant!\n");
grdmath.c:	if (gmt_M_is_geographic (GMT, GMT_IN)) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, geographic grid given to a Cartesian operator [D2DY2]!\n");
grdmath.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, operand to D2DY2 is constant!\n");
grdmath.c:	if (gmt_M_is_geographic (GMT, GMT_IN)) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, geographic grid given to a Cartesian operator [D2DXY]!\n");
grdmath.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, operand to D2DXY is constant!\n");
grdmath.c:	if (gmt_M_is_geographic (GMT, GMT_IN)) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, geographic grid given to a Cartesian operator [DDX]!\n");
grdmath.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, operand to DDX is constant!\n");
grdmath.c:	if (gmt_M_is_geographic (GMT, GMT_IN)) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, geographic grid given to a Cartesian operator [DDY]!\n");
grdmath.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, operand to DDY is constant!\n");
grdmath.c:		if (gmt_M_sph_mode (GMT) == GMT_GEODESIC) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, DEG2KM is only exact when PROJ_ELLIPSOID == sphere\n");
grdmath.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, DEG2KM used with Cartesian data\n");
grdmath.c:	if (stack[last]->constant) a = stack[last]->factor * GMT->current.proj.DIST_KM_PR_DEG;
grdmath.c:	for (node = 0; node < info->size; node++) stack[last]->G->data[node] = (float)((stack[last]->constant) ? a : stack[last]->G->data[node] * GMT->current.proj.DIST_KM_PR_DEG);
grdmath.c:	if (stack[last]->constant && stack[last]->factor == 0.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Divide by zero gives NaNs\n");
grdmath.c:	if (stack[prev]->constant && stack[prev]->factor == 0.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, operand one == 0!\n");
grdmath.c:	if (stack[last]->constant && stack[last]->factor == 0.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, operand two == 0!\n");
grdmath.c:	if (stack[last]->constant && stack[last]->factor == 0.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, operand two == 0 for PCDF!\n");
grdmath.c:	if (stack[last]->constant && stack[last]->factor == 0.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, operand two == 0 for PCDF!\n");
grdmath.c:	if (stack[last]->constant && stack[last]->factor == 0.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, operand two == 0 for PCDF!\n");
grdmath.c:		stack[prev]->G->data[node] = (gmt_M_is_fnan (a) || gmt_M_is_fnan (b)) ? GMT->session.f_NaN : (float)(a == b);
grdmath.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, operand to EXTREMA is constant!\n");
grdmath.c:	if (stack[prev2]->constant && stack[prev2]->factor == 0.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, operand one == 0 for FCRIT!\n");
grdmath.c:	if (stack[prev1]->constant && stack[prev1]->factor == 0.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, operand two == 0 for FCRIT!\n");
grdmath.c:	if (stack[last]->constant  && stack[last]->factor  == 0.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, operand three == 0 for FCRIT!\n");
grdmath.c:	if (stack[prev1]->constant && stack[prev1]->factor == 0.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, operand two == 0 for FCDF!\n");
grdmath.c:	if (stack[last]->constant  && stack[last]->factor  == 0.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, operand three == 0 for FCDF!\n");
grdmath.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, operand to FLIPLR is constant!\n");
grdmath.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, operand to FLIPLR is constant!\n");
grdmath.c:	if (stack[last]->constant && stack[last]->factor == 0.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, using FMOD 0!\n");
grdmath.c:	if (stack[prev2]->constant && stack[prev2]->factor < 0.0)  GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, operand one < 0 for FCDF!\n");
grdmath.c:	if (stack[prev1]->constant && stack[prev1]->factor == 0.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, operand two == 0 for FCDF!\n");
grdmath.c:	if (stack[last]->constant  && stack[last]->factor  == 0.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, operand three == 0 for FCDF!\n");
grdmath.c:		stack[prev]->G->data[node] = (gmt_M_is_fnan (a) || gmt_M_is_fnan (b)) ? GMT->session.f_NaN : (float)(a >= b);
grdmath.c:		stack[prev]->G->data[node] = (gmt_M_is_fnan (a) || gmt_M_is_fnan (b)) ? GMT->session.f_NaN : (float)(a > b);
grdmath.c:		if (stack[last]->factor < 0.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, order < 0 for IN!\n");
grdmath.c:		if (fabs (rint(stack[last]->factor) - stack[last]->factor) > GMT_CONV4_LIMIT) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, order not an integer for IN!\n");
grdmath.c:			stack[prev2]->G->data[node] = GMT->session.f_NaN;
grdmath.c:	if (GMT_Set_Columns (GMT->parent, GMT_IN, 2, GMT_COL_FIX_NO_TEXT) != GMT_NOERROR) {
grdmath.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error in operator INSIDE setting number of input columns\n");
grdmath.c:		info->error = GMT->parent->error;
grdmath.c:	if ((D = GMT_Read_Data (GMT->parent, GMT_IS_DATASET, GMT_IS_FILE, GMT_IS_POLY, GMT_READ_NORMAL, NULL, info->ASCII_file, NULL)) == NULL) {
grdmath.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error in operator INSIDE reading file %s!\n", info->ASCII_file);
grdmath.c:		info->error = GMT->parent->error;
grdmath.c:	if (GMT_Destroy_Data (GMT->parent, &D) != GMT_NOERROR) {
grdmath.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error in operator INSIDE destroying allocated data from %s!\n", info->ASCII_file);
grdmath.c:		info->error = GMT->parent->error;
grdmath.c:	if (stack[last]->constant && stack[last]->factor == 0.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Inverse of zero gives NaNs\n");
grdmath.c:	if (stack[last]->constant) stack[last]->factor = (stack[last]->factor == 0.0) ? GMT->session.f_NaN : 1.0 / stack[last]->factor;
grdmath.c:		if (stack[last]->factor < 0.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, order < 0 for JN!\n");
grdmath.c:		if (fabs (rint(stack[last]->factor) - stack[last]->factor) > GMT_CONV4_LIMIT) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, order not an integer for JN!\n");
grdmath.c:	double a = 0.0, f = 1.0 / GMT->current.proj.DIST_KM_PR_DEG;
grdmath.c:		if (gmt_M_sph_mode (GMT) == GMT_GEODESIC) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, KM2DEG is only exact when PROJ_ELLIPSOID == sphere\n");
grdmath.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, KM2DEG used with Cartesian data\n");
grdmath.c:		if (stack[last]->factor < 0.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, order < 0 for KN!\n");
grdmath.c:		if (fabs (rint(stack[last]->factor) - stack[last]->factor) > GMT_CONV4_LIMIT) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, order not an integer for KN!\n");
grdmath.c:		for (node = 0; node < info->size; node++) stack[last]->G->data[node] = GMT->session.f_NaN;
grdmath.c:		f_kurt = GMT->session.f_NaN;
grdmath.c:	if (GMT_Set_Columns (GMT->parent, GMT_IN, 2, GMT_COL_FIX_NO_TEXT) != GMT_NOERROR) {
grdmath.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error in operator %s setting number of input columns\n", op);
grdmath.c:		info->error = GMT->parent->error;
grdmath.c:	if ((D = GMT_Read_Data (GMT->parent, GMT_IS_DATASET, GMT_IS_FILE, geometry, GMT_READ_NORMAL, NULL, info->ASCII_file, NULL)) == NULL) {
grdmath.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error in operator %s reading file %s!\n", op, info->ASCII_file);
grdmath.c:		info->error = GMT->parent->error;
grdmath.c:	if (GMT_Destroy_Data (GMT->parent, D) != GMT_NOERROR) {
grdmath.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error in operator %s destroying allocated data from %s!\n", op, info->ASCII_file);
grdmath.c:		info->error = GMT->parent->error;
grdmath.c:		GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Row %d\n", row);
grdmath.c:	n_threads = GMT->common.x.n_threads;	/* Use the number of selected threads (see -x) */
grdmath.c:		GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Row %d\n", row);
grdmath.c:	GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Max LDISTG horizon distance used: %g\n", max_hor);
grdmath.c:			if (col == 0) GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Row %d\n", row);
grdmath.c:				stack[prev]->G->data[node] = GMT->session.f_NaN;
grdmath.c:		stack[prev]->G->data[node] = (gmt_M_is_fnan (a) || gmt_M_is_fnan (b)) ? GMT->session.f_NaN : (float)(a <= b);
grdmath.c:	if (stack[last]->constant && stack[last]->factor == 0.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, argument to log = 0\n");
grdmath.c:	if (stack[last]->constant && stack[last]->factor == 0.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, argument to log10 = 0\n");
grdmath.c:	if (stack[last]->constant && stack[last]->factor < 0.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, argument to log1p < 0\n");
grdmath.c:	if (stack[last]->constant && stack[last]->factor == 0.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, argument to log2 = 0\n");
grdmath.c:	if (low == FLT_MAX) low = GMT->session.f_NaN;
grdmath.c:		stack[prev]->G->data[node] = (gmt_M_is_fnan (a) || gmt_M_is_fnan (b)) ? GMT->session.f_NaN : (float)(a < b);
grdmath.c:		stack[prev]->G->data[node] = (gmt_M_is_fnan (a) || gmt_M_is_fnan (b)) ? GMT->session.f_NaN : MAX (a, b);
grdmath.c:	if (stack[prev]->constant && stack[prev]->factor == 0.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, operand one == 0 for MEANW!\n");
grdmath.c:	if (stack[last]->constant && stack[last]->factor == 0.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, operand two == 0 for MEANW!\n");
grdmath.c:		stack[prev]->G->data[node] = (gmt_M_is_fnan (a) || gmt_M_is_fnan (b)) ? GMT->session.f_NaN : MIN (a, b);
grdmath.c:	if (stack[last]->constant && stack[last]->factor == 0.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, using MOD 0!\n");
grdmath.c:	if (stack[prev]->constant && stack[prev]->factor == 0.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, operand one == 0!\n");
grdmath.c:	if (stack[last]->constant && stack[last]->factor == 0.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, operand two == 0!\n");
grdmath.c:		stack[prev]->G->data[node] = (a == b) ? GMT->session.f_NaN : a;
grdmath.c:	if (stack[last]->constant && stack[last]->factor == 0.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, operand == 0!\n");
grdmath.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, NORM of a constant gives NaN!\n");
grdmath.c:		a = GMT->session.d_NaN;
grdmath.c:		a = (n == 0 || zmax == zmin) ? GMT->session.f_NaN : (1.0 / (zmax - zmin));	/* Normalization scale */
grdmath.c:	if (stack[last]->constant && stack[last]->factor == 0.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, operand == 0!\n");
grdmath.c:		stack[prev]->G->data[node] = (gmt_M_is_fnan (a) || gmt_M_is_fnan (b)) ? GMT->session.f_NaN : a;
grdmath.c:				stack[prev]->G->data[node] = GMT->session.f_NaN;
grdmath.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error, argument n to PERM must be a positive integer (n >= 0)!\n");
grdmath.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error, argument r to PERM must be a positive integer (r >= 0)!\n");
grdmath.c:		float value = (error) ? GMT->session.f_NaN : (float)gmt_permutation (GMT, irint(stack[prev]->factor), irint(stack[last]->factor));
grdmath.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "L and M must be constants in PLM (no calculations performed)\n");
grdmath.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "L and M must be constants in PLMg (no calculations performed)\n");
grdmath.c:		GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "[Single point reported as %g %g]\n", pos[GMT_X], pos[GMT_Y]);
grdmath.c:		GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "[Centroid computed as %g %g]\n", pos[GMT_X], pos[GMT_Y]);
grdmath.c:	if (stack[prev]->constant && stack[prev]->factor == 0.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, operand one == 0!\n");
grdmath.c:	if (stack[last]->constant && stack[last]->factor == 0.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, operand two == 0!\n");
grdmath.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "PQUANT must be given a constant quantile (no calculations performed)\n");
grdmath.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "PQUANT must be given a constant quantile between 0-100%% (no calculations performed)\n");
grdmath.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "PQUANT of a constant is set to NaN\n");
grdmath.c:		p = GMT->session.f_NaN;
grdmath.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "PQUANTW must be given a constant quantile (no calculations performed)\n");
grdmath.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "PQUANTW must be given a constant quantile between 0-100%% (no calculations performed)\n");
grdmath.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "PQUANTW of a constant is set to NaN\n");
grdmath.c:		p = GMT->session.f_NaN;
grdmath.c:		if ((stack[first]->factor < -1.0 || stack[first]->factor > 1.0)) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, argument to %s outside domain!\n", name[kind]);
grdmath.c:	if (stack[prev]->constant && stack[prev]->factor == 0.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, operand one == 0!\n");
grdmath.c:	if (stack[last]->constant && stack[last]->factor == 0.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, operand two == 0!\n");
grdmath.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Length and shift must be constants in ROLL!\n");
grdmath.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Items on stack is fewer than required by ROLL!\n");
grdmath.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "DX shift (B) must be a constant in ROTX (no calculations performed)\n");
grdmath.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "DY shift (B) must be a constant in ROTY (no calculations performed)\n");
grdmath.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Grid must be geographic; see CDIST for Cartesian data.\n");
grdmath.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Grid must be geographic; see CDIST2 for Cartesian data.\n");
grdmath.c:				stack[prev]->G->data[node] = GMT->session.f_NaN;
grdmath.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, operand == 0!\n");
grdmath.c:		for (node = 0; node < info->size; node++) stack[last]->G->data[node] = GMT->session.f_NaN;
grdmath.c:		f_skew = GMT->session.f_NaN;
grdmath.c:	if (stack[last]->constant && stack[last]->factor < 0.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, operand one < 0!\n");
grdmath.c:		if (n_used == 0) sum = GMT->session.d_NaN;
grdmath.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "TAPER: Arguments A and B must both be constants\n");
grdmath.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "TAPER: Arguments A and B must both be >= 0\n");
grdmath.c:	if (stack[prev]->constant && stack[prev]->factor == 0.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, operand one == 0 for TCRIT!\n");
grdmath.c:	if (stack[last]->constant && stack[last]->factor == 0.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, operand two == 0 for TCRIT!\n");
grdmath.c:	if (stack[prev]->constant && stack[prev]->factor == 0.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, operand one == 0 for TCDF!\n");
grdmath.c:	if (stack[last]->constant && stack[last]->factor == 0.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, operand two == 0 for TCDF!\n");
grdmath.c:	if (stack[prev]->constant && stack[prev]->factor == 0.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, operand one == 0 for TCDF!\n");
grdmath.c:	if (stack[last]->constant && stack[last]->factor == 0.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, operand two == 0 for TCDF!\n");
grdmath.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "3rd operand for TRIM must be a grid!\n");
grdmath.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "1st operand for TRIM must be constants!\n");
grdmath.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Right alpha for TRIM must be in 0-100%% range!\n");
grdmath.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "2nd operand for TRIM must be constants!\n");
grdmath.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Left alpha for TRIM must be in 0-100%% range!\n");
grdmath.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Right alpha for TRIM must exceed left alpha!\n");
grdmath.c:		stack[prev2]->G->data[node] = (stack[last]->G->data[node] < global_zmin || stack[last]->G->data[node] > global_zmax) ? GMT->session.f_NaN : stack[last]->G->data[node];
grdmath.c:	if (high == -FLT_MAX) high = GMT->session.f_NaN;
grdmath.c:	return (n <= 1 || sumw == 0.0) ? GMT->session.f_NaN : (float) ((n * M2) / (sumw * (n - 1.0)));
grdmath.c:		var = GMT->session.f_NaN;
grdmath.c:		var = (n > 1) ? (float)(sum2 / (n - 1)) : GMT->session.f_NaN;
grdmath.c:		var = GMT->session.f_NaN;
grdmath.c:	if (stack[prev1]->constant && stack[prev1]->factor <= 0.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, operand two <= 0 for WCDF!\n");
grdmath.c:	if (stack[last]->constant  && stack[last]->factor  <= 0.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, operand three <= 0 for WCDF!\n");
grdmath.c:	if (stack[prev1]->constant && stack[prev1]->factor <= 0.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, operand two <= 0 for WCRIT!\n");
grdmath.c:	if (stack[last]->constant  && stack[last]->factor  <= 0.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, operand three <= 0 for WCRIT!\n");
grdmath.c:	if (stack[prev1]->constant && stack[prev1]->factor <= 0.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, operand two <= 0 for WPDF!\n");
grdmath.c:	if (stack[last]->constant  && stack[last]->factor  <= 0.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, operand three <= 0 for WPDF!\n");
grdmath.c:		stack[prev]->G->data[node] = (gmt_M_is_fnan (a) && gmt_M_is_fnan (b)) ? 0.0f : (gmt_M_is_fnan (b) ? GMT->session.f_NaN : a);
grdmath.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "L and M must be constants in YLM[g] (no calculations performed)\n");
grdmath.c:	if (stack[prev]->constant && stack[prev]->factor == 0.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, argument = 0 for YN!\n");
grdmath.c:		if (stack[last]->factor < 0.0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, order < 0 for YN!\n");
grdmath.c:		if ((rint(stack[last]->factor) != stack[last]->factor)) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning, order not an integer for YN!\n");
grdmath.c:		GMT_Report (GMT->parent, GMT_MSG_COMPAT, "Operator %s is deprecated; use %s instead.\n", old, t);
grdmath.c:	if (!strcmp (opt->arg, "NaN")) {*value = GMT->session.d_NaN; return GRDMATH_ARG_IS_NUMBER;}
grdmath.c:		if (check != GMT_IS_NAN && possible_number) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Your argument %s is both a file and a number.  File is selected\n", opt->arg);
grdmath.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Option %s not recognized\n", opt->arg);
grdmath.c:	GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error: %s is not a number, operator or file name\n", opt->arg);
grdmath.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "No label appended to STO|RCL|CLR operator!\n");
grdmath.c:			if ((error = GMT_Destroy_Data (GMT->parent, &stack[k]->G)) == GMT_NOERROR)
grdmath.c:				GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Freed stack item %d\n", k);
grdmath.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Failed to free stack item %d\n", k);
grdmath.c:			if ((error = GMT_Destroy_Data (GMT->parent, &recall[k]->stored.G)) != GMT_NOERROR)
grdmath.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Failed to free recall item %d\n", k);
grdmath.c:	if (GMT_Destroy_Data (GMT->parent, &info->G) != GMT_NOERROR)
grdmath.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Failed to free info.G\n");
grdmath.c:	subset = GMT->common.R.active[RSET];
grdmath.c:		if (GMT->common.R.active[RSET] && GMT->common.R.active[ISET]) {
grdmath.c:		else if  (GMT->common.R.active[GSET]) {
grdmath.c:			gmt_M_memcpy (wesn, GMT->common.R.wesn, 4, double);
grdmath.c:	else if (GMT->common.R.active[RSET] && GMT->common.R.active[ISET]) {	/* Must create from -R -I [-r] */
grdmath.c:		GMT->current.io.inc_code[GMT_X]	= GMT->current.io.inc_code[GMT_Y] = 0;	/* Must reset this since later we don't use GMT->common.R.inc but G->header->inc */
grdmath.c:		for (kk = 0; kk < info.G->header->my; kk++) info.dx[kk] = GMT->current.proj.DIST_M_PR_DEG * info.G->header->inc[GMT_X] * cosd (info.d_grd_y[kk]);
grdmath.c:		info.dy = GMT->current.proj.DIST_M_PR_DEG * info.G->header->inc[GMT_Y];
grdpaste.c:					GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error: Only two files may be pasted\n");
grdpaste.c:		sprintf (format, "%%s\t%s\t%s\t%s\t%s\t%s\t%s\t%%d\t%%d\n", GMT->current.setting.format_float_out, GMT->current.setting.format_float_out, GMT->current.setting.format_float_out, GMT->current.setting.format_float_out, GMT->current.setting.format_float_out, GMT->current.setting.format_float_out);
grdpaste.c:				GMT->current.io.pad[YHI] = B->header->n_rows - one_or_zero;
grdpaste.c:					GMT->current.io.pad[YHI]--;
grdpaste.c:					GMT->current.io.pad[YHI]++;
grdpaste.c:				gmt_M_grd_setpad (GMT, A->header, GMT->current.io.pad);
grdpaste.c:				GMT->current.io.pad[YHI] = 0;
grdpaste.c:				GMT->current.io.pad[YLO] = A->header->n_rows - one_or_zero;
grdpaste.c:					GMT->current.io.pad[YLO]--;
grdpaste.c:					GMT->current.io.pad[YLO]++;
grdpaste.c:				gmt_M_grd_setpad (GMT, B->header, GMT->current.io.pad);
grdpaste.c:				GMT->current.io.pad[YLO] = B->header->n_rows - one_or_zero;
grdpaste.c:					GMT->current.io.pad[YLO]--;
grdpaste.c:					GMT->current.io.pad[YLO]++;
grdpaste.c:				gmt_M_grd_setpad (GMT, A->header, GMT->current.io.pad);
grdpaste.c:				GMT->current.io.pad[YLO] = 0;
grdpaste.c:				GMT->current.io.pad[YHI] = A->header->n_rows - one_or_zero;
grdpaste.c:					GMT->current.io.pad[YHI]--;
grdpaste.c:					GMT->current.io.pad[YHI]++;
grdpaste.c:				gmt_M_grd_setpad (GMT, B->header, GMT->current.io.pad);
grdpaste.c:				GMT->current.io.pad[XLO] = B->header->n_columns - one_or_zero;
grdpaste.c:					GMT->current.io.pad[XLO]--;
grdpaste.c:					GMT->current.io.pad[XLO]++;
grdpaste.c:				gmt_M_grd_setpad (GMT, A->header, GMT->current.io.pad);
grdpaste.c:				GMT->current.io.pad[XLO] = 0; GMT->current.io.pad[XHI] = A->header->n_columns - one_or_zero;
grdpaste.c:					GMT->current.io.pad[XHI]--;
grdpaste.c:					GMT->current.io.pad[XHI]++;
grdpaste.c:				gmt_M_grd_setpad (GMT, B->header, GMT->current.io.pad);
grdpaste.c:				GMT->current.io.pad[XHI] = B->header->n_columns - one_or_zero;
grdpaste.c:					GMT->current.io.pad[XHI]--;
grdpaste.c:					GMT->current.io.pad[XHI]++;
grdpaste.c:				gmt_M_grd_setpad (GMT, A->header, GMT->current.io.pad);
grdpaste.c:				GMT->current.io.pad[XHI] = 0;
grdpaste.c:				GMT->current.io.pad[XLO] = A->header->n_columns - one_or_zero;
grdpaste.c:					GMT->current.io.pad[XLO]--;
grdpaste.c:					GMT->current.io.pad[XLO]++;
grdpaste.c:				gmt_M_grd_setpad (GMT, B->header, GMT->current.io.pad);
grdproject.c:	struct GMTAPI_CTRL *API = GMT->parent;
grdproject.c:	if (GMT->current.proj.pars[14] == 1)
grdproject.c:	n_errors += gmt_M_check_condition (GMT, !GMT->common.J.active,
grdproject.c:	n_errors += gmt_M_check_condition (GMT, (GMT->common.R.active[ISET] + Ctrl->E.active) > 1,
grdproject.c:	n_errors += gmt_M_check_condition (GMT, GMT->common.R.active[ISET] && (GMT->common.R.inc[GMT_X] <= 0.0 ||
grdproject.c:	                                   GMT->common.R.inc[GMT_Y] < 0.0),
grdproject.c:	if ((GMT->common.R.active[ISET] + Ctrl->E.active) == 0) set_n = true;
grdproject.c:	if (GMT->common.R.active[RSET])	/* Load the w/e/s/n from -R */
grdproject.c:		gmt_M_memcpy (wesn, GMT->common.R.wesn, 4, double);
grdproject.c:			if (gmt_M_err_pass (GMT, gmt_proj_setup (GMT, GMT->common.R.wesn), "")) Return (GMT_PROJECTION_ERROR);
grdproject.c:			if (GMT->current.proj.projection_GMT == GMT_UTM && GMT->current.proj.utm_hemisphere == -1 && y_c > 0) y_c *= -1;
grdproject.c:			if (GMT->current.proj.projection_GMT == GMT_UTM && GMT->current.proj.utm_hemisphere == -1 && y_c < 0) y_c *= -1;	/* Undo the *-1 (only for the UTM case) */ 
grdproject.c:			if (gmt_M_err_pass (GMT, gmt_proj_setup (GMT, GMT->common.R.wesn), "")) Return (GMT_PROJECTION_ERROR);
grdproject.c:			x_c *= GMT->current.proj.scale[GMT_X];
grdproject.c:			y_c *= GMT->current.proj.scale[GMT_Y];
grdproject.c:				x_c += GMT->current.proj.origin[GMT_X];
grdproject.c:				y_c += GMT->current.proj.origin[GMT_Y];
grdproject.c:			GMT->common.R.active[RSET] = false;	/* We need to reset this to not fall into non-wanted branch deeper down */
grdproject.c:			if (gmt_M_err_pass (GMT, gmt_proj_setup (GMT, GMT->common.R.wesn), "")) Return (GMT_PROJECTION_ERROR);
grdproject.c:			wesn[XLO] *= GMT->current.proj.scale[GMT_X];	wesn[XHI] *= GMT->current.proj.scale[GMT_X];
grdproject.c:			wesn[YLO] *= GMT->current.proj.scale[GMT_Y];	wesn[YHI] *= GMT->current.proj.scale[GMT_Y];
grdproject.c:				wesn[XLO] += GMT->current.proj.origin[GMT_X];	wesn[XHI] += GMT->current.proj.origin[GMT_X];
grdproject.c:				wesn[YLO] += GMT->current.proj.origin[GMT_Y];	wesn[YHI] += GMT->current.proj.origin[GMT_Y];
grdproject.c:			GMT->common.R.active[RSET] = false;
grdproject.c:			gmt_M_memcpy (wesn, GMT->common.R.wesn, 4, double);	/* Load up our best wesn setting - it will be used below if -I */
grdproject.c:	if (gmt_M_err_pass (GMT, gmt_proj_setup (GMT, GMT->common.R.wesn), "")) Return (GMT_PROJECTION_ERROR);
grdproject.c:	xmin = (Ctrl->C.active) ? GMT->current.proj.rect[XLO] - GMT->current.proj.origin[GMT_X] : GMT->current.proj.rect[XLO];
grdproject.c:	xmax = (Ctrl->C.active) ? GMT->current.proj.rect[XHI] - GMT->current.proj.origin[GMT_X] : GMT->current.proj.rect[XHI];
grdproject.c:	ymin = (Ctrl->C.active) ? GMT->current.proj.rect[YLO] - GMT->current.proj.origin[GMT_Y] : GMT->current.proj.rect[YLO];
grdproject.c:	ymax = (Ctrl->C.active) ? GMT->current.proj.rect[YHI] - GMT->current.proj.origin[GMT_Y] : GMT->current.proj.rect[YHI];
grdproject.c:		xmin /= GMT->current.proj.scale[GMT_X];
grdproject.c:		xmax /= GMT->current.proj.scale[GMT_X];
grdproject.c:		ymin /= GMT->current.proj.scale[GMT_Y];
grdproject.c:		ymax /= GMT->current.proj.scale[GMT_Y];
grdproject.c:	sprintf (format, "(%s/%s/%s/%s)", GMT->current.setting.format_float_out, GMT->current.setting.format_float_out,
grdproject.c:	                                  GMT->current.setting.format_float_out, GMT->current.setting.format_float_out);
grdproject.c:		/* if (GMT->common.R.oblique) gmt_M_double_swap (s, e); */  /* Got w/s/e/n, make into w/e/s/n */
grdproject.c:		if (gmt_M_is_azimuthal(GMT) && GMT->current.proj.polar) {	/* Watch out for polar cap grids */
grdproject.c:			gmt_geo_to_xy (GMT, 0.0, GMT->current.proj.pole, &px, &py);	/* Projected coordinates of the relevant pole */
grdproject.c:				if (GMT->current.proj.north_pole) {	/* And one of the latitude bounds must extend to the right pole */
grdproject.c:		if (GMT->common.R.active[GSET]) offset = !offset;	/* Toggle */
grdproject.c:		gmt_M_err_fail (GMT, gmt_project_init (GMT, Geo->header, GMT->common.R.inc, use_nx, use_ny, Ctrl->E.dpi, offset), Ctrl->G.file);
grdproject.c:			Rect->header->wesn[XLO] *= GMT->current.proj.scale[GMT_X];
grdproject.c:			Rect->header->wesn[XHI] *= GMT->current.proj.scale[GMT_X];
grdproject.c:			Rect->header->wesn[YLO] *= GMT->current.proj.scale[GMT_Y];
grdproject.c:			Rect->header->wesn[YHI] *= GMT->current.proj.scale[GMT_Y];
grdproject.c:		else if (GMT->current.setting.proj_length_unit != GMT_INCH) {	/* Convert from inch to whatever */
grdproject.c:			Rect->header->wesn[XLO] += GMT->current.proj.origin[GMT_X];
grdproject.c:			Rect->header->wesn[XHI] += GMT->current.proj.origin[GMT_X];
grdproject.c:			Rect->header->wesn[YLO] += GMT->current.proj.origin[GMT_Y];
grdproject.c:			Rect->header->wesn[YHI] += GMT->current.proj.origin[GMT_Y];
grdproject.c:		gmt_M_memcpy (Rect->header->wesn, GMT->current.proj.rect, 4, double);
grdproject.c:				GMT->common.R.inc[GMT_X] *= inv_scale;
grdproject.c:				GMT->common.R.inc[GMT_Y] *= inv_scale;
grdproject.c:			GMT->common.R.inc[GMT_X] *= GMT->current.proj.scale[GMT_X];
grdproject.c:			GMT->common.R.inc[GMT_Y] *= GMT->current.proj.scale[GMT_Y];
grdproject.c:		else if (GMT->current.setting.proj_length_unit != GMT_INCH) {	/* Convert from inch to whatever */
grdproject.c:			GMT->common.R.inc[GMT_X] *= unit_to_inch;
grdproject.c:			GMT->common.R.inc[GMT_Y] *= unit_to_inch;
grdproject.c:		if (GMT->common.R.active[GSET]) offset = !offset;	/* Toggle */
grdproject.c:		gmt_M_err_fail (GMT, gmt_project_init (GMT, Rect->header, GMT->common.R.inc, use_nx, use_ny, Ctrl->E.dpi, offset), Ctrl->G.file);
grdproject.c:			Rect->header->wesn[XLO] -= GMT->current.proj.origin[GMT_X];
grdproject.c:			Rect->header->wesn[XHI] -= GMT->current.proj.origin[GMT_X];
grdproject.c:			Rect->header->wesn[YLO] -= GMT->current.proj.origin[GMT_Y];
grdproject.c:			Rect->header->wesn[YHI] -= GMT->current.proj.origin[GMT_Y];
grdproject.c:			Rect->header->wesn[XLO] /= GMT->current.proj.scale[GMT_X];
grdproject.c:			Rect->header->wesn[XHI] /= GMT->current.proj.scale[GMT_X];
grdproject.c:			Rect->header->wesn[YLO] /= GMT->current.proj.scale[GMT_Y];
grdproject.c:			Rect->header->wesn[YHI] /= GMT->current.proj.scale[GMT_Y];
grdproject.c:		else if (GMT->current.setting.proj_length_unit != GMT_INCH) {	/* Convert from inch to whatever */
grdproject.c:		if (GMT->common.J.proj4string[0])
grdproject.c:			Rect->header->ProjRefPROJ4 = strdup (GMT->common.J.proj4string);
grdproject.c:		else if (GMT->common.J.WKTstring[0])
grdproject.c:			Rect->header->ProjRefWKT = strdup (GMT->common.J.WKTstring);
grdsample.c:			n = gmt_M_x_to_col(Gin->header->wesn[YHI], wesn[YLO], API->GMT->common.R.inc[GMT_Y], 0, 0);	/* First 0 is ref grid's xy_off. So it could != 0 */
grdsample.c:			y = wesn[YLO] + n * API->GMT->common.R.inc[GMT_Y];
grdsample.c:			wesn[YHI] = d >= 0 ? y : wesn[YLO] + (n - 1) * API->GMT->common.R.inc[GMT_Y]; 
grdsample.c:			n = gmt_M_x_to_col(Gin->header->wesn[YLO], wesn[YLO], API->GMT->common.R.inc[GMT_Y], 0, 0);	/* First 0 is ref grid's xy_off. So it could != 0 */
grdsample.c:			y = wesn[YLO] + n * API->GMT->common.R.inc[GMT_Y];
grdsample.c:			wesn[YLO] = d > 0 ? wesn[YLO] + (n + 1) * API->GMT->common.R.inc[GMT_Y] : y; 
grdsample.c:			n = gmt_M_x_to_col(Gin->header->wesn[XHI], wesn[XLO], API->GMT->common.R.inc[GMT_X], 0, 0);	/* First 0 is ref grid's xy_off. So it could != 0 */
grdsample.c:			x = wesn[XLO] + n * API->GMT->common.R.inc[GMT_X];
grdsample.c:			wesn[XHI] = d >= 0 ? x : wesn[XLO] + (n - 1) * API->GMT->common.R.inc[GMT_X]; 
grdsample.c:			n = gmt_M_x_to_col(Gin->header->wesn[XLO], wesn[XLO], API->GMT->common.R.inc[GMT_X], 0, 0);	/* First 0 is ref grid's xy_off. So it could != 0 */
grdsample.c:			x = wesn[XLO] + n * API->GMT->common.R.inc[GMT_X];
grdsample.c:			wesn[XLO] = d > 0 ? wesn[XLO] + (n + 1) * API->GMT->common.R.inc[GMT_X] : x; 
grdsample.c:	struct GMTAPI_CTRL *API = GMT->parent;
grdsample.c:					gmt_strncpy (GMT->common.n.BC, opt->arg, 4U);
grdsample.c:					if (!strcmp (GMT->common.n.BC, "g")) {
grdsample.c:				if (GMT->common.R.active[FSET]) GMT->common.R.active[GSET] = false;	/* Override any implicit -r via -Rgridfile */
grdsample.c:	n_errors += gmt_M_check_condition (GMT, GMT->common.R.active[GSET] && Ctrl->T.active && !GMT->common.R.active[FSET], 
grdsample.c:	n_errors += gmt_M_check_condition (GMT, GMT->common.R.active[ISET] && (GMT->common.R.inc[GMT_X] <= 0.0 || GMT->common.R.inc[GMT_Y] <= 0.0), 
grdsample.c:	gmt_M_memcpy (wesn, (GMT->common.R.active[RSET] ? GMT->common.R.wesn : Gin->header->wesn), 4, double);
grdsample.c:	gmt_M_memcpy (inc, (GMT->common.R.active[ISET] ? GMT->common.R.inc : Gin->header->inc), 2, double);
grdsample.c:	else if (GMT->common.R.active[GSET])
grdsample.c:		registration = GMT->common.R.registration;
grdsample.c:	if (GMT->common.R.active[RSET]) {		/* Make sure input grid and output -R has an overlap */
grdsample.c:		     wesn[XHI] > (Gin->header->wesn[XHI] + Gin->header->inc[GMT_X])) && GMT->common.R.active[FSET]) {
grdsample.c:		GMT->current.setting.format_float_out, GMT->current.setting.format_float_out, GMT->current.setting.format_float_out, 
grdsample.c:		GMT->current.setting.format_float_out, GMT->current.setting.format_float_out, GMT->current.setting.format_float_out);
grdsample.c:	if (!GMT->common.n.truncate && (Gout->header->z_min < Gin->header->z_min || Gout->header->z_max > Gin->header->z_max)) {	/* Report and possibly truncate output to input extrama */
grdsample.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Output grid extrema [%g/%g] exceeds extrema of input grid [%g/%g]; to clip output use -n...+c""\n",
grdtrack.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -G option: Give imgfile, scale, mode [and optionally max_lat]\n");
grdtrack.c:	struct GMTAPI_CTRL *API = GMT->parent;
grdtrack.c:						gmt_strncpy (GMT->common.n.BC, opt->arg, 4U);
grdtrack.c:					GMT->current.setting.io_nan_mode = GMT_IO_NAN_ONE;
grdtrack.c:				GMT_Report (GMT->parent, GMT_MSG_COMPAT, "Leading + with increment to set ellipsoidal mode is deprecated; use -je instead\n");
grdtrack.c:					GMT_Report (GMT->parent, GMT_MSG_COMPAT, "Leading - to increment to set Flat Earth mode is deprecated; use -jf instead\n");
grdtrack.c:					GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Negative increment is not allowed\n");
grdtrack.c:	if (error) GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -E:  All lines must have the same distance units\n");
grdtrack.c:		value[g] = GMT->session.d_NaN;	/* In case the point is outside only some of the grids */
grdtrack.c:	sprintf (run_cmd, "# %s %s", GMT->init.module_name, cmd);	/* Build command line argument string */
grdtrack.c:	if (GMT->common.R.active[RSET]) gmt_M_memcpy (wesn, GMT->common.R.wesn, 4, double);	/* Specified a subset */
grdtrack.c:			if (GMT->common.R.active[RSET]) gmt_M_err_fail (GMT, gmt_adjust_loose_wesn (GMT, wesn, GC[g].G->header), "");		/* Subset requested; make sure wesn matches header spacing */
grdtrack.c:			if (!GMT->common.R.active[RSET]) gmt_M_memcpy (GMT->common.R.wesn, GC[g].G->header->wesn, 4, double);
grdtrack.c:			gmt_M_memcpy (GMT->common.R.wesn, wesn, 4, double);
grdtrack.c:			if (!GMT->current.map.dist[GMT_MAP_DIST].arc) Ctrl->E.step *= GMT->current.proj.DIST_M_PR_DEG;	/* Convert from degrees to meters or from min/secs to degrees */
grdtrack.c:			Ctrl->E.step *= GMT->current.map.dist[GMT_MAP_DIST].scale;	/* Scale to chosen unit */
grdtrack.c:			if (Ctrl->A.loxo) GMT->current.map.loxodrome = true, Ctrl->C.dist_mode = 1 + GMT_LOXODROME;
grdtrack.c:			GMT->current.setting.io_lonlat_toggle[GMT_OUT] = false;	/* Since no x,y involved here */
grdtrack.c:		ix = (GMT->current.setting.io_lonlat_toggle[GMT_IN]);	iy = 1 - ix;
grdtrack.c:				Out->text = (GMT->current.io.trailing_text[GMT_OUT]) ? In->text : NULL;
grdtrend.c:	sprintf(format, "Coefficient fit to %%s: %s\n", GMT->current.setting.format_float_out);
grdtrend.c:	for (i = 0; i < n_model; i++) GMT_Message (GMT->parent, GMT_TIME_NONE, format, pbasis[i], gtd[i]);
grdtrend.c:	gmt_M_memcpy (wesn, GMT->common.R.wesn, 4, double);	/* Current -R setting, if any */
grdtrend.c:			sprintf (format, "grdtrend: Robust iteration %%d:  Old Chi Squared: %s  New Chi Squared: %s\n", GMT->current.setting.format_float_out, GMT->current.setting.format_float_out);
grdvector.c:	C->W.pen = GMT->current.setting.map_default_pen;
grdvector.c:	C->S.unit = unit[GMT->current.setting.proj_length_unit];
grdvector.c:		API->GMT->session.unit_name[API->GMT->current.setting.proj_length_unit]);
grdvector.c:	             API->GMT->session.unit_name[API->GMT->current.setting.proj_length_unit]);
grdvector.c:	GMT_Message (API, GMT_TIME_NONE, "\t   Default pen attributes [%s].\n", gmt_putpen(API->GMT, &API->GMT->current.setting.map_default_pen));
grdvector.c:	struct GMTAPI_CTRL *API = GMT->parent;
grdvector.c:			case 'I':	/* Only use gridnodes GMT->common.R.inc[GMT_X],GMT->common.R.inc[GMT_Y] apart */
grdvector.c:					Ctrl->Q.S.size_x = VECTOR_HEAD_LENGTH * GMT->session.u2u[GMT_PT][GMT_INCH];	/* 9p */
grdvector.c:					Ctrl->Q.S.v.pen = GMT->current.setting.map_default_pen;
grdvector.c:						Ctrl->Q.S.size_x = VECTOR_HEAD_LENGTH * GMT->session.u2u[GMT_PT][GMT_INCH];	/* 9p */
grdvector.c:						Ctrl->Q.S.v.v_norm *= GMT->session.u2u[Ctrl->Q.S.u][GMT_INCH];	/* Since we are not reading this again we change to inches */
grdvector.c:	n_errors += gmt_M_check_condition (GMT, !GMT->common.J.active, "Syntax error: Must specify a map projection with the -J option\n");
grdvector.c:	n_errors += gmt_M_check_condition (GMT, GMT->common.R.active[ISET] && (GMT->common.R.inc[GMT_X] <= 0.0 || GMT->common.R.inc[GMT_Y] <= 0.0),
grdvector.c:	if (!GMT->common.R.active[RSET])	/* -R was not set so we use the grid domain */
grdvector.c:	if (gmt_M_err_pass (GMT, gmt_map_setup (GMT, GMT->common.R.wesn), "")) Return (GMT_PROJECTION_ERROR);
grdvector.c:		gmt_plane_perspective (GMT, GMT->current.proj.z_project.view_plane, GMT->current.proj.z_level);
grdvector.c:			Ctrl->S.factor *= GMT->session.u2u[GMT_CM][GMT_INCH];
grdvector.c:			Ctrl->S.factor *= GMT->session.u2u[GMT_INCH][GMT_INCH];
grdvector.c:			Ctrl->S.factor *= GMT->session.u2u[GMT_PT][GMT_INCH];
grdvector.c:			Ctrl->S.factor *= GMT->current.proj.KM_PR_DEG;
grdvector.c:			Ctrl->S.factor *= (GMT->current.proj.KM_PR_DEG / GMT_DEG2MIN_F);
grdvector.c:			Ctrl->S.factor *= (GMT->current.proj.KM_PR_DEG / GMT_DEG2SEC_F);
grdvector.c:		if (Ctrl->Q.S.symbol == PSL_VECTOR) Ctrl->Q.S.v.v_width = (float)(Ctrl->W.pen.width * GMT->session.u2u[GMT_PT][GMT_INCH]);
grdvector.c:	gmt_plane_perspective (GMT, GMT->current.proj.z_project.view_plane, GMT->current.proj.z_level);
grdvector.c:	if (!Ctrl->N.active) gmt_map_clip_on (GMT, GMT->session.no_rgb, 3);
grdvector.c:		GMT->common.R.inc[GMT_X] *= Grid[0]->header->inc[GMT_X];
grdvector.c:		GMT->common.R.inc[GMT_Y] *= Grid[0]->header->inc[GMT_Y];
grdvector.c:	if (GMT->common.R.inc[GMT_X] != 0.0 && GMT->common.R.inc[GMT_Y] != 0.0) {	/* Coarsen the output interval. The new -Idx/dy must be integer multiples of the grid dx/dy */
grdvector.c:		double val = GMT->common.R.inc[GMT_Y] * HH->r_inc[GMT_Y];	/* Should be ~ an integer within 1 ppm */
grdvector.c:			GMT_Report (API, GMT_MSG_NORMAL, "New y grid spacing (%.12lg) is not a multiple of actual grid spacing (%.12g) [within %g]\n", GMT->common.R.inc[GMT_Y], Grid[0]->header->inc[GMT_Y], GMT_CONV6_LIMIT);
grdvector.c:		GMT->common.R.inc[GMT_Y] = d_row * Grid[0]->header->inc[GMT_Y];	/* Get exact y-increment in case of slop */
grdvector.c:		val = GMT->common.R.inc[GMT_X] * HH->r_inc[GMT_X];
grdvector.c:			GMT_Report (API, GMT_MSG_NORMAL, "New x grid spacing (%.12g) is not a multiple of actual grid spacing (%.12g) [within %g]\n", GMT->common.R.inc[GMT_X], Grid[0]->header->inc[GMT_X], GMT_CONV6_LIMIT);
grdvector.c:		GMT->common.R.inc[GMT_X] = d_col * Grid[0]->header->inc[GMT_X];	/* Get exact x-increment in case of slop */
grdvector.c:		tmp = ceil (Grid[0]->header->wesn[YHI] / GMT->common.R.inc[GMT_Y]) * GMT->common.R.inc[GMT_Y];
grdvector.c:		if (tmp > Grid[0]->header->wesn[YHI]) tmp -= GMT->common.R.inc[GMT_Y];
grdvector.c:		tmp = floor (Grid[0]->header->wesn[XLO] / GMT->common.R.inc[GMT_X]) * GMT->common.R.inc[GMT_X];
grdvector.c:		if (tmp < Grid[0]->header->wesn[XLO]) tmp += GMT->common.R.inc[GMT_X];
grdvector.c:			gmt_M_rgb_copy (Ctrl->G.fill.rgb, GMT->session.no_rgb);
grdvector.c:					if (abs (GMT->current.map.this_x_status) > 1 || abs (GMT->current.map.this_y_status) > 1) continue;
grdvector.c:			strcpy (v_unit, API->GMT->session.unit_name[API->GMT->current.setting.proj_length_unit]);
grdvector.c:			v_min *= GMT->session.u2u[GMT_INCH][GMT->current.setting.proj_length_unit];
grdvector.c:			v_max *= GMT->session.u2u[GMT_INCH][GMT->current.setting.proj_length_unit];
grdvector.c:			v_mean *= GMT->session.u2u[GMT_INCH][GMT->current.setting.proj_length_unit];
grdvector.c:	PSL_command (GMT->PSL, "V\n");
grdvector.c:				if (abs (GMT->current.map.this_x_status) > 1 || abs (GMT->current.map.this_y_status) > 1) continue;
grdvector.c:				if (GMT->current.proj.projection_GMT == GMT_POLAR) {	/* Must rotate azimuth since circular projection */
grdvector.c:					x_orient = (GMT->current.proj.got_azimuths) ? -(x + GMT->current.proj.p_base_angle) : x - GMT->current.proj.p_base_angle - 90.0;
grdvector.c:						this_rgb = GMT->session.no_rgb;
grdvector.c:	PSL_command (GMT->PSL, "U\n");
grdview.c:	GMT->current.proj.z_project.ymin = +DBL_MAX;
grdview.c:	GMT->current.proj.z_project.ymax = -DBL_MAX;
grdview.c:		GMT->current.proj.z_project.ymin = MIN (GMT->current.proj.z_project.ymin, ytmp);
grdview.c:		GMT->current.proj.z_project.ymax = MAX (GMT->current.proj.z_project.ymax, ytmp);
grdview.c:			GMT->current.proj.z_project.ymin = MIN (GMT->current.proj.z_project.ymin, ytmp);
grdview.c:			GMT->current.proj.z_project.ymax = MAX (GMT->current.proj.z_project.ymax, ytmp);
grdview.c:			GMT->current.proj.z_project.ymin = MIN (GMT->current.proj.z_project.ymin, ytmp);
grdview.c:			GMT->current.proj.z_project.ymax = MAX (GMT->current.proj.z_project.ymax, ytmp);
grdview.c:			GMT->current.proj.z_project.ymin = MIN (GMT->current.proj.z_project.ymin, ytmp);
grdview.c:			GMT->current.proj.z_project.ymax = MAX (GMT->current.proj.z_project.ymax, ytmp);
grdview.c:			GMT->current.proj.z_project.ymin = MIN (GMT->current.proj.z_project.ymin, ytmp);
grdview.c:			GMT->current.proj.z_project.ymax = MAX (GMT->current.proj.z_project.ymax, ytmp);
grdview.c:	gmt_geoz_to_xy (GMT, Z->x[col], Z->y[row],   GMT->current.proj.z_project.level, &x0, &y0);
grdview.c:	gmt_geoz_to_xy (GMT, Z->x[col], Z->y[row-1], GMT->current.proj.z_project.level, &x1, &y1);
grdview.c:	if (GMT->current.proj.projection == GMT_POLAR) {	/* Polar cylindrical has 0 at center, not pole */
grdview.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Loop over y flipped for cylindrical/polar projection\n");
grdview.c:	GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Octant %d (az = %g) one = %d\n", oct, az, one);
grdview.c:	GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Outer loop over %c doing %d:%d:%d\n", kind[id[0]], start[0], inc[0], stop[0]);
grdview.c:	GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Inner loop over %c doing %d:%d:%d\n", kind[id[1]], start[1], inc[1], stop[1]);
grdview.c:	C->T.pen = C->W.pen[0] = C->W.pen[1] = C->W.pen[2] = GMT->current.setting.map_default_pen;	/* Tile and mesh pens */
grdview.c:	gmt_init_fill (GMT, &C->Q.fill, GMT->current.setting.ps_page_rgb[0], GMT->current.setting.ps_page_rgb[1], GMT->current.setting.ps_page_rgb[2]);
grdview.c:		gmt_putcolor (API->GMT, API->GMT->PSL->init.page_rgb));
grdview.c:	P = API->GMT->current.setting.map_default_pen;
grdview.c:	struct GMTAPI_CTRL *API = GMT->parent;
grdview.c:					gmt_strncpy (GMT->common.n.BC, opt->arg, 4U);
grdview.c:	if (Ctrl->N.facade && GMT->common.R.oblique) {	/* Cannot yet do facade with oblique grid */
grdview.c:	n_errors += gmt_M_check_condition (GMT, !GMT->common.J.active,
grdview.c:	n_errors += gmt_M_check_condition (GMT, Ctrl->T.active && GMT->current.proj.JZ_set,
grdview.c:	GMT->current.plot.mode_3D = 1;	/* Only do background axis first; do foreground at end */
grdview.c:	if (!GMT->common.R.active[RSET])	/* No -R, use grid region */
grdview.c:	gmt_M_memcpy (wesn, GMT->common.R.wesn, 4, double);
grdview.c:	if (GMT->common.R.wesn[ZLO] == 0.0 && GMT->common.R.wesn[ZHI] == 0.0) {
grdview.c:		GMT->common.R.wesn[ZLO] = Topo->header->z_min;
grdview.c:		GMT->common.R.wesn[ZHI] = Topo->header->z_max;
grdview.c:		if (Ctrl->N.active && Ctrl->N.level < GMT->common.R.wesn[ZLO]) GMT->common.R.wesn[ZLO] = Ctrl->N.level;
grdview.c:		if (Ctrl->N.active && Ctrl->N.level > GMT->common.R.wesn[ZHI]) GMT->common.R.wesn[ZHI] = Ctrl->N.level;
grdview.c:	if (gmt_M_err_pass (GMT, gmt_map_setup (GMT, GMT->common.R.wesn), "")) Return (GMT_PROJECTION_ERROR);
grdview.c:		gmt_plane_perspective (GMT, GMT->current.proj.z_project.view_plane, GMT->current.proj.z_level);
grdview.c:		GMT->current.plot.mode_3D |= 2;	/* Ensure that foreground axis is drawn */
grdview.c:	if (!GMT->current.proj.xyz_pos[2]) gmt_M_double_swap (GMT->common.R.wesn[ZLO], GMT->common.R.wesn[ZHI]);	/* Negative z-scale, must flip */
grdview.c:			while ((n = gmt_contours (GMT, Z, Ctrl->S.value, GMT->current.setting.interpolant, 0, edge, &begin, &x, &y)) > 0) {
grdview.c:			if (n_out == 4) Topo->data[ij] = Topo->data[ij+1] = Topo->data[ij+Topo->header->mx] = Topo->data[ij+Topo->header->mx+1] = GMT->session.f_NaN;	/* Entire tile is outside */
grdview.c:	gmt_plane_perspective (GMT, GMT->current.proj.z_project.view_plane, GMT->current.proj.z_level);
grdview.c:	if (GMT->current.proj.three_D) gmt_map_basemap (GMT); /* Plot basemap first if 3-D */
grdview.c:	if (GMT->current.proj.z_pars[0] == 0.0) gmt_map_clip_on (GMT, GMT->session.no_rgb, 3);
grdview.c:		if (!GMT->current.proj.z_project.draw[0]) {	/* Southern side */
grdview.c:			if (GMT->common.R.oblique) {
grdview.c:				gmt_geoz_to_xy (GMT, GMT->current.proj.z_project.corner_x[0], GMT->current.proj.z_project.corner_y[0], Ctrl->N.level, &xx[0], &yy[0]);
grdview.c:				gmt_geoz_to_xy (GMT, GMT->current.proj.z_project.corner_x[1], GMT->current.proj.z_project.corner_y[1], Ctrl->N.level, &xx[1], &yy[1]);
grdview.c:		if (!GMT->current.proj.z_project.draw[2]) {	/* Northern side */
grdview.c:			if (GMT->common.R.oblique) {
grdview.c:				gmt_geoz_to_xy (GMT, GMT->current.proj.z_project.corner_x[3], GMT->current.proj.z_project.corner_y[3], Ctrl->N.level, &xx[0], &yy[0]);
grdview.c:				gmt_geoz_to_xy (GMT, GMT->current.proj.z_project.corner_x[2], GMT->current.proj.z_project.corner_y[2], Ctrl->N.level, &xx[1], &yy[1]);
grdview.c:		if (!GMT->current.proj.z_project.draw[3]) {	/* Western side */
grdview.c:			if (GMT->common.R.oblique) {
grdview.c:				gmt_geoz_to_xy (GMT, GMT->current.proj.z_project.corner_x[0], GMT->current.proj.z_project.corner_y[0], Ctrl->N.level, &xx[0], &yy[0]);
grdview.c:				gmt_geoz_to_xy (GMT, GMT->current.proj.z_project.corner_x[3], GMT->current.proj.z_project.corner_y[3], Ctrl->N.level, &xx[1], &yy[1]);
grdview.c:		if (!GMT->current.proj.z_project.draw[1]) {	/* Eastern side */
grdview.c:			if (GMT->common.R.oblique) {
grdview.c:				gmt_geoz_to_xy (GMT, GMT->current.proj.z_project.corner_x[1], GMT->current.proj.z_project.corner_y[1], Ctrl->N.level, &xx[0], &yy[0]);
grdview.c:				gmt_geoz_to_xy (GMT, GMT->current.proj.z_project.corner_x[2], GMT->current.proj.z_project.corner_y[2], Ctrl->N.level, &xx[1], &yy[1]);
grdview.c:		if (!GMT->common.R.oblique) {
grdview.c:		x_width = GMT->current.proj.z_project.xmax - GMT->current.proj.z_project.xmin;	/* Size of image in inches */
grdview.c:		y_width = GMT->current.proj.z_project.ymax - GMT->current.proj.z_project.ymin;
grdview.c:					ix[bin] = MAX(0, MIN(irint (floor((xp - GMT->current.proj.z_project.xmin) * Ctrl->Q.dpi)), last_i));
grdview.c:					iy[bin] = MAX(0, MIN(irint (floor((yp - GMT->current.proj.z_project.ymin) * Ctrl->Q.dpi)), last_j));
grdview.c:					ix[bin] = MAX(0, MIN(irint (floor((xp - GMT->current.proj.z_project.xmin) * Ctrl->Q.dpi)), last_i));
grdview.c:					iy[bin] = MAX(0, MIN(irint (floor((yp - GMT->current.proj.z_project.ymin) * Ctrl->Q.dpi)), last_j));
grdview.c:			gray = gmt_M_u255 (gmt_M_yiq (GMT->current.setting.ps_page_rgb));
grdview.c:				gmt_M_rgb_copy (rgb, GMT->current.setting.ps_page_rgb);
grdview.c:				x_imask[k]  = x_imask[nk-k]  = GMT->current.proj.z_project.xmin + ip * x_pixel_size;
grdview.c:					y_imask[k] = y_imask[k1] = y_imask[nk-k] = y_imask[nk-k1] = GMT->current.proj.z_project.ymin;
grdview.c:					y_imask[k] = y_imask[k1] = GMT->current.proj.z_project.ymin + (top_jp[ip] + 1) * y_pixel_size;
grdview.c:					y_imask[nk-k] = y_imask[nk-k1] = GMT->current.proj.z_project.ymin + bottom_jp[ip] * y_pixel_size;
grdview.c:			PSL_beginclipping (PSL, x_imask, y_imask, 4 * nx_i, GMT->session.no_rgb, 3);
grdview.c:			PSL_plotcolorimage (PSL, GMT->current.proj.z_project.xmin, GMT->current.proj.z_project.ymin,
grdview.c:			PSL_plotcolorimage (PSL, GMT->current.proj.z_project.xmin, GMT->current.proj.z_project.ymin,
grdview.c:					if (P->bfn[GMT_NAN].skip || GMT->current.proj.three_D) continue;
grdview.c:					paint_it_grdview (GMT, PSL, P, xmesh, ymesh, 4, GMT->session.d_NaN, false, Ctrl->Q.monochrome, 0.0, Ctrl->Q.outline);
grdview.c:						PSL_setfill (PSL, GMT->session.no_rgb, true);
grdview.c:	if (GMT->current.proj.z_pars[0] == 0.0) gmt_map_clip_off (GMT);
grdview.c:		if (!GMT->current.proj.z_project.draw[0])	{	/* Southern side */
grdview.c:		if (!GMT->current.proj.z_project.draw[1]) {	/*	Eastern side */
grdview.c:		if (!GMT->current.proj.z_project.draw[2])	{	/* Northern side */
grdview.c:		if (!GMT->current.proj.z_project.draw[3]) {	/*	Western side */
grdview.c:	if (GMT->current.proj.three_D)
grdvolume.c:	C->L.value = GMT->session.d_NaN;
grdvolume.c:	struct GMTAPI_CTRL *API = GMT->parent;
grdvolume.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "-S requires a geographic grid.\n");
grdvolume.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "However, your grid domain seems compatible with geographical grid domains.\n");
grdvolume.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "To make sure your Cartesian grid is recognized as geographical, use the -fg option.\n");
grdvolume.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Alternatively, use gmt grdedit -fg to bless it as a geographic grid first.\n");
grdvolume.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Yours grid is recognized as Cartesian.\n");
grdvolume.c:	if (!GMT->common.R.active[RSET]) gmt_M_memcpy (GMT->common.R.wesn, Grid->header->wesn, 4, double);	/* No -R, use grid domain */
grdvolume.c:	gmt_M_memcpy (wesn, GMT->common.R.wesn, 4, double);
grdvolume.c:		dist_pr_deg = GMT->current.proj.DIST_M_PR_DEG;
grdvolume.c:		dist_pr_deg *= GMT->current.map.dist[GMT_MAP_DIST].scale;	/* Scales meters to desired unit */
grdvolume.c:	for (c = 0; c < n_contours; c++) height[c] = (area[c] > 0.0) ? vol[c] / area[c] : GMT->session.d_NaN;
grdvolume.c:	if (GMT->common.h.add_colnames) {
greenspline.c:	struct GMTAPI_CTRL *API = GMT->parent;
greenspline.c:				GMT->common.R.active[RSET] = true;
greenspline.c:				if (Ctrl->R3.dimension > 1) gmt_M_memcpy (GMT->common.R.wesn, Ctrl->R3.range, 4, double);
greenspline.c:					GMT->common.R.active[RSET] = true;
greenspline.c:		if (GMT->common.R.active[GSET]) {
greenspline.c:			GMT->common.R.active[GSET] = !Ctrl->R3.offset;
greenspline.c:			GMT->common.R.registration = !Ctrl->R3.offset;
greenspline.c:			GMT->common.R.active[GSET] = Ctrl->R3.offset;
greenspline.c:			GMT->common.R.registration = Ctrl->R3.offset;
greenspline.c:	n_errors += gmt_M_check_condition (GMT, !(GMT->common.R.active[RSET] || Ctrl->N.active || Ctrl->T.active), "Syntax error: No output locations specified (use either [-R -I], -N, or -T)\n");
greenspline.c:	n_errors += gmt_M_check_condition (GMT, (Ctrl->I.active + GMT->common.R.active[RSET]) == 1 && dimension == 2, "Syntax error: Must specify -R, -I, [-r], -G for gridding\n");
greenspline.c:	GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Precalculate max %u terms for Legendre summation\n", L+1);
greenspline.c:		if (GMT->common.b.active[GMT_IN]) GMT->common.b.ncol[GMT_IN]++;	/* Must assume it is just one extra column */
greenspline.c:		if (! (Grid->header->registration == GMT->common.R.registration)) {
greenspline.c:				GMT->common.R.registration, GMT_NOTSET, NULL)) == NULL) Return (API->error);
greenspline.c:			Grid->header->registration = GMT->common.R.registration;
greenspline.c:			gmt_M_memcpy (col_type, GMT->current.io.col_type[GMT_OUT], 2, unsigned int);	/* Save previous x/y output col types */
greenspline.c:			GMT->current.io.col_type[GMT_OUT][GMT_X] = GMT->current.io.col_type[GMT_OUT][GMT_Y] = GMT_IS_FLOAT;
greenspline.c:			gmt_M_memcpy (GMT->current.io.col_type[GMT_OUT], col_type, 2, unsigned int);	/* Restore output col types */
greenspline.c:		bool was = GMT->current.setting.io_header[GMT_OUT];	/* Current setting */
greenspline.c:		GMT->current.setting.io_header[GMT_OUT] = true;
greenspline.c:		GMT->current.setting.io_header[GMT_OUT] = was;	/* Restore default */
greenspline.c:		std = (m > 1) ? sqrt (std / (m-1.0)) : GMT->session.d_NaN;
greenspline.c:		GMT->common.b.ncol[GMT_OUT] = dimension + 1;
greenspline.c:							GMT->hidden.mem_coord[GMT_X][col] = V[dimension];
greenspline.c:						V[dimension] = GMT->hidden.mem_coord[GMT_X][col];
inset.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "No inset command given\n");
inset.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Not an inset command: %s\n", opt->arg);
inset.c:					GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error -M: No margins given.\n");
inset.c:					k = GMT_Get_Values (GMT->parent, opt->arg, Ctrl->M.margin, 4);
inset.c:						GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error -M: Bad number of margins given.\n");
inset.c:					for (k = 0; k < 4; k++) Ctrl->M.margin[k] *= GMT->session.u2u[GMT->current.setting.proj_length_unit][GMT_INCH];
inset.c:		n_errors += gmt_M_check_condition (GMT, GMT->common.J.active && !GMT->common.R.active[RSET], "Syntax error -J: Requires -R as well!\n");
inset.c:		if (GMT->common.J.active) {	/* Compute map height */
inset.c:			if (gmt_M_err_pass (GMT, gmt_map_setup (GMT, GMT->common.R.wesn), "")) n_errors++;
inset.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error -D: Not valid for gmt inset end.\n");
inset.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error -F: Not valid for gmt inset end.\n");
inset.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error -M: Not valid for gmt inset end.\n");
inset.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error -N: Not valid for gmt inset end.\n");
inset.c:	if (API->GMT->current.setting.run_mode == GMT_CLASSIC) {
inset.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "No active plot file to append to\n");
inset.c:		fprintf (fp, "# REGION: %s\n", GMT->common.R.string);
inset.c:		fprintf (fp, "# PROJ: %s\n", GMT->common.J.string);
kml2gmt.c:						GMT_Message (GMT->parent, GMT_TIME_NONE, "Bad feature type. Use s, l or p.\n");
kml2gmt.c:	if (GMT->common.b.active[GMT_IN] && GMT->common.b.ncol[GMT_IN] == 0) GMT->common.b.ncol[GMT_IN] = 2;
kml2gmt.c:	strcpy (GMT->current.setting.format_float_out, "%.12g");	/* Get enough decimals */
kml2gmt.c:			GMT->current.io.segment_header[0] = 0;
kml2gmt.c:			if (name[0]) { strcat (GMT->current.io.segment_header, "-L\""); strcat (GMT->current.io.segment_header, name); strcat (GMT->current.io.segment_header, "\""); }
kml2gmt.c:			if (name[0] && description[0]) strcat (GMT->current.io.segment_header, " ");
kml2gmt.c:			if (description[0]) { strcat (GMT->current.io.segment_header, "-D\""); strcat (GMT->current.io.segment_header, description); strcat (GMT->current.io.segment_header, "\""); }
kml2gmt.c:			if (!GMT->current.io.segment_header[0]) sprintf (GMT->current.io.segment_header, "Next Point");
kml2gmt.c:			if (!GMT->current.io.segment_header[0]) sprintf (GMT->current.io.segment_header, "Next feature");
makecpt.c:	C->G.z_low = C->G.z_high = GMT->session.d_NaN;	/* No truncation */
makecpt.c:	const char *H_OPT = (API->GMT->current.setting.run_mode == GMT_MODERN) ? " [-H]" : "";
makecpt.c:	if (API->GMT->current.setting.run_mode == GMT_MODERN)
makecpt.c:					GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -E option: Cannot decode value\n");
makecpt.c:					GMT_Report (GMT->parent, GMT_MSG_COMPAT, "Option -Qi or -Qo are deprecated; Use -T+l for old -Qo and -Q for old -Qi.\n");
makecpt.c:	if (Ctrl->H.active && GMT->current.setting.run_mode == GMT_CLASSIC) {
makecpt.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Unrecognized option -H\n");
makecpt.c:			GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Warning -T option: Without inc, -Z has no effect (ignored)\n");
makecpt.c:		Ctrl->C.file = strdup (GMT->init.cpt[0]);
makecpt.c:	write = (GMT->current.setting.run_mode == GMT_CLASSIC || Ctrl->H.active);	/* Only output to stdout in classic mode and with -H in modern mode */
mapproject.c:					GMT_Report (GMT->parent, GMT_MSG_COMPAT, "Leading -|+ with unit to set flat Earth or ellipsoidal mode is deprecated; use -j<mode> instead\n");
mapproject.c:					GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Signed unit is not allowed\n");
mapproject.c:		Ctrl->G.unit = set_unit_and_mode (GMT->parent, arg, &Ctrl->G.sph);	/* Unit specification */
mapproject.c:		Ctrl->G.unit = set_unit_and_mode (GMT->parent, arg, &Ctrl->G.sph);	/* Unit specification */
mapproject.c:		Ctrl->G.unit = set_unit_and_mode (GMT->parent, arg, &Ctrl->G.sph);	/* Unit specification */
mapproject.c:	struct GMTAPI_CTRL *API = GMT->parent;
mapproject.c:	if (GMT->current.proj.is_proj4) {
mapproject.c:		if (!GMT->common.R.active[RSET]) {	/* Means MAYBE a 1:1 scale was used */
mapproject.c:			GMT->common.R.wesn[XLO] = 0;	GMT->common.R.wesn[XHI] = 1;
mapproject.c:			GMT->common.R.wesn[YLO] = 0;	GMT->common.R.wesn[YHI] = 1;
mapproject.c:			GMT->common.R.active[RSET] = true;
mapproject.c:		if (GMT->current.proj.pars[14] == 1)
mapproject.c:		GMT->current.ps.active = true;	/* Briefly pretend we are a PS-producing module */
mapproject.c:		GMT->current.ps.active = false;	/* Come to our senses */
mapproject.c:	n_errors += gmt_M_check_condition (GMT, GMT->common.p.active && Ctrl->I.active, "Syntax error: -p cannot work with -I\n");
mapproject.c:	n_errors += gmt_M_check_condition (GMT, !GMT->common.J.active && (Ctrl->G.mode || Ctrl->L.active) && Ctrl->G.unit == 'C',
mapproject.c:	n_errors += gmt_M_check_condition (GMT, GMT->common.J.active && Ctrl->G.active && Ctrl->G.unit != 'C',
mapproject.c:	n_errors += gmt_M_check_condition (GMT, GMT->common.J.active && Ctrl->L.active && Ctrl->L.unit != 'C',
mapproject.c:	if (!GMT->common.R.active[RSET] && GMT->current.proj.projection_GMT == GMT_UTM && Ctrl->C.active) {	/* Set default UTM region from zone info */
mapproject.c:		if (GMT->current.proj.utm_hemisphere == 0)		/* Default to N hemisphere if nothing is known */
mapproject.c:			GMT->current.proj.utm_hemisphere = 1;
mapproject.c:		if (gmt_UTMzone_to_wesn (GMT, GMT->current.proj.utm_zonex, GMT->current.proj.utm_zoney,
mapproject.c:		                         GMT->current.proj.utm_hemisphere, GMT->common.R.wesn)) {
mapproject.c:				GMT->common.R.wesn[XLO], GMT->common.R.wesn[XHI], GMT->common.R.wesn[YLO], GMT->common.R.wesn[YHI]);
mapproject.c:		GMT->common.R.active[RSET] = true;
mapproject.c:	n_errors += gmt_M_check_condition (GMT, !GMT->common.R.active[RSET] && !(geodetic_calc || Ctrl->T.active || Ctrl->E.active ||
mapproject.c:	n_errors += gmt_M_check_condition (GMT, ((Ctrl->T.active && GMT->current.proj.datum.h_given) || Ctrl->E.active) &&
mapproject.c:	                                   GMT->common.b.active[GMT_IN] && gmt_get_cols (GMT, GMT_IN) < 3,
mapproject.c:	if (!(n_errors || GMT->common.R.active[RSET])) {
mapproject.c:		GMT->common.R.wesn[XLO] = 0.0;	GMT->common.R.wesn[XHI] = 360.0;
mapproject.c:		GMT->common.R.wesn[YLO] = -90.0;	GMT->common.R.wesn[YHI] = 90.0;
mapproject.c:	if (!GMT->common.J.active && gmt_M_is_cartesian (GMT, GMT_IN)) { /* -J not given and input not specified as lon/lat; check if we should add -fg */
mapproject.c:			(i == GMT->current.setting.proj_ellipsoid) ? GMT_Message (API, GMT_TIME_NONE, "->") : GMT_Message (API, GMT_TIME_NONE,  "  ");
mapproject.c:			             GMT->current.setting.ref_ellipsoid[i].name, GMT->current.setting.ref_ellipsoid[i].date,
mapproject.c:			             GMT->current.setting.ref_ellipsoid[i].eq_radius, 1.0/GMT->current.setting.ref_ellipsoid[i].flattening);
mapproject.c:			(!strcmp (GMT->current.setting.proj_datum[i].name, "WGS 1984")) ? GMT_Message (API, GMT_TIME_NONE, "->") :
mapproject.c:			             i, GMT->current.setting.proj_datum[i].name, GMT->current.setting.proj_datum[i].ellipsoid,
mapproject.c:			             GMT->current.setting.proj_datum[i].xyz[0], GMT->current.setting.proj_datum[i].xyz[1],
mapproject.c:			             GMT->current.setting.proj_datum[i].xyz[2], GMT->current.setting.proj_datum[i].region);
mapproject.c:	if (Ctrl->T.active && GMT->current.proj.projection_GMT != GMT_LINEAR && GMT->common.R.active[RSET]) {	/* Do datum shift & project coordinates */
mapproject.c:			if (GMT->current.proj.datum.from.ellipsoid_id < 0) {
mapproject.c:				GMT->current.setting.proj_ellipsoid = GMT_N_ELLIPSOIDS - 1;
mapproject.c:				GMT->current.setting.ref_ellipsoid[i].eq_radius = GMT->current.proj.datum.from.a;
mapproject.c:				GMT->current.setting.ref_ellipsoid[i].flattening = GMT->current.proj.datum.from.f;
mapproject.c:				GMT->current.setting.proj_ellipsoid = GMT->current.proj.datum.from.ellipsoid_id;
mapproject.c:			if (GMT->current.proj.datum.to.ellipsoid_id < 0) {
mapproject.c:				GMT->current.setting.proj_ellipsoid = GMT_N_ELLIPSOIDS - 1;
mapproject.c:				GMT->current.setting.ref_ellipsoid[i].eq_radius = GMT->current.proj.datum.to.a;
mapproject.c:				GMT->current.setting.ref_ellipsoid[i].flattening = GMT->current.proj.datum.to.f;
mapproject.c:				GMT->current.setting.proj_ellipsoid = GMT->current.proj.datum.to.ellipsoid_id;
mapproject.c:	if (!GMT->common.J.active) {	/* Supply dummy linear proj */
mapproject.c:		if (!GMT->common.R.active[RSET]) {
mapproject.c:			GMT->common.R.wesn[XLO] = 0.0;	GMT->common.R.wesn[XHI] = 360.0;
mapproject.c:			GMT->common.R.wesn[YLO] = -90.0;	GMT->common.R.wesn[YHI] = 90.0;
mapproject.c:	if (gmt_M_err_pass (GMT, gmt_proj_setup (GMT, GMT->common.R.wesn), "")) Return (GMT_PROJECTION_ERROR);
mapproject.c:				w_out[GMT_X] = GMT->current.proj.rect[XHI] * inch_to_unit;	n_output = 1;	break;
mapproject.c:				w_out[GMT_X] = GMT->current.proj.rect[YHI] * inch_to_unit;	n_output = 1;	break;
mapproject.c:				w_out[GMT_X] = GMT->current.proj.rect[XHI] * inch_to_unit;
mapproject.c:				w_out[GMT_Y] = GMT->current.proj.rect[YHI] * inch_to_unit;
mapproject.c:		sprintf (format, "%s/%s/%s/%s", GMT->current.setting.format_float_out, GMT->current.setting.format_float_out,
mapproject.c:		                                GMT->current.setting.format_float_out, GMT->current.setting.format_float_out);
mapproject.c:		xmin = (Ctrl->C.active) ? GMT->current.proj.rect[XLO] - GMT->current.proj.origin[GMT_X] : GMT->current.proj.rect[XLO];
mapproject.c:		xmax = (Ctrl->C.active) ? GMT->current.proj.rect[XHI] - GMT->current.proj.origin[GMT_X] : GMT->current.proj.rect[XHI];
mapproject.c:		ymin = (Ctrl->C.active) ? GMT->current.proj.rect[YLO] - GMT->current.proj.origin[GMT_Y] : GMT->current.proj.rect[YLO];
mapproject.c:		ymax = (Ctrl->C.active) ? GMT->current.proj.rect[YHI] - GMT->current.proj.origin[GMT_Y] : GMT->current.proj.rect[YHI];
mapproject.c:			xmin /= GMT->current.proj.scale[GMT_X];
mapproject.c:			xmax /= GMT->current.proj.scale[GMT_X];
mapproject.c:			ymin /= GMT->current.proj.scale[GMT_Y];
mapproject.c:			ymax /= GMT->current.proj.scale[GMT_Y];
mapproject.c:			GMT_Message (API, GMT_TIME_NONE, format, GMT->common.R.wesn[XLO], GMT->common.R.wesn[XHI],
mapproject.c:			             GMT->common.R.wesn[YLO], GMT->common.R.wesn[YHI]);
mapproject.c:	two = (Ctrl->E.active || (Ctrl->T.active && GMT->current.proj.datum.h_given)) ? 3 : 2;	/* # of output points from conversion */
mapproject.c:			GMT->current.io.status = 0;	/* Done with gap */
mapproject.c:						in[GMT_X] *= GMT->current.proj.scale[GMT_X];
mapproject.c:						in[GMT_Y] *= GMT->current.proj.scale[GMT_Y];
mapproject.c:				else if (GMT->current.setting.proj_length_unit != GMT_INCH) {	/* Convert from whatever to inch */
mapproject.c:					in[GMT_X] += GMT->current.proj.origin[GMT_X];
mapproject.c:					in[GMT_Y] += GMT->current.proj.origin[GMT_Y];
mapproject.c:					out[GMT_X] -= GMT->current.proj.origin[GMT_X];
mapproject.c:					out[GMT_Y] -= GMT->current.proj.origin[GMT_Y];
mapproject.c:						out[GMT_X] /= GMT->current.proj.scale[GMT_X];
mapproject.c:						out[GMT_Y] /= GMT->current.proj.scale[GMT_Y];
mapproject.c:				else if (GMT->current.setting.proj_length_unit != GMT_INCH) {	/* Convert from inch to whatever */
mapproject.c:				if (GMT->current.proj.three_D) {
mapproject.c:							d = GMT->session.d_NaN;
mapproject.c:		         GMT->current.setting.format_float_out, GMT->current.setting.format_float_out,
mapproject.c:		         GMT->current.setting.format_float_out, GMT->current.setting.format_float_out);
mapproject.c:			         GMT->current.setting.format_float_out, GMT->current.setting.format_float_out,
mapproject.c:			         GMT->current.setting.format_float_out, GMT->current.setting.format_float_out);
mapproject.c:			else if (Ctrl->T.active && GMT->current.proj.datum.h_given)
movie.c:	C->x.n_threads = GMT->parent->n_cores;	/* Use all cores available unless -x is set */
movie.c:		Ctrl->x.n_threads = MAX(GMT->parent->n_cores + Ctrl->x.n_threads, 1);		/* Max-n but at least one */
movie.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Main script is bash/sh but %s is not!\n", file);
movie.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Main script is csh but %s is not!\n", file);
movie.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Main script is bat but %s is not!\n", file);
movie.c:		gmt_putfont (API->GMT, &API->GMT->current.setting.font_tag));
movie.c:	if (GMT->current.setting.proj_length_unit == GMT_INCH) {	/* Switch from SI to US dimensions in inches given format names */
movie.c:									GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error option -A+s: Allowable strides are 2,5,10,20,50,100,200,500,...\n");
movie.c:						GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error option -C: Requires name of a known format or give width x height x dpu string\n");
movie.c:							Ctrl->C.unit = GMT->session.unit_name[GMT->current.setting.proj_length_unit][0];
movie.c:					GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error option -F: Unrecognized format %s\n", opt->arg);
movie.c:					GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error option -F: Format %s already selected\n", opt->arg);
movie.c:					GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error option -L: Cannot handle more than %d tags\n", GMT_LEN32);
movie.c:				Ctrl->L.tag[T].off[GMT_X] = Ctrl->L.tag[T].off[GMT_Y] = 0.01 * GMT_TEXT_OFFSET * GMT->current.setting.font_tag.size / PSL_POINTS_PER_INCH; /* 20% */
movie.c:				Ctrl->L.tag[T].clearance[GMT_X] = Ctrl->L.tag[T].clearance[GMT_Y] = 0.01 * GMT_TEXT_CLEARANCE * GMT->current.setting.font_tag.size / PSL_POINTS_PER_INCH;	/* 15% */
movie.c:				gmt_M_memcpy (&(Ctrl->L.tag[T].font), &(GMT->current.setting.font_tag), 1, struct GMT_FONT);
movie.c:						GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error option -L: Select -Lf, -Lc<col> or -Lt<col>\n");
movie.c:							GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error option -L: +f not given any font\n");
movie.c:						GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error option -L: +t not given any format\n");
movie.c:					GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error option -S: Select -Sb or -Sf\n");
movie.c:					GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error option -S%c: Unable to open script %s\n", opt->arg[0], Ctrl->S[k].file);
movie.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Unable to determine script language from the extension of your script %s\n", Ctrl->In.file);
movie.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Allowable extensions are: *.sh, *.bash, *.csh, and *.bat\n");
movie.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Unable to open include script file %s\n", Ctrl->I.file);
movie.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Unable to open main script file %s\n", Ctrl->In.file);
movie.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Your main script file %s is not in GMT modern mode\n", Ctrl->In.file);
movie.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Unable to determine current working directory - exiting.\n");
movie.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Unable to determine current working directory.\n");
movie.c:	if (GMT->session.DATADIR)	/* Prepend initial and subdir as new datadirs to the existing search list */
movie.c:		sprintf (datadir, "%s,%s,%s", topdir, cwd, GMT->session.DATADIR);	/* Start with topdir */
movie.c:		format = (GMT->current.map.frame.primary) ? GMT->current.setting.format_time[GMT_PRIMARY] : GMT->current.setting.format_time[GMT_SECONDARY];
movie.c:						gmt_format_calendar (GMT, date, clock, &GMT->current.plot.calclock.date, &GMT->current.plot.calclock.clock, upper_case, flavor, L_col);
movie.c:						if (GMT->current.plot.calclock.clock.skip)
movie.c:						else if (GMT->current.plot.calclock.date.skip)
nearneighbor.c:	struct GMTAPI_CTRL *API = GMT->parent;
nearneighbor.c:					Ctrl->E.value = (opt->arg[0] == 'N' || opt->arg[0] == 'n') ? GMT->session.d_NaN : atof (opt->arg);
nearneighbor.c:					gmt_strncpy (GMT->common.n.BC, opt->arg, 4U);
nearneighbor.c:					if (!strcmp (GMT->common.n.BC, "g")) {
nearneighbor.c:	n_errors += gmt_M_check_condition (GMT, !GMT->common.R.active[RSET], "Syntax error: Must specify -R option\n");
nearneighbor.c:	n_errors += gmt_M_check_condition (GMT, GMT->common.R.inc[GMT_X] <= 0.0 || GMT->common.R.inc[GMT_Y] <= 0.0, "Syntax error -I option: Must specify positive increment(s)\n");
nearneighbor.c:	if (!Ctrl->E.active) Ctrl->E.value = GMT->session.d_NaN;
nearneighbor.c:		sprintf (line, "%s)\n", GMT->current.setting.format_float_out);
project.c:	struct GMTAPI_CTRL *API = GMT->parent;
project.c:					if (opt->arg[0] == 'g') GMT->current.io.geo.range = GMT_IS_0_TO_P360_RANGE;
project.c:					if (opt->arg[0] == 'd') GMT->current.io.geo.range = GMT_IS_M180_TO_P180_RANGE;
project.c:			p_data[rec].a[2] *= GMT->current.proj.DIST_KM_PR_DEG;
project.c:			p_data[rec].a[3] *= GMT->current.proj.DIST_KM_PR_DEG;
project.c:		GMT_Put_Record (GMT->parent, GMT_WRITE_DATA, Out);	/* Write this to output */
project.c:			if (Ctrl->Q.active) Ctrl->L.max *= GMT->current.proj.DIST_KM_PR_DEG;
project.c:			if (Ctrl->Q.active) Ctrl->L.max *= GMT->current.proj.DIST_KM_PR_DEG;
project.c:		Ctrl->G.inc /= GMT->current.proj.DIST_KM_PR_DEG;
project.c:		Ctrl->L.min /= GMT->current.proj.DIST_KM_PR_DEG;
project.c:		Ctrl->L.max /= GMT->current.proj.DIST_KM_PR_DEG;
project.c:		Ctrl->W.min /= GMT->current.proj.DIST_KM_PR_DEG;
project.c:		Ctrl->W.max /= GMT->current.proj.DIST_KM_PR_DEG;
project.c:				p_data[rec].a[2] *= GMT->current.proj.DIST_KM_PR_DEG;
project.c:				p_data[rec].a[3] *= GMT->current.proj.DIST_KM_PR_DEG;
project.c:		if (!GMT->common.b.active[GMT_OUT] && Ctrl->G.header) {	/* Want segment header on output */
project.c:				sprintf (GMT->current.io.segment_header, "%s", z_header);
project.c:				sprintf (GMT->current.io.segment_header, "%s-circle Pole at %g %g", type[kind], P.plon, P.plat);
project.c:								for (k = 0; k < P.n_z; k++, kk++) gmt_set_column (GMT, GMT_OUT, kk, GMT->current.io.col_type[GMT_IN][k+GMT_Z]);
psbasemap.c:	bool classic = (API->GMT->current.setting.run_mode == GMT_CLASSIC);
psbasemap.c:		API->GMT->session.u2u[GMT_INCH][GMT_PT] * API->GMT->current.setting.map_line_step);
psbasemap.c:	struct GMTAPI_CTRL *API = GMT->parent;
psbasemap.c:	classic = (GMT->current.setting.run_mode == GMT_CLASSIC);
psbasemap.c:					GMT->current.map.frame.paint = true;
psbasemap.c:					if (gmt_getfill (GMT, opt->arg, &GMT->current.map.frame.fill)) {
psbasemap.c:				GMT->hidden.gridline_debug = true;
psbasemap.c:				GMT->hidden.gridline_kind = opt->arg[0];	/* Get x or y */
psbasemap.c:				GMT->hidden.gridline_val = atof (&opt->arg[1]);	/* Value of grid line */
psbasemap.c:	n_errors += gmt_M_check_condition (GMT, !GMT->common.J.active, "Syntax error: Must specify a map projection with the -J option\n");
psbasemap.c:	n_errors += gmt_M_check_condition (GMT, !GMT->common.R.active[RSET], "Syntax error: Must specify -R option\n");
psbasemap.c:	n_errors += gmt_M_check_condition (GMT, !(GMT->current.map.frame.init || Ctrl->A.active || Ctrl->D.active || Ctrl->L.active || Ctrl->T.active), "Syntax error: Must specify at least one of -A, -B, -D, -L, -T\n");
psbasemap.c:	n_errors += gmt_M_check_condition (GMT, Ctrl->A.active && (GMT->current.map.frame.init || Ctrl->D.active || Ctrl->L.active || Ctrl->T.active), "Syntax error: Cannot use -B, -D, -L, -T with -A\n");
psbasemap.c:	if (API->GMT->current.setting.run_mode == GMT_CLASSIC && !API->usage) {
psbasemap.c:	if (gmt_M_err_pass (GMT, gmt_map_setup (GMT, GMT->common.R.wesn), "")) Return (GMT_PROJECTION_ERROR);
psbasemap.c:		nx = urint (GMT->current.map.width  / GMT->current.setting.map_line_step);
psbasemap.c:		ny = urint (GMT->current.map.height / GMT->current.setting.map_line_step);
psbasemap.c:		for (i = 0; i < nx; i++, k++) gmt_xy_to_geo (GMT, &S->data[GMT_X][k], &S->data[GMT_Y][k], i * GMT->current.setting.map_line_step, 0.0);
psbasemap.c:		for (i = 0; i < ny; i++, k++) gmt_xy_to_geo (GMT, &S->data[GMT_X][k], &S->data[GMT_Y][k], GMT->current.map.width, i * GMT->current.setting.map_line_step);
psbasemap.c:		for (i = nx; i > 0; i--, k++) gmt_xy_to_geo (GMT, &S->data[GMT_X][k], &S->data[GMT_Y][k], i * GMT->current.setting.map_line_step, GMT->current.map.height);
psbasemap.c:		for (i = ny; i > 0; i--, k++) gmt_xy_to_geo (GMT, &S->data[GMT_X][k], &S->data[GMT_Y][k], 0.0, i * GMT->current.setting.map_line_step);
psbasemap.c:		sprintf (msg, " Geographical coordinates for a (%s) rectangular plot domain outline polygon", kind[GMT->common.R.oblique]);
psbasemap.c:		GMT->current.setting.io_header[GMT_OUT] = true;	/* Turn on table headers on output */
psbasemap.c:	gmt_plane_perspective (GMT, GMT->current.proj.z_project.view_plane, GMT->current.proj.z_level);
psclip.c:	struct GMTAPI_CTRL *API = GMT->parent;
psclip.c:		n_errors += gmt_M_check_condition (GMT, !GMT->common.R.active[RSET], "Syntax error: Must specify -R option\n");
psclip.c:		n_errors += gmt_M_check_condition (GMT, !GMT->common.J.active, "Syntax error: Must specify a map projection with the -J option\n");
psclip.c:	if (Ctrl->N.active && GMT->current.map.frame.init) {
psclip.c:		GMT->current.map.frame.draw = false;
psclip.c:	if (API->GMT->current.setting.run_mode == GMT_CLASSIC && !API->usage) {
psclip.c:		GMT->current.ps.nclip = MIN (-1, -Ctrl->C.n);	/* Program terminates n levels of prior clipping */
psclip.c:		GMT->current.ps.nclip = +1;		/* Program adds one new level of clipping */
psclip.c:	if (Ctrl->C.active && !GMT->current.map.frame.init) {
psclip.c:	if (gmt_M_err_pass (GMT, gmt_map_setup (GMT, GMT->common.R.wesn), "")) Return (GMT_PROJECTION_ERROR);
psclip.c:	gmt_plane_perspective (GMT, GMT->current.proj.z_project.view_plane, GMT->current.proj.z_level);
psclip.c:		if (Ctrl->A.active) Ctrl->A.step = Ctrl->A.step / GMT->current.proj.scale[GMT_X] / GMT->current.proj.M_PR_DEG;
psclip.c:			gmt_map_clip_on (GMT, GMT->session.no_rgb, 1 + eo_flag);
psclip.c:			duplicate = (DH->alloc_mode == GMT_ALLOC_EXTERNALLY && GMT->current.map.path_mode == GMT_RESAMPLE_PATH);
psclip.c:					if (GMT->current.map.path_mode == GMT_RESAMPLE_PATH) {	/* Resample if spacing is too coarse or stair-case is requested */
psclip.c:					PSL_beginclipping (PSL, S->data[GMT_X], S->data[GMT_Y], (int)S->n_rows, GMT->session.no_rgb, first);
psclip.c:		PSL_beginclipping (PSL, NULL, NULL, 0, GMT->session.no_rgb, 2 + first + eo_flag);
pscoast.c:	if (GMT->current.map.frame.paint)	/* Default Ocean color = Frame background color */
pscoast.c:		C->S.fill = GMT->current.map.frame.fill;
pscoast.c:	for (k = 0; k < GSHHS_N_RLEVELS; k++) C->I.pen[k] = GMT->current.setting.map_default_pen;		/* Default river pens */
pscoast.c:	for (k = 0; k < GSHHS_N_BLEVELS; k++) C->N.pen[k] = GMT->current.setting.map_default_pen;		/* Default border pens */
pscoast.c:	for (k = 0; k < GSHHS_MAX_LEVEL; k++) C->W.pen[k] = GMT->current.setting.map_default_pen;	/* Default coastline pens */
pscoast.c:	struct GMTAPI_CTRL *API = GMT->parent;
pscoast.c:				pen = GMT->current.setting.map_default_pen;	/* Set default pen */
pscoast.c:				pen = GMT->current.setting.map_default_pen;	/* Set default pen */
pscoast.c:	if (!GMT->common.J.active) {	/* So without -J we can only do -M or report region only */
pscoast.c:		else if (GMT->common.B.active[GMT_PRIMARY] || GMT->common.B.active[GMT_SECONDARY] || Ctrl->C.active || Ctrl->G.active || Ctrl->I.active || Ctrl->N.active || GMT->common.P.active || Ctrl->S.active || Ctrl->W.active)
pscoast.c:		unsigned int range = GMT->current.io.geo.range;	/* Old setting */
pscoast.c:		GMT->current.io.geo.range = GMT_IGNORE_RANGE;	/* wesn is set correctly so don't mess with it during formatting */
pscoast.c:		gmt_ascii_format_col (GMT, text, GMT->common.R.wesn[XLO], GMT_OUT, GMT_X);	strcat (record, text);	strcat (record, "/");
pscoast.c:		gmt_ascii_format_col (GMT, text, GMT->common.R.wesn[XHI], GMT_OUT, GMT_X);	strcat (record, text);	strcat (record, "/");
pscoast.c:		gmt_ascii_format_col (GMT, text, GMT->common.R.wesn[YLO], GMT_OUT, GMT_Y);	strcat (record, text);	strcat (record, "/");
pscoast.c:		gmt_ascii_format_col (GMT, text, GMT->common.R.wesn[YHI], GMT_OUT, GMT_Y);	strcat (record, text);
pscoast.c:		GMT->current.io.geo.range = range;	/* Reset to what it was */
pscoast.c:		n_errors += gmt_M_check_condition (GMT, !Ctrl->E.active && !GMT->common.R.active[RSET], "Syntax error: Must specify -R option\n");
pscoast.c:		n_errors += gmt_M_check_condition (GMT, !GMT->common.R.active[RSET], "Syntax error: Must specify -R option\n");
pscoast.c:		n_errors += gmt_M_check_condition (GMT, !GMT->common.J.active, "Syntax error: Must specify a map projection with the -J option\n");
pscoast.c:	n_errors += gmt_M_check_condition (GMT, clipping && GMT->current.proj.projection_GMT == GMT_AZ_EQDIST && fabs (GMT->common.R.wesn[XLO] -
pscoast.c:	                                 GMT->common.R.wesn[XHI]) == 360.0 && (GMT->common.R.wesn[YHI] - GMT->common.R.wesn[YLO]) == 180.0,
pscoast.c:	strncpy (old_J, GMT->common.J.string, GMT_LEN128-1);
pscoast.c:	GMT->common.J.active = false;
pscoast.c:	if (gmt_M_err_pass (GMT, gmt_map_setup (GMT, GMT->common.R.wesn), "")) return (-1);
pscoast.c:	GMT->current.map.parallel_straight = GMT->current.map.meridian_straight = 2;	/* No resampling along bin boundaries */
pscoast.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Projection center outside -R region so cannot determine status\n");
pscoast.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Projection antipode outside -R region so cannot determine status\n");
pscoast.c:	GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Determined GSHHG level of projection center at (%g, %g) [%d] and antipode at (%g, %g) [%d].\n",
pscoast.c:	GMT->common.J.active = false;
pscoast.c:	if (gmt_M_err_pass (GMT, gmt_map_setup (GMT, GMT->common.R.wesn), "")) return (-1);
pscoast.c:	if (API->GMT->current.setting.run_mode == GMT_CLASSIC && !API->usage) {	/* See if -E+l|L was given, which is part of usage */
pscoast.c:	if (GMT->current.setting.run_mode == GMT_MODERN && !Ctrl->D.active)
pscoast.c:	if (GMT->common.R.wesn[XLO] > 360.0) {
pscoast.c:		GMT->common.R.wesn[XLO] -= 360.0;
pscoast.c:		GMT->common.R.wesn[XHI] -= 360.0;
pscoast.c:	if ((Ctrl->Q.active || Ctrl->E.active) && !GMT->common.J.active) {	/* Set fake area and linear projection */
pscoast.c:		GMT->common.R.wesn[XLO] = GMT->common.R.wesn[YLO] = 0.0;
pscoast.c:		GMT->common.R.wesn[XHI] = GMT->common.R.wesn[YHI] = 1.0;
pscoast.c:	else if (Ctrl->M.active && !GMT->common.J.active)	/* Set fake linear projection */
pscoast.c:	else if (GMT->common.J.active && gmt_M_is_cartesian (GMT, GMT_IN)) {	/* Gave -J but forgot the "d" */
pscoast.c:	if (gmt_M_err_pass (GMT, gmt_map_setup (GMT, GMT->common.R.wesn), "")) Return (GMT_PROJECTION_ERROR);
pscoast.c:	world_map_save = GMT->current.map.is_world;
pscoast.c:		clip_to_extend_lines = (!(gmt_M_is_azimuthal (GMT) && !GMT->current.proj.polar) || GMT->common.R.oblique);
pscoast.c:	if (need_coast_base && (err = gmt_init_shore (GMT, Ctrl->D.set, &c, GMT->common.R.wesn, &Ctrl->A.info)) != 0)  {
pscoast.c:	if (Ctrl->N.active && (err = gmt_init_br (GMT, 'b', Ctrl->D.set, &b, GMT->common.R.wesn)) != 0) {
pscoast.c:	if (Ctrl->I.active && (err = gmt_init_br (GMT, 'r', Ctrl->D.set, &r, GMT->common.R.wesn)) != 0) {
pscoast.c:			GMT->current.ps.nclip = -1;	/* Signal that this program terminates polygon clipping that initiated prior to this process */
pscoast.c:			GMT->current.ps.nclip = +1;	/* Signal that this program initiates new clipping that will outlive this process */
pscoast.c:			if (GMT->common.B.active[GMT_PRIMARY] || GMT->common.B.active[GMT_SECONDARY]) {
pscoast.c:				gmt_plane_perspective (GMT, GMT->current.proj.z_project.view_plane, GMT->current.proj.z_level);
pscoast.c:		gmt_plane_perspective (GMT, GMT->current.proj.z_project.view_plane, GMT->current.proj.z_level);
pscoast.c:	if (GMT->current.proj.projection_GMT == GMT_AZ_EQDIST && gmt_M_360_range (GMT->common.R.wesn[XLO], GMT->common.R.wesn[XHI]) && gmt_M_180_range (GMT->common.R.wesn[YHI], GMT->common.R.wesn[YLO])) {
pscoast.c:		if (check_antipode_status (GMT, &c, GMT_INSIDE, GMT->current.proj.central_meridian, GMT->current.proj.pole, status)) {
pscoast.c:		anti_lon = GMT->current.proj.central_meridian + 180.0;
pscoast.c:		anti_lat = -GMT->current.proj.pole;
pscoast.c:		gmt_geo_to_xy (GMT, GMT->current.proj.central_meridian, GMT->current.proj.pole, &x_0, &y_0);
pscoast.c:	if (GMT->common.R.wesn[XLO] < 0.0 && GMT->common.R.wesn[XHI] > 0.0 && !gmt_M_is_linear (GMT)) greenwich = true;
pscoast.c:	if (need_coast_base && (360.0 - fabs (GMT->common.R.wesn[XHI] - GMT->common.R.wesn[XLO]) ) < c.bsize) {
pscoast.c:		GMT->current.map.is_world = true;
pscoast.c:		if (GMT->current.proj.projection_GMT == GMT_GNOMONIC || GMT->current.proj.projection_GMT == GMT_GENPER) GMT->current.map.is_world = false;
pscoast.c:		if (gmt_M_is_azimuthal (GMT)) GMT->current.map.is_world = false;
pscoast.c:	if (GMT->current.map.is_world && greenwich)
pscoast.c:		edge = GMT->current.proj.central_meridian;
pscoast.c:	else if (!GMT->current.map.is_world && greenwich) {
pscoast.c:		edge = GMT->common.R.wesn[XLO];	if (edge < 0.0) edge += 360.0;
pscoast.c:	if (GMT->common.R.wesn[XLO] < 0.0 && GMT->common.R.wesn[XHI] <= 0.0) {	/* Temporarily shift boundaries */
pscoast.c:		GMT->common.R.wesn[XLO] += 360.0;
pscoast.c:		GMT->common.R.wesn[XHI] += 360.0;
pscoast.c:		if (GMT->current.proj.central_meridian < 0.0) GMT->current.proj.central_meridian += 360.0;
pscoast.c:		west_border = floor (GMT->common.R.wesn[XLO] / c.bsize) * c.bsize;
pscoast.c:		east_border = ceil  (GMT->common.R.wesn[XHI] / c.bsize) * c.bsize;
pscoast.c:		GMT->current.map.coastline = true;
pscoast.c:	if (clip_to_extend_lines) gmt_map_clip_on (GMT, GMT->session.no_rgb, 3);
pscoast.c:	if (clipping) PSL_beginclipping (PSL, xtmp, ytmp, 0, GMT->session.no_rgb, 1);	/* Start clippath */
pscoast.c:		if (GMT->current.map.is_world && greenwich) {
pscoast.c:			donut_hell = (dist > 0.8 * GMT->current.proj.r || gmt_non_zero_winding (GMT, anti_lon, anti_lat, bin_x, bin_y, 5));
pscoast.c:						sprintf (GMT->current.io.segment_header, "Shore Bin # %d, Level %d", bin, p[i].level);
pscoast.c:						out[GMT_X] = out[GMT_Y] = GMT->session.d_NaN;
pscoast.c:					GMT->current.plot.n = gmt_geo_to_xy_line (GMT, p[i].lon, p[i].lat, p[i].n);
pscoast.c:					if (!GMT->current.plot.n) continue;
pscoast.c:					gmt_plot_line (GMT, GMT->current.plot.x, GMT->current.plot.y, GMT->current.plot.pen, GMT->current.plot.n, PSL_LINEAR);
pscoast.c:		GMT->current.map.coastline = false;
pscoast.c:	if (clipping) PSL_beginclipping (PSL, xtmp, ytmp, 0, GMT->session.no_rgb, 2);	/* End clippath */
pscoast.c:			if (GMT->current.map.is_world && greenwich) {
pscoast.c:						sprintf (GMT->current.io.segment_header, "River Bin # %d, Level %d", bin, p[i].level);
pscoast.c:						out[GMT_X] = out[GMT_Y] = GMT->session.d_NaN;
pscoast.c:					GMT->current.plot.n = gmt_geo_to_xy_line (GMT, p[i].lon, p[i].lat, p[i].n);
pscoast.c:					if (!GMT->current.plot.n) continue;
pscoast.c:					gmt_plot_line (GMT, GMT->current.plot.x, GMT->current.plot.y, GMT->current.plot.pen, GMT->current.plot.n, PSL_LINEAR);
pscoast.c:		step = MAX (fabs(GMT->common.R.wesn[XLO] - GMT->common.R.wesn[XHI]), fabs (GMT->common.R.wesn[YHI] - GMT->common.R.wesn[YLO])) / 4.0;
pscoast.c:			if (GMT->current.map.is_world && greenwich) {
pscoast.c:						sprintf (GMT->current.io.segment_header, "Border Bin # %d, Level %d", bin, p[i].level);
pscoast.c:						out[GMT_X] = out[GMT_Y] = GMT->session.d_NaN;
pscoast.c:					GMT->current.plot.n = gmt_geo_to_xy_line (GMT, p[i].lon, p[i].lat, p[i].n);
pscoast.c:					if (!GMT->current.plot.n) continue;
pscoast.c:					gmt_plot_line (GMT, GMT->current.plot.x, GMT->current.plot.y, GMT->current.plot.pen, GMT->current.plot.n, PSL_LINEAR);
pscoast.c:		if (GMT->current.map.frame.init) {
pscoast.c:			GMT->current.map.is_world = world_map_save;
pscoast.c:	GMT->current.map.coastline = false;
pscontour.c:	C->A.single_cont = GMT->session.d_NaN;
pscontour.c:	C->C.single_cont = GMT->session.d_NaN;
pscontour.c:	C->L.pen = GMT->current.setting.map_default_pen;
pscontour.c:	C->T.dim[GMT_X] = TICKED_SPACING * GMT->session.u2u[GMT_PT][GMT_INCH];	/* 14p */
pscontour.c:	C->T.dim[GMT_Y] = TICKED_LENGTH  * GMT->session.u2u[GMT_PT][GMT_INCH];	/* 3p */
pscontour.c:	C->W.pen[0] = C->W.pen[1] = GMT->current.setting.map_default_pen;
pscontour.c:	(void)gmt_setfont (GMT, &GMT->current.setting.font_annot[GMT_PRIMARY]);
pscontour.c:				PSL_plottext (PSL, x_mean, y_mean, GMT->current.setting.font_annot[GMT_PRIMARY].size, lbl[save[pol].high], 0.0, PSL_MC, form);
pscontour.c:	P = API->GMT->current.setting.map_default_pen;
pscontour.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -T option: Give low and high labels either as +lLH or +l<low>,<high>.\n");
pscontour.c:	struct GMTAPI_CTRL *API = GMT->parent;
pscontour.c:				if (GMT->current.setting.run_mode == GMT_MODERN && gmt_M_no_cpt_given (opt->arg))
pscontour.c:	n_errors += gmt_M_check_condition (GMT, !GMT->common.J.active && !Ctrl->D.active,
pscontour.c:	n_errors += gmt_M_check_condition (GMT, !GMT->common.R.active[RSET] && !Ctrl->D.active, "Syntax error: Must specify a region with the -R option\n");
pscontour.c:	if (API->GMT->current.setting.run_mode == GMT_CLASSIC && !API->usage) {
pscontour.c:	convert = (make_plot || (GMT->common.R.active[RSET] && GMT->common.J.active));
pscontour.c:	if (GMT->common.J.active && gmt_M_err_pass (GMT, gmt_map_setup (GMT, GMT->common.R.wesn), "")) Return (GMT_PROJECTION_ERROR);
pscontour.c:			skip = (abs (GMT->current.map.this_x_status) > 1 || abs (GMT->current.map.this_y_status) > 1);
pscontour.c:		            np, tri_algorithm[GMT->current.setting.triangulate]);
pscontour.c:			cont[c].angle = (Ctrl->contour.angle_type == 2) ? Ctrl->contour.label_angle : GMT->session.d_NaN;
pscontour.c:			cont[c].angle = (Ctrl->contour.angle_type == 2) ? Ctrl->contour.label_angle : GMT->session.d_NaN;
pscontour.c:			cont[c].angle = (Ctrl->contour.angle_type == 2) ? Ctrl->contour.label_angle : GMT->session.d_NaN;
pscontour.c:			cont[c+nc].angle = (Ctrl->contour.angle_type == 2) ? Ctrl->contour.label_angle : GMT->session.d_NaN;
pscontour.c:			cont[c].angle = (got == 3) ? tmp : GMT->session.d_NaN;
pscontour.c:			cont[n_contours].angle = (Ctrl->contour.angle_type == 2) ? Ctrl->contour.label_angle : GMT->session.d_NaN;
pscontour.c:			cont[c].angle = (Ctrl->contour.angle_type == 2) ? Ctrl->contour.label_angle : GMT->session.d_NaN;
pscontour.c:			GMT->current.ps.nclip = (Ctrl->N.active) ? +1 : +2;
pscontour.c:		gmt_plane_perspective (GMT, GMT->current.proj.z_project.view_plane, GMT->current.proj.z_level);
pscontour.c:		if (!Ctrl->N.active) gmt_map_clip_on (GMT, GMT->session.no_rgb, 3);
psconvert.c:					Ctrl->A.pen = GMT->current.setting.map_default_pen;
psconvert.c:	if (ghostbuster(GMT->parent, C) != GMT_NOERROR)  /* Try first to find the gspath from registry */
psconvert.c:	if (API->GMT->current.setting.run_mode == GMT_CLASSIC)
psconvert.c:	             gmt_putpen (API->GMT, &API->GMT->current.setting.map_default_pen));
psconvert.c:	             GMT_DIM_UNITS_DISPLAY, API->GMT->session.unit_name[API->GMT->current.setting.proj_length_unit][0]);
psconvert.c:	if (API->GMT->current.setting.run_mode == GMT_CLASSIC)
psconvert.c:				if (!(GMT->parent->external && !strncmp (opt->arg, "=", 1))) {	/* Can check if file is sane */
psconvert.c:						GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error option -M: Select -Mb or -Sf\n");
psconvert.c:						GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error option -M%c: Cannot read file %s\n", opt->arg[0], &opt->arg[1]);
psconvert.c:					GMT_Report (GMT->parent, GMT_MSG_NORMAL, "The -Q option requires setting -Qg, -Qp, or -Qt!\n");
psconvert.c:				if (GMT->current.setting.run_mode == GMT_CLASSIC)
psconvert.c:					GMT_Report (GMT->parent, GMT_MSG_NORMAL, "The -Z option is not available in MODERN mode!\n");
psconvert.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "-Mb: %sground file %s cannot be found!\n", layer[j], Ctrl->M[j].file);
psconvert.c:	n_errors += gmt_M_check_condition (GMT, Ctrl->L.active && (GMT->current.setting.run_mode == GMT_MODERN),
psconvert.c:	n_errors += gmt_M_check_condition (GMT, GMT->current.setting.run_mode == GMT_MODERN && !(Ctrl->In.n_files == 0 || (Ctrl->In.n_files == 1 && halfbaked)),
psconvert.c:	n_errors += gmt_M_check_condition (GMT, !Ctrl->F.active && GMT->current.setting.run_mode == GMT_MODERN,
psconvert.c:	GMT->PSL->internal.dpp = PSL_DOTS_PER_INCH / 72.0;	/* Dots pr. point resolution of output device, set here since no PSL initialization */
psconvert.c:		GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Paint background BoundingBox using paint %s\n", gmt_putrgb (GMT, A->fill.rgb));
psconvert.c:		if (GMT->PSL->internal.comments) fprintf (fp, "%% Paint background BoundingBox using paint %s\n", gmt_putrgb (GMT, A->fill.rgb));
psconvert.c:		ptr = PSL_makecolor (GMT->PSL, A->fill.rgb);
psconvert.c:		GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Outline background BoundingBox using pen %s\n", gmt_putpen (GMT, &A->pen));
psconvert.c:		if (GMT->PSL->internal.comments) fprintf (fp, "%% Outline background BoundingBox using pen %s\n", gmt_putpen (GMT, &A->pen));
psconvert.c:		ptr = PSL_makepen (GMT->PSL, 2.0*A->pen.width, A->pen.rgb, A->pen.style, A->pen.offset);
psconvert.c:	/* Allocate GMT_POSTSCRIPT struct to hold the string that lives inside GMT->PSL */
psconvert.c:	PS->data = PSL_getplot (API->GMT->PSL);		/* Get pointer to the internal plot buffer */
psconvert.c:	PS->n_bytes = API->GMT->PSL->internal.n;	/* Length of plot buffer; note P->n_alloc = 0 since nothing was allocated here */
psconvert.c:	PS->data = PSL_getplot (API->GMT->PSL);		/* Get pointer to the plot buffer */
psconvert.c:	PS->n_bytes = API->GMT->PSL->internal.n;	/* Length of plot buffer; note P->n_alloc = 0 since nothing was allocated here */
psconvert.c:	if (API->GMT->PSL->internal.pmode != 3) {
psconvert.c:		            API->GMT->PSL->internal.pmode);
psconvert.c:	sprintf (newfile, "%s/psconvert_sandwich_%d.ps", GMT->parent->tmp_dir, (int)getpid());
psconvert.c:	GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Creating %s\n", newfile);
psconvert.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Failed to create temporary file %s.\n", newfile);
psconvert.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Prepend %s as background in %s\n", bfile, newfile);
psconvert.c:			GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Append %s as main content in %s\n", main, newfile);
psconvert.c:			GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Append %s as foreground in %s\n", ffile, newfile);
psconvert.c:			GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Append %s as main content in %s\n", main, newfile);
psconvert.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Prepend %s as main in %s\n", main, newfile);
psconvert.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Append %s as foreground in %s\n", ffile, newfile);
psconvert.c:	GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Remove old %s\n", main);
psconvert.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Failed to remove original file %s.\n", main);
psconvert.c:	GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Rename %s -> %s\n", newfile, main);
psconvert.c:	if (!Ctrl->L.active && (GMT->current.setting.run_mode == GMT_CLASSIC) && (Ctrl->In.n_files == 0)) {	/* No files given, bail */
psconvert.c:	if (GMT->current.setting.run_mode == GMT_MODERN) {	/* Need to complete the half-baked PS file */
psconvert.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "No hidden PS file %s found\n", GMT->current.ps.filename);
psconvert.c:			GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Hidden PS file %s found\n", GMT->current.ps.filename);
psconvert.c:			ps_names[0] = noquote_name (GMT->current.ps.filename);
psconvert.c:			GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Complete partial PS file %s\n", ps_names[0]);
psconvert.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Could not determine size of file %s\n", ps_names[0]);
psconvert.c:				GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Size of half-baked PS file = %" PRIuS ".\n", buf.st_size);
psconvert.c:			if ((fp = PSL_fopen (GMT->PSL, ps_names[0], "a")) == NULL) {	/* Must open inside PSL DLL */
psconvert.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Cannot append to file %s\n", ps_names[0]);
psconvert.c:			GMT->PSL->internal.call_level++;	/* Must increment here since PSL_beginplot not called, and PSL_endplot will decrement */
psconvert.c:			PSL_endplot (GMT->PSL, 1);	/* Finalize the PS plot */
psconvert.c:			if (PSL_fclose (GMT->PSL)) {
psconvert.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Unable to close hidden PS file %s!\n", ps_names[0]);
psconvert.c:			GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Fattened up PS file %s\n", ps_names[0]);
psconvert.c:			API->print_func (GMT->session.std[GMT_ERR], cmd2);
psconvert.c:			API->print_func (GMT->session.std[GMT_ERR], "\n");
psconvert.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Unable to wrap %s inside optional back- and fore-ground layers!\n", ps_file);
psconvert.c:			if (GMT->current.setting.run_mode == GMT_MODERN)	/* Place temporary EPS files in session dir */
psconvert.c:			if (GMT->current.setting.run_mode == GMT_MODERN)	/* Place BB file in session dir */
psconvert.c:							API->print_func (GMT->session.std[GMT_ERR], cmd);
psconvert.c:							API->print_func (GMT->session.std[GMT_ERR], "\n");
psconvert.c:					            x1-x0, (x1-x0)*GMT->session.u2u[GMT_PT][GMT->current.setting.proj_length_unit],
psconvert.c:					            API->GMT->session.unit_name[API->GMT->current.setting.proj_length_unit],
psconvert.c:					            y1-y0, (y1-y0)*GMT->session.u2u[GMT_PT][GMT->current.setting.proj_length_unit],
psconvert.c:					            API->GMT->session.unit_name[API->GMT->current.setting.proj_length_unit]);
psconvert.c:			if (GMT->current.setting.run_mode == GMT_MODERN)	/* Place temporary EPS files in session dir */
psconvert.c:				GMT->common.R.wesn[XLO] = atof (xx1);		GMT->common.R.wesn[XHI] = atof (xx2);
psconvert.c:				if (GMT->common.R.wesn[XLO] > 180.0 && GMT->common.R.wesn[XHI] > 180.0) {
psconvert.c:					GMT->common.R.wesn[XLO] -= 360.0;
psconvert.c:					GMT->common.R.wesn[XHI] -= 360.0;
psconvert.c:				GMT->common.R.wesn[YLO] = atof (yy1);	GMT->common.R.wesn[YHI] = atof (yy2);
psconvert.c:				API->print_func (GMT->session.std[GMT_ERR], cmd);
psconvert.c:				API->print_func (GMT->session.std[GMT_ERR], "\n");
psconvert.c:					API->print_func (GMT->session.std[GMT_ERR], cmd);
psconvert.c:					API->print_func (GMT->session.std[GMT_ERR], "\n");
psconvert.c:		if (GMT->current.setting.run_mode == GMT_MODERN) {
psconvert.c:			if (GMT->current.gdal_read_in.O.mem_layout[0])		/* At one point this should never be allowed to be empty */
psconvert.c:				GMT_Set_Default (API, "API_IMAGE_LAYOUT", GMT->current.gdal_read_in.O.mem_layout);
psconvert.c:				if (GMT->current.setting.verbose < GMT_MSG_VERBOSE)	/* Shut up the gdal_translate (low level) verbosity */
psconvert.c:				fprintf (fpw, "\t\t\t<north>%f</north>\n", GMT->common.R.wesn[YHI]);
psconvert.c:				fprintf (fpw, "\t\t\t<south>%f</south>\n", GMT->common.R.wesn[YLO]);
psconvert.c:				fprintf (fpw, "\t\t\t<east>%f</east>\n", GMT->common.R.wesn[XHI]);
psconvert.c:				fprintf (fpw, "\t\t\t<west>%f</west>\n", GMT->common.R.wesn[XLO]);
psconvert.c:	sprintf (data, "%s/gswin64c.exe", API->GMT->init.runtime_bindir);
psconvert.c:	sprintf (data, "%s/gswin32c.exe", API->GMT->init.runtime_bindir);
psevents.c:		gmt_putfont (API->GMT, &API->GMT->current.setting.font_annot[GMT_PRIMARY]));
psevents.c:					GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -E: No modifiers given?\n");
psevents.c:								GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -E[s]: The +l modifier is only allowed for -Et\n");
psevents.c:						GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -M: Directive %c not valid\n", opt->arg[1]);
psevents.c:						GMT->current.setting.proj_length_unit = GMT_INCH;	/* Since S.size is now in inches */
psevents.c:						GMT->current.setting.proj_length_unit = GMT_INCH;	/* Since S.size is now in inches */
psevents.c:					GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -S: Cannot (yet) handle symbol code %c\n", opt->arg[0]);
psevents.c:	gmt_consider_current_cpt (GMT->parent, &Ctrl->C.active, &(Ctrl->C.file));
psevents.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error: -T<now> is a required option.\n");
psevents.c:	if (GMT->common.b.active[GMT_IN] && GMT->common.b.ncol[GMT_IN] == 0) GMT->common.b.ncol[GMT_IN] = n_col;
psevents.c:	n_errors += gmt_M_check_condition (GMT, GMT->common.b.active[GMT_IN] && GMT->common.b.ncol[GMT_IN] < n_col, "Syntax error: Binary input data (-bi) must have at least %u columns.\n", n_col);
psevents.c:	n_errors += gmt_M_check_condition (GMT, !GMT->common.R.active[RSET], "Syntax error: Must specify -R option\n");
psevents.c:	n_errors += gmt_M_check_condition (GMT, !GMT->common.J.active, "Syntax error: Must specify a map projection with the -J option\n");
psevents.c:	if (API->GMT->current.setting.run_mode == GMT_CLASSIC && !API->usage) {
psevents.c:	if (gmt_M_err_pass (GMT, gmt_map_setup (GMT, GMT->common.R.wesn), "")) {	/* Set up map projection */
psevents.c:	gmt_plane_perspective (GMT, GMT->current.proj.z_project.view_plane, GMT->current.proj.z_level);
psevents.c:		sprintf (cmd, "%s -R -J -O -K -I -t -S%s --GMT_HISTORY=false --PROJ_LENGTH_UNIT=%s", tmp_file_symbols, Ctrl->S.symbol, GMT->session.unit_name[GMT->current.setting.proj_length_unit]);
pshistogram.c:	C->D.font = GMT->current.setting.font_annot[GMT_PRIMARY];		/* Default font */
pshistogram.c:	C->W.pen = GMT->current.setting.map_default_pen;
pshistogram.c:	for (k = 0; k < 3; k++) C->N.pen[k] = GMT->current.setting.map_default_pen;
pshistogram.c:	if (n_multiples > 0) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "%d multiple modes found\n", n_multiples);
pshistogram.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Cannot tell if -T%s -W%s is new or deprecated syntax; selected new.\n", T, W);
pshistogram.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Cannot tell if -T%s -W%s is new or deprecated syntax; selected deprecated.\n", T, W);
pshistogram.c:	struct GMTAPI_CTRL *API = GMT->parent;
pshistogram.c:	if (API->GMT->current.setting.run_mode == GMT_CLASSIC && !API->usage) {
pshistogram.c:	if (!Ctrl->I.active && !GMT->common.R.active[RSET]) automatic = true;
pshistogram.c:	if (GMT->common.R.active[RSET]) {	/* Gave -R which initially defines the bins also */
pshistogram.c:		gmt_M_memcpy (F.wesn, GMT->common.R.wesn, 4, double);
pshistogram.c:		sprintf (format, "Extreme values of the data :\t%s\t%s\n", GMT->current.setting.format_float_out, GMT->current.setting.format_float_out);
pshistogram.c:		         GMT->current.setting.format_float_out, GMT->current.setting.format_float_out, GMT->current.setting.format_float_out,
pshistogram.c:		         GMT->current.setting.format_float_out, GMT->current.setting.format_float_out, GMT->current.setting.format_float_out);
pshistogram.c:		if (GMT->current.map.frame.axis[GMT_X].item[GMT_ANNOT_UPPER].interval == 0.0) {
pshistogram.c:			tmp = GMT->current.map.frame.axis[GMT_X].item[GMT_ANNOT_UPPER].interval;
pshistogram.c:		if (GMT->current.map.frame.axis[GMT_X].item[GMT_ANNOT_UPPER].interval == 0.0) {
pshistogram.c:			GMT->current.map.frame.axis[GMT_X].item[GMT_ANNOT_UPPER].interval = GMT->current.map.frame.axis[GMT_X].item[GMT_TICK_UPPER].interval = tmp;
pshistogram.c:			GMT->current.map.frame.axis[GMT_X].item[GMT_ANNOT_UPPER].parent = 0;
pshistogram.c:			GMT->current.map.frame.axis[GMT_X].item[GMT_ANNOT_UPPER].active = true;
pshistogram.c:			GMT->current.map.frame.draw = true;
pshistogram.c:		         GMT->current.setting.format_float_out, GMT->current.setting.format_float_out,
pshistogram.c:		         GMT->current.setting.format_float_out, GMT->current.setting.format_float_out);
pshistogram.c:			if (GMT_Write_Data (GMT->parent, GMT_IS_DATASET, GMT_IS_STREAM, GMT_IS_POINT, 0, NULL, Ctrl->Out.file, D) != GMT_NOERROR) {
pshistogram.c:			if (GMT_Destroy_Data (GMT->parent, &D) != GMT_NOERROR) {
pshistogram.c:			gmt_M_memcpy (col_type, GMT->current.io.col_type[GMT_OUT], 4U, unsigned int);	/* Save first 4 current output col types */
pshistogram.c:			gmt_M_memcpy (GMT->current.io.col_type[GMT_OUT], col_type, 4U, unsigned int);	/* Restore 4 current output col types */
pshistogram.c:		GMT->common.R.active[RSET] = true;
pshistogram.c:		if (GMT->current.map.frame.axis[GMT_Y].item[GMT_ANNOT_UPPER].interval == 0.0) {
pshistogram.c:			tmp = GMT->current.map.frame.axis[GMT_Y].item[GMT_ANNOT_UPPER].interval;
pshistogram.c:		if (GMT->current.map.frame.axis[GMT_Y].item[GMT_ANNOT_UPPER].interval == 0.0) {	/* Tickmarks not set */
pshistogram.c:			GMT->current.map.frame.axis[GMT_Y].item[GMT_ANNOT_UPPER].interval = GMT->current.map.frame.axis[GMT_Y].item[GMT_TICK_UPPER].interval = tmp;
pshistogram.c:			GMT->current.map.frame.axis[GMT_Y].item[GMT_ANNOT_UPPER].parent = 1;
pshistogram.c:			GMT->current.map.frame.axis[GMT_Y].item[GMT_ANNOT_UPPER].active = true;
pshistogram.c:			GMT->current.map.frame.draw = true;
pshistogram.c:		if (GMT->current.proj.pars[0] == 0.0 && GMT->current.proj.pars[1] == 0.0) {
pshistogram.c:		         GMT->current.setting.format_float_out, GMT->current.setting.format_float_out,
pshistogram.c:		         GMT->current.setting.format_float_out, GMT->current.setting.format_float_out,
pshistogram.c:		         GMT->current.setting.format_float_out, GMT->current.setting.format_float_out);
pshistogram.c:		            GMT->current.map.frame.axis[GMT_X].item[GMT_ANNOT_UPPER].interval,
pshistogram.c:		            GMT->current.map.frame.axis[GMT_Y].item[GMT_ANNOT_UPPER].interval);
pshistogram.c:		gmt_M_memcpy (&shelf, &GMT->current.map.frame.axis[GMT_X], 1, struct GMT_PLOT_AXIS);
pshistogram.c:		gmt_M_memcpy (&GMT->current.map.frame.axis[GMT_X], &GMT->current.map.frame.axis[GMT_Y], 1, struct GMT_PLOT_AXIS);
pshistogram.c:		gmt_M_memcpy (&GMT->current.map.frame.axis[GMT_Y], &shelf, 1, struct GMT_PLOT_AXIS);
pshistogram.c:		gmt_M_int_swap (GMT->current.proj.xyz_projection[GMT_X], GMT->current.proj.xyz_projection[GMT_Y]);
pshistogram.c:		GMT->current.map.frame.axis[GMT_X].id = GMT_X;
pshistogram.c:		GMT->current.map.frame.axis[GMT_Y].id = GMT_Y;
pshistogram.c:			GMT->current.map.frame.axis[GMT_Y].item[k].parent = GMT_Y;
pshistogram.c:			GMT->current.map.frame.axis[GMT_X].item[k].parent = GMT_X;
pshistogram.c:	gmt_plane_perspective (GMT, GMT->current.proj.z_project.view_plane, GMT->current.proj.z_level);
pshistogram.c:	if (Ctrl->D.just == 0) gmt_map_clip_on (GMT, GMT->session.no_rgb, 3);
psimage.c:				GMT_Report (GMT->parent, GMT_MSG_COMPAT, "-C option is deprecated, use -Dx instead.\n");
psimage.c:					GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -D: Basic parsing of reference point in %s failed\n", opt->arg);
psimage.c:				GMT_Report (GMT->parent, GMT_MSG_COMPAT, "The -E option is deprecated but is accepted.\n");
psimage.c:				GMT_Report (GMT->parent, GMT_MSG_COMPAT, "For the current -D syntax you should use -D modifier +r instead.\n");
psimage.c:				GMT_Report (GMT->parent, GMT_MSG_COMPAT, "Note you cannot mix new-style modifiers (+r) with the old-style -C option.\n");
psimage.c:						GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -G: Must specify a color when +t is used\n");
psimage.c:						GMT_Report (GMT->parent, GMT_MSG_COMPAT, "-G with color - for transparency is deprecated; give no <color> instead.\n");
psimage.c:						GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Syntax error -G: - is not a color\n");
psimage.c:				GMT_Report (GMT->parent, GMT_MSG_COMPAT, "-N option is deprecated; use -D modifier +n instead.\n");
psimage.c:				GMT_Report (GMT->parent, GMT_MSG_COMPAT, "-W option is deprecated; use -D modifier +w instead.\n");
psimage.c:		n_errors += gmt_M_check_condition (GMT, !GMT->common.R.active[RSET], "Syntax error: -D%c requires the -R option\n", kind[Ctrl->D.refpoint->mode]);
psimage.c:		n_errors += gmt_M_check_condition (GMT, !GMT->common.J.active, "Syntax error: -D%c requires the -J option\n", kind[Ctrl->D.refpoint->mode]);
psimage.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Cannot open file %s\n", F);
psimage.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Could not read 4 bytes from file %s\n", F);
psimage.c:	if (API->GMT->current.setting.run_mode == GMT_CLASSIC && !API->usage) {
psimage.c:	if (!(GMT->common.R.active[RSET] && GMT->common.J.active)) {	/* When no projection specified, use fake linear projection */
psimage.c:		GMT->common.R.active[RSET] = true;
psimage.c:		GMT->common.J.active = false;
psimage.c:		gmt_plane_perspective (GMT, GMT->current.proj.z_project.view_plane, GMT->current.proj.z_level);
psimage.c:		if (gmt_M_err_pass (GMT, gmt_map_setup (GMT, GMT->common.R.wesn), "")) {
psimage.c:		gmt_plane_perspective (GMT, GMT->current.proj.z_project.view_plane, GMT->current.proj.z_level);
psimage.c:		GMT->common.J.active = false;
psimage.c:		GMT->common.R.active[RSET] = GMT->common.J.active = true;
pslegend.c:	C->C.off[GMT_X] = C->C.off[GMT_Y] = GMT->session.u2u[GMT_PT][GMT_INCH] * GMT_FRAME_CLEARANCE;	/* 4 pt */
pslegend.c:	if (API->GMT->current.setting.run_mode == GMT_MODERN)
pslegend.c:	if (API->GMT->current.setting.run_mode == GMT_MODERN)
pslegend.c:					GMT_Report (GMT->parent, GMT_MSG_COMPAT, "Option -G is deprecated; -F...+g%s was set instead, use this in the future.\n", opt->arg);
pslegend.c:				GMT_Report (GMT->parent, GMT_MSG_COMPAT, "Option -L is deprecated; -D...+l%s was set instead, use this in the future.\n", opt->arg);
pslegend.c:					GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Option -T requires a filename\n");
pslegend.c:		n_errors += gmt_M_check_condition (GMT, !GMT->common.R.active[RSET], "Syntax error: -D%c requires the -R option\n", kind[Ctrl->D.refpoint->mode]);
pslegend.c:		n_errors += gmt_M_check_condition (GMT, !GMT->common.J.active, "Syntax error: -D%c requires the -J option\n", kind[Ctrl->D.refpoint->mode]);
pslegend.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Unable to interpret %s as a valid fill, skipped\n", fill[col]);
pslegend.c:		PSL_plotsymbol (GMT->PSL, x0 + 0.5 * (xoff[col+1] + xoff[col]), y0, dim, PSL_RECT);
pslegend.c:		if (PSL_loadeps (API->GMT->PSL, file, &h, NULL)) {
pslegend.c:		GMT_Report (GMT->parent, GMT_MSG_COMPAT, "Your GMT4 font specification [%s %s] is deprecated; use [<size>][,<name>][,<fill>][=<pen>] in the future.\n", word1, word2);
pslegend.c:#define FONT_HEIGHT_PRIMARY (GMT->session.font[GMT->current.setting.font_annot[GMT_PRIMARY].id].height)
pslegend.c:#define FONT_HEIGHT(font_id) (GMT->session.font[font_id].height)
pslegend.c:#define FONT_HEIGHT_LABEL (GMT->session.font[GMT->current.setting.font_label.id].height)
pslegend.c:	if (API->GMT->current.setting.run_mode == GMT_CLASSIC && !API->usage) {
pslegend.c:		GMT->current.setting.io_seg_marker[GMT_IN] = '#';
pslegend.c:	ID = GMT->current.setting.run_mode;	/* Use as index to arrays with correct module names for classic [0] or modern [1] */
pslegend.c:	one_line_spacing = Ctrl->D.spacing * GMT->current.setting.font_annot[GMT_PRIMARY].size / PSL_POINTS_PER_INCH;
pslegend.c:				if (line[0] == GMT->current.setting.io_head_marker[GMT_IN] || gmt_is_a_blank_line (line)) continue;	/* Skip all headers or blank lines  */
pslegend.c:						height += gmt_M_to_inch (GMT, bar_height) + GMT->current.setting.map_tick_length[0] + GMT->current.setting.map_annot_offset[0] + FONT_HEIGHT_PRIMARY * GMT->current.setting.font_annot[GMT_PRIMARY].size / PSL_POINTS_PER_INCH;
pslegend.c:								sprintf (tmp, "%s", gmt_putfont (GMT, &GMT->current.setting.font_title));
pslegend.c:						ifont = GMT->current.setting.font_title;	/* Set default font */
pslegend.c:								sprintf (tmp, "%s", gmt_putfont (GMT, &GMT->current.setting.font_label));
pslegend.c:						ifont = GMT->current.setting.font_label;	/* Set default font */
pslegend.c:						d_off = FONT_HEIGHT_LABEL * GMT->current.setting.font_label.size / PSL_POINTS_PER_INCH + fabs(GMT->current.setting.map_label_offset);
pslegend.c:						height += GMT->current.setting.map_scale_height + FONT_HEIGHT_PRIMARY * GMT->current.setting.font_annot[GMT_PRIMARY].size / PSL_POINTS_PER_INCH + GMT->current.setting.map_annot_offset[0];
pslegend.c:							gmt_M_memcpy (&legend_item[n_item].font, &(GMT->current.setting.font_annot[GMT_PRIMARY]), 1, struct GMT_FONT);
pslegend.c:		x_lines = n_char * (average_char_width * GMT->current.setting.font_annot[GMT_PRIMARY].size / PSL_POINTS_PER_INCH) / ((Ctrl->D.dim[GMT_X] - 2 * Ctrl->C.off[GMT_X]));
pslegend.c:		height += n_lines * Ctrl->D.spacing * GMT->current.setting.font_annot[GMT_PRIMARY].size / PSL_POINTS_PER_INCH;
pslegend.c:	scl = gmt_convert_units (GMT, "1", GMT_INCH, GMT->current.setting.proj_length_unit);
pslegend.c:			GMT->session.unit_name[GMT->current.setting.proj_length_unit]);
pslegend.c:		            scl*Ctrl->D.dim[GMT_Y], GMT->session.unit_name[GMT->current.setting.proj_length_unit],
pslegend.c:		            scl*height, GMT->session.unit_name[GMT->current.setting.proj_length_unit]);
pslegend.c:	if (!(GMT->common.R.active[RSET] && GMT->common.J.active)) {	/* When no projection specified (i.e, -Dx is used), use fake linear projection -Jx1i */
pslegend.c:		GMT->common.R.active[RSET] = true;
pslegend.c:		GMT->common.J.active = false;
pslegend.c:		if (GMT->common.B.active[GMT_PRIMARY] || GMT->common.B.active[GMT_SECONDARY]) {	/* Cannot use -B if no -R -J */
pslegend.c:			GMT->common.B.active[GMT_PRIMARY] = GMT->common.B.active[GMT_SECONDARY] = false;
pslegend.c:	else if (gmt_M_err_pass (GMT, gmt_map_setup (GMT, GMT->common.R.wesn), ""))
pslegend.c:	gmt_plane_perspective (GMT, GMT->current.proj.z_project.view_plane, GMT->current.proj.z_level);
pslegend.c:	if (GMT->current.map.frame.draw && b_cpt)	/* Two conflicting -B settings, reset main -B since we just finished the frame */
pslegend.c:		gmt_M_memset (&(GMT->current.map.frame), 1, struct GMT_PLOT_FRAME);
pslegend.c:	if (GMT->current.setting.run_mode == GMT_MODERN) {
pslegend.c:		struct GMT_SUBPLOT *SP = &(GMT->current.plot.panel);
pslegend.c:	current_pen = GMT->current.setting.map_default_pen;
pslegend.c:	sprintf (def_txtcolor, "%s", gmt_putcolor (GMT, GMT->current.setting.font_annot[GMT_PRIMARY].fill.rgb));
pslegend.c:	sprintf (txtcolor, "%s", gmt_putcolor (GMT, GMT->current.setting.font_annot[GMT_PRIMARY].fill.rgb));
pslegend.c:	/* Tech, note: Using GMT->current.setting.io_seg_marker[GMT_IN] instead of GMT_OUT when writing data records as segment records
pslegend.c:				if (line[0] == GMT->current.setting.io_head_marker[GMT_IN] || gmt_is_a_blank_line (line)) continue;	/* Skip all headers */
pslegend.c:						GMT->current.setting.color_model = GMT_RGB;	/* Since we will be interpreting r/g/b triplets via z=<value> */
pslegend.c:						row_height = gmt_M_to_inch (GMT, bar_height) + GMT->current.setting.map_tick_length[0] + GMT->current.setting.map_annot_offset[0] + FONT_HEIGHT_PRIMARY * GMT->current.setting.font_annot[GMT_PRIMARY].size / PSL_POINTS_PER_INCH;
pslegend.c:							GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Text color %s not recognized!\n", txtcolor);
pslegend.c:								sprintf (tmp, "%s", gmt_putfont (GMT, &GMT->current.setting.font_title));
pslegend.c:						ifont = GMT->current.setting.font_title;	/* Set default font */
pslegend.c:								sprintf (tmp, "%s", gmt_putfont (GMT, &GMT->current.setting.font_label));
pslegend.c:						ifont = GMT->current.setting.font_label;	/* Set default font */
pslegend.c:						row_height = GMT->current.setting.map_scale_height + FONT_HEIGHT_PRIMARY * GMT->current.setting.font_annot[GMT_PRIMARY].size / PSL_POINTS_PER_INCH + GMT->current.setting.map_annot_offset[0];
pslegend.c:						d_off = FONT_HEIGHT_LABEL * GMT->current.setting.font_label.size / PSL_POINTS_PER_INCH + fabs(GMT->current.setting.map_label_offset);
pslegend.c:							if (!GMT->common.R.active[RSET] || !GMT->common.J.active) {
pslegend.c:							sprintf (buffer, "-R%s -J%s -O -K -L%s", GMT->common.R.string, GMT->common.J.string, mapscale);
pslegend.c:							double s = gmt_convert_units (GMT, "1", GMT_INCH, GMT->current.setting.proj_length_unit);
pslegend.c:								GMT_Report (API, GMT_MSG_DEBUG, "Column %d: %g %s\n", col, s*(x_off_col[col]-x_off_col[col-1]), GMT->session.unit_name[GMT->current.setting.proj_length_unit]);
pslegend.c:							if (n == 0 || size[0] == '-') sprintf (size, "%g", GMT->current.setting.font_annot[GMT_PRIMARY].size);
pslegend.c:							if (n == 0 || font[0] == '-') sprintf (font, "%d", GMT->current.setting.font_annot[GMT_PRIMARY].id);
pslegend.c:						if (n == 0 || tmp[0] == '-') sprintf (tmp, "%gp,%d,%s", GMT->current.setting.font_annot[GMT_PRIMARY].size, GMT->current.setting.font_annot[GMT_PRIMARY].id, txtcolor);
pslegend.c:							S[PAR] = D[PAR]->table[0]->segment[n_para] = GMT_Alloc_Segment (GMT->parent, GMT_WITH_STRINGS, krow[PAR], 0U, NULL, S[PAR]);
pslegend.c:						d_off = 0.5 * (Ctrl->D.spacing - FONT_HEIGHT_PRIMARY) * GMT->current.setting.font_annot[GMT_PRIMARY].size / PSL_POINTS_PER_INCH;	/* To center the text */
pslegend.c:							sprintf (buffer, "%gp,%d,%s BL %s", GMT->current.setting.font_annot[GMT_PRIMARY].size, GMT->current.setting.font_annot[GMT_PRIMARY].id, txtcolor, text);
pslegend.c:								S[PAR] = D[PAR]->table[0]->segment[n_para] = GMT_Alloc_Segment (GMT->parent, GMT_WITH_STRINGS, krow[PAR], 0U, NULL, S[PAR]);
pslegend.c:							S[PAR] = D[PAR]->table[0]->segment[n_para] = GMT_Alloc_Segment (GMT->parent, GMT_WITH_STRINGS, n_par_lines, 0U, NULL, NULL);
pslegend.c:							d_off = 0.5 * (Ctrl->D.spacing - FONT_HEIGHT_PRIMARY) * GMT->current.setting.font_annot[GMT_PRIMARY].size / PSL_POINTS_PER_INCH;
pslegend.c:							sprintf (buffer, "%g %g 0 %gp,%d,%s TL %gi %gi j", col_left_x, row_base_y - d_off, GMT->current.setting.font_annot[GMT_PRIMARY].size, GMT->current.setting.font_annot[GMT_PRIMARY].id, txtcolor, one_line_spacing, Ctrl->D.dim[GMT_X] - 2.0 * Ctrl->C.off[GMT_X]);
pslegend.c:		sprintf (buffer, "-R0/%g/0/%g -Jx1i -O -K -N -Sf0.1i %s --GMT_HISTORY=false", GMT->current.proj.rect[XHI], GMT->current.proj.rect[YHI], string);
pslegend.c:		sprintf (buffer, "-R0/%g/0/%g -Jx1i -O -K -N -Sqn1 %s --GMT_HISTORY=false", GMT->current.proj.rect[XHI], GMT->current.proj.rect[YHI], string);
pslegend.c:		sprintf (buffer, "-R0/%g/0/%g -Jx1i -O -K -N -S %s --PROJ_LENGTH_UNIT=inch --GMT_HISTORY=false", GMT->current.proj.rect[XHI], GMT->current.proj.rect[YHI], string);
pslegend.c:		sprintf (buffer, "-R0/%g/0/%g -Jx1i -O -K -N -F+f+j %s --GMT_HISTORY=false", GMT->current.proj.rect[XHI], GMT->current.proj.rect[YHI], string);
pslegend.c:			S[PAR] = D[PAR]->table[0]->segment[n_para] = GMT_Alloc_Segment (GMT->parent, GMT_WITH_STRINGS, krow[PAR], 0U, NULL, S[PAR]);
pslegend.c:		sprintf (buffer, "-R0/%g/0/%g -Jx1i -O -K -N -M -F+a+f+j %s --GMT_HISTORY=false", GMT->current.proj.rect[XHI], GMT->current.proj.rect[YHI], string);
psmask.c:		GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Change orientation of closed polygon\n");
psmask.c:	struct GMTAPI_CTRL *API = GMT->parent;
psmask.c:		n_errors += gmt_M_check_condition (GMT, GMT->common.B.active[0] || GMT->common.B.active[1], "Syntax error: Cannot specify -B option in -C mode\n");
psmask.c:		n_errors += gmt_M_check_condition (GMT, !GMT->common.R.active[RSET], "Syntax error: Must specify -R option\n");
psmask.c:		n_errors += gmt_M_check_condition (GMT, !GMT->common.J.active && !Ctrl->D.active, "Syntax error: Must specify a map projection with the -J option\n");
psmask.c:		n_errors += gmt_M_check_condition (GMT, !GMT->common.R.active[ISET], "Syntax error: Must specify -I option\n");
psmask.c:		n_errors += gmt_M_check_condition (GMT, GMT->common.R.active[ISET] && (GMT->common.R.inc[GMT_X] <= 0.0 || GMT->common.R.inc[GMT_Y] <= 0.0), "Syntax error -I option: Must specify positive increments\n");
psmask.c:	if (API->GMT->current.setting.run_mode == GMT_CLASSIC && !API->usage) {
psmask.c:	if (Ctrl->D.active && GMT->current.proj.projection < 0) {	/* Is this the right way of testing it? */
psmask.c:	if (!Ctrl->C.active && make_plot && gmt_M_err_pass (GMT, gmt_map_setup (GMT, GMT->common.R.wesn), "")) Return (GMT_PROJECTION_ERROR);
psmask.c:			GMT->current.ps.nclip = -1;	/* Signal that this program terminates clipping that initiated prior to this process */
psmask.c:			GMT->current.ps.nclip = +1;	/* Signal that this program initiates clipping that will outlive this process */
psmask.c:			gmt_plane_perspective (GMT, GMT->current.proj.z_project.view_plane, GMT->current.proj.z_level);
psmask.c:		gmt_M_grd_setpad (GMT, Grid->header, GMT->current.io.pad);	/* Change header pad to 0 */
psmask.c:						G->data[ij] = (grd[ij] == 0) ? GMT->session.f_NaN : (gmt_grdfloat)grd[ij];
psmask.c:						G->data[ij] = (grd[ij] == 1) ? GMT->session.f_NaN : (gmt_grdfloat)grd[ij];
psmask.c:					S = gmt_prepare_contour (GMT, x, y, n, GMT->session.d_NaN);
psmask.c:						TH->file[GMT_OUT] = gmt_make_filename (GMT, Ctrl->D.file, fmt, GMT->session.d_NaN, closed, cont_counts);
psmask.c:						SH->file[GMT_OUT] = gmt_make_filename (GMT, Ctrl->D.file, fmt, GMT->session.d_NaN, closed, cont_counts);
psmask.c:					if ((*GMT->current.map.will_it_wrap) (GMT, xp, yp, plot_n, &start)) {	/* Polygon wraps */
psmask.c:						GMT->current.plot.n = gmt_map_truncate (GMT, xp, yp, plot_n, start, -1);
psmask.c:						n_use = gmt_compact_line (GMT, GMT->current.plot.x, GMT->current.plot.y, GMT->current.plot.n, false, 0);
psmask.c:						PSL_plotpolygon (PSL, GMT->current.plot.x, GMT->current.plot.y, (int)n_use);
psmask.c:						GMT->current.plot.n = gmt_map_truncate (GMT, xp, yp, plot_n, start, +1);
psmask.c:						n_use = gmt_compact_line (GMT, GMT->current.plot.x, GMT->current.plot.y, GMT->current.plot.n, false, 0);
psmask.c:						PSL_plotpolygon (PSL, GMT->current.plot.x, GMT->current.plot.y, (int)n_use);
psrose.c:	C->W.pen[0] = C->W.pen[1] = GMT->current.setting.map_default_pen;
psrose.c:	r = (API->GMT->current.setting.proj_length_unit == GMT_CM) ? 7.5 : 3.0;
psrose.c:	GMT_Message (API, GMT_TIME_NONE, "\t-J Use -JX<width>[unit] to set the plot diameter [%g %s].\n", r, API->GMT->session.unit_name[API->GMT->current.setting.proj_length_unit]);
psrose.c:	GMT_Message (API, GMT_TIME_NONE, "\t-: Expect (azimuth,radius) input rather than (radius,azimuth) [%s].\n", choice[API->GMT->current.setting.io_lonlat_toggle[GMT_IN]]);
psrose.c:	struct GMTAPI_CTRL *API = GMT->parent;
psrose.c:						Ctrl->M.S.size_x = VECTOR_HEAD_LENGTH * GMT->session.u2u[GMT_PT][GMT_INCH];	/* 9p */
psrose.c:						Ctrl->M.S.v.pen = GMT->current.setting.map_default_pen;
psrose.c:	GMT->common.R.wesn[XLO] = 0.0;
psrose.c:	range = GMT->common.R.wesn[YHI] - GMT->common.R.wesn[YLO];
psrose.c:		n_errors += gmt_M_check_condition (GMT, !GMT->common.J.active, "Syntax error: Must specify -JX option\n");
psrose.c:		n_errors += gmt_M_check_condition (GMT, GMT->current.proj.projection != GMT_LINEAR, "Syntax error: Must specify -JX option\n");
psrose.c:		n_errors += gmt_M_check_condition (GMT, !GMT->common.R.active[RSET], "Syntax error: Must specify -R option\n");
psrose.c:		n_errors += gmt_M_check_condition (GMT, !((GMT->common.R.wesn[YLO] == -90.0 && GMT->common.R.wesn[YHI] == 90.0) \
psrose.c:			|| (GMT->common.R.wesn[YLO] == 0.0 && GMT->common.R.wesn[YHI] == 180.0)
psrose.c:			|| (GMT->common.R.wesn[YLO] == 0.0 && GMT->common.R.wesn[YHI] == 360.0)),
psrose.c:	if (API->GMT->current.setting.run_mode == GMT_CLASSIC && !API->usage) {
psrose.c:	asize = GMT->current.setting.font_annot[GMT_PRIMARY].size * GMT->session.u2u[GMT_PT][GMT_INCH];
psrose.c:	lsize = GMT->current.setting.font_annot[GMT_PRIMARY].size * GMT->session.u2u[GMT_PT][GMT_INCH];
psrose.c:	max_radius = GMT->common.R.wesn[XHI];
psrose.c:	if (doubleAlmostEqual (GMT->common.R.wesn[YLO], -90.0))
psrose.c:	else if (doubleAlmostEqual (GMT->common.R.wesn[YHI], 180.0))
psrose.c:	if (!Ctrl->I.active && !GMT->common.R.active[RSET]) automatic = true;
psrose.c:	n_in = (GMT->common.i.select && GMT->common.i.n_cols == 1) ? 1 : 2;
psrose.c:	if (GMT->common.colon.active)
psrose.c:		GMT->current.setting.io_lonlat_toggle[GMT_IN] = true;
psrose.c:			GMT->current.setting.format_float_out, GMT->current.setting.format_float_out, GMT->current.setting.format_float_out, kind[Ctrl->A.active],
psrose.c:			GMT->current.setting.format_float_out, GMT->current.setting.format_float_out, GMT->current.setting.format_float_out);
psrose.c:			gmt_M_memcpy (col_type, GMT->current.io.col_type[GMT_OUT], 2U, unsigned int);	/* Save first 2 current output col types */
psrose.c:			gmt_M_memcpy (GMT->current.io.col_type[GMT_OUT], col_type, 2U, unsigned int);	/* Restore 2 current output col types */
psrose.c:		if (gmt_M_is_zero (GMT->current.map.frame.axis[GMT_X].item[GMT_ANNOT_UPPER].interval)) {
psrose.c:			tmp = GMT->current.map.frame.axis[GMT_X].item[GMT_ANNOT_UPPER].interval;
psrose.c:		if (gmt_M_is_zero (GMT->current.map.frame.axis[GMT_X].item[GMT_ANNOT_UPPER].interval) || gmt_M_is_zero (GMT->current.map.frame.axis[GMT_X].item[GMT_GRID_UPPER].interval)) {	/* Tickmarks not set */
psrose.c:			GMT->current.map.frame.axis[GMT_X].item[GMT_ANNOT_UPPER].interval = GMT->current.map.frame.axis[GMT_X].item[GMT_GRID_UPPER].interval = tmp;
psrose.c:			GMT->current.map.frame.draw = true;
psrose.c:	if (GMT->current.map.frame.draw && gmt_M_is_zero (GMT->current.map.frame.axis[GMT_Y].item[GMT_ANNOT_UPPER].interval)) GMT->current.map.frame.axis[GMT_Y].item[GMT_ANNOT_UPPER].interval = GMT->current.map.frame.axis[GMT_Y].item[GMT_GRID_UPPER].interval = 30.0;
psrose.c:	Ctrl->S.scale = 0.5 * gmt_M_to_inch (GMT, &GMT->common.J.string[1]);	/* Get radius from full width */
psrose.c:	GMT->common.J.active = false;	/* Reset projection machinery */
psrose.c:	GMT->common.R.active[RSET] = GMT->common.J.active = true;
psrose.c:	if (GMT->current.map.frame.paint) {	/* Until psrose uses a polar projection we must bypass the basemap fill and do it ourself here */
psrose.c:		GMT->current.map.frame.paint = false;	/* Turn off so gmt_plotinit won't fill */
psrose.c:	gmt_plane_perspective (GMT, GMT->current.proj.z_project.view_plane, GMT->current.proj.z_level);
psrose.c:		GMT->current.map.frame.paint = true;	/* Restore original setting */
psrose.c:			PSL_beginclipping (PSL, xc, yc, 4, GMT->session.no_rgb, 3);
psrose.c:		gmt_setfill (GMT, &GMT->current.map.frame.fill, false);
psrose.c:	if (GMT->common.B.active[0]) {	/* Draw frame */
psrose.c:		gmt_setpen (GMT, &GMT->current.setting.map_frame_pen);
psrose.c:		PSL_defpen (GMT->PSL, "PSL_vecheadpen", Ctrl->M.S.v.pen.width, Ctrl->M.S.v.pen.style, Ctrl->M.S.v.pen.offset, Ctrl->M.S.v.pen.rgb);
psrose.c:		PSL_defpen (GMT->PSL, "PSL_vecheadpen", 0.5 * Ctrl->W.pen[1].width, Ctrl->W.pen[1].style, Ctrl->W.pen[1].offset, Ctrl->W.pen[1].rgb);
psrose.c:			if (Ctrl->M.S.symbol == PSL_VECTOR) Ctrl->M.S.v.v_width = (float)(Ctrl->W.pen[1].width * GMT->session.u2u[GMT_PT][GMT_INCH]);
psrose.c:							this_rgb = GMT->session.no_rgb;
psrose.c:						dim[5] = GMT->current.setting.map_vector_shape;
psrose.c:							this_rgb = GMT->session.no_rgb;
psrose.c:						dim[5] = GMT->current.setting.map_vector_shape;
psrose.c:			if ((V = GMT_Create_Data (GMT->parent, GMT_IS_DATASET, GMT_IS_POINT, 0, dim, NULL, NULL, 0, 0, NULL)) == NULL) {
psrose.c:			Ctrl->M.S.size_x = VECTOR_HEAD_LENGTH * GMT->session.u2u[GMT_PT][GMT_INCH];	/* 9p */
psrose.c:			Ctrl->M.S.v.v_width  = (float)(VECTOR_LINE_WIDTH * GMT->session.u2u[GMT_PT][GMT_INCH]);	/* 9p */
psrose.c:		if (Ctrl->M.S.symbol == PSL_VECTOR) Ctrl->M.S.v.v_width = (float)(Ctrl->W.pen[1].width * GMT->session.u2u[GMT_PT][GMT_INCH]);
psrose.c:			dim[5] = GMT->current.setting.map_vector_shape;
psrose.c:				this_rgb = GMT->session.no_rgb;
psrose.c:				PSL_defpen (GMT->PSL, "PSL_vecheadpen", Ctrl->M.S.v.pen.width, Ctrl->M.S.v.pen.style, Ctrl->M.S.v.pen.offset, Ctrl->M.S.v.pen.rgb);
psrose.c:				PSL_defpen (GMT->PSL, "PSL_vecheadpen", 0.5 * Ctrl->W.pen[1].width, Ctrl->W.pen[1].style, Ctrl->W.pen[1].offset, Ctrl->W.pen[1].rgb);
psrose.c:		Ctrl->L.w = strdup (GMT->current.language.cardinal_name[0][0]);
psrose.c:		Ctrl->L.e = strdup (GMT->current.language.cardinal_name[0][1]);
psrose.c:		Ctrl->L.s = strdup (GMT->current.language.cardinal_name[0][2]);
psrose.c:		Ctrl->L.n = strdup (GMT->current.language.cardinal_name[0][3]);
psrose.c:	if (GMT->current.map.frame.draw) {	/* Draw grid lines etc */
psrose.c:		gmt_setpen (GMT, &GMT->current.setting.map_grid_pen[GMT_PRIMARY]);
psrose.c:		n_alpha = (GMT->current.map.frame.axis[GMT_Y].item[GMT_GRID_UPPER].interval > 0.0) ? irint (total_arc / GMT->current.map.frame.axis[GMT_Y].item[GMT_GRID_UPPER].interval) : -1;
psrose.c:			angle = k * GMT->current.map.frame.axis[GMT_Y].item[GMT_GRID_UPPER].interval;
psrose.c:		if (GMT->current.map.frame.axis[GMT_X].item[GMT_GRID_UPPER].interval > 0.0) {
psrose.c:			n_bins = urint (max_radius / GMT->current.map.frame.axis[GMT_X].item[GMT_GRID_UPPER].interval);
psrose.c:				PSL_plotarc (PSL, 0.0, 0.0, bin * GMT->current.map.frame.axis[GMT_X].item[GMT_GRID_UPPER].interval * Ctrl->S.scale, 0.0, total_arc, PSL_MOVE|PSL_STROKE);
psrose.c:		PSL_setcolor (PSL, GMT->current.setting.map_frame_pen.rgb, PSL_IS_STROKE);
psrose.c:		y = lsize + 6.0 * GMT->current.setting.map_annot_offset[GMT_PRIMARY];
psrose.c:		form = gmt_setfont (GMT, &GMT->current.setting.font_title);
psrose.c:		PSL_plottext (PSL, 0.0, off + y, GMT->current.setting.font_title.size, GMT->current.map.frame.header, 0.0, PSL_BC, form);
psrose.c:		gmt_get_format (GMT, GMT->current.map.frame.axis[GMT_X].item[GMT_ANNOT_UPPER].interval, GMT->current.map.frame.axis[GMT_X].unit, GMT->current.map.frame.axis[GMT_X].prefix, format);
psrose.c:				if (GMT->current.setting.map_degree_symbol == gmt_none) {
psrose.c:						sprintf (Ctrl->L.w, "90%s", GMT->current.language.cardinal_name[2][0]);
psrose.c:						sprintf (Ctrl->L.e, "90%s", GMT->current.language.cardinal_name[2][1]);
psrose.c:						sprintf (Ctrl->L.w, "0%s",   GMT->current.language.cardinal_name[2][3]);
psrose.c:						sprintf (Ctrl->L.e, "180%s", GMT->current.language.cardinal_name[2][2]);
psrose.c:						sprintf (Ctrl->L.n, "90%s",  GMT->current.language.cardinal_name[2][1]);
psrose.c:						sprintf (Ctrl->L.w, "90%c%s", (int)GMT->current.setting.ps_encoding.code[GMT->current.setting.map_degree_symbol], GMT->current.language.cardinal_name[2][0]);
psrose.c:						sprintf (Ctrl->L.e, "90%c%s", (int)GMT->current.setting.ps_encoding.code[GMT->current.setting.map_degree_symbol], GMT->current.language.cardinal_name[2][1]);
psrose.c:						sprintf (Ctrl->L.n, "0%c",    (int)GMT->current.setting.ps_encoding.code[GMT->current.setting.map_degree_symbol]);
psrose.c:						sprintf (Ctrl->L.w, "0%c%s",   (int)GMT->current.setting.ps_encoding.code[GMT->current.setting.map_degree_symbol], GMT->current.language.cardinal_name[2][3]);
psrose.c:						sprintf (Ctrl->L.e, "180%c%s", (int)GMT->current.setting.ps_encoding.code[GMT->current.setting.map_degree_symbol], GMT->current.language.cardinal_name[2][2]);
psrose.c:						sprintf (Ctrl->L.n, "90%c%s",  (int)GMT->current.setting.ps_encoding.code[GMT->current.setting.map_degree_symbol], GMT->current.language.cardinal_name[2][1]);
psrose.c:			form = gmt_setfont (GMT, &GMT->current.setting.font_label);
psrose.c:			y = -(3.0 * GMT->current.setting.map_annot_offset[GMT_PRIMARY] + GMT->session.font[GMT->current.setting.font_annot[GMT_PRIMARY].id].height * asize);
psrose.c:			if (GMT->current.map.frame.axis[GMT_X].label[0]) PSL_plottext (PSL, 0.0, y, GMT->current.setting.font_label.size, GMT->current.map.frame.axis[GMT_X].label, 0.0, PSL_TC, form);
psrose.c:			y = -(5.0 * GMT->current.setting.map_annot_offset[GMT_PRIMARY] + GMT->session.font[GMT->current.setting.font_annot[GMT_PRIMARY].id].height * lsize + GMT->session.font[GMT->current.setting.font_label.id].height * lsize);
psrose.c:			if (GMT->current.map.frame.axis[GMT_Y].label[0]) PSL_plottext (PSL, 0.0, y, GMT->current.setting.font_label.size, GMT->current.map.frame.axis[GMT_Y].label, 0.0, PSL_TC, form);
psrose.c:			form = gmt_setfont (GMT, &GMT->current.setting.font_annot[GMT_PRIMARY]);
psrose.c:			PSL_plottext (PSL, 0.0, -GMT->current.setting.map_annot_offset[GMT_PRIMARY], GMT->current.setting.font_annot[GMT_PRIMARY].size, "0", 0.0, PSL_TC, form);
psrose.c:			n_annot = (GMT->current.map.frame.axis[GMT_X].item[GMT_ANNOT_UPPER].interval > 0.0) ? irint (max_radius / GMT->current.map.frame.axis[GMT_X].item[GMT_ANNOT_UPPER].interval) : -1;
psrose.c:				x = k * GMT->current.map.frame.axis[GMT_X].item[GMT_ANNOT_UPPER].interval;
psrose.c:				PSL_plottext (PSL, x, -GMT->current.setting.map_annot_offset[GMT_PRIMARY], GMT->current.setting.font_annot[GMT_PRIMARY].size, text, 0.0, PSL_TC, form);
psrose.c:				PSL_plottext (PSL, -x, -GMT->current.setting.map_annot_offset[GMT_PRIMARY], GMT->current.setting.font_annot[GMT_PRIMARY].size, text, 0.0, PSL_TC, form);
psrose.c:			form = gmt_setfont (GMT, &GMT->current.setting.font_label);
psrose.c:			PSL_plottext (PSL, 0.0, -off - 2.0 * GMT->current.setting.map_annot_offset[GMT_PRIMARY], GMT->current.setting.font_label.size, Ctrl->L.s, 0.0, PSL_TC, form);
psrose.c:			if (!Ctrl->F.active && GMT->current.map.frame.axis[GMT_X].item[GMT_GRID_UPPER].interval > 0.0) {	/* Draw scale bar but only if x-grid interval is set */
psrose.c:				PSL_plotsegment (PSL, off, -off, (max_radius - GMT->current.map.frame.axis[GMT_X].item[GMT_GRID_UPPER].interval) * Ctrl->S.scale, -off);
psrose.c:				PSL_plotsegment (PSL, off, -off, off, GMT->current.setting.map_tick_length[0] - off);
psrose.c:				PSL_plotsegment (PSL, (max_radius - GMT->current.map.frame.axis[GMT_X].item[GMT_GRID_UPPER].interval) * Ctrl->S.scale, -off, (max_radius - GMT->current.map.frame.axis[GMT_X].item[GMT_GRID_UPPER].interval) * Ctrl->S.scale, GMT->current.setting.map_tick_length[0] - off);
psrose.c:				if (GMT->current.map.frame.axis[GMT_X].label[0]) {
psrose.c:					sprintf (text, format, GMT->current.map.frame.axis[GMT_X].item[GMT_GRID_UPPER].interval, GMT->current.map.frame.axis[GMT_X].label);
psrose.c:					sprintf (text, format, GMT->current.map.frame.axis[GMT_X].item[GMT_GRID_UPPER].interval);
psrose.c:				form = gmt_setfont (GMT, &GMT->current.setting.font_annot[GMT_PRIMARY]);
psrose.c:				PSL_plottext (PSL, (max_radius - 0.5 * GMT->current.map.frame.axis[GMT_X].item[GMT_GRID_UPPER].interval) * Ctrl->S.scale, -(off + GMT->current.setting.map_annot_offset[GMT_PRIMARY]), GMT->current.setting.font_annot[GMT_PRIMARY].size, text, 0.0, PSL_TC, form);
psrose.c:			y = -(off + 5.0 * GMT->current.setting.map_annot_offset[GMT_PRIMARY] + GMT->session.font[GMT->current.setting.font_annot[GMT_PRIMARY].id].height * lsize + GMT->session.font[GMT->current.setting.font_label.id].height * lsize);
psrose.c:			form = gmt_setfont (GMT, &GMT->current.setting.font_label);
psrose.c:			if (GMT->current.map.frame.axis[GMT_Y].label[0]) PSL_plottext (PSL, 0.0, y, GMT->current.setting.font_label.size, GMT->current.map.frame.axis[GMT_Y].label, 0.0, PSL_TC, form);
psrose.c:		form = gmt_setfont (GMT, &GMT->current.setting.font_label);
psrose.c:		PSL_plottext (PSL, off + 2.0 * GMT->current.setting.map_annot_offset[GMT_PRIMARY], 0.0, GMT->current.setting.font_label.size, Ctrl->L.e, 0.0, PSL_ML, form);
psrose.c:		PSL_plottext (PSL, -off - 2.0 * GMT->current.setting.map_annot_offset[GMT_PRIMARY], 0.0, GMT->current.setting.font_label.size, Ctrl->L.w, 0.0, PSL_MR, form);
psrose.c:		PSL_plottext (PSL, 0.0, off + 2.0 * GMT->current.setting.map_annot_offset[GMT_PRIMARY], GMT->current.setting.font_label.size, Ctrl->L.n, 0.0, PSL_BC, form);
psrose.c:		PSL_setcolor (PSL, GMT->current.setting.map_default_pen.rgb, PSL_IS_STROKE);
psscale.c:	C->G.z_low = C->G.z_high = GMT->session.d_NaN;	/* No truncation */
psscale.c:		API->GMT->session.unit_name[API->GMT->current.setting.proj_length_unit]);
psscale.c:	struct GMTAPI_CTRL *API = GMT->parent;
psscale.c:	GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Bar settings: justify = %d, dx = %g dy = %g\n", Ctrl->D.justify, Ctrl->D.off[GMT_X], Ctrl->D.off[GMT_Y]);
psscale.c:			n_errors += gmt_M_check_condition (GMT, !GMT->common.R.active[RSET], "Syntax error: -D%c requires the -R option\n", kind[Ctrl->D.refpoint->mode]);
psscale.c:			n_errors += gmt_M_check_condition (GMT, !GMT->common.J.active, "Syntax error: -D%c requires the -J option\n", kind[Ctrl->D.refpoint->mode]);
psscale.c:	n_errors += gmt_M_check_condition (GMT, Ctrl->L.active && GMT->current.map.frame.set, "Syntax error -L option: Cannot be used if -B option sets increments.\n");
psscale.c:	p_width = (float)(s * pen.width * GMT->session.u2u[GMT_PT][GMT_INCH]);
psscale.c:	pen.width = p_width * GMT->session.u2u[GMT_INCH][GMT_PT];
psscale.c:	PSL_defpen (GMT->PSL, "PSL_vecheadpen", 0.0, "", 0, black.rgb);
psscale.c:	PSL_plotsymbol (GMT->PSL, x, y, vdim, PSL_MARC);
psscale.c:	PSL_plotsymbol (GMT->PSL, x, y, vdim, PSL_MARC);
psscale.c:#define FONT_HEIGHT_PRIMARY (GMT->session.font[GMT->current.setting.font_annot[GMT_PRIMARY].id].height)
psscale.c:	bool B_set = GMT->current.map.frame.draw, skip_lines = Ctrl->S.active, need_image;
psscale.c:	struct PSL_CTRL *PSL = GMT->PSL;
psscale.c:	GMT->current.setting.map_annot_offset[GMT_PRIMARY] = fabs (GMT->current.setting.map_annot_offset[GMT_PRIMARY]);	/* No 'inside' annotations allowed in colorbar */
psscale.c:		A = &GMT->current.map.frame.axis[GMT_X];
psscale.c:		ndec = gmt_get_format (GMT, GMT->current.map.frame.axis[GMT_X].item[GMT_ANNOT_UPPER].interval, GMT->current.map.frame.axis[GMT_X].unit, GMT->current.map.frame.axis[GMT_X].prefix, format);
psscale.c:			if (exp_notation && !strchr (GMT->current.setting.format_float_map, 'e')) {	/* Unwanted exponential notation: Abandon automatic format detection and use FORMAT_FLOAT_MAP */
psscale.c:		strncpy (format, GMT->current.setting.format_float_map, GMT_LEN256-1);
psscale.c:		fix_format (GMT->current.map.frame.axis[GMT_X].unit, format);	/* Add units if needed */
psscale.c:	len = GMT->current.setting.map_tick_length[GMT_ANNOT_UPPER];	/* +ve means draw on the outside of bar */
psscale.c:	len2 = GMT->current.setting.map_tick_length[GMT_TICK_UPPER];
psscale.c:	GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Color bar will be plotted using %s\n", method[use_image]);
psscale.c:	if (!strcmp (GMT->current.map.frame.axis[GMT_X].label, GMT->current.map.frame.axis[GMT_Y].label)) GMT->current.map.frame.axis[GMT_Y].label[0] = 0;
psscale.c:			* GMT->current.setting.font_annot[GMT_PRIMARY].size / PSL_POINTS_PER_INCH;
psscale.c:		bar_tick_len = fabs (GMT->current.setting.map_tick_length[GMT_ANNOT_UPPER]);	/* Length of tickmarks */
psscale.c:			annot_off = MAX (0.0, GMT->current.setting.map_annot_offset[GMT_PRIMARY]);	/* Allow for space between bar and annotations */
psscale.c:			annot_off += GMT_LET_HEIGHT * GMT->current.setting.font_annot[GMT_PRIMARY].size / PSL_POINTS_PER_INCH;
psscale.c:			if (GMT->current.map.frame.axis[GMT_X].label[0]) {
psscale.c:				if (!(flip & PSSCALE_FLIP_LABEL) && letter_hangs_down (GMT->current.map.frame.axis[GMT_X].label))
psscale.c:				label_off *= GMT_LET_HEIGHT * GMT->current.setting.font_label.size / PSL_POINTS_PER_INCH;	/* Scale to inches */
psscale.c:				label_off += MAX (0.0, GMT->current.setting.map_label_offset);	/* Add offset */
psscale.c:			if (GMT->current.map.frame.axis[GMT_Y].label[0]) {
psscale.c:				size_t ylen = strlen (GMT->current.map.frame.axis[GMT_Y].label);
psscale.c:				if (strchr (GMT->current.map.frame.axis[GMT_Y].label, '\\')) ylen = (ylen > 3) ? ylen - 3 : 0;
psscale.c:				u_off = MAX (0.0, GMT->current.setting.map_annot_offset[GMT_PRIMARY]) + (0.5+ylen) * GMT_LET_WIDTH * GMT->current.setting.font_annot[GMT_PRIMARY].size / PSL_POINTS_PER_INCH;
psscale.c:				v_off = 0.5 * (GMT_LET_HEIGHT * GMT->current.setting.font_annot[GMT_PRIMARY].size / PSL_POINTS_PER_INCH - width);
psscale.c:			dim[YHI] += 0.5 * GMT->current.setting.map_frame_pen.width / PSL_POINTS_PER_INCH;
psscale.c:				dim[XLO] += 2.0 * Ctrl->D.elength + gap + fabs (GMT->current.setting.map_annot_offset[GMT_PRIMARY]) + 3.25 * GMT_LET_WIDTH * GMT->current.setting.font_annot[GMT_PRIMARY].size / PSL_POINTS_PER_INCH;
psscale.c:			if (GMT->current.setting.map_annot_ortho[0] == '\0') {	/* Annotations are parallel to bar, reset width */
psscale.c:				hor_annot_width = GMT_LET_HEIGHT * GMT->current.setting.font_annot[GMT_PRIMARY].size / PSL_POINTS_PER_INCH;
psscale.c:				h_off = 0.5 * GMT_LET_HEIGHT * GMT->current.setting.font_annot[GMT_PRIMARY].size / PSL_POINTS_PER_INCH;
psscale.c:			annot_off = MAX (0.0, GMT->current.setting.map_annot_offset[GMT_PRIMARY]);	/* Allow for space between bar and annotations */
psscale.c:			if (GMT->current.map.frame.axis[GMT_X].label[0])
psscale.c:				label_off = MAX (0.0, GMT->current.setting.map_label_offset) + GMT->current.setting.font_label.size / PSL_POINTS_PER_INCH;
psscale.c:			if (GMT->current.map.frame.axis[GMT_Y].label[0]) {
psscale.c:				size_t ylen = strlen (GMT->current.map.frame.axis[GMT_Y].label);
psscale.c:				if (strchr (GMT->current.map.frame.axis[GMT_Y].label, '\\')) ylen = (ylen > 3) ? ylen - 3 : 0;
psscale.c:				u_off = 0.5 * MAX (0.0, 1.3*ylen * GMT_LET_WIDTH * GMT->current.setting.font_annot[GMT_PRIMARY].size / PSL_POINTS_PER_INCH - width);
psscale.c:				v_off = MAX (0.0, GMT->current.setting.map_annot_offset[GMT_PRIMARY]) + GMT->current.setting.font_annot[GMT_PRIMARY].size * GMT_LET_HEIGHT / PSL_POINTS_PER_INCH;
psscale.c:				dim[YLO] += 2.0 * Ctrl->D.elength + gap + fabs (GMT->current.setting.map_annot_offset[GMT_PRIMARY]) + 1.75 * GMT_LET_HEIGHT * GMT->current.setting.font_annot[GMT_PRIMARY].size / PSL_POINTS_PER_INCH;
psscale.c:	gmt_setpen (GMT, &GMT->current.setting.map_frame_pen);
psscale.c:	/* Save label and unit, because we are going to switch them off in GMT->current.map.frame and do it ourselves */
psscale.c:	strncpy (label, GMT->current.map.frame.axis[GMT_X].label, GMT_LEN256-1);
psscale.c:	strncpy (unit, GMT->current.map.frame.axis[GMT_Y].label, GMT_LEN256-1);
psscale.c:	GMT->current.map.frame.axis[GMT_X].label[0] = GMT->current.map.frame.axis[GMT_Y].label[1] = 0;
psscale.c:		y_label = width + GMT->current.setting.map_label_offset;
psscale.c:		y_label = -GMT->current.setting.map_label_offset;
psscale.c:		double theta, s, c, w = GMT->current.setting.map_frame_pen.width * GMT->session.u2u[GMT_PT][GMT_INCH];
psscale.c:					PSL_setfill (PSL, GMT->session.no_rgb, center);
psscale.c:		annot_off = ((len > 0.0 && !center) ? len : 0.0) + GMT->current.setting.map_annot_offset[GMT_PRIMARY];
psscale.c:		label_off = annot_off + GMT_LET_HEIGHT * GMT->current.setting.font_annot[GMT_PRIMARY].size * GMT->session.u2u[GMT_PT][GMT_INCH] + GMT->current.setting.map_label_offset;
psscale.c:			if (Ctrl->D.etext) PSL_plottext (PSL, xp[2] - fabs (GMT->current.setting.map_annot_offset[GMT_PRIMARY]), 0.5 * width, GMT->current.setting.font_annot[GMT_PRIMARY].size, Ctrl->D.etext, 0.0, PSL_MR, 0);
psscale.c:			gmt_xy_axis2 (GMT, xleft, y_base, length, start_val, stop_val, A, !(flip & PSSCALE_FLIP_ANNOT), GMT->current.map.frame.side[flip & PSSCALE_FLIP_ANNOT ? N_SIDE : S_SIDE] & PSSCALE_FLIP_LABEL, GMT->current.map.frame.side[flip & PSSCALE_FLIP_ANNOT ? N_SIDE : S_SIDE]);
psscale.c:				gmt_setpen (GMT, &GMT->current.setting.map_grid_pen[GMT_PRIMARY]);
psscale.c:				gmt_setpen (GMT, &GMT->current.setting.map_grid_pen[GMT_PRIMARY]);
psscale.c:			gmt_setpen (GMT, &GMT->current.setting.map_tick_pen[GMT_PRIMARY]);
psscale.c:			form = gmt_setfont (GMT, &GMT->current.setting.font_annot[GMT_PRIMARY]);
psscale.c:					if (do_annot) PSL_plottext (PSL, xx, y_annot, GMT->current.setting.font_annot[GMT_PRIMARY].size, text, 0.0, -this_just, form);
psscale.c:					if (do_annot) PSL_plottext (PSL, xpos[P->n_colors], y_annot, GMT->current.setting.font_annot[GMT_PRIMARY].size, text, 0.0, -this_just, form);
psscale.c:			form = gmt_setfont (GMT, &GMT->current.setting.font_label);
psscale.c:			PSL_plottext (PSL, xleft + 0.5 * length, y_label, GMT->current.setting.font_label.size, label, 0.0, Label_justify, form);
psscale.c:			form = gmt_setfont (GMT, &GMT->current.setting.font_annot[GMT_PRIMARY]);
psscale.c:				PSL_plottext (PSL, xleft  - elength[XLO] - GMT->current.setting.map_annot_offset[GMT_PRIMARY], 0.5 * width, GMT->current.setting.font_annot[GMT_PRIMARY].size, unit, 0.0, PSL_MR, form);
psscale.c:				PSL_plottext (PSL, xright + elength[XHI] + GMT->current.setting.map_annot_offset[GMT_PRIMARY], 0.5 * width, GMT->current.setting.font_annot[GMT_PRIMARY].size, unit, 0.0, PSL_ML, form);
psscale.c:				x0 = xright + GMT->current.setting.map_annot_offset[GMT_PRIMARY] + 0.45 * width;
psscale.c:				x0 = xleft - GMT->current.setting.map_annot_offset[GMT_PRIMARY] - 0.45 * width;
psscale.c:					PSL_setfill (PSL, GMT->session.no_rgb, center);
psscale.c:				* GMT->current.setting.font_annot[GMT_PRIMARY].size * GMT->session.u2u[GMT_PT][GMT_INCH];
psscale.c:				* GMT->current.setting.font_annot[GMT_PRIMARY].size * GMT->session.u2u[GMT_PT][GMT_INCH];
psscale.c:		if (GMT->current.setting.map_annot_ortho[0] == '\0')	/* Reset width to height since rotated */
psscale.c:			hor_annot_width = GMT->current.setting.font_annot[GMT_PRIMARY].size * GMT->session.u2u[GMT_PT][GMT_INCH];	/* Annotations are orthogonal */
psscale.c:		annot_off = ((len > 0.0 && !center) ? len : 0.0) + GMT->current.setting.map_annot_offset[GMT_PRIMARY] + hor_annot_width;
psscale.c:		label_off = annot_off + GMT->current.setting.map_label_offset;
psscale.c:			if (Ctrl->D.etext) PSL_plottext (PSL, xp[2] - fabs (GMT->current.setting.map_annot_offset[GMT_PRIMARY]), 0.5 * width, GMT->current.setting.font_annot[GMT_PRIMARY].size, Ctrl->D.etext, -90.0, PSL_TC, 0);
psscale.c:			A = &GMT->current.map.frame.axis[GMT_X];
psscale.c:				gmt_setpen (GMT, &GMT->current.setting.map_grid_pen[GMT_PRIMARY]);
psscale.c:			custum = GMT->current.map.frame.axis[GMT_Y].file_custom;	/* Need to remember what this was */
psscale.c:			gmt_M_memcpy (&GMT->current.map.frame.axis[GMT_Y], &GMT->current.map.frame.axis[GMT_X], 1, struct GMT_PLOT_AXIS);
psscale.c:			gmt_M_double_swap (GMT->current.proj.scale[GMT_X], GMT->current.proj.scale[GMT_Y]);
psscale.c:			gmt_M_double_swap (GMT->current.proj.origin[GMT_X], GMT->current.proj.origin[GMT_Y]);
psscale.c:			gmt_M_uint_swap (GMT->current.proj.xyz_projection[GMT_X], GMT->current.proj.xyz_projection[GMT_Y]);
psscale.c:			tmp = GMT->current.proj.fwd_x; GMT->current.proj.fwd_y = GMT->current.proj.fwd_x; GMT->current.proj.fwd_x = tmp;
psscale.c:			GMT->current.map.frame.axis[GMT_Y].id = GMT_Y;
psscale.c:			for (i = 0; i < 5; i++) GMT->current.map.frame.axis[GMT_Y].item[i].parent = GMT_Y;
psscale.c:			gmt_xy_axis2 (GMT, -y_base, 0.0, length, start_val, stop_val, &GMT->current.map.frame.axis[GMT_Y], flip & PSSCALE_FLIP_ANNOT, GMT->current.map.frame.side[flip & PSSCALE_FLIP_ANNOT ? W_SIDE : E_SIDE] & GMT_AXIS_ANNOT, GMT->current.map.frame.side[flip & PSSCALE_FLIP_ANNOT ? W_SIDE : E_SIDE]);
psscale.c:			GMT->current.map.frame.axis[GMT_Y].file_custom = custum;	/* Restore correct pointer */
psscale.c:				gmt_setpen (GMT, &GMT->current.setting.map_grid_pen[GMT_PRIMARY]);
psscale.c:				gmt_setpen (GMT, &GMT->current.setting.map_tick_pen[GMT_PRIMARY]);
psscale.c:			form = gmt_setfont (GMT, &GMT->current.setting.font_annot[GMT_PRIMARY]);
psscale.c:					if (do_annot) PSL_plottext (PSL, xx, y_annot, GMT->current.setting.font_annot[GMT_PRIMARY].size, text, -90.0, -this_just, form);
psscale.c:					if (do_annot) PSL_plottext (PSL, xpos[P->n_colors], y_annot, GMT->current.setting.font_annot[GMT_PRIMARY].size, text, -90.0, -this_just, form);
psscale.c:			form = gmt_setfont (GMT, &GMT->current.setting.font_label);
psscale.c:				PSL_plottext (PSL, xleft + 0.5 * length, y_label, GMT->current.setting.font_label.size, label, 0.0, Label_justify, form);
psscale.c:				y_label += 0.5 * dir * GMT->current.setting.font_label.size * GMT->session.u2u[GMT_PT][GMT_INCH];
psscale.c:				size = 0.9 * GMT->current.setting.font_label.size * GMT->session.u2u[GMT_PT][GMT_INCH];
psscale.c:					PSL_plottext (PSL, x1, y_label, GMT->current.setting.font_label.size, text, -90.0, PSL_MC, form);
psscale.c:			form = gmt_setfont (GMT, &GMT->current.setting.font_annot[GMT_PRIMARY]);
psscale.c:				PSL_plottext (PSL, xleft  - GMT->current.setting.map_annot_offset[GMT_PRIMARY] - elength[XLO], 0.5 * width, GMT->current.setting.font_annot[GMT_PRIMARY].size, unit, -90.0, PSL_TC, form);
psscale.c:				PSL_plottext (PSL, xright + GMT->current.setting.map_annot_offset[GMT_PRIMARY] + elength[XHI], 0.5 * width, GMT->current.setting.font_annot[GMT_PRIMARY].size, unit, -90.0, PSL_BC, form);
psscale.c:				x0 = xright + GMT->current.setting.map_annot_offset[GMT_PRIMARY] + 0.45 * width;
psscale.c:				x0 = xleft - GMT->current.setting.map_annot_offset[GMT_PRIMARY] - 0.45 * width;
psscale.c:	if (API->GMT->current.setting.run_mode == GMT_CLASSIC && !API->usage) {
psscale.c:	GMT->current.map.frame.side[S_SIDE] = GMT->current.map.frame.side[E_SIDE] = GMT->current.map.frame.side[N_SIDE] = GMT->current.map.frame.side[W_SIDE] = GMT_AXIS_ALL;
psscale.c:	GMT->current.map.frame.draw = false;	/* No -B parsed explicitly yet */
psscale.c:	if (Ctrl->Q.active && GMT->current.map.frame.draw) {
psscale.c:	if (!(GMT->common.R.active[RSET] && GMT->common.J.active)) {	/* When no projection specified, use fake linear projection */
psscale.c:		GMT->common.R.active[RSET] = true;
psscale.c:		GMT->common.J.active = false;
psscale.c:		gmt_plane_perspective (GMT, GMT->current.proj.z_project.view_plane, GMT->current.proj.z_level);
psscale.c:		if (gmt_M_err_pass (GMT, gmt_map_setup (GMT, GMT->common.R.wesn), ""))
psscale.c:			Ctrl->D.dim[GMT_X] = PSSCALE_L_SCALE * (Ctrl->D.horizontal ? GMT->current.proj.rect[XHI] : GMT->current.proj.rect[YHI]);
psscale.c:			if (Ctrl->Q.active && GMT->current.map.frame.draw)
psscale.c:		gmt_plane_perspective (GMT, GMT->current.proj.z_project.view_plane, GMT->current.proj.z_level);
psscale.c:		GMT->common.J.active = false;
psscale.c:		if (GMT->current.plot.panel.active) GMT->current.plot.panel.no_scaling = 1;	/* Do not rescale dimensions */
psscale.c:		if (GMT->current.plot.panel.active) GMT->current.plot.panel.no_scaling = 0;	/* Reset no_scaling flag */
psscale.c:	if (!GMT->current.map.frame.draw && (PH = gmt_get_C_hidden (P)) && PH->auto_scale) {	/* No -B given yet we have raw auto-scaling */
psscale.c:	else if (GMT->common.B.active[GMT_PRIMARY] || GMT->common.B.active[GMT_SECONDARY]) {	/* Must redo the -B parsing since projection has changed */
psscale.c:		GMT->current.map.frame.init = false;	/* To ensure we reset B parameters */
psscale.c:			if (!GMT->common.B.active[i]) continue;
psscale.c:			tmp = strdup (GMT->common.B.string[i]);
psscale.c:		GMT->current.map.frame.side[E_SIDE] = GMT->current.map.frame.side[W_SIDE] = GMT_AXIS_NONE;
psscale.c:		GMT->current.map.frame.side[S_SIDE] = GMT->current.map.frame.side[N_SIDE] = GMT_AXIS_NONE;
psscale.c:		gmt_M_double_swap (GMT->current.proj.z_project.xmin, GMT->current.proj.z_project.ymin);
psscale.c:		gmt_M_double_swap (GMT->current.proj.z_project.xmax, GMT->current.proj.z_project.ymax);
psscale.c:	GMT_Report (GMT->parent, GMT_MSG_DEBUG, "After shifts, Bar reference x = %g y = %g\n", Ctrl->D.refpoint->x, Ctrl->D.refpoint->y);
pssolar.c:	if (Ctrl->N.active && GMT->current.map.frame.init) {
pssolar.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Option -B cannot be used in combination with Option -N. -B is ignored.\n");
pssolar.c:		GMT->current.map.frame.draw = false;
pssolar.c:		if (!GMT->common.J.active) {	/* When no projection specified, use fake linear projection */
pssolar.c:			GMT->common.J.active = true;
pssolar.c:		if (!GMT->common.R.active[RSET]) {	/*  */
pssolar.c:			GMT->common.R.active[RSET] = true;
pssolar.c:	if (API->GMT->current.setting.run_mode == GMT_CLASSIC && !API->usage) {
pssolar.c:		if (gmt_M_err_pass (GMT, gmt_map_setup (GMT, GMT->common.R.wesn), "")) {
pssolar.c:		gmt_plane_perspective (GMT, GMT->current.proj.z_project.view_plane, GMT->current.proj.z_level);
pssolar.c:		if (Ctrl->N.active) gmt_map_clip_on (GMT, GMT->session.no_rgb, 1);	/* Must clip map */
pssolar.c:				PSL_beginclipping (PSL, lon, lat, n_pts, GMT->session.no_rgb, 2 + first);
psternary.c:		API->GMT->session.unit_name[API->GMT->current.setting.proj_length_unit]);
psternary.c:	gmt_consider_current_cpt (GMT->parent, &Ctrl->C.active, &(Ctrl->C.string));
psternary.c:		n_errors += gmt_M_check_condition (GMT, !GMT->common.R.active[RSET], "Syntax error: Must specify -R option\n");
psternary.c:		n_errors += gmt_M_check_condition (GMT, !GMT->common.J.active, "Syntax error: Must specify a map projection with the -J option\n");
psternary.c:	if (API->GMT->current.setting.run_mode == GMT_CLASSIC && !API->usage) {
psternary.c:	rect[XHI] = gmt_M_to_inch (GMT, &GMT->common.J.string[1]);
psternary.c:	gmt_M_memcpy (wesn_orig, GMT->common.R.wesn, 6, double);
psternary.c:	gmt_plane_perspective (GMT, GMT->current.proj.z_project.view_plane, GMT->current.proj.z_level);
psternary.c:	width = GMT->current.map.width;
psternary.c:	if (GMT->current.map.frame.paint) {	/* Paint the inside of the map with specified fill */
psternary.c:		gmt_setfill (GMT, &GMT->current.map.frame.fill, false);
psternary.c:		GMT->current.map.frame.paint = false;
psternary.c:	if (GMT->current.map.frame.side[S_SIDE]) n_sides++;	/* The bottom (a) side */
psternary.c:	if (GMT->current.map.frame.side[E_SIDE]) n_sides++;	/* The right (b) side */
psternary.c:	if (GMT->current.map.frame.side[W_SIDE]) n_sides++;	/* The left (c) side */
psternary.c:		gmt_setpen (GMT, &GMT->current.setting.map_frame_pen);
psternary.c:			if (GMT->current.map.frame.side[S_SIDE] == GMT_AXIS_NONE)
psternary.c:			else if (GMT->current.map.frame.side[W_SIDE] == GMT_AXIS_NONE)
psternary.c:		else if (GMT->current.map.frame.side[S_SIDE] & GMT_AXIS_DRAW)
psternary.c:		else if (GMT->current.map.frame.side[E_SIDE] & GMT_AXIS_DRAW)
psternary.c:		else if (GMT->current.map.frame.side[W_SIDE] & GMT_AXIS_DRAW)
psternary.c:	L_off = 3.0 * GMT->current.setting.map_label_offset;	T_off = 2.0 * GMT->current.setting.map_title_offset;
psternary.c:	if (GMT->current.map.frame.header[0]) {	/* Plot title */
psternary.c:		int form = gmt_setfont (GMT, &GMT->current.setting.font_title);
psternary.c:		PSL_plottext (PSL, tri_x[2], tri_y[2]+2.0*T_off, GMT->current.setting.font_title.size, GMT->current.map.frame.header, 0.0, PSL_BC, form);
psternary.c:		int form = gmt_setfont (GMT, &GMT->current.setting.font_label);
psternary.c:		PSL_plottext (PSL, -dx, -dy, GMT->current.setting.font_label.size, Ctrl->L.vlabel[GMT_X], 0.0, PSL_TR, form);
psternary.c:		PSL_plottext (PSL, tri_x[1]+dx, -dy, GMT->current.setting.font_label.size, Ctrl->L.vlabel[GMT_Y], 0.0, PSL_TL, form);
psternary.c:		PSL_plottext (PSL, tri_x[2], tri_y[2]+L_off, GMT->current.setting.font_label.size, Ctrl->L.vlabel[GMT_Z], 0.0, PSL_BC, form);
psternary.c:	x_origin[0] = 0.0;	y_origin[0] = 0.0;	rot[0] = 0.0;	sign[0] = +1;	side[0] = GMT->current.map.frame.side[S_SIDE]; cmode[0] = 'S';	/* S_SIDE settings */
psternary.c:	x_origin[1] = -width * 0.25;	y_origin[1] = 0.5 * height;	rot[1] = -60.0;	sign[1] = -1;	side[1] = GMT->current.map.frame.side[E_SIDE]; cmode[1] = 'N';	/* E_SIDE settings */
psternary.c:	x_origin[2] = 0.75 * width;	y_origin[2] = -0.5 * height;	rot[2] = 60.0;	sign[2] = -1;	side[2] = GMT->current.map.frame.side[W_SIDE]; cmode[2] = 'N';	/* W_SIDE settings */
psternary.c:			PSL_beginclipping (PSL, tri_x, tri_y, 4, GMT->session.no_rgb, 3);
pstext.c:	C->D.pen = C->W.pen = GMT->current.setting.map_default_pen;
pstext.c:	C->F.font = GMT->current.setting.font_annot[GMT_PRIMARY];		/* Default font */
pstext.c:	C->S.pen = GMT->current.setting.map_default_pen;
pstext.c:	gmt_M_memcpy (PSL->current.rgb[PSL_IS_FILL], GMT->session.no_rgb, 3, double);	/* Reset to -1,-1,-1 since text setting must set the color desired */
pstext.c:	gmt_M_memcpy (PSL->current.rgb[PSL_IS_STROKE], GMT->session.no_rgb, 3, double);	/* Reset to -1,-1,-1 since text setting must set the color desired */
pstext.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Cannot have non-rectangular text box if clearance (-C) is zero.\n");
pstext.c:	GMT_Report (GMT->parent, GMT_MSG_COMPAT, "Use of old style pstext input is deprecated.\n");
pstext.c:		for (i = 0; i < API->GMT->session.n_fonts; i++)
pstext.c:			GMT_Message (API, GMT_TIME_NONE, "\t%3ld\t%s\n", i, API->GMT->session.font[i].name);
pstext.c:		gmt_putfont (API->GMT, &API->GMT->current.setting.font_annot[GMT_PRIMARY]));
pstext.c:	struct GMTAPI_CTRL *API = GMT->parent;
pstext.c:								Ctrl->F.text = (p[1]) ? strdup (&p[1]) : strdup (GMT->current.setting.format_float_map);
pstext.c:					GMT->current.proj.z_level = atof(opt->arg);
pstext.c:	n_errors += gmt_M_check_condition (GMT, !Ctrl->L.active && !GMT->common.R.active[RSET], "Syntax error: Must specify -R option\n");
pstext.c:	n_errors += gmt_M_check_condition (GMT, !Ctrl->L.active && !GMT->common.J.active, "Syntax error: Must specify a map projection with the -J option\n");
pstext.c:	ix = (GMT->current.setting.io_lonlat_toggle[GMT_IN]);	iy = 1 - ix;
pstext.c:	gmt_just_to_xy (GMT, justify, &GMT->current.io.curr_rec[ix], &GMT->current.io.curr_rec[iy]);
pstext.c:	GMT->current.io.curr_rec[GMT_Z] = GMT->current.proj.z_level;
pstext.c:	ix = (GMT->current.setting.io_lonlat_toggle[GMT_IN]);	iy = 1 - ix;
pstext.c:		if (gmt_strtok (record, GMT->current.io.scan_separators, &pos, txt_x)) nscan++;	/* Returns xcol and update pos */
pstext.c:		if (gmt_strtok (record, GMT->current.io.scan_separators, &pos, txt_y)) nscan++;	/* Returns ycol and update pos */
pstext.c:		if (gmt_strtok (record, GMT->current.io.scan_separators, &pos, txt_z)) nscan++;	/* Returns zcol and update pos */
pstext.c:		if (GMT->common.t.variable && gmt_strtok (record, GMT->current.io.scan_separators, &pos, txt_t)) nscan++;	/* Returns tcol and update pos */
pstext.c:		if ((gmt_scanf (GMT, txt_z, gmt_M_type (GMT, GMT_IN, GMT_Z), &GMT->current.io.curr_rec[GMT_Z]) == GMT_IS_NAN)) {
pstext.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Record %d had bad z coordinate, skipped)\n", rec_no);
pstext.c:		if ((gmt_scanf (GMT, txt_t, GMT_IS_FLOAT, &GMT->current.io.curr_rec[3]) == GMT_IS_NAN)) {
pstext.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Record %d had bad transparency, skipped)\n", rec_no);
pstext.c:		gmt_just_to_xy (GMT, Ctrl->F.R_justify, &GMT->current.io.curr_rec[ix], &GMT->current.io.curr_rec[iy]);
pstext.c:		GMT->current.io.curr_rec[GMT_Z] = GMT->current.proj.z_level;
pstext.c:		if (gmt_strtok (record, GMT->current.io.scan_separators, &pos, txt_x)) nscan++;	/* Returns xcol and update pos */
pstext.c:		if (gmt_strtok (record, GMT->current.io.scan_separators, &pos, txt_y)) nscan++;	/* Returns ycol and update pos */
pstext.c:		if (GMT->common.t.variable && gmt_strtok (record, GMT->current.io.scan_separators, &pos, txt_t)) nscan++;	/* Returns tcol and update pos */
pstext.c:		GMT->current.io.curr_rec[GMT_Z] = GMT->current.proj.z_level;
pstext.c:		if ((gmt_scanf (GMT, txt_t, GMT_IS_FLOAT, &GMT->current.io.curr_rec[2]) == GMT_IS_NAN)) {
pstext.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Record %d had bad transparency, skipped)\n", rec_no);
pstext.c:		if (gmt_scanf (GMT, txt_x, gmt_M_type (GMT, GMT_IN, GMT_X), &GMT->current.io.curr_rec[ix]) == GMT_IS_NAN) {
pstext.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Record %d had bad x coordinate, skipped)\n", rec_no);
pstext.c:		if (gmt_scanf (GMT, txt_y, gmt_M_type (GMT, GMT_IN, GMT_Y), &GMT->current.io.curr_rec[iy]) == GMT_IS_NAN) {
pstext.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Record %d had bad y coordinate, skipped)\n", rec_no);
pstext.c:	if (API->GMT->current.setting.run_mode == GMT_CLASSIC && !API->usage) {
pstext.c:			GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Trailing text did not have %d words (only %d found) - no label selected.\n", Ctrl->F.w_col, col);
pstext.c:	n_expected_cols = 2 + Ctrl->Z.active + Ctrl->F.nread + GMT->common.t.variable;	/* Normal number of columns to read, plus any text. This includes x,y */
pstext.c:	if (gmt_M_err_pass (GMT, gmt_map_setup (GMT, GMT->common.R.wesn), "")) Return (GMT_PROJECTION_ERROR);
pstext.c:	if (Ctrl->G.mode) GMT->current.ps.nclip = (Ctrl->N.active) ? +1 : +2;	/* Signal that this program initiates clipping that will outlive this process */
pstext.c:	gmt_plane_perspective (GMT, GMT->current.proj.z_project.view_plane, GMT->current.proj.z_level);
pstext.c:		gmt_BB_clip_on (GMT, GMT->session.no_rgb, 3);
pstext.c:	old_is_world = GMT->current.map.is_world;
pstext.c:	GMT->current.map.is_world = true;
pstext.c:		ix = (GMT->current.setting.io_lonlat_toggle[GMT_IN]);	iy = 1 - ix;
pstext.c:		plot_x = GMT->current.io.curr_rec[ix]; plot_y = GMT->current.io.curr_rec[iy];
pstext.c:		gmt_plane_perspective (GMT, GMT->current.proj.z_project.view_plane, 0.0);
pstext.c:	in = GMT->current.io.curr_rec;	/* Since text gets parsed and stored in this record */
pstext.c:		GMT->current.io.scan_separators = GMT_TOKEN_SEPARATORS_PSTEXT;		/* Characters that may separate columns in ascii records */
pstext.c:		if (GMT->common.t.variable) ncol++;	/* Will have transparency as well */
pstext.c:		GMT->current.io.curr_rec[GMT_Z] = GMT->current.proj.z_level;	/* In case there are 3-D going on */
pstext.c:				line = GMT->current.io.segment_header;
pstext.c:						nscan += gmt_strtok (buffer, GMT->current.io.scan_separators, &pos, text);
pstext.c:					if (abs (GMT->current.map.this_x_status) > 1 || abs (GMT->current.map.this_y_status) > 1) continue;
pstext.c:								nscan += gmt_strtok (line, GMT->current.io.scan_separators, &pos, text);
pstext.c:							nscan += gmt_strtok (line, GMT->current.io.scan_separators, &pos, text);
pstext.c:							GMT->current.io.curr_rec[GMT_Z] = GMT->current.proj.z_level;
pstext.c:							nscan += gmt_strtok (line, GMT->current.io.scan_separators, &pos, text);
pstext.c:							nscan += gmt_strtok (line, GMT->current.io.scan_separators, &pos, text);
pstext.c:				if (GMT->current.io.segment_header[0] == 0)
pstext.c:				strcpy (label, GMT->current.io.segment_header);
pstext.c:				if (!gmt_parse_segment_item (GMT, GMT->current.io.segment_header, "-L", label))
pstext.c:			nscan += gmt_load_aspatial_string (GMT, GMT->current.io.OGR, text_col, in_txt);	/* Substitute OGR attribute if used */
pstext.c:				if (abs (GMT->current.map.this_x_status) > 1 || abs (GMT->current.map.this_y_status) > 1) continue;
pstext.c:			if (GMT->common.t.variable)	/* Update the transparency for current symbol (or -t was given) */
pstext.c:			gmt_plane_perspective (GMT, GMT->current.proj.z_project.view_plane, in[GMT_Z]);
pstext.c:	if (GMT->common.t.variable)	/* Reset the transparency */
pstext.c:	GMT->current.map.is_world = old_is_world;
pstext.c:	GMT->current.io.scan_separators = GMT_TOKEN_SEPARATORS;		/* Reset */
pswiggle.c: * Brief synopsis: pswiggle reads x,y,z from GMT->session.std[GMT_IN] and plots a wiggleplot using the
pswiggle.c:	C->T.pen = C->W.pen = GMT->current.setting.map_default_pen;
pswiggle.c:	gmt_init_fill (GMT, &C->G.fill[0], GMT->current.setting.map_frame_pen.rgb[0], GMT->current.setting.map_frame_pen.rgb[1], GMT->current.setting.map_frame_pen.rgb[2]);
pswiggle.c:		if (!GMT->current.plot.n_alloc) gmt_get_plot_array (GMT);
pswiggle.c:		GMT->current.plot.x[0] = x[0];
pswiggle.c:		GMT->current.plot.y[0] = y[0];
pswiggle.c:			GMT->current.plot.x[n] = x[i] + x_inc;
pswiggle.c:			GMT->current.plot.y[n] = y[i] + y_inc;
pswiggle.c:			if (n == GMT->current.plot.n_alloc) gmt_get_plot_array (GMT);
pswiggle.c:		GMT->current.plot.x[n] = x[np-1];
pswiggle.c:		GMT->current.plot.y[n] = y[np-1];
pswiggle.c:				if (n == GMT->current.plot.n_alloc) gmt_get_plot_array (GMT);
pswiggle.c:				GMT->current.plot.x[n] = x[i];
pswiggle.c:				GMT->current.plot.y[n] = y[i];
pswiggle.c:		PSL_plotpolygon (PSL, GMT->current.plot.x, GMT->current.plot.y, (int)n);
pswiggle.c:		PSL_plotline (PSL, &GMT->current.plot.x[1], &GMT->current.plot.y[1], (int)np, PSL_MOVE|PSL_STROKE);
pswiggle.c:	gmt_setpen (GMT, &GMT->current.setting.map_tick_pen[GMT_PRIMARY]);
pswiggle.c:	gmt_xyz_to_xy (GMT, x0 + GMT->current.setting.map_scale_height, y0 - dy, 0.0, &xx[0], &yy[0]);
pswiggle.c:	gmt_xyz_to_xy (GMT, x0 + GMT->current.setting.map_scale_height, y0 + dy, 0.0, &xx[3], &yy[3]);
pswiggle.c:	off = ((GMT->current.setting.map_scale_height > 0.0) ? GMT->current.setting.map_tick_length[0] : 0.0) + GMT->current.setting.map_annot_offset[GMT_PRIMARY];
pswiggle.c:	form = gmt_setfont (GMT, &GMT->current.setting.font_annot[GMT_PRIMARY]);
pswiggle.c:	PSL_plottext (PSL, x0 + off, y0, GMT->current.setting.font_annot[GMT_PRIMARY].size, txt, 0.0, PSL_ML, form);
pswiggle.c:		API->GMT->session.unit_name[API->GMT->current.setting.proj_length_unit]);
pswiggle.c:	struct GMTAPI_CTRL *API = GMT->parent;
pswiggle.c:					GMT->common.g.active = true;
pswiggle.c:	n_errors += gmt_M_check_condition (GMT, !GMT->common.R.active[RSET], "Syntax error: Must specify -R option\n");
pswiggle.c:	n_errors += gmt_M_check_condition (GMT, !GMT->common.J.active, "Syntax error: Must specify a map projection with the -J option\n");
pswiggle.c:	if (API->GMT->current.setting.run_mode == GMT_CLASSIC && !API->usage) {
pswiggle.c:	if (gmt_M_err_pass (GMT, gmt_map_setup (GMT, GMT->common.R.wesn), "")) Return (GMT_PROJECTION_ERROR);
pswiggle.c:	gmt_plane_perspective (GMT, GMT->current.proj.z_project.view_plane, GMT->current.proj.z_level);
pswiggle.c:			Ctrl->Z.scale *= GMT->session.u2u[GMT_CM][GMT_INCH];
pswiggle.c:			Ctrl->Z.scale *= GMT->session.u2u[GMT_INCH][GMT_INCH];
pswiggle.c:			Ctrl->Z.scale *= GMT->session.u2u[GMT_PT][GMT_INCH];
pswiggle.c:			Ctrl->Z.scale *= GMT->session.u2u[GMT->current.setting.proj_length_unit][GMT_INCH];
pswiggle.c:	gmt_map_clip_on (GMT, GMT->session.no_rgb, 3);
psxy.c:	C->E.pen = C->W.pen = GMT->current.setting.map_default_pen;
psxy.c:	C->E.size = EBAR_CAP_WIDTH  * GMT->session.u2u[GMT_PT][GMT_INCH];	/* 7p */
psxy.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "X error bar exceeded domain near line %d. Reset to x_min\n", line);
psxy.c:		x_1 = GMT->current.proj.rect[XLO];
psxy.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "X error bar exceeded domain near line %d. Reset to x_max\n", line);
psxy.c:		x_2 = GMT->current.proj.rect[XHI];
psxy.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Y error bar exceeded domain near line %d. Reset to y_min\n", line);
psxy.c:		y_1 = GMT->current.proj.rect[YLO];
psxy.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Y error bar exceeded domain near line %d. Reset to y_max\n", line);
psxy.c:		y_2 = GMT->current.proj.rect[YHI];
psxy.c:			GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "X %d %% hinge exceeded domain near line %d\n", q[i], line);
psxy.c:			xx[i] = (i < 2) ? GMT->current.proj.rect[XLO] : GMT->current.proj.rect[XHI];
psxy.c:			GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Y %d %% hinge exceeded domain near line %d\n", q[i], line);
psxy.c:			yy[i] = (i < 2) ? GMT->current.proj.rect[YLO] : GMT->current.proj.rect[YHI];
psxy.c:	if (GMT_Open_VirtualFile (GMT->parent, GMT_IS_DATASET, GMT_IS_POINT, GMT_IN, D, string) != GMT_NOERROR)
psxy.c:		return (GMT->parent->error);
psxy.c:	if (GMT->parent->tmp_dir)	/* Make unique file in temp dir */
psxy.c:		sprintf (tmp_file, "%s/GMT_symbol%d.def", GMT->parent->tmp_dir, (int)getpid());
psxy.c:	GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Number of decorated line symbols: %d\n", (int)D->n_records);
psxy.c:	GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Temporary decorated line symbol .def file created: %s\n", tmp_file);
psxy.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Unable to create symbol file needed for decorated lines: %s\n", tmp_file);
psxy.c:	sprintf (buffer, "-R%g/%g/%g/%g -Jx1i -O -K -SK%s %s --GMT_HISTORY=false", GMT->current.proj.rect[XLO], GMT->current.proj.rect[XHI],
psxy.c:		GMT->current.proj.rect[YLO], GMT->current.proj.rect[YHI], tmp_file, string);
psxy.c:	GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Calling psxy with args %s\n", buffer);
psxy.c:	if (GMT_Call_Module (GMT->parent, "psxy", GMT_MODULE_CMD, buffer) != GMT_NOERROR)	/* Plot all the symbols */
psxy.c:		return (GMT->parent->error);
psxy.c:	if (GMT_Close_VirtualFile (GMT->parent, string) != GMT_NOERROR)
psxy.c:		return (GMT->parent->error);
psxy.c:		bool was = GMT->current.setting.io_header[GMT_OUT];	/* Save current setting */
psxy.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Temporary symbol file for decorated lines saved: %s\n", tmp_file);
psxy.c:		if (GMT->parent->tmp_dir)	/* Make unique file in tmp dir */
psxy.c:			sprintf (tmp_file2, "%s/GMT_symbol%d.txt", GMT->parent->tmp_dir, (int)getpid());
psxy.c:		GMT_Set_Comment (GMT->parent, GMT_IS_DATASET, GMT_COMMENT_IS_TEXT | GMT_COMMENT_IS_COMMAND, buffer, D);
psxy.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Temporary data file for decorated lines saved: %s\n", tmp_file2);
psxy.c:		if (GMT_Write_Data (GMT->parent, GMT_IS_DATASET, GMT_IS_FILE, GMT_IS_POINT, GMT_IO_RESET, NULL, tmp_file2, D) != GMT_NOERROR) {
psxy.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Unable to write file: %s\n", tmp_file2);
psxy.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Failed to delete file: %s\n", tmp_file);
psxy.c:	PSL_command (GMT->PSL, "V\n");
psxy.c:	GMT->PSL->current.linewidth = -1.0;	/* Will be changed by next PSL_setlinewidth */
psxy.c:		PSL_comment (GMT->PSL, "Add vector head to %s of line\n", end[k]);
psxy.c:		P->end[k].V->v.v_width = (float)(P->end[k].V->v.pen.width * GMT->session.u2u[GMT_PT][GMT_INCH]);	/* Set symbol pen width */
psxy.c:			PSL_defpen (GMT->PSL, "PSL_vecheadpen", P->end[k].V->v.pen.width, P->end[k].V->v.pen.style, P->end[k].V->v.pen.offset, P->end[k].V->v.pen.rgb);
psxy.c:			PSL_defpen (GMT->PSL, "PSL_vecheadpen", 0.5 * P->width, P->style, P->offset, P->rgb);
psxy.c:		PSL_plotsymbol (GMT->PSL, x[current[k]], y[current[k]], dim, PSL_VECTOR);
psxy.c:	GMT->PSL->current.linewidth = -1.0;	/* Will be changed by next PSL_setlinewidth */
psxy.c:	PSL_command (GMT->PSL, "U\n");
psxy.c:	if (API->GMT->current.setting.run_mode == GMT_CLASSIC)	/* -T has no purpose in modern mode */
psxy.c:		API->GMT->session.unit_name[API->GMT->current.setting.proj_length_unit]);
psxy.c:		API->GMT->session.unit_name[API->GMT->current.setting.proj_length_unit]);
psxy.c:		API->GMT->session.unit_name[API->GMT->current.setting.proj_length_unit]);
psxy.c:	if (API->GMT->current.setting.run_mode == GMT_CLASSIC)	/* -T has no purpose in modern mode */
psxy.c:	struct GMTAPI_CTRL *API = GMT->parent;
psxy.c:	n_errors += gmt_M_check_condition (GMT, !GMT->common.R.active[RSET], "Syntax error: Must specify -R option\n");
psxy.c:	n_errors += gmt_M_check_condition (GMT, !GMT->common.J.active, "Syntax error: Must specify a map projection with the -J option\n");
psxy.c:	n_errors += gmt_M_check_condition (GMT, GMT->common.b.active[GMT_IN] && S->symbol == GMT_SYMBOL_NOT_SET, "Syntax error: Binary input data cannot have symbol information\n");
psxy.c:	if (API->GMT->current.setting.run_mode == GMT_CLASSIC && !API->usage) {
psxy.c:	S.base = GMT->session.d_NaN;
psxy.c:	S.font = GMT->current.setting.font_annot[GMT_PRIMARY];
psxy.c:	S.u = GMT->current.setting.proj_length_unit;
psxy.c:	pos2x = ex1 + GMT->current.setting.io_lonlat_toggle[GMT_IN];	/* Column with a 2nd longitude (for VECTORS with two sets of coordinates) */
psxy.c:	pos2y = ex2 - GMT->current.setting.io_lonlat_toggle[GMT_IN];	/* Column with a 2nd latitude (for VECTORS with two sets of coordinates) */
psxy.c:		if (def_err_xy && GMT->current.setting.io_lonlat_toggle[GMT_IN]) {	/* With -:, -E should become -Eyx */
psxy.c:	if (GMT->common.t.variable) {
psxy.c:	if (gmt_M_err_pass (GMT, gmt_map_setup (GMT, GMT->common.R.wesn), ""))
psxy.c:		save_u = GMT->current.setting.proj_length_unit;
psxy.c:		GMT->current.setting.proj_length_unit = S.u;
psxy.c:	if (S.G.delay) GMT->current.ps.nclip = +2;	/* Signal that this program initiates clipping that will outlive this process */
psxy.c:	gmt_plane_perspective (GMT, GMT->current.proj.z_project.view_plane, GMT->current.proj.z_level);
psxy.c:	if (Ctrl->A.active) Ctrl->A.step = Ctrl->A.step / GMT->current.proj.scale[GMT_X] / GMT->current.proj.M_PR_DEG;
psxy.c:	if ((gmt_M_is_conical(GMT) && gmt_M_360_range (GMT->common.R.wesn[XLO], GMT->common.R.wesn[XHI]))) {	/* Must turn clipping on for 360-range conical */
psxy.c:	if (clip_set) gmt_map_clip_on (GMT, GMT->session.no_rgb, 3);
psxy.c:	if (S.symbol == GMT_SYMBOL_BARX && !S.base_set) S.base = GMT->common.R.wesn[XLO];	/* Default to west level for horizontal log10 bars */
psxy.c:	if (S.symbol == GMT_SYMBOL_BARY && !S.base_set) S.base = GMT->common.R.wesn[YLO];	/* Default to south level for vertical log10 bars */
psxy.c:	old_is_world = GMT->current.map.is_world;
psxy.c:	in = GMT->current.io.curr_rec;
psxy.c:			if (GMT->common.l.active && !get_rgb && (!S.read_size || GMT->common.l.item.size > 0.0)) {
psxy.c:				gmt_add_legend_item (API, &S, Ctrl->G.active, &(Ctrl->G.fill), Ctrl->W.active, &(Ctrl->W.pen), &(GMT->common.l.item));
psxy.c:		if ((Ctrl->N.mode == PSXY_CLIP_REPEAT || Ctrl->N.mode == PSXY_NO_CLIP_REPEAT) && gmt_M_360_range (GMT->common.R.wesn[XLO], GMT->common.R.wesn[XHI]) && gmt_M_is_geographic (GMT, GMT_IN)) {
psxy.c:		PSL_command (GMT->PSL, "V\n");	/* Place all symbols under a gsave/grestore clause */
psxy.c:		if (S.read_size && GMT->current.io.col[GMT_IN][ex1].convert) {	/* Doing math on the size column, must delay unit conversion unless inch */
psxy.c:			else if (GMT->current.setting.proj_length_unit != GMT_INCH) {	/* Gave no unit but default unit is not inch so we must scale */
psxy.c:				S.u = GMT->current.setting.proj_length_unit;
psxy.c:					PSL_comment (PSL, "Segment header: %s\n", GMT->current.io.segment_header);
psxy.c:					(void)gmt_parse_segment_header (GMT, GMT->current.io.segment_header, P, &fill_active, &current_fill, &default_fill, &outline_active, &current_pen, &default_pen, default_outline, NULL);
psxy.c:					if (gmt_parse_segment_item (GMT, GMT->current.io.segment_header, "-S", s_args)) {	/* Found -Sargs */
psxy.c:				if (S.n_nondim && GMT->current.setting.proj_length_unit != GMT_INCH) {	/* Since these are not dimensions but angles or other quantities */
psxy.c:					for (j = 0; j < S.n_nondim; j++) in[S.nondim_col[j]+rgb_from_z] *= GMT->session.u2u[GMT_INCH][GMT->current.setting.proj_length_unit];
psxy.c:						in[pos2x] *= GMT->session.u2u[GMT_INCH][GMT->current.setting.proj_length_unit];
psxy.c:						in[pos2y] *= GMT->session.u2u[GMT_INCH][GMT->current.setting.proj_length_unit];
psxy.c:				if (abs (GMT->current.map.this_x_status) > 1 || abs (GMT->current.map.this_y_status) > 1) {
psxy.c:			if (GMT->common.t.variable)	/* Update the transparency for current symbol (or -t was given) */
psxy.c:				if (Ctrl->E.mode & 1) gmt_M_rgb_copy (current_fill.rgb, GMT->session.no_rgb);
psxy.c:					gmt_M_rgb_copy (current_fill.rgb, GMT->session.no_rgb);
psxy.c:				if (delayed_unit_scaling) S.size_x *= GMT->session.u2u[S.u][GMT_INCH];
psxy.c:				if (plot_x < GMT->current.map.half_width)     /* Might reappear at right edge */
psxy.c:						if (!Ctrl->N.active) in[GMT_X] = MAX (GMT->common.R.wesn[XLO], MIN (in[GMT_X], GMT->common.R.wesn[XHI]));
psxy.c:							gmt_geo_to_xy (GMT, S.base, GMT->common.R.wesn[YLO], &x_1, &y_1);	/* Zero x level for horizontal bars */
psxy.c:						if (!Ctrl->N.active) in[GMT_Y] = MAX (GMT->common.R.wesn[YLO], MIN (in[GMT_Y], GMT->common.R.wesn[YHI]));
psxy.c:							gmt_geo_to_xy (GMT, GMT->common.R.wesn[XLO], S.base, &x_1, &y_1);	/* Zero y level for vertical bars */
psxy.c:							dim[1] = in[ex2] * GMT->current.proj.scale[GMT_X];
psxy.c:							dim[2] = in[ex3] * GMT->current.proj.scale[GMT_Y];
psxy.c:								PSL_setfill (PSL, GMT->session.no_rgb, outline_active);
psxy.c:								PSL_setfill (PSL, GMT->session.no_rgb, outline_active);
psxy.c:							PSL_setfill (PSL, GMT->session.no_rgb, outline_active);
psxy.c:								if (x_2 < GMT->current.map.half_width)     /* Might reappear at right edge */
psxy.c:							S.v.v_width = (float)(current_pen.width * GMT->session.u2u[GMT_PT][GMT_INCH]);
psxy.c:								v4_rgb = GMT->session.no_rgb;
psxy.c:							dim[5] = GMT->current.setting.map_vector_shape;
psxy.c:							S.v.v_width = (float)(S.v.pen.width * GMT->session.u2u[GMT_PT][GMT_INCH]);
psxy.c:							S.v.v_width = (float)(current_pen.width * GMT->session.u2u[GMT_PT][GMT_INCH]);
psxy.c:						S.v.v_width = (float)(current_pen.width * GMT->session.u2u[GMT_PT][GMT_INCH]);
psxy.c:		if (GMT->common.t.variable)	/* Reset the transparency */
psxy.c:		PSL_command (GMT->PSL, "U\n");
psxy.c:		gmt_map_clip_on (GMT, GMT->session.no_rgb, 3);
psxy.c:			if ((Decorate = GMT_Create_Data (GMT->parent, GMT_IS_DATASET, GMT_IS_POINT, GMT_WITH_STRINGS, dim, NULL, NULL, 0, 0, NULL)) == NULL) Return (API->error);
psxy.c:		if (GMT->current.io.OGR && (GMT->current.io.OGR->geometry == GMT_IS_POLYGON || GMT->current.io.OGR->geometry == GMT_IS_MULTIPOLYGON)) polygon = true;
psxy.c:		if (GMT->common.l.active && S.symbol == GMT_SYMBOL_LINE) {
psxy.c:				gmt_add_legend_item (API, &S, Ctrl->G.active, &(Ctrl->G.fill), Ctrl->W.active, &(Ctrl->W.pen), &(GMT->common.l.item));
psxy.c:				gmt_add_legend_item (API, &S, false, NULL, Ctrl->W.active, &(Ctrl->W.pen), &(GMT->common.l.item));
psxy.c:				duplicate = (DH->alloc_mode == GMT_ALLOC_EXTERNALLY && ((polygon && gmt_polygon_is_open (GMT, L->data[GMT_X], L->data[GMT_Y], L->n_rows)) || GMT->current.map.path_mode == GMT_RESAMPLE_PATH));
psxy.c:						gmt_M_rgb_copy (current_fill.rgb, GMT->session.no_rgb);
psxy.c:				if (GMT->current.map.path_mode == GMT_RESAMPLE_PATH && !resampled) {	/* Resample if spacing is too coarse */
psxy.c:					if ((GMT->current.plot.n = gmt_geo_to_xy_line (GMT, L->data[GMT_X], L->data[GMT_Y], L->n_rows)) == 0) continue;
psxy.c:					for (k0 = 0; !split && k0 < GMT->current.plot.n; k0++) if (GMT->current.plot.pen[k0] & PSL_MOVE) split = true;
psxy.c:						while (k0 < GMT->current.plot.n) {	/* While more sections... */
psxy.c:							while (k1 < GMT->current.plot.n && GMT->current.plot.pen[k1] == PSL_DRAW) k1++;	/* Find next section anchor */
psxy.c:							/* k1 is now pointing to next move (anchor) point or it is GMT->current.plot.n */
psxy.c:							gmt_M_memcpy (xxx, &GMT->current.plot.x[k0], n_section, double);
psxy.c:							gmt_M_memcpy (yyy, &GMT->current.plot.y[k0], n_section, double);
psxy.c:						closed = !(gmt_polygon_is_open (GMT, GMT->current.plot.x, GMT->current.plot.y, GMT->current.plot.n));
psxy.c:						gmt_hold_contour (GMT, &GMT->current.plot.x, &GMT->current.plot.y, GMT->current.plot.n, 0.0, "N/A", 'A', S.G.label_angle, closed, false, &S.G);
psxy.c:						GMT->current.plot.n_alloc = GMT->current.plot.n;	/* Since gmt_hold_contour reallocates to fit the array */
psxy.c:					if ((GMT->current.plot.n = gmt_geo_to_xy_line (GMT, L->data[GMT_X], L->data[GMT_Y], L->n_rows)) == 0) continue;
psxy.c:					gmt_plot_line (GMT, GMT->current.plot.x, GMT->current.plot.y, GMT->current.plot.pen, GMT->current.plot.n, PSL_LINEAR);
psxy.c:					for (k0 = 1; !split && k0 < GMT->current.plot.n; k0++) if (GMT->current.plot.pen[k0] & PSL_MOVE) split = true;
psxy.c:						while (k0 < GMT->current.plot.n) {	/* While more sections... */
psxy.c:							while (k1 < GMT->current.plot.n && GMT->current.plot.pen[k1] == PSL_DRAW) k1++;	/* Find next section anchor */
psxy.c:							/* k1 is now pointing to next move (anchor) point or it is GMT->current.plot.n */
psxy.c:							gmt_M_memcpy (xxx, &GMT->current.plot.x[k0], n_section, double);
psxy.c:							gmt_M_memcpy (yyy, &GMT->current.plot.y[k0], n_section, double);
psxy.c:						gmt_decorated_line (GMT, &GMT->current.plot.x, &GMT->current.plot.y, GMT->current.plot.n, &S.D, Decorate, seg_out);
psxy.c:							gmt_M_memcpy (GMT->hidden.mem_coord[GMT_X], L->data[GMT_X], L->n_rows, double);
psxy.c:								GMT->hidden.mem_coord[GMT_Y][k] = L->data[GMT_Y][k] - fabs (L->data[2][k]);
psxy.c:								GMT->hidden.mem_coord[GMT_X][n] = L->data[GMT_X][k-1];
psxy.c:								GMT->hidden.mem_coord[GMT_Y][n] = L->data[GMT_Y][k-1] + fabs (L->data[col][k-1]);
psxy.c:							GMT->hidden.mem_coord[GMT_X][end-1] = GMT->hidden.mem_coord[GMT_X][0];
psxy.c:							GMT->hidden.mem_coord[GMT_Y][end-1] = GMT->hidden.mem_coord[GMT_Y][0];
psxy.c:							gmt_M_memcpy (GMT->hidden.mem_coord[GMT_X], L->data[GMT_X], L->n_rows, double);
psxy.c:								GMT->hidden.mem_coord[GMT_Y][k] = L->data[2][k];
psxy.c:								GMT->hidden.mem_coord[GMT_X][n] = L->data[GMT_X][k-1];
psxy.c:								GMT->hidden.mem_coord[GMT_Y][n] = L->data[3][k-1];
psxy.c:							GMT->hidden.mem_coord[GMT_X][end-1] = GMT->hidden.mem_coord[GMT_X][0];
psxy.c:							GMT->hidden.mem_coord[GMT_Y][end-1] = GMT->hidden.mem_coord[GMT_Y][0];
psxy.c:							gmt_M_memcpy (GMT->hidden.mem_coord[GMT_X], L->data[GMT_X], end, double);
psxy.c:							gmt_M_memcpy (GMT->hidden.mem_coord[GMT_Y], L->data[GMT_Y], end, double);
psxy.c:									value = (Ctrl->L.mode == ZLO) ? Ctrl->L.value : GMT->common.R.wesn[XLO+off];
psxy.c:									GMT->hidden.mem_coord[GMT_X][end] = GMT->hidden.mem_coord[GMT_X][end+1] = value;
psxy.c:									GMT->hidden.mem_coord[GMT_Y][end] = L->data[GMT_Y][end-1];
psxy.c:									GMT->hidden.mem_coord[GMT_Y][end+1] = L->data[GMT_Y][0];
psxy.c:									value = (Ctrl->L.mode == ZHI) ? Ctrl->L.value : GMT->common.R.wesn[YLO+off];
psxy.c:									GMT->hidden.mem_coord[GMT_Y][end] = GMT->hidden.mem_coord[GMT_Y][end+1] = value;
psxy.c:									GMT->hidden.mem_coord[GMT_X][end] = L->data[GMT_X][end-1];
psxy.c:									GMT->hidden.mem_coord[GMT_X][end+1] = L->data[GMT_X][0];
psxy.c:							GMT->hidden.mem_coord[GMT_X][end+2] = L->data[GMT_X][0];
psxy.c:							GMT->hidden.mem_coord[GMT_Y][end+2] = L->data[GMT_Y][0];
psxy.c:						if ((GMT->current.plot.n = gmt_geo_to_xy_line (GMT, GMT->hidden.mem_coord[GMT_X], GMT->hidden.mem_coord[GMT_Y], end)) == 0) continue;
psxy.c:						PSL_plotpolygon (PSL, GMT->current.plot.x, GMT->current.plot.y, (int)GMT->current.plot.n);
psxy.c:						if ((GMT->current.plot.n = gmt_geo_to_xy_line (GMT, L->data[GMT_X], L->data[GMT_Y], L->n_rows)) == 0) continue;
psxy.c:						gmt_plot_line (GMT, GMT->current.plot.x, GMT->current.plot.y, GMT->current.plot.pen, GMT->current.plot.n, current_pen.mode);
psxy.c:						plot_end_vectors (GMT, GMT->current.plot.x, GMT->current.plot.y, GMT->current.plot.n, &current_pen);	/* Maybe add vector heads */
psxy.c:					gmt_draw_front (GMT, GMT->current.plot.x, GMT->current.plot.y, GMT->current.plot.n, &S.f);
psxy.c:	if (S.u_set) GMT->current.setting.proj_length_unit = save_u;	/* Reset unit */
psxy.c:	GMT->current.map.is_world = old_is_world;
psxy_new.c:	C->E.pen = C->W.pen = GMT->current.setting.map_default_pen;
psxy_new.c:	C->E.size = EBAR_CAP_WIDTH  * GMT->session.u2u[GMT_PT][GMT_INCH];	/* 7p */
psxy_new.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "X error bar exceeded domain near line %d. Reset to x_min\n", line);
psxy_new.c:		x_1 = GMT->current.proj.rect[XLO];
psxy_new.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "X error bar exceeded domain near line %d. Reset to x_max\n", line);
psxy_new.c:		x_2 = GMT->current.proj.rect[XHI];
psxy_new.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Y error bar exceeded domain near line %d. Reset to y_min\n", line);
psxy_new.c:		y_1 = GMT->current.proj.rect[YLO];
psxy_new.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Y error bar exceeded domain near line %d. Reset to y_max\n", line);
psxy_new.c:		y_2 = GMT->current.proj.rect[YHI];
psxy_new.c:			GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "X %d %% hinge exceeded domain near line %d\n", q[i], line);
psxy_new.c:			xx[i] = (i < 2) ? GMT->current.proj.rect[XLO] : GMT->current.proj.rect[XHI];
psxy_new.c:			GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Y %d %% hinge exceeded domain near line %d\n", q[i], line);
psxy_new.c:			yy[i] = (i < 2) ? GMT->current.proj.rect[YLO] : GMT->current.proj.rect[YHI];
psxy_new.c:	if (GMT_Open_VirtualFile (GMT->parent, GMT_IS_DATASET, GMT_IS_POINT, GMT_IN, D, string) != GMT_NOERROR)
psxy_new.c:		return (GMT->parent->error);
psxy_new.c:	if (GMT->parent->tmp_dir)	/* Make unique file in temp dir */
psxy_new.c:		sprintf (tmp_file, "%s/GMT_symbol%d.def", GMT->parent->tmp_dir, (int)getpid());
psxy_new.c:	GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Number of decorated line symbols: %d\n", (int)D->n_records);
psxy_new.c:	GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Temporary decorated line symbol .def file created: %s\n", tmp_file);
psxy_new.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Unable to create symbol file needed for decorated lines: %s\n", tmp_file);
psxy_new.c:	sprintf (buffer, "-R%g/%g/%g/%g -Jx1i -O -K -SK%s %s --GMT_HISTORY=false", GMT->current.proj.rect[XLO], GMT->current.proj.rect[XHI],
psxy_new.c:		GMT->current.proj.rect[YLO], GMT->current.proj.rect[YHI], tmp_file, string);
psxy_new.c:	GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Calling psxy with args %s\n", buffer);
psxy_new.c:	if (GMT_Call_Module (GMT->parent, "psxy", GMT_MODULE_CMD, buffer) != GMT_NOERROR)	/* Plot all the symbols */
psxy_new.c:		return (GMT->parent->error);
psxy_new.c:	if (GMT_Close_VirtualFile (GMT->parent, string) != GMT_NOERROR)
psxy_new.c:		return (GMT->parent->error);
psxy_new.c:		bool was = GMT->current.setting.io_header[GMT_OUT];	/* Save current setting */
psxy_new.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Temporary symbol file for decorated lines saved: %s\n", tmp_file);
psxy_new.c:		if (GMT->parent->tmp_dir)	/* Make unique file in tmp dir */
psxy_new.c:			sprintf (tmp_file2, "%s/GMT_symbol%d.txt", GMT->parent->tmp_dir, (int)getpid());
psxy_new.c:		GMT_Set_Comment (GMT->parent, GMT_IS_DATASET, GMT_COMMENT_IS_TEXT | GMT_COMMENT_IS_COMMAND, buffer, D);
psxy_new.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Temporary data file for decorated lines saved: %s\n", tmp_file2);
psxy_new.c:		if (GMT_Write_Data (GMT->parent, GMT_IS_DATASET, GMT_IS_FILE, GMT_IS_POINT, GMT_IO_RESET, NULL, tmp_file2, D) != GMT_NOERROR) {
psxy_new.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Unable to write file: %s\n", tmp_file2);
psxy_new.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Failed to delete file: %s\n", tmp_file);
psxy_new.c:	PSL_command (GMT->PSL, "V\n");
psxy_new.c:	GMT->PSL->current.linewidth = -1.0;	/* Will be changed by next PSL_setlinewidth */
psxy_new.c:		PSL_comment (GMT->PSL, "Add vector head to %s of line\n", end[k]);
psxy_new.c:		P->end[k].V->v.v_width = (float)(P->end[k].V->v.pen.width * GMT->session.u2u[GMT_PT][GMT_INCH]);	/* Set symbol pen width */
psxy_new.c:		PSL_plotsymbol (GMT->PSL, x[current[k]], y[current[k]], dim, PSL_VECTOR);
psxy_new.c:	GMT->PSL->current.linewidth = -1.0;	/* Will be changed by next PSL_setlinewidth */
psxy_new.c:	PSL_command (GMT->PSL, "U\n");
psxy_new.c:	if (API->GMT->current.setting.run_mode == GMT_CLASSIC)	/* -T has no purpose in modern mode */
psxy_new.c:		API->GMT->session.unit_name[API->GMT->current.setting.proj_length_unit]);
psxy_new.c:		API->GMT->session.unit_name[API->GMT->current.setting.proj_length_unit]);
psxy_new.c:	if (API->GMT->current.setting.run_mode == GMT_CLASSIC)	/* -T has no purpose in modern mode */
psxy_new.c:	struct GMTAPI_CTRL *API = GMT->parent;
psxy_new.c:	n_errors += gmt_M_check_condition (GMT, !GMT->common.R.active[RSET], "Syntax error: Must specify -R option\n");
psxy_new.c:	n_errors += gmt_M_check_condition (GMT, !GMT->common.J.active, "Syntax error: Must specify a map projection with the -J option\n");
psxy_new.c:	n_errors += gmt_M_check_condition (GMT, GMT->common.b.active[GMT_IN] && S->symbol == GMT_SYMBOL_NOT_SET, "Syntax error: Binary input data cannot have symbol information\n");
psxy_new.c:	if (API->GMT->current.setting.run_mode == GMT_CLASSIC && !API->usage) {
psxy_new.c:	if (API->GMT->current.setting.run_mode == GMT_CLASSIC) {	/* Classic requires options, while modern does not */
psxy_new.c:	S.base = GMT->session.d_NaN;
psxy_new.c:	S.font = GMT->current.setting.font_annot[GMT_PRIMARY];
psxy_new.c:	S.u = GMT->current.setting.proj_length_unit;
psxy_new.c:	pos2x = ex1 + GMT->current.setting.io_lonlat_toggle[GMT_IN];	/* Column with a 2nd longitude (for VECTORS with two sets of coordinates) */
psxy_new.c:	pos2y = ex2 - GMT->current.setting.io_lonlat_toggle[GMT_IN];	/* Column with a 2nd latitude (for VECTORS with two sets of coordinates) */
psxy_new.c:		if (def_err_xy && GMT->current.setting.io_lonlat_toggle[GMT_IN]) {	/* With -:, -E should become -Eyx */
psxy_new.c:	if (gmt_M_err_pass (GMT, gmt_map_setup (GMT, GMT->common.R.wesn), ""))
psxy_new.c:		save_u = GMT->current.setting.proj_length_unit;
psxy_new.c:		GMT->current.setting.proj_length_unit = S.u;
psxy_new.c:	if (S.G.delay) GMT->current.ps.nclip = +2;	/* Signal that this program initiates clipping that will outlive this process */
psxy_new.c:	gmt_plane_perspective (GMT, GMT->current.proj.z_project.view_plane, GMT->current.proj.z_level);
psxy_new.c:	if (Ctrl->A.active) Ctrl->A.step = Ctrl->A.step / GMT->current.proj.scale[GMT_X] / GMT->current.proj.M_PR_DEG;
psxy_new.c:	if ((gmt_M_is_conical(GMT) && gmt_M_360_range (GMT->common.R.wesn[XLO], GMT->common.R.wesn[XHI]))) {	/* Must turn clipping on for 360-range conical */
psxy_new.c:	if (clip_set) gmt_map_clip_on (GMT, GMT->session.no_rgb, 3);
psxy_new.c:	if (S.symbol == GMT_SYMBOL_BARX && !S.base_set) S.base = GMT->common.R.wesn[XLO];	/* Default to west level for horizontal log10 bars */
psxy_new.c:	if (S.symbol == GMT_SYMBOL_BARY && !S.base_set) S.base = GMT->common.R.wesn[YLO];	/* Default to south level for vertical log10 bars */
psxy_new.c:	old_is_world = GMT->current.map.is_world;
psxy_new.c:			if ((Decorate = GMT_Create_Data (GMT->parent, GMT_IS_DATASET, GMT_IS_POINT, GMT_WITH_STRINGS, dim, NULL, NULL, 0, 0, NULL)) == NULL) Return (API->error);
psxy_new.c:		if (GMT->current.io.OGR && (GMT->current.io.OGR->geometry == GMT_IS_POLYGON || GMT->current.io.OGR->geometry == GMT_IS_MULTIPOLYGON)) polygon = true;
psxy_new.c:				duplicate = (DH->alloc_mode == GMT_ALLOC_EXTERNALLY && ((polygon && gmt_polygon_is_open (GMT, L->data[GMT_X], L->data[GMT_Y], L->n_rows)) || GMT->current.map.path_mode == GMT_RESAMPLE_PATH));
psxy_new.c:				if (GMT->current.map.path_mode == GMT_RESAMPLE_PATH && !resampled) {	/* Resample if spacing is too coarse */
psxy_new.c:					if ((GMT->current.plot.n = gmt_geo_to_xy_line (GMT, L->data[GMT_X], L->data[GMT_Y], L->n_rows)) == 0) continue;
psxy_new.c:					for (k0 = 0; !split && k0 < GMT->current.plot.n; k0++) if (GMT->current.plot.pen[k0] & PSL_MOVE) split = true;
psxy_new.c:						while (k0 < GMT->current.plot.n) {	/* While more sections... */
psxy_new.c:							while (k1 < GMT->current.plot.n && GMT->current.plot.pen[k1] == PSL_DRAW) k1++;	/* Find next section anchor */
psxy_new.c:							/* k1 is now pointing to next move (anchor) point or it is GMT->current.plot.n */
psxy_new.c:							gmt_M_memcpy (xxx, &GMT->current.plot.x[k0], n_section, double);
psxy_new.c:							gmt_M_memcpy (yyy, &GMT->current.plot.y[k0], n_section, double);
psxy_new.c:						closed = !(gmt_polygon_is_open (GMT, GMT->current.plot.x, GMT->current.plot.y, GMT->current.plot.n));
psxy_new.c:						gmt_hold_contour (GMT, &GMT->current.plot.x, &GMT->current.plot.y, GMT->current.plot.n, 0.0, "N/A", 'A', S.G.label_angle, closed, false, &S.G);
psxy_new.c:						GMT->current.plot.n_alloc = GMT->current.plot.n;	/* Since gmt_hold_contour reallocates to fit the array */
psxy_new.c:					if ((GMT->current.plot.n = gmt_geo_to_xy_line (GMT, L->data[GMT_X], L->data[GMT_Y], L->n_rows)) == 0) continue;
psxy_new.c:					gmt_plot_line (GMT, GMT->current.plot.x, GMT->current.plot.y, GMT->current.plot.pen, GMT->current.plot.n, PSL_LINEAR);
psxy_new.c:					for (k0 = 1; !split && k0 < GMT->current.plot.n; k0++) if (GMT->current.plot.pen[k0] & PSL_MOVE) split = true;
psxy_new.c:						while (k0 < GMT->current.plot.n) {	/* While more sections... */
psxy_new.c:							while (k1 < GMT->current.plot.n && GMT->current.plot.pen[k1] == PSL_DRAW) k1++;	/* Find next section anchor */
psxy_new.c:							/* k1 is now pointing to next move (anchor) point or it is GMT->current.plot.n */
psxy_new.c:							gmt_M_memcpy (xxx, &GMT->current.plot.x[k0], n_section, double);
psxy_new.c:							gmt_M_memcpy (yyy, &GMT->current.plot.y[k0], n_section, double);
psxy_new.c:						gmt_decorated_line (GMT, &GMT->current.plot.x, &GMT->current.plot.y, GMT->current.plot.n, &S.D, Decorate, seg_out);
psxy_new.c:							gmt_M_memcpy (GMT->hidden.mem_coord[GMT_X], L->data[GMT_X], L->n_rows, double);
psxy_new.c:								GMT->hidden.mem_coord[GMT_Y][k] = L->data[GMT_Y][k] - fabs (L->data[2][k]);
psxy_new.c:								GMT->hidden.mem_coord[GMT_X][n] = L->data[GMT_X][k-1];
psxy_new.c:								GMT->hidden.mem_coord[GMT_Y][n] = L->data[GMT_Y][k-1] + fabs (L->data[col][k-1]);
psxy_new.c:							GMT->hidden.mem_coord[GMT_X][end-1] = GMT->hidden.mem_coord[GMT_X][0];
psxy_new.c:							GMT->hidden.mem_coord[GMT_Y][end-1] = GMT->hidden.mem_coord[GMT_Y][0];
psxy_new.c:							gmt_M_memcpy (GMT->hidden.mem_coord[GMT_X], L->data[GMT_X], L->n_rows, double);
psxy_new.c:								GMT->hidden.mem_coord[GMT_Y][k] = L->data[2][k];
psxy_new.c:								GMT->hidden.mem_coord[GMT_X][n] = L->data[GMT_X][k-1];
psxy_new.c:								GMT->hidden.mem_coord[GMT_Y][n] = L->data[3][k-1];
psxy_new.c:							GMT->hidden.mem_coord[GMT_X][end-1] = GMT->hidden.mem_coord[GMT_X][0];
psxy_new.c:							GMT->hidden.mem_coord[GMT_Y][end-1] = GMT->hidden.mem_coord[GMT_Y][0];
psxy_new.c:							gmt_M_memcpy (GMT->hidden.mem_coord[GMT_X], L->data[GMT_X], end, double);
psxy_new.c:							gmt_M_memcpy (GMT->hidden.mem_coord[GMT_Y], L->data[GMT_Y], end, double);
psxy_new.c:									value = (Ctrl->L.mode == ZLO) ? Ctrl->L.value : GMT->common.R.wesn[XLO+off];
psxy_new.c:									GMT->hidden.mem_coord[GMT_X][end] = GMT->hidden.mem_coord[GMT_X][end+1] = value;
psxy_new.c:									GMT->hidden.mem_coord[GMT_Y][end] = L->data[GMT_Y][end-1];
psxy_new.c:									GMT->hidden.mem_coord[GMT_Y][end+1] = L->data[GMT_Y][0];
psxy_new.c:									value = (Ctrl->L.mode == ZHI) ? Ctrl->L.value : GMT->common.R.wesn[YLO+off];
psxy_new.c:									GMT->hidden.mem_coord[GMT_Y][end] = GMT->hidden.mem_coord[GMT_Y][end+1] = value;
psxy_new.c:									GMT->hidden.mem_coord[GMT_X][end] = L->data[GMT_X][end-1];
psxy_new.c:									GMT->hidden.mem_coord[GMT_X][end+1] = L->data[GMT_X][0];
psxy_new.c:							GMT->hidden.mem_coord[GMT_X][end+2] = L->data[GMT_X][0];
psxy_new.c:							GMT->hidden.mem_coord[GMT_Y][end+2] = L->data[GMT_Y][0];
psxy_new.c:						if ((GMT->current.plot.n = gmt_geo_to_xy_line (GMT, GMT->hidden.mem_coord[GMT_X], GMT->hidden.mem_coord[GMT_Y], end)) == 0) continue;
psxy_new.c:						PSL_plotpolygon (PSL, GMT->current.plot.x, GMT->current.plot.y, (int)GMT->current.plot.n);
psxy_new.c:						if ((GMT->current.plot.n = gmt_geo_to_xy_line (GMT, L->data[GMT_X], L->data[GMT_Y], L->n_rows)) == 0) continue;
psxy_new.c:						gmt_plot_line (GMT, GMT->current.plot.x, GMT->current.plot.y, GMT->current.plot.pen, GMT->current.plot.n, current_pen.mode);
psxy_new.c:						plot_end_vectors (GMT, GMT->current.plot.x, GMT->current.plot.y, GMT->current.plot.n, &current_pen);	/* Maybe add vector heads */
psxy_new.c:					gmt_draw_front (GMT, GMT->current.plot.x, GMT->current.plot.y, GMT->current.plot.n, &S.f);
psxy_new.c:		if ((Ctrl->N.mode == PSXY_CLIP_REPEAT || Ctrl->N.mode == PSXY_NO_CLIP_REPEAT) && gmt_M_360_range (GMT->common.R.wesn[XLO], GMT->common.R.wesn[XHI]) && gmt_M_is_geographic (GMT, GMT_IN)) {
psxy_new.c:		PSL_command (GMT->PSL, "V\n");
psxy_new.c:		if (S.read_size && GMT->current.io.col[GMT_IN][ex1].convert) {	/* Doing math on the size column, must delay unit conversion unless inch */
psxy_new.c:						if (S.n_nondim && GMT->current.setting.proj_length_unit != GMT_INCH) {	/* Since these are not dimensions but angles or other quantities */
psxy_new.c:							for (j = 0; j < S.n_nondim; j++) in[S.nondim_col[j]+get_rgb] *= GMT->session.u2u[GMT_INCH][GMT->current.setting.proj_length_unit];
psxy_new.c:						if (abs (GMT->current.map.this_x_status) > 1 || abs (GMT->current.map.this_y_status) > 1) {
psxy_new.c:						if (Ctrl->E.mode & 1) gmt_M_rgb_copy (current_fill.rgb, GMT->session.no_rgb);
psxy_new.c:							gmt_M_rgb_copy (current_fill.rgb, GMT->session.no_rgb);
psxy_new.c:						//if (delayed_unit_scaling) S.size_x *= GMT->session.u2u[S.u][GMT_INCH];
psxy_new.c:						if (plot_x < GMT->current.map.half_width)     /* Might reappear at right edge */
psxy_new.c:								if (!Ctrl->N.active) in[GMT_X] = MAX (GMT->common.R.wesn[XLO], MIN (in[GMT_X], GMT->common.R.wesn[XHI]));
psxy_new.c:									gmt_geo_to_xy (GMT, S.base, GMT->common.R.wesn[YLO], &x_1, &y_1);	/* Zero x level for horizontal bars */
psxy_new.c:								if (!Ctrl->N.active) in[GMT_Y] = MAX (GMT->common.R.wesn[YLO], MIN (in[GMT_Y], GMT->common.R.wesn[YHI]));
psxy_new.c:									gmt_geo_to_xy (GMT, GMT->common.R.wesn[XLO], S.base, &x_1, &y_1);	/* Zero y level for vertical bars */
psxy_new.c:									dim[1] = in[ex2] * GMT->current.proj.scale[GMT_X];
psxy_new.c:									dim[2] = in[ex3] * GMT->current.proj.scale[GMT_X];
psxy_new.c:										PSL_setfill (PSL, GMT->session.no_rgb, outline_active);
psxy_new.c:										PSL_setfill (PSL, GMT->session.no_rgb, outline_active);
psxy_new.c:									PSL_setfill (PSL, GMT->session.no_rgb, outline_active);
psxy_new.c:										if (x_2 < GMT->current.map.half_width)     /* Might reappear at right edge */
psxy_new.c:									S.v.v_width = (float)(current_pen.width * GMT->session.u2u[GMT_PT][GMT_INCH]);
psxy_new.c:										v4_rgb = GMT->session.no_rgb;
psxy_new.c:									dim[5] = GMT->current.setting.map_vector_shape;
psxy_new.c:									S.v.v_width = (float)(S.v.pen.width * GMT->session.u2u[GMT_PT][GMT_INCH]);
psxy_new.c:									S.v.v_width = (float)(current_pen.width * GMT->session.u2u[GMT_PT][GMT_INCH]);
psxy_new.c:								S.v.v_width = (float)(current_pen.width * GMT->session.u2u[GMT_PT][GMT_INCH]);
psxy_new.c:		PSL_command (GMT->PSL, "U\n");
psxy_new.c:	if (S.u_set) GMT->current.setting.proj_length_unit = save_u;	/* Reset unit */
psxy_new.c:	GMT->current.map.is_world = old_is_world;
psxyz.c:	C->W.pen = GMT->current.setting.map_default_pen;
psxyz.c:	C->A.step = GMT->current.setting.map_line_step;
psxyz.c:	if (API->GMT->current.setting.run_mode == GMT_CLASSIC)	/* -T has no purpose in modern mode */
psxyz.c:		API->GMT->session.unit_name[API->GMT->current.setting.proj_length_unit]);
psxyz.c:		API->GMT->session.unit_name[API->GMT->current.setting.proj_length_unit]);
psxyz.c:	if (API->GMT->current.setting.run_mode == GMT_CLASSIC)	/* -T has no purpose in modern mode */
psxyz.c:	struct GMTAPI_CTRL *API = GMT->parent;
psxyz.c:	if ((opt = GMT_Find_Option (GMT->parent, 'p', options))) three_D = true;	/* Gave -p */
psxyz.c:				if (three_D && strchr ("lf", opt->arg[0]) == NULL && API->GMT->current.setting.run_mode == GMT_CLASSIC) {	/* Could possibly be old-style 3-D -Z<level> setting */
psxyz.c:	n_errors += gmt_M_check_condition (GMT, !GMT->common.R.active[RSET], "Syntax error: Must specify -R option\n");
psxyz.c:	n_errors += gmt_M_check_condition (GMT, !GMT->common.J.active, "Syntax error: Must specify a map projection with the -J option\n");
psxyz.c:	n_errors += gmt_M_check_condition (GMT, GMT->common.b.active[GMT_IN] && S->symbol == GMT_SYMBOL_NOT_SET, "Syntax error: Binary input data cannot have symbol information\n");
psxyz.c:		k = GMT->current.proj.z_project.face[i] / 2;
psxyz.c:		switch (GMT->current.proj.z_project.face[i]) {
psxyz.c:	if (API->GMT->current.setting.run_mode == GMT_CLASSIC && !API->usage) {
psxyz.c:	if (API->GMT->current.setting.run_mode == GMT_CLASSIC) {	/* Classic requires options, while modern does not */
psxyz.c:	S.base = GMT->session.d_NaN;
psxyz.c:	S.font = GMT->current.setting.font_annot[GMT_PRIMARY];
psxyz.c:	S.u = GMT->current.setting.proj_length_unit;
psxyz.c:	GMT->current.plot.mode_3D = 1;	/* Only do background axis first; do foreground at end */
psxyz.c:	pos2x = ex1 + GMT->current.setting.io_lonlat_toggle[GMT_IN];	/* Column with a 2nd longitude (for VECTORS with two sets of coordinates) */
psxyz.c:	pos2y = ex2 - GMT->current.setting.io_lonlat_toggle[GMT_IN];	/* Column with a 2nd latitude (for VECTORS with two sets of coordinates) */
psxyz.c:	if (GMT->common.t.variable) {
psxyz.c:	if (gmt_M_err_pass (GMT, gmt_map_setup (GMT, GMT->common.R.wesn), ""))
psxyz.c:		save_u = GMT->current.setting.proj_length_unit;
psxyz.c:		GMT->current.setting.proj_length_unit = S.u;
psxyz.c:	lux[0] = fabs (GMT->current.proj.z_project.sin_az * GMT->current.proj.z_project.cos_el);
psxyz.c:	lux[1] = fabs (GMT->current.proj.z_project.cos_az * GMT->current.proj.z_project.cos_el);
psxyz.c:	lux[2] = fabs (GMT->current.proj.z_project.sin_el);
psxyz.c:	gmt_plane_perspective (GMT, GMT_Z + GMT_ZW, GMT->current.proj.z_level);
psxyz.c:	if (GMT->current.proj.z_pars[0] == 0.0) {	/* Only consider clipping if there is no z scaling */
psxyz.c:		if ((gmt_M_is_conical(GMT) && gmt_M_360_range (GMT->common.R.wesn[XLO], GMT->common.R.wesn[XHI]))) {	/* Must turn clipping on for 360-range conical */
psxyz.c:	if (clip_set) gmt_map_clip_on (GMT, GMT->session.no_rgb, 3);
psxyz.c:		gmt_plane_perspective (GMT, GMT_Z + GMT_ZW, GMT->current.proj.z_level);
psxyz.c:	GMT->current.io.skip_if_NaN[GMT_Z] = true;	/* Extend GMT NaN-handling to the z-coordinate */
psxyz.c:	old_is_world = GMT->current.map.is_world;
psxyz.c:		double in2[7] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}, *p_in = GMT->current.io.curr_rec;
psxyz.c:		if (clip_set && (Ctrl->N.mode == PSXYZ_CLIP_REPEAT || Ctrl->N.mode == PSXYZ_NO_CLIP_REPEAT) && gmt_M_360_range (GMT->common.R.wesn[XLO], GMT->common.R.wesn[XHI]) && gmt_M_is_geographic (GMT, GMT_IN)) {
psxyz.c:		GMT->current.map.is_world = !(S.symbol == PSL_ELLIPSE && S.convert_angles);
psxyz.c:		if (S.read_size && GMT->current.io.col[GMT_IN][ex1].convert) {	/* Doing math on the size column, must delay unit conversion unless inch */
psxyz.c:			else if (GMT->current.setting.proj_length_unit != GMT_INCH) {
psxyz.c:				S.u = GMT->current.setting.proj_length_unit;
psxyz.c:		if (S.read_size && GMT->current.io.col[GMT_IN][ex2].convert) {	/* Doing math on the size column, must delay unit conversion unless inch */
psxyz.c:		else if (GMT->common.l.active && !get_rgb && (!S.read_size || GMT->common.l.item.size > 0.0)) {
psxyz.c:			gmt_add_legend_item (API, &S, Ctrl->G.active, &(Ctrl->G.fill), Ctrl->W.active, &(Ctrl->W.pen), &(GMT->common.l.item));
psxyz.c:					PSL_comment (PSL, "Segment header: %s\n", GMT->current.io.segment_header);
psxyz.c:					(void)gmt_parse_segment_header (GMT, GMT->current.io.segment_header, P, &fill_active, &current_fill, &default_fill, &outline_active, &current_pen, &default_pen, default_outline, NULL);
psxyz.c:					if (gmt_parse_segment_item (GMT, GMT->current.io.segment_header, "-S", s_args)) {	/* Found -Sargs */
psxyz.c:				if (S.n_nondim && GMT->current.setting.proj_length_unit != GMT_INCH) {	/* Since these are not dimensions but angles or other quantities */
psxyz.c:					for (j = 0; j < S.n_nondim; j++) in[S.nondim_col[j]+rgb_from_z] *= GMT->session.u2u[GMT_INCH][GMT->current.setting.proj_length_unit];
psxyz.c:						in[pos2x] *= GMT->session.u2u[GMT_INCH][GMT->current.setting.proj_length_unit];
psxyz.c:						in[pos2y] *= GMT->session.u2u[GMT_INCH][GMT->current.setting.proj_length_unit];
psxyz.c:			if (!Ctrl->N.active && (in[GMT_Z] < GMT->common.R.wesn[ZLO] || in[GMT_Z] > GMT->common.R.wesn[ZHI])) continue;
psxyz.c:				if (abs (GMT->current.map.this_x_status) > 1 || abs (GMT->current.map.this_y_status) > 1) continue;
psxyz.c:				if (delayed_unit_scaling[GMT_X]) S.size_x *= GMT->session.u2u[S.u][GMT_INCH];
psxyz.c:				if (delayed_unit_scaling[GMT_Y]) S.size_y *= GMT->session.u2u[S.u][GMT_INCH];
psxyz.c:					gmt_M_rgb_copy (current_fill.rgb, GMT->session.no_rgb);
psxyz.c:			if (GMT->common.t.variable) data[n].transparency = 0.01 * in[tcol];	/* Specific transparency for current symbol if -t was given */
psxyz.c:			data[n].dist[0] = GMT->current.proj.z_project.sin_az * data[n].x + GMT->current.proj.z_project.cos_az * data[n].y;
psxyz.c:			data[n].dist[1] = GMT->current.proj.z_project.sin_el * data[n].z;
psxyz.c:						data[n].dim[1] = p_in[ex2] * GMT->current.proj.scale[GMT_X];
psxyz.c:						data[n].dim[2] = p_in[ex3] * GMT->current.proj.scale[GMT_Y];
psxyz.c:						S.v.v_width = (float)(current_pen.width * GMT->session.u2u[GMT_PT][GMT_INCH]);
psxyz.c:						data[n].dim[5] = GMT->current.setting.map_vector_shape;
psxyz.c:						S.v.v_width = (float)(S.v.pen.width * GMT->session.u2u[GMT_PT][GMT_INCH]);
psxyz.c:						S.v.v_width = (float)(current_pen.width * GMT->session.u2u[GMT_PT][GMT_INCH]);
psxyz.c:					S.v.v_width = (float)(current_pen.width * GMT->session.u2u[GMT_PT][GMT_INCH]);
psxyz.c:		PSL_command (GMT->PSL, "V\n");
psxyz.c:			if (GMT->common.t.variable)	/* Update the transparency for current symbol */
psxyz.c:				if (data[i].x < GMT->current.map.half_width)     /* Might reappear at right edge */
psxyz.c:						if (!Ctrl->N.active) in[GMT_X] = MAX (GMT->common.R.wesn[XLO], MIN (xpos[item], GMT->common.R.wesn[XHI]));
psxyz.c:						if (!Ctrl->N.active) in[GMT_Y] = MAX (GMT->common.R.wesn[YLO], MIN (data[i].y, GMT->common.R.wesn[YHI]));
psxyz.c:							PSL_setfill (PSL, GMT->session.no_rgb, data[i].outline);
psxyz.c:							v4_rgb = GMT->session.no_rgb;
psxyz.c:		PSL_command (GMT->PSL, "U\n");
psxyz.c:		if (GMT->common.l.active && S.symbol == GMT_SYMBOL_LINE) {
psxyz.c:				gmt_add_legend_item (API, &S, Ctrl->G.active, &(Ctrl->G.fill), Ctrl->W.active, &(Ctrl->W.pen), &(GMT->common.l.item));
psxyz.c:				gmt_add_legend_item (API, &S, false, NULL, Ctrl->W.active, &(Ctrl->W.pen), &(GMT->common.l.item));
psxyz.c:					gmt_plane_perspective (GMT, GMT_Z + GMT_ZW, GMT->current.proj.z_level);
psxyz.c:					if ((GMT->current.plot.n = gmt_geo_to_xy_line (GMT, L->data[GMT_X], L->data[GMT_Y], L->n_rows)) == 0) continue;
psxyz.c:					closed = !(gmt_polygon_is_open (GMT, GMT->current.plot.x, GMT->current.plot.y, GMT->current.plot.n));
psxyz.c:					gmt_hold_contour (GMT, &GMT->current.plot.x, &GMT->current.plot.y, GMT->current.plot.n, 0.0, "N/A", 'A', S.G.label_angle, closed, false, &S.G);
psxyz.c:					GMT->current.plot.n_alloc = GMT->current.plot.n;	/* Since gmt_hold_contour reallocates to fit the array */
psxyz.c:							gmt_M_memcpy (GMT->hidden.mem_coord[GMT_X], L->data[GMT_X], L->n_rows, double);
psxyz.c:							gmt_M_memcpy (GMT->hidden.mem_coord[GMT_Z], L->data[GMT_Z], L->n_rows, double);
psxyz.c:								GMT->hidden.mem_coord[GMT_Y][k] = L->data[GMT_Y][k] - fabs (L->data[3][k]);
psxyz.c:								GMT->hidden.mem_coord[GMT_X][m] = L->data[GMT_X][k-1];
psxyz.c:								GMT->hidden.mem_coord[GMT_Z][m] = L->data[GMT_Z][k-1];
psxyz.c:								GMT->hidden.mem_coord[GMT_Y][m] = L->data[GMT_Y][k-1] + fabs (L->data[col][k-1]);
psxyz.c:							GMT->hidden.mem_coord[GMT_X][end-1] = GMT->hidden.mem_coord[GMT_X][0];
psxyz.c:							GMT->hidden.mem_coord[GMT_Y][end-1] = GMT->hidden.mem_coord[GMT_Y][0];
psxyz.c:							GMT->hidden.mem_coord[GMT_Z][end-1] = GMT->hidden.mem_coord[GMT_Z][0];
psxyz.c:							gmt_M_memcpy (GMT->hidden.mem_coord[GMT_X], L->data[GMT_X], L->n_rows, double);
psxyz.c:							gmt_M_memcpy (GMT->hidden.mem_coord[GMT_Z], L->data[GMT_X], L->n_rows, double);
psxyz.c:								GMT->hidden.mem_coord[GMT_Y][k] = L->data[3][k];
psxyz.c:								GMT->hidden.mem_coord[GMT_X][m] = L->data[GMT_X][k-1];
psxyz.c:								GMT->hidden.mem_coord[GMT_Z][m] = L->data[GMT_Z][k-1];
psxyz.c:								GMT->hidden.mem_coord[GMT_Y][m] = L->data[4][k-1];
psxyz.c:							GMT->hidden.mem_coord[GMT_X][end-1] = GMT->hidden.mem_coord[GMT_X][0];
psxyz.c:							GMT->hidden.mem_coord[GMT_Y][end-1] = GMT->hidden.mem_coord[GMT_Y][0];
psxyz.c:							GMT->hidden.mem_coord[GMT_Z][end-1] = GMT->hidden.mem_coord[GMT_Z][0];
psxyz.c:							gmt_M_memcpy (GMT->hidden.mem_coord[GMT_X], L->data[GMT_X], end, double);
psxyz.c:							gmt_M_memcpy (GMT->hidden.mem_coord[GMT_Y], L->data[GMT_Y], end, double);
psxyz.c:							gmt_M_memcpy (GMT->hidden.mem_coord[GMT_Z], L->data[GMT_Z], end, double);
psxyz.c:									value = (Ctrl->L.mode == ZLO) ? Ctrl->L.value : GMT->common.R.wesn[XLO+off];
psxyz.c:									GMT->hidden.mem_coord[GMT_X][end] = GMT->hidden.mem_coord[GMT_X][end+1] = value;
psxyz.c:									GMT->hidden.mem_coord[GMT_Z][end] = GMT->hidden.mem_coord[GMT_Z][end+1] = L->data[GMT_Z][0];
psxyz.c:									GMT->hidden.mem_coord[GMT_Y][end] = L->data[GMT_Y][end-1];
psxyz.c:									GMT->hidden.mem_coord[GMT_Y][end+1] = L->data[GMT_Y][0];
psxyz.c:									value = (Ctrl->L.mode == ZHI) ? Ctrl->L.value : GMT->common.R.wesn[YLO+off];
psxyz.c:									GMT->hidden.mem_coord[GMT_Y][end] = GMT->hidden.mem_coord[GMT_Y][end+1] = value;
psxyz.c:									GMT->hidden.mem_coord[GMT_Z][end] = GMT->hidden.mem_coord[GMT_Z][end+1] = L->data[GMT_Z][0];
psxyz.c:									GMT->hidden.mem_coord[GMT_X][end] = L->data[GMT_X][end-1];
psxyz.c:									GMT->hidden.mem_coord[GMT_X][end+1] = L->data[GMT_X][0];
psxyz.c:							GMT->hidden.mem_coord[GMT_X][end+2] = L->data[GMT_X][0];
psxyz.c:							GMT->hidden.mem_coord[GMT_Y][end+2] = L->data[GMT_Y][0];
psxyz.c:							GMT->hidden.mem_coord[GMT_Z][end+2] = L->data[GMT_Z][0];
psxyz.c:							gmt_geoz_to_xy (GMT, GMT->hidden.mem_coord[GMT_X][i], GMT->hidden.mem_coord[GMT_Y][i], GMT->hidden.mem_coord[GMT_Z][i], &xp[i], &yp[i]);
psxyz.c:					gmt_plane_perspective (GMT, GMT_Z + GMT_ZW, GMT->current.proj.z_level);
psxyz.c:					if ((GMT->current.plot.n = gmt_geo_to_xy_line (GMT, L->data[GMT_X], L->data[GMT_Y], L->n_rows)) == 0) continue;
psxyz.c:					gmt_draw_front (GMT, GMT->current.plot.x, GMT->current.plot.y, GMT->current.plot.n, &S.f);
psxyz.c:	if (S.u_set) GMT->current.setting.proj_length_unit = save_u;	/* Reset unit */
psxyz.c:	GMT->current.map.is_world = old_is_world;
sample1d.c:	C->F.mode = GMT->current.setting.interpolant;
sample1d.c:	GMT_Message (API, GMT_TIME_NONE, "\t   [Default is -F%c].\n", type[API->GMT->current.setting.interpolant]);
sample1d.c:	struct GMTAPI_CTRL *API = GMT->parent;
sample1d.c:	GMT->current.setting.interpolant = Ctrl->F.mode % 10;
sample1d.c:	GMT->current.io.skip_if_NaN[GMT_X] = GMT->current.io.skip_if_NaN[GMT_Y] = false;	/* Turn off default GMT NaN-handling for (x,y) which is not the case here */
sample1d.c:	GMT->current.io.skip_if_NaN[Ctrl->N.col] = true;				/* ... But disallow NaN in "time" column */
sample1d.c:		if (Ctrl->A.loxo) GMT->current.map.loxodrome = true;
sample1d.c:			Sout = GMT_Alloc_Segment (GMT->parent, GMT_NO_STRINGS, m, Din->n_columns, NULL, Tout->segment[seg]);
sample1d.c:				if (nan_flag[col] && !GMT->current.setting.io_nan_records) {	/* NaN's present, need "clean" time and data columns */
spectrum1d.c:		if (GMT_FFT_1D (GMT->parent, C->datac, C->window, GMT_FFT_FWD, GMT_FFT_COMPLEX))
spectrum1d.c:			GMT_Message (GMT->parent, GMT_TIME_NONE, "Window %d from %d to %d\n", w, t_start, t_stop);
spectrum1d.c:				GMT->current.setting.format_float_out, GMT->current.setting.format_float_out, GMT->current.setting.format_float_out, GMT->current.setting.format_float_out, GMT->current.setting.format_float_out, GMT->current.setting.format_float_out);
spectrum1d.c:			GMT_Message (GMT->parent, GMT_TIME_NONE, format, C->x_variance, x_varp, (C->x_variance/x_varp), C->y_variance, y_varp, C->y_pow);
spectrum1d.c:			if ((fpout = gmt_fopen (GMT, fname, GMT->current.io.w_mode)) == NULL) {
spectrum1d.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, " Cannot open w %s\n", fname);
spectrum1d.c:			GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, " Writing %s\n", fname);
spectrum1d.c:				GMT->current.io.output (GMT, fpout, 3, out, NULL);
spectrum1d.c:			if ((fpout = gmt_fopen (GMT, fname, GMT->current.io.w_mode)) == NULL) {
spectrum1d.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, " Cannot open w %s\n", fname);
spectrum1d.c:			GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, " Writing %s\n", fname);
spectrum1d.c:				GMT->current.io.output (GMT, fpout, 3, out, NULL);
spectrum1d.c:			if ((fpout = gmt_fopen (GMT, fname, GMT->current.io.w_mode)) == NULL) {
spectrum1d.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, " Cannot open w %s\n", fname);
spectrum1d.c:			GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, " Writing %s\n", fname);
spectrum1d.c:				GMT->current.io.output (GMT, fpout, 3, out, NULL);
spectrum1d.c:			if ((fpout = gmt_fopen (GMT, fname, GMT->current.io.w_mode)) == NULL) {
spectrum1d.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, " Cannot open w %s\n", fname);
spectrum1d.c:			GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, " Writing %s\n", fname);
spectrum1d.c:				GMT->current.io.output (GMT, fpout, 3, out, NULL);
spectrum1d.c:			if ((fpout = gmt_fopen (GMT, fname, GMT->current.io.w_mode)) == NULL) {
spectrum1d.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, " Cannot open w %s\n", fname);
spectrum1d.c:			GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, " Writing %s\n", fname);
spectrum1d.c:				GMT->current.io.output (GMT, fpout, 3, out, NULL);
spectrum1d.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, " Cannot open w %s\n", fname);
spectrum1d.c:			GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, " Writing %s\n", fname);
spectrum1d.c:				GMT->current.io.output (GMT, fpout, 3, out, NULL);
spectrum1d.c:			if ((fpout = gmt_fopen (GMT, fname, GMT->current.io.w_mode)) == NULL) {
spectrum1d.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, " Cannot open w %s\n", fname);
spectrum1d.c:			GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, " Writing %s\n", fname);
spectrum1d.c:				GMT->current.io.output (GMT, fpout, 3, out, NULL);
spectrum1d.c:			if ((fpout = gmt_fopen (GMT, fname, GMT->current.io.w_mode)) == NULL) {
spectrum1d.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, " Cannot open w %s\n", fname);
spectrum1d.c:			GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, " Writing %s\n", fname);
spectrum1d.c:				GMT->current.io.output (GMT, fpout, 3, out, NULL);
spectrum1d.c:	struct GMTAPI_CTRL *API = GMT->parent;
spectrum1d.c:				Sout = Tout->segment[seg] = GMT_Alloc_Segment (GMT->parent, smode, C.n_spec, Tout->n_columns, NULL, Tout->segment[seg]);
sph2grd.c:	struct GMTAPI_CTRL *API = GMT->parent;
sph2grd.c:	n_errors += gmt_M_check_condition (GMT, !GMT->common.R.active[RSET], "Syntax error: Must specify -R option\n");
sph2grd.c:		double scale = 360.0 * GMT->current.proj.DIST_KM_PR_DEG;
sphdistance.c:	struct GMTAPI_CTRL *API = GMT->parent;
sphdistance.c:	if (GMT->common.b.active[GMT_IN] && GMT->common.b.ncol[GMT_IN] == 0) GMT->common.b.ncol[GMT_IN] = 3;
sphdistance.c:	n_errors += gmt_M_check_condition (GMT, GMT->common.b.active[GMT_IN] && GMT->common.b.ncol[GMT_IN] < 3, "Syntax error: Binary input data (-bi) must have at least 3 columns\n");
sphdistance.c:	n_errors += gmt_M_check_condition (GMT, GMT->common.R.inc[GMT_X] <= 0.0 || GMT->common.R.inc[GMT_Y] <= 0.0, "Syntax error -I option: Must specify positive increment(s)\n");
sphdistance.c:	n_errors += gmt_M_check_condition (GMT, Ctrl->Q.active && GMT->common.b.active[GMT_IN] && !Ctrl->N.active, "Syntax error: Binary input data (-bi) with -Q also requires -N.\n");
sphdistance.c:	if (!GMT->common.R.active[RSET]) {	/* Default to a global grid */
sphdistance.c:		GMT->common.R.wesn[XLO] = 0.0;	GMT->common.R.wesn[XHI] = 360.0;	GMT->common.R.wesn[YLO] = -90.0;	GMT->common.R.wesn[YHI] = 90.0;
sphdistance.c:		GMT->session.min_meminc = GMT_INITIAL_MEM_ROW_ALLOC;	/* Start by allocating a 32 Mb chunk */ 
sphdistance.c:		GMT->session.min_meminc = GMT_MIN_MEMINC;		/* Reset to the default value */
sphdistance.c:	periodic = gmt_M_360_range (GMT->common.R.wesn[XLO], GMT->common.R.wesn[XHI]);
sphinterpolate.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "%s\n", msg);
sphinterpolate.c:	struct GMTAPI_CTRL *API = GMT->parent;
sphinterpolate.c:	if (GMT->common.b.active[GMT_IN] && GMT->common.b.ncol[GMT_IN] == 0) GMT->common.b.ncol[GMT_IN] = 3;
sphinterpolate.c:	n_errors += gmt_M_check_condition (GMT, GMT->common.b.active[GMT_IN] && GMT->common.b.ncol[GMT_IN] < 3, "Syntax error: Binary input data (-bi) must have at least 3 columns\n");
sphinterpolate.c:	n_errors += gmt_M_check_condition (GMT, GMT->common.R.inc[GMT_X] <= 0.0 || GMT->common.R.inc[GMT_Y] <= 0.0, "Syntax error -I option: Must specify positive increment(s)\n");
sphinterpolate.c:	if (!GMT->common.R.active[RSET]) {	/* Default is global region */
sphinterpolate.c:		GMT->common.R.wesn[XLO] = 0.0;	GMT->common.R.wesn[XHI] = 360.0;	GMT->common.R.wesn[YLO] = -90.0;	GMT->common.R.wesn[YHI] = 90.0;
sphinterpolate.c:	GMT->session.min_meminc = GMT_INITIAL_MEM_ROW_ALLOC;	/* Start by allocating a 32 Mb chunk */ 
sphinterpolate.c:	GMT->session.min_meminc = GMT_MIN_MEMINC;		/* Reset to the default value */
sphtriangulate.c:	double area_sphere = 0.0, area_triangle = GMT->session.d_NaN, V[3][3], R2, y, dist;
sphtriangulate.c:		R2 = GMT->current.map.dist[GMT_MAP_DIST].scale = 1.0;
sphtriangulate.c:		R2 = pow (R2D * GMT->current.proj.M_PR_DEG, 2.0);	/* squared mean radius in meters */
sphtriangulate.c:		R2 *= (GMT->current.map.dist[GMT_MAP_DIST].scale * GMT->current.map.dist[GMT_MAP_DIST].scale);	/* Get final measure unit for area */
sphtriangulate.c:	do_authalic = (get_area && !get_arcs && !gmt_M_is_zero (GMT->current.setting.ref_ellipsoid[GMT->current.setting.proj_ellipsoid].flattening));
sphtriangulate.c:		if ((Dout[0] = GMT_Create_Data (GMT->parent, GMT_IS_DATASET, GMT_IS_LINE, 0, dim, NULL, NULL, 0, 0, NULL)) == NULL) {
sphtriangulate.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Unable to create a data set for sphtriangulate\n");
sphtriangulate.c:			if ((Dout[1] = GMT_Create_Data (GMT->parent, GMT_IS_DATASET, GMT_IS_POINT, 0, dim, NULL, NULL, 0, 0, NULL)) == NULL) {
sphtriangulate.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Unable to create a data set for sphtriangulate nodes\n");
sphtriangulate.c:		GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Output %d unique triangle polygons\n", D->n);
sphtriangulate.c:		if (get_area) GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Total surface area = %g\n", area_sphere * R2);
sphtriangulate.c:		GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Output %" PRIu64 " unique triangle arcs\n", n_arcs);
sphtriangulate.c:		if ((Dout[0] = GMT_Create_Data (GMT->parent, GMT_IS_DATASET, GMT_IS_LINE, 0, dim, NULL, NULL, 0, 0, NULL)) == NULL) {
sphtriangulate.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Unable to create a data set for sphtriangulate arcs\n");
sphtriangulate.c:	double area_sphere = 0.0, area_polygon, area_triangle, area_km2 = GMT->session.d_NaN, dist;
sphtriangulate.c:		R2 = GMT->current.map.dist[GMT_MAP_DIST].scale = 1.0;
sphtriangulate.c:		R2 = pow (R2D * GMT->current.proj.M_PR_DEG, 2.0);	/* squared mean radius in meters */
sphtriangulate.c:		R2 *= (GMT->current.map.dist[GMT_MAP_DIST].scale * GMT->current.map.dist[GMT_MAP_DIST].scale);	/* Get final measure unit for area */
sphtriangulate.c:	do_authalic = (get_area && !get_arcs && !gmt_M_is_zero (GMT->current.setting.ref_ellipsoid[GMT->current.setting.proj_ellipsoid].flattening));
sphtriangulate.c:	if ((Dout[0] = GMT_Create_Data (GMT->parent, GMT_IS_DATASET, geometry, 0, dim, NULL, NULL, 0, 0, NULL)) == NULL) {
sphtriangulate.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Unable to create a data set for sphtriangulate\n");
sphtriangulate.c:		if ((Dout[1] = GMT_Create_Data (GMT->parent, GMT_IS_DATASET, GMT_IS_POINT, 0, dim, NULL, NULL, 0, 0, NULL)) == NULL) {
sphtriangulate.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Unable to create a data set for sphtriangulate nodes\n");
sphtriangulate.c:			S[0] = Dout[0]->table[0]->segment[node] = GMT_Alloc_Segment (GMT->parent, GMT_NO_STRINGS, vertex, 2U, segment_header, Dout[0]->table[0]->segment[node]);
sphtriangulate.c:		if ((Dout[0] = GMT_Create_Data (GMT->parent, GMT_IS_DATASET, GMT_IS_LINE, 0, dim, NULL, NULL, 0, 0, NULL)) == NULL) {
sphtriangulate.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Unable to create a data set for sphtriangulate Voronoi nodes\n");
sphtriangulate.c:		GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Output %d unique Voronoi arcs\n", n_arcs);
sphtriangulate.c:		if (get_area) GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Total surface area = %g\n", area_sphere * R2);
sphtriangulate.c:	struct GMTAPI_CTRL *API = GMT->parent;
sphtriangulate.c:	if (GMT->common.b.active[GMT_IN] && GMT->common.b.ncol[GMT_IN] == 0) GMT->common.b.ncol[GMT_IN] = 3;
sphtriangulate.c:	n_errors += gmt_M_check_condition (GMT, GMT->common.b.active[GMT_IN] && GMT->common.b.ncol[GMT_IN] < 3,
sphtriangulate.c:	n_errors += gmt_M_check_condition (GMT, GMT->common.b.active[GMT_OUT] && Ctrl->A.active && !Ctrl->N.active,
sphtriangulate.c:	do_authalic = (Ctrl->A.active && !Ctrl->T.active && !gmt_M_is_zero (GMT->current.setting.ref_ellipsoid[GMT->current.setting.proj_ellipsoid].flattening));
sphtriangulate.c:	GMT->session.min_meminc = GMT_INITIAL_MEM_ROW_ALLOC;	/* Start by allocating a 32 Mb chunk */
sphtriangulate.c:	GMT->session.min_meminc = GMT_MIN_MEMINC;		/* Reset to the default value */
sphtriangulate.c:	GMT->current.setting.io_header[GMT_OUT] = true;	/* Turn on table headers on output */
splitxyz.c:	struct GMTAPI_CTRL *API = GMT->parent;
splitxyz.c:					GMT->common.g.active = true;
splitxyz.c:	n_errors += gmt_M_check_condition (GMT, GMT->common.b.active[GMT_OUT] && !Ctrl->N.name,
splitxyz.c:						dy *= GMT->current.proj.DIST_KM_PR_DEG;
splitxyz.c:						dx *= (GMT->current.proj.DIST_KM_PR_DEG * cosd (0.5 * (S->data[GMT_Y][row] + S->data[GMT_Y][row-1])));
subplot.c:	C->A.off[GMT_X] = C->A.off[GMT_Y] = 0.01 * GMT_TEXT_OFFSET * GMT->current.setting.font_tag.size / PSL_POINTS_PER_INCH; /* 20% */
subplot.c:	C->A.clearance[GMT_X] = C->A.clearance[GMT_Y] = 0.01 * GMT_TEXT_CLEARANCE * GMT->current.setting.font_tag.size / PSL_POINTS_PER_INCH;	/* 15% */
subplot.c:	for (unsigned int k = 0; k < 4; k++) C->M.margin[k] = 0.5 * GMT->current.setting.font_annot[GMT_PRIMARY].size / PSL_POINTS_PER_INCH;	/* Split annot font across two sides */
subplot.c:	GMT_Message (API, GMT_TIME_NONE, "\t   or individual <wmargin>/<emargin>/<smargin>/<nmargin> for each side [%gp].\n", 0.5*API->GMT->current.setting.font_annot[GMT_PRIMARY].size);
subplot.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "No subplot command given\n");
subplot.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "subplot begin: Unable to extract nrows and ncols from %s\n", opt->arg);
subplot.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error set: Unable to parse row,col: %s\n", opt->arg);
subplot.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error set: Unable to parse row,col|index: %s\n", opt->arg);
subplot.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Not a subplot command: %s\n", opt->arg);
subplot.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error set: Unable to parse index: %s\n", opt->arg);
subplot.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Not a recognized subplot command: %s\n", opt->arg);
subplot.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "subplot end: Unrecognized option: %s\n", opt->arg);
subplot.c:							GMT_Report (GMT->parent, GMT_MSG_DEBUG, "The mirror of %s is %s\n", Ctrl->A.placement, Ctrl->A.justify);
subplot.c:					GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error Option -F: +f modifier can only be used with -F[f].\n");
subplot.c:							GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Option -Ff...+f missing slash between width and height fractions.\n");
subplot.c:						k = GMT_Get_Values (GMT->parent, &ytxt[1], Ctrl->F.h, Ctrl->N.dim[GMT_Y]);
subplot.c:							GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Option -Ff...+f requires as many height fractions as there are rows.\n");
subplot.c:						k = GMT_Get_Values (GMT->parent, &q[2], Ctrl->F.w, Ctrl->N.dim[GMT_X]);
subplot.c:							GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Option -Ff...+f requires as many width fractions as there are columns.\n");
subplot.c:					if ((k = GMT_Get_Values (GMT->parent, &opt->arg[n], Ctrl->F.dim, 2)) < 2) {
subplot.c:						GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Option -F requires width and height of plot area.\n");
subplot.c:					for (k = 0; k < 2; k++) Ctrl->F.dim[k] *= GMT->session.u2u[GMT->current.setting.proj_length_unit][GMT_INCH];
subplot.c:							GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Option -Fs requires heights and width lists separated by a slash.\n");
subplot.c:						k = GMT_Get_Values (GMT->parent, &ytxt[1], Ctrl->F.h, Ctrl->N.dim[GMT_Y]);
subplot.c:							GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Option -Fs requires as many heights as there are rows, or just a constant one.\n");
subplot.c:						k = GMT_Get_Values (GMT->parent, &opt->arg[1], Ctrl->F.w, Ctrl->N.dim[GMT_X]);
subplot.c:							GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Option -Fs requires as many widths as there are columns, or just a constant one.\n");
subplot.c:						for (k = 0; k < Ctrl->N.dim[GMT_X]; k++) Ctrl->F.w[k] *= GMT->session.u2u[GMT->current.setting.proj_length_unit][GMT_INCH];
subplot.c:						for (k = 0; k < Ctrl->N.dim[GMT_Y]; k++) Ctrl->F.h[k] *= GMT->session.u2u[GMT->current.setting.proj_length_unit][GMT_INCH];
subplot.c:						if ((k = GMT_Get_Values (GMT->parent, &opt->arg[n], Ctrl->F.dim, 2)) == 1)	/* Square subplot */
subplot.c:						for (k = 0; k < 2; k++) Ctrl->F.dim[k] *= GMT->session.u2u[GMT->current.setting.proj_length_unit][GMT_INCH];
subplot.c:					GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Option -S requires C or R as first argument!\n");
subplot.c:					GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Option -S%c already specified!\n", flavor[k]);
subplot.c:					GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Modifier +p only allowed for -SR\n");
subplot.c:					GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error -M: No margins given.\n");
subplot.c:					k = GMT_Get_Values (GMT->parent, opt->arg, Ctrl->M.margin, 4);
subplot.c:						GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error -M: Bad number of margins given.\n");
subplot.c:					for (k = 0; k < 4; k++) Ctrl->M.margin[k] *= GMT->session.u2u[GMT->current.setting.proj_length_unit][GMT_INCH];
subplot.c:		n_errors += gmt_M_check_condition (GMT, GMT->common.J.active && !GMT->common.R.active[RSET], "Syntax error -J: Requires -R as well!\n");
subplot.c:		n_errors += gmt_M_check_condition (GMT, GMT->common.J.active && Ctrl->F.mode == SUBPLOT_FIGURE, "Syntax error -J: Requires -Fs to determine subplot height!\n");
subplot.c:		if (GMT->common.J.active) {	/* Compute map height from -R -J */
subplot.c:			if (gmt_M_err_pass (GMT, gmt_map_setup (GMT, GMT->common.R.wesn), "")) n_errors++;
subplot.c:			for (j = 0; j < Ctrl->N.dim[GMT_Y]; j++) Ctrl->F.h[j] = GMT->current.map.height;
subplot.c:					GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Error -B: Must either set -Bx and -By or -B that applies to both axes.\n");
subplot.c:			if (strchr (GMT->current.setting.map_frame_axes, 'S')) Ctrl->S[GMT_X].axes[px++] = 'S';
subplot.c:			else if (strchr (GMT->current.setting.map_frame_axes, 's')) Ctrl->S[GMT_X].axes[px++] = 's';
subplot.c:			else if (strchr (GMT->current.setting.map_frame_axes, 'b')) Ctrl->S[GMT_X].axes[px++] = 'b';
subplot.c:			if (strchr (GMT->current.setting.map_frame_axes, 'N')) Ctrl->S[GMT_X].axes[px++] = 'N';
subplot.c:			else if (strchr (GMT->current.setting.map_frame_axes, 'n')) Ctrl->S[GMT_X].axes[px++] = 'n';
subplot.c:			else if (strchr (GMT->current.setting.map_frame_axes, 't')) Ctrl->S[GMT_X].axes[px++] = 't';
subplot.c:			if (strchr (GMT->current.setting.map_frame_axes, 'W')) Ctrl->S[GMT_Y].axes[py++] = 'W';
subplot.c:			else if (strchr (GMT->current.setting.map_frame_axes, 'w')) Ctrl->S[GMT_Y].axes[py++] = 'w';
subplot.c:			else if (strchr (GMT->current.setting.map_frame_axes, 'l')) Ctrl->S[GMT_Y].axes[py++] = 'l';
subplot.c:			if (strchr (GMT->current.setting.map_frame_axes, 'E')) Ctrl->S[GMT_Y].axes[py++] = 'E';
subplot.c:			else if (strchr (GMT->current.setting.map_frame_axes, 'e')) Ctrl->S[GMT_Y].axes[py++] = 'e';
subplot.c:			else if (strchr (GMT->current.setting.map_frame_axes, 'r')) Ctrl->S[GMT_Y].axes[py++] = 'r';
subplot.c:	if (API->GMT->current.setting.run_mode == GMT_CLASSIC) {
subplot.c:			if (GMT->common.X.mode == 'a' && GMT->common.Y.mode == 'a')
subplot.c:				if (!GMT->common.X.active) GMT->current.setting.map_origin[GMT_X] = 0.0;
subplot.c:				if (!GMT->common.Y.active) GMT->current.setting.map_origin[GMT_Y] = 0.0;
subplot.c:			if (GMT->common.X.mode == 'a' && GMT->common.Y.mode == 'a')
subplot.c:		if (xymode == 'a') gmt_M_memcpy (off, GMT->current.setting.map_origin, 2, double);
subplot.c:		tick_height   = MAX(0,GMT->current.setting.map_tick_length[GMT_ANNOT_UPPER]);	/* Allow for axis ticks */
subplot.c:		annot_height  = (GMT_LETTER_HEIGHT * GMT->current.setting.font_annot[GMT_PRIMARY].size / PSL_POINTS_PER_INCH) + MAX (0.0, GMT->current.setting.map_annot_offset[GMT_PRIMARY]);	/* Allow for space between axis and annotations */
subplot.c:		label_height  = (GMT_LETTER_HEIGHT * GMT->current.setting.font_label.size / PSL_POINTS_PER_INCH) + MAX (0.0, GMT->current.setting.map_label_offset);
subplot.c:		title_height = (GMT_LETTER_HEIGHT * GMT->current.setting.font_title.size / PSL_POINTS_PER_INCH) + GMT->current.setting.map_title_offset;
subplot.c:		y_header_off = GMT->current.setting.map_heading_offset;
subplot.c:				for (row = 0; row < Ctrl->N.dim[GMT_Y]; row++) Ctrl->F.h[row] = Ctrl->F.w[0] * (GMT->current.map.height / GMT->current.map.width);
subplot.c:			gmt_M_memcpy (GMT->current.plot.panel.gap, Ctrl->C.gap, 4, double);
subplot.c:		if (GMT->common.J.active && GMT->current.proj.projection == GMT_LINEAR)	/* Write axes directions for Cartesian plots as +1 or -1 */
subplot.c:			fprintf (fp, "# DIRECTION: %d %d\n", 2*GMT->current.proj.xyz_pos[GMT_X]-1, 2*GMT->current.proj.xyz_pos[GMT_Y]-1);
subplot.c:				width, height, gmt_putfont (GMT, &GMT->current.setting.font_heading), vfile, xymode, GMT->current.setting.map_origin[GMT_X]-Ctrl->F.clearance[GMT_X], xymode, GMT->current.setting.map_origin[GMT_Y]-Ctrl->F.clearance[GMT_Y]);
subplot.c:			sprintf (command, "-R0/%g/0/%g -Jx1i -T -X%c%gi -Y%c%gi --GMT_HISTORY=false", width, height, xymode, GMT->current.setting.map_origin[GMT_X]-Ctrl->F.clearance[GMT_X], xymode, GMT->current.setting.map_origin[GMT_Y]-Ctrl->F.clearance[GMT_Y]);
subplot.c:			sprintf (command, "-R0/%g/0/%g -Jx1i -W%s %s --GMT_HISTORY=false", Ctrl->F.dim[GMT_X] + GMT->current.setting.map_origin[GMT_X], Ctrl->F.dim[GMT_Y] + GMT->current.setting.map_origin[GMT_Y], Ctrl->F.Lpen, vfile);
subplot.c:			bool save = GMT->current.setting.io_header[GMT_OUT];
subplot.c:			sprintf (command, "0/%g/0/%g", Ctrl->F.dim[GMT_X] + GMT->current.setting.map_origin[GMT_X], Ctrl->F.dim[GMT_Y] + GMT->current.setting.map_origin[GMT_Y]);	/* Save page region */
subplot.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "No subplot information file!\n");
subplot.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "No subplot information file!\n");
subplot.c:		API->GMT->current.map.width  = P->dim[GMT_X];
subplot.c:		API->GMT->current.map.height = P->dim[GMT_Y];
subplot.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "No workflow directory\n");
subplot.c:		if ((fp = PSL_fopen (GMT->PSL, GMT->current.ps.filename, wmode[k])) == NULL) {	/* Must open inside PSL DLL */
subplot.c:			GMT_Report (API, GMT_MSG_NORMAL, "Cannot open %s with mode %s\n", GMT->current.ps.filename, wmode[k]);
subplot.c:		PSL_command (GMT->PSL, "PSL_plot_completion /PSL_plot_completion {} def\n");	/* Run once, then make it a null function */
subplot.c:		if (PSL_fclose (GMT->PSL)) {
subplot.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Unable to close hidden PS file %s!\n", GMT->current.ps.filename);
subplot.c:		sprintf (file, "%s/%s.%s", GMT->parent->gwf_dir, GMT_HISTORY_FILE, tag);
subplot.c:		if (GMT->init.history[id]) gmt_M_str_free (GMT->init.history[id]);	/* Remove whatever this was */
subplot.c:		GMT->init.history[id] = strdup (Rtxt);	/* Update with the dimension of the whole subplot frame */
subplot.c:		if (id > 0 && GMT->init.history[id]) {	/* There should/must be an entry but we check id nevertheless */
subplot.c:			Jstr[1] = GMT->init.history[id][0];	/* The actual -J? that was used in the last subplot panel */
subplot.c:			gmt_M_str_free (GMT->init.history[id]);	/* Remove whatever that was */
subplot.c:			GMT->init.history[id] = strdup ("x");	/* Just place the linear projection code */
subplot.c:			if ((id = gmt_get_option_id (id + 1, Jstr)) >= 0 && GMT->init.history[id]) gmt_M_str_free (GMT->init.history[id]);	/* Remove the subplot -J? entry */
subplot.c:		if (id > 0 && GMT->init.history[id]) gmt_M_str_free (GMT->init.history[id]);	/* Remove what this was */
subplot.c:		GMT->init.history[id] = strdup ("x1i");	/* Add a scale of 1 inch per unit to match the inches we gave in the -R history */
subplot.c:		gmt_M_memset (&GMT->current.plot.panel, 1, struct GMT_SUBPLOT);	/* Wipe that smile off your face */
surface.c:	GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Set finite-difference coefficients [stride = %d]\n", C->current_stride);
surface.c:	GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Expand grid by factor of %d when going from stride = %d to %d\n", expand, C->previous_stride, C->current_stride);
surface.c:	GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Fill in expanded grid by bilinear interpolation [stride = %d]\n", C->current_stride);
surface.c:	GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Recompute data index for next iteration [stride = %d]\n", C->current_stride);
surface.c:	GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Determine nearest point and set Briggs coefficients [stride = %d]\n", C->current_stride);
surface.c:	GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Initialize grid using moving average scheme [stride = %d]\n", C->current_stride);
surface.c:	 			sprintf (C->format, "No data inside search radius at: %s %s [node set to data mean]\n", GMT->current.setting.format_float_out, GMT->current.setting.format_float_out);
surface.c:	 			GMT_Report (GMT->parent, GMT_MSG_VERBOSE, C->format, x0, y0);
surface.c:	GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Processing input table data\n");
surface.c:	if ((error = GMT_Set_Columns (GMT->parent, GMT_IN, 3, GMT_COL_FIX_NO_TEXT)) != GMT_NOERROR)
surface.c:	if (GMT_Init_IO (GMT->parent, GMT_IS_DATASET, GMT_IS_POINT, GMT_IN, GMT_ADD_DEFAULT, 0, options) != GMT_NOERROR)	/* Establishes data input */
surface.c:		return (GMT->parent->error);
surface.c:	if (GMT_Begin_IO (GMT->parent, GMT_IS_DATASET, GMT_IN, GMT_HEADER_ON) != GMT_NOERROR)	/* Enables data input and sets access mode */
surface.c:		return (GMT->parent->error);
surface.c:		if ((In = GMT_Get_Record (GMT->parent, GMT_READ_DATA, NULL)) == NULL) {	/* Read next record, get NULL if special case */
surface.c:	if (GMT_End_IO (GMT->parent, GMT_IN, 0) != GMT_NOERROR)	/* Disables further data input */
surface.c:		return (GMT->parent->error);
surface.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "No datapoints inside region, aborting\n");
surface.c:		sprintf (C->format, "%s %s %s\n", GMT->current.setting.format_float_out, GMT->current.setting.format_float_out, GMT->current.setting.format_float_out);
surface.c:		GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Minimum value of your dataset x,y,z at: %s", msg);
surface.c:		GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Maximum value of your dataset x,y,z at: %s", msg);
surface.c:		if (C->periodic && n_dup) GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Number of input values shared between repeating west and east column nodes: %" PRIu64 "\n", n_dup);
surface.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Your lower value is > than min data value.\n");
surface.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Your upper value is < than max data value.\n");
surface.c:	struct GMTAPI_CTRL *API = GMT->parent;
surface.c:	GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Load any data constraint limit grids\n");
surface.c:			if ((C->Bound[end] = GMT_Read_Data (GMT->parent, GMT_IS_GRID, GMT_IS_FILE, GMT_IS_SURFACE, GMT_CONTAINER_ONLY, NULL, C->limit_file[end], NULL)) == NULL) return (API->error);	/* Get header only */
surface.c:			if (GMT_Read_Data (GMT->parent, GMT_IS_GRID, GMT_IS_FILE, GMT_IS_SURFACE, GMT_DATA_ONLY, NULL, C->limit_file[end], C->Bound[end]) == NULL) return (API->error);
surface.c:	GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Prepare final output grid [stride = %d]\n", C->current_stride);
surface.c:	if (GMT->common.R.active[GSET]) {	/* Pixel registration request. Reset region to the original extent */
surface.c:		C->Grid->header->registration = GMT->common.R.registration;
surface.c:			if ((C->set_limit[end] > NONE && C->set_limit[end] < SURFACE) && GMT_Destroy_Data (GMT->parent, &C->Bound[end]) != GMT_NOERROR) {
surface.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Failed to free %s boundary\n", limit[end]);
surface.c:	if (GMT_Write_Data (GMT->parent, GMT_IS_GRID, GMT_IS_FILE, GMT_IS_SURFACE, GMT_CONTAINER_AND_DATA, NULL, grdfile, C->Grid) != GMT_NOERROR)
surface.c:		return (GMT->parent->error);
surface.c:	GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Apply all boundary conditions [stride = %d]\n", C->current_stride);
surface.c:	GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Starting iterations, mode = %s Max iterations = %d [stride = %d]\n", mode_name[mode], current_max_iterations, C->current_stride);
surface.c:	sprintf (C->format, "%%4ld\t%%c\t%%8" PRIu64 "\t%s\t%s\t%%10" PRIu64 "\n", GMT->current.setting.format_float_out, GMT->current.setting.format_float_out);
surface.c:		GMT->current.setting.io_seg_marker[GMT_OUT], C->current_stride, C->mode_type[mode], current_limit, C->current_stride);
surface.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Iteration %d\n", iteration_count);
surface.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, C->format,
surface.c:	GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, C->format,
surface.c:	GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Compute rms misfit and curvature.\n");
surface.c:	GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Fit info: N data points  N nodes\tmean error\trms error\tcurvature\n");
surface.c:	sprintf (C->format,"\t%%8ld\t%%8ld\t%s\t%s\t%s\n", GMT->current.setting.format_float_out, GMT->current.setting.format_float_out, GMT->current.setting.format_float_out);
surface.c:	GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, C->format, C->npoints, C->nxny, mean_error, mean_squared_error, curvature);
surface.c:	GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Plane fit z = %g + (%g * col) + (%g * row)\n", C->plane_icept, C->plane_sx, C->plane_sy);
surface.c:	GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Eliminate data points that are not nearest a node.\n");
surface.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "%" PRIu64 " unusable points were supplied; these will be ignored.\n", n_outside);
surface.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "You should have pre-processed the data with block-mean, -median, or -mode.\n");
surface.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Check that previous processing steps write results with enough decimals.\n");
surface.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Possibly some data were half-way between nodes and subject to IEEE 754 rounding.\n");
surface.c:	GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Normalize detrended data constraints by z rms = %g\n", C->z_rms);
surface.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Input data lie exactly on a plane.\n");
surface.c:		GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Select default convergence limit of %g (%u ppm of L2 scale)\n", C->converge_limit, ppm);
surface.c:		unsigned int m, save_range = GMT->current.io.geo.range;
surface.c:		GMT->current.io.geo.range = GMT_IS_GIVEN_RANGE;		/* Override this setting explicitly */
surface.c:			GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Hint: Choosing %s [n_columns = %d, n_rows = %d] might cut run time by a factor of %.8g\n",
surface.c:		GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Hint: After completion you can recover the desired region via gmt grdcut\n");
surface.c:			GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Note: One or more of the suggested south/north bounds exceed the allowable range [-90/90]\n");
surface.c:			GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "A workaround is to use -fx to only consider x as geographic longitudes\n");
surface.c:		GMT->current.io.geo.range = save_range;
surface.c:		GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Cannot suggest any n_columns,n_rows better than your current -R -I settings.\n");
surface.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Unable to create file %s\n", fname1);
surface.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Unable to create file %s\n", fname1);
surface.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Reinterpolated breakline saved to file %s\n", fname1);
surface.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Final breakline constraints saved to file %s\n", fname2);
surface.c:	GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Found %d breakline points, reinterpolated to %d points, reduced to %d points\n", (int)T->n_records, (int)new_n, (int)nb);
surface.c:	struct GMTAPI_CTRL *API = GMT->parent;
surface.c:	n_errors += gmt_M_check_condition (GMT, !GMT->common.R.active[RSET], "Syntax error: Must specify -R option\n");
surface.c:	n_errors += gmt_M_check_condition (GMT, GMT->common.R.inc[GMT_X] <= 0.0 || GMT->common.R.inc[GMT_Y] <= 0.0,
surface.c:	old_verbose = GMT->current.setting.verbose;
surface.c:	gmt_M_memcpy (C.wesn_orig, GMT->common.R.wesn, 4, double);	/* Save original region in case user specified -r */
surface.c:	gmt_M_memcpy (wesn, GMT->common.R.wesn, 4, double);		/* Save specified region */
surface.c:	if (GMT->common.R.active[GSET]) {		/* Pixel registration request. Use the trick of offsetting area by x_inc(y_inc) / 2 */
surface.c:		wesn[XLO] += GMT->common.R.inc[GMT_X] / 2.0;	wesn[XHI] += GMT->common.R.inc[GMT_X] / 2.0;
surface.c:		wesn[YLO] += GMT->common.R.inc[GMT_Y] / 2.0;	wesn[YHI] += GMT->common.R.inc[GMT_Y] / 2.0;
surface.c:		GMT->current.setting.verbose = GMT_MSG_LONG_VERBOSE;
surface.c:		sprintf (C.format, "Grid domain: W: %s E: %s S: %s N: %s n_columns: %%d n_rows: %%d [", GMT->current.setting.format_float_out, GMT->current.setting.format_float_out, GMT->current.setting.format_float_out, GMT->current.setting.format_float_out);
surface.c:		(GMT->common.R.active[GSET]) ? strcat (C.format, "pixel registration]\n") : strcat (C.format, "gridline registration]\n");
surface.c:	if ((C.current_stride == 1 && gmt_M_is_verbose (GMT, GMT_MSG_LONG_VERBOSE)) || Ctrl->Q.active) suggest_sizes (GMT, C.Grid, C.factors, C.n_columns-1, C.n_rows-1, GMT->common.R.active[GSET]);
surface.c:		GMT->current.setting.verbose = old_verbose;
surface.c:		         input, mask, wesn[XLO], wesn[XHI], wesn[YLO], wesn[YHI], GMT->common.R.inc[GMT_X],
surface.c:				 GMT->common.R.inc[GMT_Y], Ctrl->M.arg, V_level[GMT->current.setting.verbose]);
surface.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Calling grdsample with args %s\n", cmd);
surface_experimental.c:	GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Set finite-difference coefficients [stride = %d]\n", C->current_stride);
surface_experimental.c:	GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Expand grid by factor of %d when going from stride = %d to %d\n", expand, C->previous_stride, C->current_stride);
surface_experimental.c:	GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Fill in expanded grid by bilinear interpolation [stride = %d]\n", C->current_stride);
surface_experimental.c:	GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Recompute data index for next iteration [stride = %d]\n", C->current_stride);
surface_experimental.c:	GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Determine nearest point and set Briggs coefficients [stride = %d]\n", C->current_stride);
surface_experimental.c:	GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Determine mean data constraints and set Briggs coefficients [stride = %d]\n", C->current_stride);
surface_experimental.c:	GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Initialize grid using moving average scheme [stride = %d]\n", C->current_stride);
surface_experimental.c:	 			sprintf (C->format, "No data inside search radius at: %s %s [node set to data mean]\n", GMT->current.setting.format_float_out, GMT->current.setting.format_float_out);
surface_experimental.c:	 			GMT_Report (GMT->parent, GMT_MSG_VERBOSE, C->format, x0, y0);
surface_experimental.c:	GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Processing input table data\n");
surface_experimental.c:	if ((error = GMT_Set_Columns (GMT->parent, GMT_IN, 3, GMT_COL_FIX_NO_TEXT)) != GMT_NOERROR)
surface_experimental.c:	if (GMT_Init_IO (GMT->parent, GMT_IS_DATASET, GMT_IS_POINT, GMT_IN, GMT_ADD_DEFAULT, 0, options) != GMT_NOERROR)	/* Establishes data input */
surface_experimental.c:		return (GMT->parent->error);
surface_experimental.c:	if (GMT_Begin_IO (GMT->parent, GMT_IS_DATASET, GMT_IN, GMT_HEADER_ON) != GMT_NOERROR)	/* Enables data input and sets access mode */
surface_experimental.c:		return (GMT->parent->error);
surface_experimental.c:		if ((In = GMT_Get_Record (GMT->parent, GMT_READ_DATA, NULL)) == NULL) {	/* Read next record, get NULL if special case */
surface_experimental.c:	if (GMT_End_IO (GMT->parent, GMT_IN, 0) != GMT_NOERROR)	/* Disables further data input */
surface_experimental.c:		return (GMT->parent->error);
surface_experimental.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "No datapoints inside region, aborting\n");
surface_experimental.c:		sprintf (C->format, "%s %s %s\n", GMT->current.setting.format_float_out, GMT->current.setting.format_float_out, GMT->current.setting.format_float_out);
surface_experimental.c:		GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Minimum value of your dataset x,y,z at: %s", msg);
surface_experimental.c:		GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Maximum value of your dataset x,y,z at: %s", msg);
surface_experimental.c:		if (C->periodic && n_dup) GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Number of input values shared between repeating west and east column nodes: %" PRIu64 "\n", n_dup);
surface_experimental.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Your lower value is > than min data value.\n");
surface_experimental.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Your upper value is < than max data value.\n");
surface_experimental.c:	struct GMTAPI_CTRL *API = GMT->parent;
surface_experimental.c:	GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Load any data constraint limit grids\n");
surface_experimental.c:			if ((C->Bound[end] = GMT_Read_Data (GMT->parent, GMT_IS_GRID, GMT_IS_FILE, GMT_IS_SURFACE, GMT_CONTAINER_ONLY, NULL, C->limit_file[end], NULL)) == NULL) return (API->error);	/* Get header only */
surface_experimental.c:			if (GMT_Read_Data (GMT->parent, GMT_IS_GRID, GMT_IS_FILE, GMT_IS_SURFACE, GMT_DATA_ONLY, NULL, C->limit_file[end], C->Bound[end]) == NULL) return (API->error);
surface_experimental.c:	GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Prepare final output grid [stride = %d]\n", C->current_stride);
surface_experimental.c:	if (GMT->common.R.active[GSET]) {	/* Pixel registration request. Reset region to the original extent */
surface_experimental.c:		C->Grid->header->registration = GMT->common.R.registration;
surface_experimental.c:			if ((C->set_limit[end] > NONE && C->set_limit[end] < SURFACE) && GMT_Destroy_Data (GMT->parent, &C->Bound[end]) != GMT_NOERROR) {
surface_experimental.c:				GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Failed to free %s boundary\n", limit[end]);
surface_experimental.c:	if (GMT_Write_Data (GMT->parent, GMT_IS_GRID, GMT_IS_FILE, GMT_IS_SURFACE, GMT_CONTAINER_AND_DATA, NULL, grdfile, C->Grid) != GMT_NOERROR)
surface_experimental.c:		return (GMT->parent->error);
surface_experimental.c:	GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Apply all boundary conditions [stride = %d]\n", C->current_stride);
surface_experimental.c:		G = GMT_Create_Data (GMT->parent, GMT_IS_GRID, GMT_IS_SURFACE, GMT_CONTAINER_ONLY, NULL, C->Grid->header->wesn, C->inc, GMT_GRID_NODE_REG, GMT_NOTSET, NULL);
surface_experimental.c:	GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Starting iterations, mode = %s Max iterations = %d [stride = %d]\n", mode_name[mode], current_max_iterations, C->current_stride);
surface_experimental.c:	sprintf (C->format, "%%4ld\t%%c\t%%8" PRIu64 "\t%s\t%s\t%%10" PRIu64 "\n", GMT->current.setting.format_float_out, GMT->current.setting.format_float_out);
surface_experimental.c:		GMT->current.setting.io_seg_marker[GMT_OUT], C->current_stride, C->mode_type[mode], current_limit, C->current_stride);
surface_experimental.c:			if (GMT_Write_Data (GMT->parent, GMT_IS_GRID, GMT_IS_FILE, GMT_IS_SURFACE, GMT_CONTAINER_AND_DATA, NULL, file, G) != GMT_NOERROR)
surface_experimental.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Iteration %d\n", iteration_count);
surface_experimental.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, C->format,
surface_experimental.c:			if (GMT_Write_Data (GMT->parent, GMT_IS_GRID, GMT_IS_FILE, GMT_IS_SURFACE, GMT_CONTAINER_AND_DATA, NULL, file, G) != GMT_NOERROR)
surface_experimental.c:	GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, C->format,
surface_experimental.c:		GMT_Destroy_Data (GMT->parent, &G);
surface_experimental.c:	GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Compute rms misfit and curvature.\n");
surface_experimental.c:	GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Fit info: N data points  N nodes\tmean error\trms error\tcurvature\n");
surface_experimental.c:	sprintf (C->format,"\t%%8ld\t%%8ld\t%s\t%s\t%s\n", GMT->current.setting.format_float_out, GMT->current.setting.format_float_out, GMT->current.setting.format_float_out);
surface_experimental.c:	GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, C->format, C->npoints, C->nxny, mean_error, mean_squared_error, curvature);
surface_experimental.c:	GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Plane fit z = %g + (%g * col) + (%g * row)\n", C->plane_icept, C->plane_sx, C->plane_sy);
surface_experimental.c:	GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Eliminate data points that are not nearest a node.\n");
surface_experimental.c:				GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "The %s point %" PRId64 " has been replaced by a %s point.\n", point_type[C->data[k].kind], int64_abs(C->data[k].number), point_type[last_kind]);
surface_experimental.c:				GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "The %s point %" PRId64 " will be ignored.\n", point_type[C->data[k].kind], int64_abs(C->data[k].number));
surface_experimental.c:			GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "%" PRIu64 " unusable points were supplied; these will be ignored.\n", n_ignored);
surface_experimental.c:			GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "You should have pre-processed the data with block-mean, -median, or -mode.\n");
surface_experimental.c:			GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Check that previous processing steps write results with enough decimals.\n");
surface_experimental.c:			GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Possibly some data were half-way between nodes and subject to IEEE 754 rounding.\n");
surface_experimental.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Writing final usable data constraints to file surface.data.\n");
surface_experimental.c:	GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Normalize detrended data constraints by z rms = %g\n", C->z_rms);
surface_experimental.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Input data lie exactly on a plane.\n");
surface_experimental.c:		GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Select default convergence limit of %g (%u ppm of L2 scale)\n", C->converge_limit, ppm);
surface_experimental.c:		unsigned int m, save_range = GMT->current.io.geo.range;
surface_experimental.c:		GMT->current.io.geo.range = GMT_IS_GIVEN_RANGE;		/* Override this setting explicitly */
surface_experimental.c:			GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Hint: Choosing %s [n_columns = %d, n_rows = %d] might cut run time by a factor of %.8g\n",
surface_experimental.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Hint: After completion you can recover the desired region via gmt grdcut\n");
surface_experimental.c:			GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Note: One or more of the suggested south/north bounds exceed the allowable range [-90/90]\n");
surface_experimental.c:			GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "A workaround is to use -fx to only consider x as geographic longitudes\n");
surface_experimental.c:		GMT->current.io.geo.range = save_range;
surface_experimental.c:		GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Cannot suggest any n_columns,n_rows better than your current -R -I settings.\n");
surface_experimental.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Reinterpolated breakline saved to file %s\n", fname1);
surface_experimental.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Final breakline constraints saved to file %s\n", fname2);
surface_experimental.c:	GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Found %d breakline points, reinterpolated to %d points, reduced to %d points\n", (int)T->n_records, (int)new_n, (int)nb);
surface_experimental.c:	struct GMTAPI_CTRL *API = GMT->parent;
surface_experimental.c:	n_errors += gmt_M_check_condition (GMT, !GMT->common.R.active[RSET], "Syntax error: Must specify -R option\n");
surface_experimental.c:	n_errors += gmt_M_check_condition (GMT, GMT->common.R.inc[GMT_X] <= 0.0 || GMT->common.R.inc[GMT_Y] <= 0.0, "Syntax error -I option: Must specify positive increment(s)\n");
surface_experimental.c:	old_verbose = GMT->current.setting.verbose;
surface_experimental.c:	gmt_M_memcpy (C.wesn_orig, GMT->common.R.wesn, 4, double);	/* Save original region in case user specified -r */
surface_experimental.c:	gmt_M_memcpy (wesn, GMT->common.R.wesn, 4, double);		/* Save specified region */
surface_experimental.c:	if (GMT->common.R.active[GSET]) {		/* Pixel registration request. Use the trick of offsetting area by x_inc(y_inc) / 2 */
surface_experimental.c:		wesn[XLO] += GMT->common.R.inc[GMT_X] / 2.0;	wesn[XHI] += GMT->common.R.inc[GMT_X] / 2.0;
surface_experimental.c:		wesn[YLO] += GMT->common.R.inc[GMT_Y] / 2.0;	wesn[YHI] += GMT->common.R.inc[GMT_Y] / 2.0;
surface_experimental.c:		GMT->current.setting.verbose = GMT_MSG_LONG_VERBOSE;
surface_experimental.c:		sprintf (C.format, "Grid domain: W: %s E: %s S: %s N: %s n_columns: %%d n_rows: %%d [", GMT->current.setting.format_float_out, GMT->current.setting.format_float_out, GMT->current.setting.format_float_out, GMT->current.setting.format_float_out);
surface_experimental.c:		(GMT->common.R.active[GSET]) ? strcat (C.format, "pixel registration]\n") : strcat (C.format, "gridline registration]\n");
surface_experimental.c:	if ((C.current_stride == 1 && gmt_M_is_verbose (GMT, GMT_MSG_LONG_VERBOSE)) || Ctrl->Q.active) suggest_sizes (GMT, C.Grid, C.factors, C.n_columns-1, C.n_rows-1, GMT->common.R.active[GSET]);
surface_experimental.c:		GMT->current.setting.verbose = old_verbose;
surface_experimental.c:			GMT->common.R.inc[GMT_X], GMT->common.R.inc[GMT_Y], Ctrl->M.arg, V_level[GMT->current.setting.verbose]);
surface_experimental.c:		GMT_Report (GMT->parent, GMT_MSG_DEBUG, "Calling grdsample with args %s\n", cmd);
surface_old.c:	 			sprintf (C->format, "No data inside search radius at: %s %s\n", GMT->current.setting.format_float_out, GMT->current.setting.format_float_out);
surface_old.c:	 			GMT_Report (GMT->parent, GMT_MSG_NORMAL, C->format, x0, y0);
surface_old.c:	GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Processing input table data\n");
surface_old.c:	if ((error = GMT_Set_Columns (GMT->parent, GMT_IN, 3, GMT_COL_FIX_NO_TEXT)) != GMT_NOERROR) {
surface_old.c:	if (GMT_Init_IO (GMT->parent, GMT_IS_DATASET, GMT_IS_POINT, GMT_IN, GMT_ADD_DEFAULT, 0, options) != GMT_NOERROR) {	/* Establishes data input */
surface_old.c:		return (GMT->parent->error);
surface_old.c:	if (GMT_Begin_IO (GMT->parent, GMT_IS_DATASET, GMT_IN, GMT_HEADER_ON) != GMT_NOERROR) {	/* Enables data input and sets access mode */
surface_old.c:		return (GMT->parent->error);
surface_old.c:		if ((In = GMT_Get_Record (GMT->parent, GMT_READ_DATA, NULL)) == NULL) {	/* Read next record, get NULL if special case */
surface_old.c:	if (GMT_End_IO (GMT->parent, GMT_IN, 0) != GMT_NOERROR) {	/* Disables further data input */
surface_old.c:		return (GMT->parent->error);
surface_old.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, " No datapoints inside region, aborts\n");
surface_old.c:		sprintf (C->format, "%s %s %s\n", GMT->current.setting.format_float_out, GMT->current.setting.format_float_out, GMT->current.setting.format_float_out);
surface_old.c:		GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Minimum value of your dataset x,y,z at: ");
surface_old.c:		GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, C->format, (double)C->data[kmin].x, (double)C->data[kmin].y, (double)C->data[kmin].z);
surface_old.c:		GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Maximum value of your dataset x,y,z at: ");
surface_old.c:		GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, C->format, (double)C->data[kmax].x, (double)C->data[kmax].y, (double)C->data[kmax].z);
surface_old.c:		if (C->periodic && n_dup) GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Number of input values shared between repeating west and east column nodes: %" PRIu64 "\n", n_dup);
surface_old.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Your lower value is > than min data value.\n");
surface_old.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Your upper value is < than max data value.\n");
surface_old.c:	struct GMTAPI_CTRL *API = GMT->parent;
surface_old.c:			if ((C->Low = GMT_Read_Data (GMT->parent, GMT_IS_GRID, GMT_IS_FILE, GMT_IS_SURFACE, GMT_CONTAINER_ONLY, NULL, C->low_file, NULL)) == NULL) return (API->error);	/* Get header only */
surface_old.c:			if (GMT_Read_Data (GMT->parent, GMT_IS_GRID, GMT_IS_FILE, GMT_IS_SURFACE, GMT_DATA_ONLY, NULL, C->low_file, C->Low) == NULL) return (API->error);
surface_old.c:			if ((C->High = GMT_Read_Data (GMT->parent, GMT_IS_GRID, GMT_IS_FILE, GMT_IS_SURFACE, GMT_CONTAINER_ONLY, NULL, C->high_file, NULL)) == NULL) return (API->error);	/* Get header only */
surface_old.c:			if (GMT_Read_Data (GMT->parent, GMT_IS_GRID, GMT_IS_FILE, GMT_IS_SURFACE, GMT_DATA_ONLY, NULL, C->high_file, C->High) == NULL) return (API->error);
surface_old.c:	if (GMT->common.R.active[GSET]) {	/* Pixel registration request. Reset limits to the original extents */
surface_old.c:		C->Grid->header->registration = GMT->common.R.registration;
surface_old.c:	if (GMT_Write_Data (GMT->parent, GMT_IS_GRID, GMT_IS_FILE, GMT_IS_SURFACE, GMT_CONTAINER_AND_DATA, NULL, grdfile, C->Grid) != GMT_NOERROR) {
surface_old.c:		return (GMT->parent->error);
surface_old.c:	if ((C->set_low  > 0 && C->set_low  < 3) && GMT_Destroy_Data (GMT->parent, &C->Low) != GMT_NOERROR) {
surface_old.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Failed to free C->Low\n");
surface_old.c:	if ((C->set_high > 0 && C->set_high < 3) && GMT_Destroy_Data (GMT->parent, &C->High) != GMT_NOERROR) {
surface_old.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Failed to free C->High\n");
surface_old.c:	sprintf (C->format, "%%4ld\t%%c\t%%8" PRIu64 "\t%s\t%s\t%%10" PRIu64 "\n", GMT->current.setting.format_float_out, GMT->current.setting.format_float_out);
surface_old.c:		GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, C->format,
surface_old.c:	GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, C->format,
surface_old.c:	 GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Fit info: N data points  N nodes\tmean error\trms error\tcurvature\n");
surface_old.c:	 sprintf (C->format,"\t%%8ld\t%%8ld\t%s\t%s\t%s\n", GMT->current.setting.format_float_out, GMT->current.setting.format_float_out, GMT->current.setting.format_float_out);
surface_old.c:	 GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, C->format, C->npoints, C->nxny, mean_error, mean_squared_error, curvature);
surface_old.c:	GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "LS plane determined: z = %g + (%g * col) + (%g * row)\n", C->plane_c0, C->plane_c1, C->plane_c2);
surface_old.c:			GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Original point %" PRIu64 " will be ignored.\n", C->data[k].number);
surface_old.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "%" PRIu64 " unusable points were supplied; these will be ignored.\n", n_outside);
surface_old.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "You should have pre-processed the data with block-mean, -median, or -mode.\n");
surface_old.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Check that previous processing steps write results with enough decimals.\n");
surface_old.c:		GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Input data lie exactly on a plane.\n");
surface_old.c:		GMT_Report (GMT->parent, GMT_MSG_LONG_VERBOSE, "Select default convergence limit of %g (%u ppm of L2 scale)\n", C->converge_limit, ppm);
surface_old.c:		unsigned int m, save_range = GMT->current.io.geo.range;
surface_old.c:		GMT->current.io.geo.range = GMT_IS_GIVEN_RANGE;		/* Override this setting explicitly */
surface_old.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Hint: Choosing %s [n_columns = %d, n_rows = %d] might cut run time by a factor of %.8g\n",
surface_old.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Hint: After completion you can recover the desired region via gmt grdcut\n");
surface_old.c:		GMT->current.io.geo.range = save_range;
surface_old.c:		GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Cannot suggest any n_columns,n_rows better than your -R -I define.\n");
surface_old.c:	struct GMTAPI_CTRL *API = GMT->parent;
surface_old.c:	n_errors += gmt_M_check_condition (GMT, !GMT->common.R.active[RSET], "Syntax error: Must specify -R option\n");
surface_old.c:	n_errors += gmt_M_check_condition (GMT, GMT->common.R.inc[GMT_X] <= 0.0 || GMT->common.R.inc[GMT_Y] <= 0.0, "Syntax error -I option: Must specify positive increment(s)\n");
surface_old.c:	gmt_M_memcpy (C.wesn_orig, GMT->common.R.wesn, 4, double);	/* Save original region in case of -r */
surface_old.c:	gmt_M_memcpy (wesn, GMT->common.R.wesn, 4, double);		/* Specified region */
surface_old.c:	if (GMT->common.R.active[GSET]) {		/* Pixel registration request. Use the trick of offsetting area by x_inc(y_inc) / 2 */
surface_old.c:		wesn[XLO] += GMT->common.R.inc[GMT_X] / 2.0;	wesn[XHI] += GMT->common.R.inc[GMT_X] / 2.0;
surface_old.c:		wesn[YLO] += GMT->common.R.inc[GMT_Y] / 2.0;	wesn[YHI] += GMT->common.R.inc[GMT_Y] / 2.0;
surface_old.c:		sprintf (C.format, "Grid domain: W: %s E: %s S: %s N: %s n_columns: %%d n_rows: %%d [", GMT->current.setting.format_float_out, GMT->current.setting.format_float_out, GMT->current.setting.format_float_out, GMT->current.setting.format_float_out);
surface_old.c:		(GMT->common.R.active[GSET]) ? strcat (C.format, "pixel registration]\n") : strcat (C.format, "gridline registration]\n");
surface_old.c:	if ((C.grid == 1 && gmt_M_is_verbose (GMT, GMT_MSG_LONG_VERBOSE)) || Ctrl->Q.active) suggest_sizes (GMT, C.Grid, C.factors, C.n_columns-1, C.n_rows-1, GMT->common.R.active[GSET]);
testapi_mixmatrix.c:	/* Destroy session, which will free all GMT-allocated memory */
testapi_userdataset.c: * as pre-allocated and GMT-allocated output spaces.
testapi_userdataset.c:	/* Destroy session, which will free all GMT-allocated memory */
testapi_userdataset.c:	if (bad && !quiet) printf ("%d of %d combinations with GMT-allocated output memory failed the test\n", bad, n);
testapi_usergrid.c: * as pre-allocated and GMT-allocated output spaces.
testapi_usergrid.c:	/* Destroy session, which will free all GMT-allocated memory */
testapi_uservectors.c: * as pre-allocated and GMT-allocated output spaces.
testapi_uservectors.c:	/* Destroy session, which will free all GMT-allocated memory */
testgmtio.c:				GMT_Report (API, GMT_MSG_VERBOSE, "Error found in record %" PRIu64 "\n", GMT->current.io.rec_no);
testgmtio.c:				GMT_Report (API, GMT_MSG_VERBOSE, "End of intermediate data file after record %" PRIu64 "\n", GMT->current.io.rec_no);
testgmtio.c:				GMT_Report (API, GMT_MSG_VERBOSE, "Table header found in record %" PRIu64 "\n", GMT->current.io.rec_no);
testgmtio.c:				GMT_Report (API, GMT_MSG_VERBOSE, "Segment header found in record %" PRIu64 "\n", GMT->current.io.rec_no);
testgmtio.c:				GMT_Report (API, GMT_MSG_VERBOSE, "NaN data found in record %" PRIu64 "\n", GMT->current.io.rec_no);
testgmtio.c:				GMT_Report (API, GMT_MSG_VERBOSE, "A gap found in record %" PRIu64 "\n", GMT->current.io.rec_no);
testgmtio.c:			GMT_Report (API, GMT_MSG_VERBOSE, "Data found in record %" PRIu64 "\n", GMT->current.io.rec_no);
trend1d.c:		if ((In = GMT_Get_Record (GMT->parent, GMT_READ_DATA, NULL)) == NULL) {	/* Read next record, get NULL if special case */
trend1d.c:		GMT_Put_Record (GMT->parent, GMT_WRITE_DATA, &Out);	/* Write this to output */
trend1d.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Matrix Solver Convergence Failure.\n");
trend1d.c:	struct GMTAPI_CTRL *API = GMT->parent;
trend1d.c:		sprintf (format,"Read %%" PRIu64 " data with X values from %s to %s\n", GMT->current.setting.format_float_out, GMT->current.setting.format_float_out);
trend1d.c:		GMT_Report (API, GMT_MSG_LONG_VERBOSE, "N_model%sRank%sChi_Squared%sSignificance\n", GMT->current.setting.io_col_separator, GMT->current.setting.io_col_separator, GMT->current.setting.io_col_separator);
trend1d.c:	sprintf (format, "%%d%s%%d%s%s%s%s\n", GMT->current.setting.io_col_separator, GMT->current.setting.io_col_separator, GMT->current.setting.format_float_out, GMT->current.setting.io_col_separator, GMT->current.setting.format_float_out);
trend1d.c:		sprintf (format, "Final model stats: N model parameters %%d.  Rank %%d.  Chi-Squared: %s\n", GMT->current.setting.format_float_out);
trend1d.c:			sprintf (format, "%s%s", GMT->current.setting.io_col_separator, GMT->current.setting.format_float_out);
trend1d.c:	if (GMT_Init_IO (GMT->parent, GMT_IS_DATASET, GMT_IS_NONE, GMT_OUT, GMT_ADD_DEFAULT, 0, options) != GMT_NOERROR) {	/* Establishes data output */
trend2d.c:		if ((In = GMT_Get_Record (GMT->parent, GMT_READ_DATA, NULL)) == NULL) {	/* Read next record, get NULL if special case */
trend2d.c:			GMT_Report (GMT->parent, GMT_MSG_NORMAL, "Internal error: input pointer is NULL where it should not be, aborting\n");
trend2d.c:		GMT_Put_Record (GMT->parent, GMT_WRITE_DATA, &Out);	/* Write this to output */
trend2d.c:			GMT_Report (GMT->parent, GMT_MSG_VERBOSE, "Matrix Solver Convergence Failure.\n");
trend2d.c:	struct GMTAPI_CTRL *API = GMT->parent;
trend2d.c:	sprintf (format, "%s%s", GMT->current.setting.format_float_out, GMT->current.setting.io_col_separator);
trend2d.c:	GMT->common.R.wesn[XLO] = 0;	GMT->common.R.wesn[XHI] = 360.0;	/* For -L not to cause trouble in GMT->current.io.input */
trend2d.c:	if (GMT_Init_IO (GMT->parent, GMT_IS_DATASET, GMT_IS_POINT, GMT_IN,  GMT_ADD_DEFAULT, 0, options) != GMT_NOERROR) {	/* Establishes data input */
trend2d.c:	if (GMT_Init_IO (GMT->parent, GMT_IS_DATASET, GMT_IS_POINT, GMT_OUT, GMT_ADD_DEFAULT, 0, options) != GMT_NOERROR) {	/* Establishes data output */
trend2d.c:	GMT_Report (API, GMT_MSG_LONG_VERBOSE, "N_model%sRank%sChi_Squared%sSignificance\n", GMT->current.setting.io_col_separator, GMT->current.setting.io_col_separator, GMT->current.setting.io_col_separator);
trend2d.c:	sprintf (format, "%%d%s%%d%s%s%s%s\n", GMT->current.setting.io_col_separator, GMT->current.setting.io_col_separator, GMT->current.setting.format_float_out, GMT->current.setting.io_col_separator, GMT->current.setting.format_float_out);
trend2d.c:		sprintf (format, "Final model stats: N model parameters %%d.  Rank %%d.  Chi-Squared: %s\n", GMT->current.setting.format_float_out);
trend2d.c:		sprintf (format, "%s%s", GMT->current.setting.format_float_out, GMT->current.setting.io_col_separator);
triangulate.c:	struct GMTAPI_CTRL *API = GMT->parent;
triangulate.c:				Ctrl->E.value = (opt->arg[0] == 'N' || opt->arg[0] == 'n') ? GMT->session.d_NaN : atof (opt->arg);
triangulate.c:					GMT_Report (GMT->parent, GMT_MSG_COMPAT, "Option -F is deprecated. Use -r instead.\n" );
triangulate.c:	n_errors += gmt_M_check_condition (GMT, GMT->common.R.active[ISET] && (GMT->common.R.inc[GMT_X] <= 0.0 ||
triangulate.c:	                                   GMT->common.R.inc[GMT_Y] <= 0.0), "Syntax error -I option: Must specify positive increment(s)\n");
triangulate.c:	n_errors += gmt_M_check_condition (GMT, Ctrl->G.active && (GMT->common.R.active[ISET] + GMT->common.R.active[RSET]) != 2,
triangulate.c:	(void)gmt_M_check_condition (GMT, !Ctrl->G.active && GMT->common.R.active[ISET], "Warning: -I not needed when -G is not set\n");
triangulate.c:	(void)gmt_M_check_condition (GMT, !(Ctrl->G.active || Ctrl->Q.active) && GMT->common.R.active[RSET],
triangulate.c:	n_errors += gmt_M_check_condition (GMT, Ctrl->Q.active && !GMT->common.R.active[RSET], "Syntax error -Q option: Requires -R\n");
triangulate.c:	n_errors += gmt_M_check_condition (GMT, Ctrl->Q.active && GMT->current.setting.triangulate == GMT_TRIANGLE_WATSON,
triangulate.c:	n_errors += gmt_M_check_condition (GMT, Ctrl->C.active && (GMT->common.R.active[RSET] || GMT->common.R.active[ISET] ||
triangulate.c:									   GMT->common.R.active[GSET]),
triangulate.c:	GMT_Report (API, GMT_MSG_LONG_VERBOSE, "%s triangulation algorithm selected\n", tri_algorithm[GMT->current.setting.triangulate]);
triangulate.c:	if (Ctrl->G.active && GMT->common.R.active[RSET] && GMT->common.J.active) { /* Gave -R -J */
triangulate.c:			V = gmt_voronoi (GMT, xxp, yyp, n, GMT->current.proj.rect, Ctrl->Q.mode);
triangulate.c:			V = gmt_voronoi (GMT, xx, yy, n, GMT->common.R.wesn, Ctrl->Q.mode);
triangulate.c:		periodic = gmt_M_360_range (GMT->common.R.wesn[XLO], GMT->common.R.wesn[XHI]);
triangulate.c:		double inv_delta_min = 1.0 / MIN (GMT->common.R.inc[GMT_X], GMT->common.R.inc[GMT_Y]);	/* Inverse minimum spacing */
triangulate.c:			if (!Ctrl->E.active) Ctrl->E.value = GMT->session.d_NaN;
xyz2grd.c:	struct GMTAPI_CTRL *API = GMT->parent;
xyz2grd.c:			strcpy (GMT->current.io.r_mode, "rb");
xyz2grd.c:			strcpy (GMT->current.io.w_mode, "wb");
xyz2grd.c:		GMT->common.b.type[GMT_IN] = Ctrl->Z.type;
xyz2grd.c:			GMT->common.b.active[GMT_IN] = false;
xyz2grd.c:		n_errors += gmt_M_check_condition (GMT, !GMT->common.R.active[RSET], "Syntax error: Must specify -R option\n");
xyz2grd.c:		n_errors += gmt_M_check_condition (GMT, GMT->common.R.inc[GMT_X] <= 0.0 || GMT->common.R.inc[GMT_Y] <= 0.0, "Syntax error -I option: Must specify positive increment(s)\n");
xyz2grd.c:		save_i = GMT->current.io.input;			/* Save previous i/0 parameters */
xyz2grd.c:		save_o = GMT->current.io.output;
xyz2grd.c:		previous_bin_i = GMT->common.b.active[GMT_IN];
xyz2grd.c:		previous_bin_o = GMT->common.b.active[GMT_OUT];
xyz2grd.c:		GMT->current.io.input = gmt_z_input;		/* Override input reader with chosen binary reader for selected type */
xyz2grd.c:		GMT->current.io.output = gmt_z_output;		/* Override output writer with chosen binary writer for selected type */
xyz2grd.c:		GMT->common.b.active[GMT_IN] = io.binary;	/* May have to set input binary as well */
xyz2grd.c:		GMT->common.b.active[GMT_OUT] = io.binary;	/* May have to set output binary as well */
xyz2grd.c:		GMT->current.io.input = save_i;			/* Reset input pointer */
xyz2grd.c:		GMT->common.b.active[GMT_IN] = previous_bin_i;	/* Reset input binary */
xyz2grd.c:		GMT->current.io.output = save_o;		/* Reset output pointer */
xyz2grd.c:		GMT->common.b.active[GMT_OUT] = previous_bin_o;	/* Reset output binary */
xyz2grd.c:		FILE *fp = GMT->session.std[GMT_IN];
xyz2grd.c:			Grid->data[ij] = (value == Ctrl->E.nodata) ? GMT->session.f_NaN : (gmt_grdfloat) value;
xyz2grd.c:			Grid->data[ij] = (value == Ctrl->E.nodata) ? GMT->session.f_NaN : (gmt_grdfloat) value;
xyz2grd.c:	no_data_f = (GMT->common.d.active[GMT_IN]) ? (gmt_grdfloat)GMT->common.d.nan_proxy[GMT_IN] : GMT->session.f_NaN;
xyz2grd.c:	if (GMT->common.J.active)		/* Convert the GMT -J<...> into a proj4 string and save it in the header */
xyz2grd.c:	if (GMT->common.b.active[GMT_IN] && gmt_M_type (GMT, GMT_IN, GMT_Z) & GMT_IS_RATIME && GMT->current.io.fmt[GMT_IN][GMT_Z].type == GMT_FLOAT) {
xyz2grd.c:	if (Ctrl->Z.active && GMT->common.d.active[GMT_IN] && gmt_M_is_fnan (no_data_f)) GMT->common.d.active[GMT_IN] = false;	/* No point testing since nan_proxy is NaN... */
xyz2grd.c:		save_i = GMT->current.io.input;
xyz2grd.c:		previous_bin_i = GMT->common.b.active[GMT_IN];
xyz2grd.c:		GMT->current.io.input = gmt_z_input;		/* Override and use chosen input mode */
xyz2grd.c:		GMT->common.b.active[GMT_IN] = io.binary;	/* May have to set binary as well */
xyz2grd.c:		GMT->current.io.fmt[GMT_IN][zcol].type = gmt_get_io_type (GMT, Ctrl->Z.type);
xyz2grd.c:		GMT->current.setting.io_nan_records = false;	/* Cannot have x,y as NaNs here */
xyz2grd.c:			Grid->data[ij_gmt] = (gmt_input_is_nan_proxy (GMT, in[zcol])) ? GMT->session.f_NaN : (gmt_grdfloat)in[zcol];
xyz2grd.c:		GMT->current.io.input = save_i;	/* Reset pointer */
xyz2grd.c:		GMT->common.b.active[GMT_IN] = previous_bin_i;	/* Reset binary */
xyz2grd.c:			sprintf (line, "%s\n", GMT->current.setting.format_float_out);
xyz2grd.c:			(GMT->common.d.active[GMT_IN]) ? sprintf (e_value, GMT->current.setting.format_float_out, GMT->common.d.nan_proxy[GMT_IN]) : sprintf (e_value, "NaN");
xyz2grd.c:	gmt_grd_pad_on (GMT, Grid, GMT->current.io.pad);	/* Restore padding */
